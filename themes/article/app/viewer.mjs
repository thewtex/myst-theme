var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __reflectGet = Reflect.get;
var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __pow = Math.pow;
var __defNormalProp = (obj2, key, value) => key in obj2 ? __defProp(obj2, key, { enumerable: true, configurable: true, writable: true, value }) : obj2[key] = value;
var __spreadValues = (a4, b3) => {
  for (var prop in b3 || (b3 = {}))
    if (__hasOwnProp.call(b3, prop))
      __defNormalProp(a4, prop, b3[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b3)) {
      if (__propIsEnum.call(b3, prop))
        __defNormalProp(a4, prop, b3[prop]);
    }
  return a4;
};
var __spreadProps = (a4, b3) => __defProps(a4, __getOwnPropDescs(b3));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all3) => {
  for (var name in all3)
    __defProp(target, name, { get: all3[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __publicField = (obj2, key, value) => __defNormalProp(obj2, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj2, member, msg) => member.has(obj2) || __typeError("Cannot " + msg);
var __privateGet = (obj2, member, getter) => (__accessCheck(obj2, member, "read from private field"), getter ? getter.call(obj2) : member.get(obj2));
var __privateAdd = (obj2, member, value) => member.has(obj2) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj2) : member.set(obj2, value);
var __privateSet = (obj2, member, value, setter) => (__accessCheck(obj2, member, "write to private field"), setter ? setter.call(obj2, value) : member.set(obj2, value), value);
var __privateMethod = (obj2, member, method) => (__accessCheck(obj2, member, "access private method"), method);
var __privateWrapper = (obj2, member, setter, getter) => ({
  set _(value) {
    __privateSet(obj2, member, value, setter);
  },
  get _() {
    return __privateGet(obj2, member, getter);
  }
});
var __superGet = (cls, obj2, key) => __reflectGet(__getProtoOf(cls), key, obj2);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e13) {
        reject(e13);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e13) {
        reject(e13);
      }
    };
    var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var __await = function(promise, isYieldStar) {
  this[0] = promise;
  this[1] = isYieldStar;
};
var __asyncGenerator = (__this, __arguments, generator) => {
  var resume = (k2, v2, yes, no) => {
    try {
      var x2 = generator[k2](v2), isAwait = (v2 = x2.value) instanceof __await, done = x2.done;
      Promise.resolve(isAwait ? v2[0] : v2).then((y3) => isAwait ? resume(k2 === "return" ? k2 : "next", v2[1] ? { done: y3.done, value: y3.value } : y3, yes, no) : yes({ value: y3, done })).catch((e13) => resume("throw", e13, yes, no));
    } catch (e13) {
      no(e13);
    }
  }, method = (k2) => it[k2] = (x2) => new Promise((yes, no) => resume(k2, x2, yes, no)), it = {};
  return generator = generator.apply(__this, __arguments), it[__knownSymbol("asyncIterator")] = () => it, method("next"), method("throw"), method("return"), it;
};
var __yieldStar = (value) => {
  var obj2 = value[__knownSymbol("asyncIterator")], isAwait = false, method, it = {};
  if (obj2 == null) {
    obj2 = value[__knownSymbol("iterator")]();
    method = (k2) => it[k2] = (x2) => obj2[k2](x2);
  } else {
    obj2 = obj2.call(value);
    method = (k2) => it[k2] = (v2) => {
      if (isAwait) {
        isAwait = false;
        if (k2 === "throw") throw v2;
        return v2;
      }
      isAwait = true;
      return {
        done: false,
        value: new __await(new Promise((resolve) => {
          var x2 = obj2[k2](v2);
          if (!(x2 instanceof Object)) __typeError("Object expected");
          resolve(x2);
        }), 1)
      };
    };
  }
  return it[__knownSymbol("iterator")] = () => it, method("next"), "throw" in obj2 ? method("throw") : it.throw = (x2) => {
    throw x2;
  }, "return" in obj2 && method("return"), it;
};
var __forAwait = (obj2, it, method) => (it = obj2[__knownSymbol("asyncIterator")]) ? it.call(obj2) : (obj2 = obj2[__knownSymbol("iterator")](), it = {}, method = (key, fn) => (fn = obj2[key]) && (it[key] = (arg) => new Promise((yes, no, done) => (arg = fn.call(obj2, arg), done = arg.done, Promise.resolve(arg.value).then((value) => yes({ value, done }), no)))), method("next"), method("return"), it);

// node_modules/react/cjs/react.development.js
var require_react_development = __commonJS({
  "node_modules/react/cjs/react.development.js"(exports, module) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var ReactVersion = "18.2.0";
        var REACT_ELEMENT_TYPE = Symbol.for("react.element");
        var REACT_PORTAL_TYPE = Symbol.for("react.portal");
        var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
        var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
        var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
        var REACT_CONTEXT_TYPE = Symbol.for("react.context");
        var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
        var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
        var REACT_MEMO_TYPE = Symbol.for("react.memo");
        var REACT_LAZY_TYPE = Symbol.for("react.lazy");
        var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          if (maybeIterable === null || typeof maybeIterable !== "object") {
            return null;
          }
          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
          if (typeof maybeIterator === "function") {
            return maybeIterator;
          }
          return null;
        }
        var ReactCurrentDispatcher = {
          /**
           * @internal
           * @type {ReactComponent}
           */
          current: null
        };
        var ReactCurrentBatchConfig = {
          transition: null
        };
        var ReactCurrentActQueue = {
          current: null,
          // Used to reproduce behavior of `batchedUpdates` in legacy mode.
          isBatchingLegacy: false,
          didScheduleLegacyUpdate: false
        };
        var ReactCurrentOwner = {
          /**
           * @internal
           * @type {ReactComponent}
           */
          current: null
        };
        var ReactDebugCurrentFrame = {};
        var currentExtraStackFrame = null;
        function setExtraStackFrame(stack) {
          {
            currentExtraStackFrame = stack;
          }
        }
        {
          ReactDebugCurrentFrame.setExtraStackFrame = function(stack) {
            {
              currentExtraStackFrame = stack;
            }
          };
          ReactDebugCurrentFrame.getCurrentStack = null;
          ReactDebugCurrentFrame.getStackAddendum = function() {
            var stack = "";
            if (currentExtraStackFrame) {
              stack += currentExtraStackFrame;
            }
            var impl = ReactDebugCurrentFrame.getCurrentStack;
            if (impl) {
              stack += impl() || "";
            }
            return stack;
          };
        }
        var enableScopeAPI = false;
        var enableCacheElement = false;
        var enableTransitionTracing = false;
        var enableLegacyHidden = false;
        var enableDebugTracing = false;
        var ReactSharedInternals = {
          ReactCurrentDispatcher,
          ReactCurrentBatchConfig,
          ReactCurrentOwner
        };
        {
          ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
          ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;
        }
        function warn(format) {
          {
            {
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              printWarning("warn", format, args);
            }
          }
        }
        function error(format) {
          {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format, args);
            }
          }
        }
        function printWarning(level, format, args) {
          {
            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame2.getStackAddendum();
            if (stack !== "") {
              format += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        var didWarnStateUpdateForUnmountedComponent = {};
        function warnNoop(publicInstance, callerName) {
          {
            var _constructor = publicInstance.constructor;
            var componentName = _constructor && (_constructor.displayName || _constructor.name) || "ReactClass";
            var warningKey = componentName + "." + callerName;
            if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
              return;
            }
            error("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", callerName, componentName);
            didWarnStateUpdateForUnmountedComponent[warningKey] = true;
          }
        }
        var ReactNoopUpdateQueue = {
          /**
           * Checks whether or not this composite component is mounted.
           * @param {ReactClass} publicInstance The instance we want to test.
           * @return {boolean} True if mounted, false otherwise.
           * @protected
           * @final
           */
          isMounted: function(publicInstance) {
            return false;
          },
          /**
           * Forces an update. This should only be invoked when it is known with
           * certainty that we are **not** in a DOM transaction.
           *
           * You may want to call this when you know that some deeper aspect of the
           * component's state has changed but `setState` was not called.
           *
           * This will not invoke `shouldComponentUpdate`, but it will invoke
           * `componentWillUpdate` and `componentDidUpdate`.
           *
           * @param {ReactClass} publicInstance The instance that should rerender.
           * @param {?function} callback Called after component is updated.
           * @param {?string} callerName name of the calling function in the public API.
           * @internal
           */
          enqueueForceUpdate: function(publicInstance, callback, callerName) {
            warnNoop(publicInstance, "forceUpdate");
          },
          /**
           * Replaces all of the state. Always use this or `setState` to mutate state.
           * You should treat `this.state` as immutable.
           *
           * There is no guarantee that `this.state` will be immediately updated, so
           * accessing `this.state` after calling this method may return the old value.
           *
           * @param {ReactClass} publicInstance The instance that should rerender.
           * @param {object} completeState Next state.
           * @param {?function} callback Called after component is updated.
           * @param {?string} callerName name of the calling function in the public API.
           * @internal
           */
          enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {
            warnNoop(publicInstance, "replaceState");
          },
          /**
           * Sets a subset of the state. This only exists because _pendingState is
           * internal. This provides a merging strategy that is not available to deep
           * properties which is confusing. TODO: Expose pendingState or don't use it
           * during the merge.
           *
           * @param {ReactClass} publicInstance The instance that should rerender.
           * @param {object} partialState Next partial state to be merged with state.
           * @param {?function} callback Called after component is updated.
           * @param {?string} Name of the calling function in the public API.
           * @internal
           */
          enqueueSetState: function(publicInstance, partialState, callback, callerName) {
            warnNoop(publicInstance, "setState");
          }
        };
        var assign2 = Object.assign;
        var emptyObject = {};
        {
          Object.freeze(emptyObject);
        }
        function Component(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        Component.prototype.isReactComponent = {};
        Component.prototype.setState = function(partialState, callback) {
          if (typeof partialState !== "object" && typeof partialState !== "function" && partialState != null) {
            throw new Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
          }
          this.updater.enqueueSetState(this, partialState, callback, "setState");
        };
        Component.prototype.forceUpdate = function(callback) {
          this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
        };
        {
          var deprecatedAPIs = {
            isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
            replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
          };
          var defineDeprecationWarning = function(methodName, info) {
            Object.defineProperty(Component.prototype, methodName, {
              get: function() {
                warn("%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
                return void 0;
              }
            });
          };
          for (var fnName in deprecatedAPIs) {
            if (deprecatedAPIs.hasOwnProperty(fnName)) {
              defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
            }
          }
        }
        function ComponentDummy() {
        }
        ComponentDummy.prototype = Component.prototype;
        function PureComponent(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
        pureComponentPrototype.constructor = PureComponent;
        assign2(pureComponentPrototype, Component.prototype);
        pureComponentPrototype.isPureReactComponent = true;
        function createRef() {
          var refObject = {
            current: null
          };
          {
            Object.seal(refObject);
          }
          return refObject;
        }
        var isArrayImpl = Array.isArray;
        function isArray3(a4) {
          return isArrayImpl(a4);
        }
        function typeName(value) {
          {
            var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
            var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            return type;
          }
        }
        function willCoercionThrow(value) {
          {
            try {
              testStringCoercion(value);
              return false;
            } catch (e13) {
              return true;
            }
          }
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkKeyStringCoercion(value) {
          {
            if (willCoercionThrow(value)) {
              error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var displayName = outerType.displayName;
          if (displayName) {
            return displayName;
          }
          var functionName = innerType.displayName || innerType.name || "";
          return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
        }
        function getContextName(type) {
          return type.displayName || "Context";
        }
        function getComponentNameFromType(type) {
          if (type == null) {
            return null;
          }
          {
            if (typeof type.tag === "number") {
              error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type === "function") {
            return type.displayName || type.name || null;
          }
          if (typeof type === "string") {
            return type;
          }
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_CONTEXT_TYPE:
                var context = type;
                return getContextName(context) + ".Consumer";
              case REACT_PROVIDER_TYPE:
                var provider = type;
                return getContextName(provider._context) + ".Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type, type.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                var outerName = type.displayName || null;
                if (outerName !== null) {
                  return outerName;
                }
                return getComponentNameFromType(type.type) || "Memo";
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return getComponentNameFromType(init(payload));
                } catch (x2) {
                  return null;
                }
              }
            }
          }
          return null;
        }
        var hasOwnProperty2 = Object.prototype.hasOwnProperty;
        var RESERVED_PROPS = {
          key: true,
          ref: true,
          __self: true,
          __source: true
        };
        var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
        {
          didWarnAboutStringRefs = {};
        }
        function hasValidRef(config) {
          {
            if (hasOwnProperty2.call(config, "ref")) {
              var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config.ref !== void 0;
        }
        function hasValidKey(config) {
          {
            if (hasOwnProperty2.call(config, "key")) {
              var getter = Object.getOwnPropertyDescriptor(config, "key").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config.key !== void 0;
        }
        function defineKeyPropWarningGetter(props, displayName) {
          var warnAboutAccessingKey = function() {
            {
              if (!specialPropKeyWarningShown) {
                specialPropKeyWarningShown = true;
                error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            }
          };
          warnAboutAccessingKey.isReactWarning = true;
          Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
        function defineRefPropWarningGetter(props, displayName) {
          var warnAboutAccessingRef = function() {
            {
              if (!specialPropRefWarningShown) {
                specialPropRefWarningShown = true;
                error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            }
          };
          warnAboutAccessingRef.isReactWarning = true;
          Object.defineProperty(props, "ref", {
            get: warnAboutAccessingRef,
            configurable: true
          });
        }
        function warnIfStringRefCannotBeAutoConverted(config) {
          {
            if (typeof config.ref === "string" && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {
              var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
              if (!didWarnAboutStringRefs[componentName]) {
                error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);
                didWarnAboutStringRefs[componentName] = true;
              }
            }
          }
        }
        var ReactElement = function(type, key, ref, self2, source, owner, props) {
          var element = {
            // This tag allows us to uniquely identify this as a React Element
            $$typeof: REACT_ELEMENT_TYPE,
            // Built-in properties that belong on the element
            type,
            key,
            ref,
            props,
            // Record the component responsible for creating this element.
            _owner: owner
          };
          {
            element._store = {};
            Object.defineProperty(element._store, "validated", {
              configurable: false,
              enumerable: false,
              writable: true,
              value: false
            });
            Object.defineProperty(element, "_self", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: self2
            });
            Object.defineProperty(element, "_source", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: source
            });
            if (Object.freeze) {
              Object.freeze(element.props);
              Object.freeze(element);
            }
          }
          return element;
        };
        function createElement2(type, config, children) {
          var propName;
          var props = {};
          var key = null;
          var ref = null;
          var self2 = null;
          var source = null;
          if (config != null) {
            if (hasValidRef(config)) {
              ref = config.ref;
              {
                warnIfStringRefCannotBeAutoConverted(config);
              }
            }
            if (hasValidKey(config)) {
              {
                checkKeyStringCoercion(config.key);
              }
              key = "" + config.key;
            }
            self2 = config.__self === void 0 ? null : config.__self;
            source = config.__source === void 0 ? null : config.__source;
            for (propName in config) {
              if (hasOwnProperty2.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                props[propName] = config[propName];
              }
            }
          }
          var childrenLength = arguments.length - 2;
          if (childrenLength === 1) {
            props.children = children;
          } else if (childrenLength > 1) {
            var childArray = Array(childrenLength);
            for (var i6 = 0; i6 < childrenLength; i6++) {
              childArray[i6] = arguments[i6 + 2];
            }
            {
              if (Object.freeze) {
                Object.freeze(childArray);
              }
            }
            props.children = childArray;
          }
          if (type && type.defaultProps) {
            var defaultProps = type.defaultProps;
            for (propName in defaultProps) {
              if (props[propName] === void 0) {
                props[propName] = defaultProps[propName];
              }
            }
          }
          {
            if (key || ref) {
              var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
              if (key) {
                defineKeyPropWarningGetter(props, displayName);
              }
              if (ref) {
                defineRefPropWarningGetter(props, displayName);
              }
            }
          }
          return ReactElement(type, key, ref, self2, source, ReactCurrentOwner.current, props);
        }
        function cloneAndReplaceKey(oldElement, newKey) {
          var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
          return newElement;
        }
        function cloneElement(element, config, children) {
          if (element === null || element === void 0) {
            throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
          }
          var propName;
          var props = assign2({}, element.props);
          var key = element.key;
          var ref = element.ref;
          var self2 = element._self;
          var source = element._source;
          var owner = element._owner;
          if (config != null) {
            if (hasValidRef(config)) {
              ref = config.ref;
              owner = ReactCurrentOwner.current;
            }
            if (hasValidKey(config)) {
              {
                checkKeyStringCoercion(config.key);
              }
              key = "" + config.key;
            }
            var defaultProps;
            if (element.type && element.type.defaultProps) {
              defaultProps = element.type.defaultProps;
            }
            for (propName in config) {
              if (hasOwnProperty2.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                if (config[propName] === void 0 && defaultProps !== void 0) {
                  props[propName] = defaultProps[propName];
                } else {
                  props[propName] = config[propName];
                }
              }
            }
          }
          var childrenLength = arguments.length - 2;
          if (childrenLength === 1) {
            props.children = children;
          } else if (childrenLength > 1) {
            var childArray = Array(childrenLength);
            for (var i6 = 0; i6 < childrenLength; i6++) {
              childArray[i6] = arguments[i6 + 2];
            }
            props.children = childArray;
          }
          return ReactElement(element.type, key, ref, self2, source, owner, props);
        }
        function isValidElement(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        var SEPARATOR = ".";
        var SUBSEPARATOR = ":";
        function escape(key) {
          var escapeRegex = /[=:]/g;
          var escaperLookup = {
            "=": "=0",
            ":": "=2"
          };
          var escapedString = key.replace(escapeRegex, function(match) {
            return escaperLookup[match];
          });
          return "$" + escapedString;
        }
        var didWarnAboutMaps = false;
        var userProvidedKeyEscapeRegex = /\/+/g;
        function escapeUserProvidedKey(text) {
          return text.replace(userProvidedKeyEscapeRegex, "$&/");
        }
        function getElementKey(element, index2) {
          if (typeof element === "object" && element !== null && element.key != null) {
            {
              checkKeyStringCoercion(element.key);
            }
            return escape("" + element.key);
          }
          return index2.toString(36);
        }
        function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
          var type = typeof children;
          if (type === "undefined" || type === "boolean") {
            children = null;
          }
          var invokeCallback = false;
          if (children === null) {
            invokeCallback = true;
          } else {
            switch (type) {
              case "string":
              case "number":
                invokeCallback = true;
                break;
              case "object":
                switch (children.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                  case REACT_PORTAL_TYPE:
                    invokeCallback = true;
                }
            }
          }
          if (invokeCallback) {
            var _child = children;
            var mappedChild = callback(_child);
            var childKey = nameSoFar === "" ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;
            if (isArray3(mappedChild)) {
              var escapedChildKey = "";
              if (childKey != null) {
                escapedChildKey = escapeUserProvidedKey(childKey) + "/";
              }
              mapIntoArray(mappedChild, array, escapedChildKey, "", function(c6) {
                return c6;
              });
            } else if (mappedChild != null) {
              if (isValidElement(mappedChild)) {
                {
                  if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) {
                    checkKeyStringCoercion(mappedChild.key);
                  }
                }
                mappedChild = cloneAndReplaceKey(
                  mappedChild,
                  // Keep both the (mapped) and old keys if they differ, just as
                  // traverseAllChildren used to do for objects as children
                  escapedPrefix + // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
                  (mappedChild.key && (!_child || _child.key !== mappedChild.key) ? (
                    // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
                    // eslint-disable-next-line react-internal/safe-string-coercion
                    escapeUserProvidedKey("" + mappedChild.key) + "/"
                  ) : "") + childKey
                );
              }
              array.push(mappedChild);
            }
            return 1;
          }
          var child;
          var nextName;
          var subtreeCount = 0;
          var nextNamePrefix = nameSoFar === "" ? SEPARATOR : nameSoFar + SUBSEPARATOR;
          if (isArray3(children)) {
            for (var i6 = 0; i6 < children.length; i6++) {
              child = children[i6];
              nextName = nextNamePrefix + getElementKey(child, i6);
              subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
            }
          } else {
            var iteratorFn = getIteratorFn(children);
            if (typeof iteratorFn === "function") {
              var iterableChildren = children;
              {
                if (iteratorFn === iterableChildren.entries) {
                  if (!didWarnAboutMaps) {
                    warn("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                  }
                  didWarnAboutMaps = true;
                }
              }
              var iterator = iteratorFn.call(iterableChildren);
              var step;
              var ii = 0;
              while (!(step = iterator.next()).done) {
                child = step.value;
                nextName = nextNamePrefix + getElementKey(child, ii++);
                subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
              }
            } else if (type === "object") {
              var childrenString = String(children);
              throw new Error("Objects are not valid as a React child (found: " + (childrenString === "[object Object]" ? "object with keys {" + Object.keys(children).join(", ") + "}" : childrenString) + "). If you meant to render a collection of children, use an array instead.");
            }
          }
          return subtreeCount;
        }
        function mapChildren(children, func, context) {
          if (children == null) {
            return children;
          }
          var result = [];
          var count = 0;
          mapIntoArray(children, result, "", "", function(child) {
            return func.call(context, child, count++);
          });
          return result;
        }
        function countChildren(children) {
          var n9 = 0;
          mapChildren(children, function() {
            n9++;
          });
          return n9;
        }
        function forEachChildren(children, forEachFunc, forEachContext) {
          mapChildren(children, function() {
            forEachFunc.apply(this, arguments);
          }, forEachContext);
        }
        function toArray3(children) {
          return mapChildren(children, function(child) {
            return child;
          }) || [];
        }
        function onlyChild(children) {
          if (!isValidElement(children)) {
            throw new Error("React.Children.only expected to receive a single React element child.");
          }
          return children;
        }
        function createContext(defaultValue2) {
          var context = {
            $$typeof: REACT_CONTEXT_TYPE,
            // As a workaround to support multiple concurrent renderers, we categorize
            // some renderers as primary and others as secondary. We only expect
            // there to be two concurrent renderers at most: React Native (primary) and
            // Fabric (secondary); React DOM (primary) and React ART (secondary).
            // Secondary renderers store their context values on separate fields.
            _currentValue: defaultValue2,
            _currentValue2: defaultValue2,
            // Used to track how many concurrent renderers this context currently
            // supports within in a single renderer. Such as parallel server rendering.
            _threadCount: 0,
            // These are circular
            Provider: null,
            Consumer: null,
            // Add these to use same hidden class in VM as ServerContext
            _defaultValue: null,
            _globalName: null
          };
          context.Provider = {
            $$typeof: REACT_PROVIDER_TYPE,
            _context: context
          };
          var hasWarnedAboutUsingNestedContextConsumers = false;
          var hasWarnedAboutUsingConsumerProvider = false;
          var hasWarnedAboutDisplayNameOnConsumer = false;
          {
            var Consumer = {
              $$typeof: REACT_CONTEXT_TYPE,
              _context: context
            };
            Object.defineProperties(Consumer, {
              Provider: {
                get: function() {
                  if (!hasWarnedAboutUsingConsumerProvider) {
                    hasWarnedAboutUsingConsumerProvider = true;
                    error("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?");
                  }
                  return context.Provider;
                },
                set: function(_Provider) {
                  context.Provider = _Provider;
                }
              },
              _currentValue: {
                get: function() {
                  return context._currentValue;
                },
                set: function(_currentValue) {
                  context._currentValue = _currentValue;
                }
              },
              _currentValue2: {
                get: function() {
                  return context._currentValue2;
                },
                set: function(_currentValue2) {
                  context._currentValue2 = _currentValue2;
                }
              },
              _threadCount: {
                get: function() {
                  return context._threadCount;
                },
                set: function(_threadCount) {
                  context._threadCount = _threadCount;
                }
              },
              Consumer: {
                get: function() {
                  if (!hasWarnedAboutUsingNestedContextConsumers) {
                    hasWarnedAboutUsingNestedContextConsumers = true;
                    error("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                  }
                  return context.Consumer;
                }
              },
              displayName: {
                get: function() {
                  return context.displayName;
                },
                set: function(displayName) {
                  if (!hasWarnedAboutDisplayNameOnConsumer) {
                    warn("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", displayName);
                    hasWarnedAboutDisplayNameOnConsumer = true;
                  }
                }
              }
            });
            context.Consumer = Consumer;
          }
          {
            context._currentRenderer = null;
            context._currentRenderer2 = null;
          }
          return context;
        }
        var Uninitialized = -1;
        var Pending = 0;
        var Resolved = 1;
        var Rejected = 2;
        function lazyInitializer(payload) {
          if (payload._status === Uninitialized) {
            var ctor = payload._result;
            var thenable = ctor();
            thenable.then(function(moduleObject2) {
              if (payload._status === Pending || payload._status === Uninitialized) {
                var resolved = payload;
                resolved._status = Resolved;
                resolved._result = moduleObject2;
              }
            }, function(error2) {
              if (payload._status === Pending || payload._status === Uninitialized) {
                var rejected = payload;
                rejected._status = Rejected;
                rejected._result = error2;
              }
            });
            if (payload._status === Uninitialized) {
              var pending = payload;
              pending._status = Pending;
              pending._result = thenable;
            }
          }
          if (payload._status === Resolved) {
            var moduleObject = payload._result;
            {
              if (moduleObject === void 0) {
                error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?", moduleObject);
              }
            }
            {
              if (!("default" in moduleObject)) {
                error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))", moduleObject);
              }
            }
            return moduleObject.default;
          } else {
            throw payload._result;
          }
        }
        function lazy(ctor) {
          var payload = {
            // We use these fields to store the result.
            _status: Uninitialized,
            _result: ctor
          };
          var lazyType2 = {
            $$typeof: REACT_LAZY_TYPE,
            _payload: payload,
            _init: lazyInitializer
          };
          {
            var defaultProps;
            var propTypes;
            Object.defineProperties(lazyType2, {
              defaultProps: {
                configurable: true,
                get: function() {
                  return defaultProps;
                },
                set: function(newDefaultProps) {
                  error("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                  defaultProps = newDefaultProps;
                  Object.defineProperty(lazyType2, "defaultProps", {
                    enumerable: true
                  });
                }
              },
              propTypes: {
                configurable: true,
                get: function() {
                  return propTypes;
                },
                set: function(newPropTypes) {
                  error("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                  propTypes = newPropTypes;
                  Object.defineProperty(lazyType2, "propTypes", {
                    enumerable: true
                  });
                }
              }
            });
          }
          return lazyType2;
        }
        function forwardRef(render) {
          {
            if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
              error("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).");
            } else if (typeof render !== "function") {
              error("forwardRef requires a render function but was given %s.", render === null ? "null" : typeof render);
            } else {
              if (render.length !== 0 && render.length !== 2) {
                error("forwardRef render functions accept exactly two parameters: props and ref. %s", render.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined.");
              }
            }
            if (render != null) {
              if (render.defaultProps != null || render.propTypes != null) {
                error("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
              }
            }
          }
          var elementType = {
            $$typeof: REACT_FORWARD_REF_TYPE,
            render
          };
          {
            var ownName;
            Object.defineProperty(elementType, "displayName", {
              enumerable: false,
              configurable: true,
              get: function() {
                return ownName;
              },
              set: function(name) {
                ownName = name;
                if (!render.name && !render.displayName) {
                  render.displayName = name;
                }
              }
            });
          }
          return elementType;
        }
        var REACT_MODULE_REFERENCE;
        {
          REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
        }
        function isValidElementType(type) {
          if (typeof type === "string" || typeof type === "function") {
            return true;
          }
          if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
            return true;
          }
          if (typeof type === "object" && type !== null) {
            if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
            // types supported by any Flight configuration anywhere since
            // we don't know which Flight build this will end up being used
            // with.
            type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {
              return true;
            }
          }
          return false;
        }
        function memo2(type, compare) {
          {
            if (!isValidElementType(type)) {
              error("memo: The first argument must be a component. Instead received: %s", type === null ? "null" : typeof type);
            }
          }
          var elementType = {
            $$typeof: REACT_MEMO_TYPE,
            type,
            compare: compare === void 0 ? null : compare
          };
          {
            var ownName;
            Object.defineProperty(elementType, "displayName", {
              enumerable: false,
              configurable: true,
              get: function() {
                return ownName;
              },
              set: function(name) {
                ownName = name;
                if (!type.name && !type.displayName) {
                  type.displayName = name;
                }
              }
            });
          }
          return elementType;
        }
        function resolveDispatcher() {
          var dispatcher = ReactCurrentDispatcher.current;
          {
            if (dispatcher === null) {
              error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
            }
          }
          return dispatcher;
        }
        function useContext(Context) {
          var dispatcher = resolveDispatcher();
          {
            if (Context._context !== void 0) {
              var realContext = Context._context;
              if (realContext.Consumer === Context) {
                error("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?");
              } else if (realContext.Provider === Context) {
                error("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
              }
            }
          }
          return dispatcher.useContext(Context);
        }
        function useState(initialState) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useState(initialState);
        }
        function useReducer(reducer, initialArg, init) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useReducer(reducer, initialArg, init);
        }
        function useRef2(initialValue) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useRef(initialValue);
        }
        function useEffect2(create6, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useEffect(create6, deps);
        }
        function useInsertionEffect(create6, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useInsertionEffect(create6, deps);
        }
        function useLayoutEffect(create6, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useLayoutEffect(create6, deps);
        }
        function useCallback(callback, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useCallback(callback, deps);
        }
        function useMemo(create6, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useMemo(create6, deps);
        }
        function useImperativeHandle(ref, create6, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useImperativeHandle(ref, create6, deps);
        }
        function useDebugValue(value, formatterFn) {
          {
            var dispatcher = resolveDispatcher();
            return dispatcher.useDebugValue(value, formatterFn);
          }
        }
        function useTransition() {
          var dispatcher = resolveDispatcher();
          return dispatcher.useTransition();
        }
        function useDeferredValue(value) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useDeferredValue(value);
        }
        function useId() {
          var dispatcher = resolveDispatcher();
          return dispatcher.useId();
        }
        function useSyncExternalStore2(subscribe2, getSnapshot, getServerSnapshot) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useSyncExternalStore(subscribe2, getSnapshot, getServerSnapshot);
        }
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {
        }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          {
            if (disabledDepth === 0) {
              prevLog = console.log;
              prevInfo = console.info;
              prevWarn = console.warn;
              prevError = console.error;
              prevGroup = console.group;
              prevGroupCollapsed = console.groupCollapsed;
              prevGroupEnd = console.groupEnd;
              var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
              };
              Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
              });
            }
            disabledDepth++;
          }
        }
        function reenableLogs() {
          {
            disabledDepth--;
            if (disabledDepth === 0) {
              var props = {
                configurable: true,
                enumerable: true,
                writable: true
              };
              Object.defineProperties(console, {
                log: assign2({}, props, {
                  value: prevLog
                }),
                info: assign2({}, props, {
                  value: prevInfo
                }),
                warn: assign2({}, props, {
                  value: prevWarn
                }),
                error: assign2({}, props, {
                  value: prevError
                }),
                group: assign2({}, props, {
                  value: prevGroup
                }),
                groupCollapsed: assign2({}, props, {
                  value: prevGroupCollapsed
                }),
                groupEnd: assign2({}, props, {
                  value: prevGroupEnd
                })
              });
            }
            if (disabledDepth < 0) {
              error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
            }
          }
        }
        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix;
        function describeBuiltInComponentFrame(name, source, ownerFn) {
          {
            if (prefix === void 0) {
              try {
                throw Error();
              } catch (x2) {
                var match = x2.stack.trim().match(/\n( *(at )?)/);
                prefix = match && match[1] || "";
              }
            }
            return "\n" + prefix + name;
          }
        }
        var reentry = false;
        var componentFrameCache;
        {
          var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
          componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) {
            return "";
          }
          {
            var frame = componentFrameCache.get(fn);
            if (frame !== void 0) {
              return frame;
            }
          }
          var control;
          reentry = true;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher;
          {
            previousDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = null;
            disableLogs();
          }
          try {
            if (construct) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if (typeof Reflect === "object" && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x2) {
                  control = x2;
                }
                Reflect.construct(fn, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x2) {
                  control = x2;
                }
                fn.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x2) {
                control = x2;
              }
              fn();
            }
          } catch (sample) {
            if (sample && control && typeof sample.stack === "string") {
              var sampleLines = sample.stack.split("\n");
              var controlLines = control.stack.split("\n");
              var s9 = sampleLines.length - 1;
              var c6 = controlLines.length - 1;
              while (s9 >= 1 && c6 >= 0 && sampleLines[s9] !== controlLines[c6]) {
                c6--;
              }
              for (; s9 >= 1 && c6 >= 0; s9--, c6--) {
                if (sampleLines[s9] !== controlLines[c6]) {
                  if (s9 !== 1 || c6 !== 1) {
                    do {
                      s9--;
                      c6--;
                      if (c6 < 0 || sampleLines[s9] !== controlLines[c6]) {
                        var _frame = "\n" + sampleLines[s9].replace(" at new ", " at ");
                        if (fn.displayName && _frame.includes("<anonymous>")) {
                          _frame = _frame.replace("<anonymous>", fn.displayName);
                        }
                        {
                          if (typeof fn === "function") {
                            componentFrameCache.set(fn, _frame);
                          }
                        }
                        return _frame;
                      }
                    } while (s9 >= 1 && c6 >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            {
              ReactCurrentDispatcher$1.current = previousDispatcher;
              reenableLogs();
            }
            Error.prepareStackTrace = previousPrepareStackTrace;
          }
          var name = fn ? fn.displayName || fn.name : "";
          var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
          {
            if (typeof fn === "function") {
              componentFrameCache.set(fn, syntheticFrame);
            }
          }
          return syntheticFrame;
        }
        function describeFunctionComponentFrame(fn, source, ownerFn) {
          {
            return describeNativeComponentFrame(fn, false);
          }
        }
        function shouldConstruct(Component2) {
          var prototype3 = Component2.prototype;
          return !!(prototype3 && prototype3.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
          if (type == null) {
            return "";
          }
          if (typeof type === "function") {
            {
              return describeNativeComponentFrame(type, shouldConstruct(type));
            }
          }
          if (typeof type === "string") {
            return describeBuiltInComponentFrame(type);
          }
          switch (type) {
            case REACT_SUSPENSE_TYPE:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type.render);
              case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                } catch (x2) {
                }
              }
            }
          }
          return "";
        }
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame$1.setExtraStackFrame(null);
            }
          }
        }
        function checkPropTypes(typeSpecs, values, location, componentName, element) {
          {
            var has = Function.call.bind(hasOwnProperty2);
            for (var typeSpecName in typeSpecs) {
              if (has(typeSpecs, typeSpecName)) {
                var error$1 = void 0;
                try {
                  if (typeof typeSpecs[typeSpecName] !== "function") {
                    var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err.name = "Invariant Violation";
                    throw err;
                  }
                  error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (ex) {
                  error$1 = ex;
                }
                if (error$1 && !(error$1 instanceof Error)) {
                  setCurrentlyValidatingElement(element);
                  error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                  setCurrentlyValidatingElement(null);
                }
                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                  loggedTypeFailures[error$1.message] = true;
                  setCurrentlyValidatingElement(element);
                  error("Failed %s type: %s", location, error$1.message);
                  setCurrentlyValidatingElement(null);
                }
              }
            }
          }
        }
        function setCurrentlyValidatingElement$1(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              setExtraStackFrame(stack);
            } else {
              setExtraStackFrame(null);
            }
          }
        }
        var propTypesMisspellWarningShown;
        {
          propTypesMisspellWarningShown = false;
        }
        function getDeclarationErrorAddendum() {
          if (ReactCurrentOwner.current) {
            var name = getComponentNameFromType(ReactCurrentOwner.current.type);
            if (name) {
              return "\n\nCheck the render method of `" + name + "`.";
            }
          }
          return "";
        }
        function getSourceInfoErrorAddendum(source) {
          if (source !== void 0) {
            var fileName = source.fileName.replace(/^.*[\\\/]/, "");
            var lineNumber = source.lineNumber;
            return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
          }
          return "";
        }
        function getSourceInfoErrorAddendumForProps(elementProps) {
          if (elementProps !== null && elementProps !== void 0) {
            return getSourceInfoErrorAddendum(elementProps.__source);
          }
          return "";
        }
        var ownerHasKeyUseWarning = {};
        function getCurrentComponentErrorInfo(parentType) {
          var info = getDeclarationErrorAddendum();
          if (!info) {
            var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
            if (parentName) {
              info = "\n\nCheck the top-level render call using <" + parentName + ">.";
            }
          }
          return info;
        }
        function validateExplicitKey(element, parentType) {
          if (!element._store || element._store.validated || element.key != null) {
            return;
          }
          element._store.validated = true;
          var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
          if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
            return;
          }
          ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
          var childOwner = "";
          if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
            childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
          }
          {
            setCurrentlyValidatingElement$1(element);
            error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
            setCurrentlyValidatingElement$1(null);
          }
        }
        function validateChildKeys(node, parentType) {
          if (typeof node !== "object") {
            return;
          }
          if (isArray3(node)) {
            for (var i6 = 0; i6 < node.length; i6++) {
              var child = node[i6];
              if (isValidElement(child)) {
                validateExplicitKey(child, parentType);
              }
            }
          } else if (isValidElement(node)) {
            if (node._store) {
              node._store.validated = true;
            }
          } else if (node) {
            var iteratorFn = getIteratorFn(node);
            if (typeof iteratorFn === "function") {
              if (iteratorFn !== node.entries) {
                var iterator = iteratorFn.call(node);
                var step;
                while (!(step = iterator.next()).done) {
                  if (isValidElement(step.value)) {
                    validateExplicitKey(step.value, parentType);
                  }
                }
              }
            }
          }
        }
        function validatePropTypes(element) {
          {
            var type = element.type;
            if (type === null || type === void 0 || typeof type === "string") {
              return;
            }
            var propTypes;
            if (typeof type === "function") {
              propTypes = type.propTypes;
            } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
            // Inner props are checked in the reconciler.
            type.$$typeof === REACT_MEMO_TYPE)) {
              propTypes = type.propTypes;
            } else {
              return;
            }
            if (propTypes) {
              var name = getComponentNameFromType(type);
              checkPropTypes(propTypes, element.props, "prop", name, element);
            } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
              propTypesMisspellWarningShown = true;
              var _name = getComponentNameFromType(type);
              error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
            }
            if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
              error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
            }
          }
        }
        function validateFragmentProps(fragment) {
          {
            var keys = Object.keys(fragment.props);
            for (var i6 = 0; i6 < keys.length; i6++) {
              var key = keys[i6];
              if (key !== "children" && key !== "key") {
                setCurrentlyValidatingElement$1(fragment);
                error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
                setCurrentlyValidatingElement$1(null);
                break;
              }
            }
            if (fragment.ref !== null) {
              setCurrentlyValidatingElement$1(fragment);
              error("Invalid attribute `ref` supplied to `React.Fragment`.");
              setCurrentlyValidatingElement$1(null);
            }
          }
        }
        function createElementWithValidation(type, props, children) {
          var validType = isValidElementType(type);
          if (!validType) {
            var info = "";
            if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
              info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            }
            var sourceInfo = getSourceInfoErrorAddendumForProps(props);
            if (sourceInfo) {
              info += sourceInfo;
            } else {
              info += getDeclarationErrorAddendum();
            }
            var typeString;
            if (type === null) {
              typeString = "null";
            } else if (isArray3(type)) {
              typeString = "array";
            } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
              typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />";
              info = " Did you accidentally export a JSX literal instead of a component?";
            } else {
              typeString = typeof type;
            }
            {
              error("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
            }
          }
          var element = createElement2.apply(this, arguments);
          if (element == null) {
            return element;
          }
          if (validType) {
            for (var i6 = 2; i6 < arguments.length; i6++) {
              validateChildKeys(arguments[i6], type);
            }
          }
          if (type === REACT_FRAGMENT_TYPE) {
            validateFragmentProps(element);
          } else {
            validatePropTypes(element);
          }
          return element;
        }
        var didWarnAboutDeprecatedCreateFactory = false;
        function createFactoryWithValidation(type) {
          var validatedFactory = createElementWithValidation.bind(null, type);
          validatedFactory.type = type;
          {
            if (!didWarnAboutDeprecatedCreateFactory) {
              didWarnAboutDeprecatedCreateFactory = true;
              warn("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.");
            }
            Object.defineProperty(validatedFactory, "type", {
              enumerable: false,
              get: function() {
                warn("Factory.type is deprecated. Access the class directly before passing it to createFactory.");
                Object.defineProperty(this, "type", {
                  value: type
                });
                return type;
              }
            });
          }
          return validatedFactory;
        }
        function cloneElementWithValidation(element, props, children) {
          var newElement = cloneElement.apply(this, arguments);
          for (var i6 = 2; i6 < arguments.length; i6++) {
            validateChildKeys(arguments[i6], newElement.type);
          }
          validatePropTypes(newElement);
          return newElement;
        }
        function startTransition(scope, options) {
          var prevTransition = ReactCurrentBatchConfig.transition;
          ReactCurrentBatchConfig.transition = {};
          var currentTransition = ReactCurrentBatchConfig.transition;
          {
            ReactCurrentBatchConfig.transition._updatedFibers = /* @__PURE__ */ new Set();
          }
          try {
            scope();
          } finally {
            ReactCurrentBatchConfig.transition = prevTransition;
            {
              if (prevTransition === null && currentTransition._updatedFibers) {
                var updatedFibersCount = currentTransition._updatedFibers.size;
                if (updatedFibersCount > 10) {
                  warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.");
                }
                currentTransition._updatedFibers.clear();
              }
            }
          }
        }
        var didWarnAboutMessageChannel = false;
        var enqueueTaskImpl = null;
        function enqueueTask(task) {
          if (enqueueTaskImpl === null) {
            try {
              var requireString = ("require" + Math.random()).slice(0, 7);
              var nodeRequire = module && module[requireString];
              enqueueTaskImpl = nodeRequire.call(module, "timers").setImmediate;
            } catch (_err) {
              enqueueTaskImpl = function(callback) {
                {
                  if (didWarnAboutMessageChannel === false) {
                    didWarnAboutMessageChannel = true;
                    if (typeof MessageChannel === "undefined") {
                      error("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning.");
                    }
                  }
                }
                var channel = new MessageChannel();
                channel.port1.onmessage = callback;
                channel.port2.postMessage(void 0);
              };
            }
          }
          return enqueueTaskImpl(task);
        }
        var actScopeDepth = 0;
        var didWarnNoAwaitAct = false;
        function act(callback) {
          {
            var prevActScopeDepth = actScopeDepth;
            actScopeDepth++;
            if (ReactCurrentActQueue.current === null) {
              ReactCurrentActQueue.current = [];
            }
            var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;
            var result;
            try {
              ReactCurrentActQueue.isBatchingLegacy = true;
              result = callback();
              if (!prevIsBatchingLegacy && ReactCurrentActQueue.didScheduleLegacyUpdate) {
                var queue = ReactCurrentActQueue.current;
                if (queue !== null) {
                  ReactCurrentActQueue.didScheduleLegacyUpdate = false;
                  flushActQueue(queue);
                }
              }
            } catch (error2) {
              popActScope(prevActScopeDepth);
              throw error2;
            } finally {
              ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;
            }
            if (result !== null && typeof result === "object" && typeof result.then === "function") {
              var thenableResult = result;
              var wasAwaited = false;
              var thenable = {
                then: function(resolve, reject) {
                  wasAwaited = true;
                  thenableResult.then(function(returnValue2) {
                    popActScope(prevActScopeDepth);
                    if (actScopeDepth === 0) {
                      recursivelyFlushAsyncActWork(returnValue2, resolve, reject);
                    } else {
                      resolve(returnValue2);
                    }
                  }, function(error2) {
                    popActScope(prevActScopeDepth);
                    reject(error2);
                  });
                }
              };
              {
                if (!didWarnNoAwaitAct && typeof Promise !== "undefined") {
                  Promise.resolve().then(function() {
                  }).then(function() {
                    if (!wasAwaited) {
                      didWarnNoAwaitAct = true;
                      error("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);");
                    }
                  });
                }
              }
              return thenable;
            } else {
              var returnValue = result;
              popActScope(prevActScopeDepth);
              if (actScopeDepth === 0) {
                var _queue3 = ReactCurrentActQueue.current;
                if (_queue3 !== null) {
                  flushActQueue(_queue3);
                  ReactCurrentActQueue.current = null;
                }
                var _thenable = {
                  then: function(resolve, reject) {
                    if (ReactCurrentActQueue.current === null) {
                      ReactCurrentActQueue.current = [];
                      recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                    } else {
                      resolve(returnValue);
                    }
                  }
                };
                return _thenable;
              } else {
                var _thenable2 = {
                  then: function(resolve, reject) {
                    resolve(returnValue);
                  }
                };
                return _thenable2;
              }
            }
          }
        }
        function popActScope(prevActScopeDepth) {
          {
            if (prevActScopeDepth !== actScopeDepth - 1) {
              error("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. ");
            }
            actScopeDepth = prevActScopeDepth;
          }
        }
        function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
          {
            var queue = ReactCurrentActQueue.current;
            if (queue !== null) {
              try {
                flushActQueue(queue);
                enqueueTask(function() {
                  if (queue.length === 0) {
                    ReactCurrentActQueue.current = null;
                    resolve(returnValue);
                  } else {
                    recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                  }
                });
              } catch (error2) {
                reject(error2);
              }
            } else {
              resolve(returnValue);
            }
          }
        }
        var isFlushing = false;
        function flushActQueue(queue) {
          {
            if (!isFlushing) {
              isFlushing = true;
              var i6 = 0;
              try {
                for (; i6 < queue.length; i6++) {
                  var callback = queue[i6];
                  do {
                    callback = callback(true);
                  } while (callback !== null);
                }
                queue.length = 0;
              } catch (error2) {
                queue = queue.slice(i6 + 1);
                throw error2;
              } finally {
                isFlushing = false;
              }
            }
          }
        }
        var createElement$1 = createElementWithValidation;
        var cloneElement$1 = cloneElementWithValidation;
        var createFactory = createFactoryWithValidation;
        var Children = {
          map: mapChildren,
          forEach: forEachChildren,
          count: countChildren,
          toArray: toArray3,
          only: onlyChild
        };
        exports.Children = Children;
        exports.Component = Component;
        exports.Fragment = REACT_FRAGMENT_TYPE;
        exports.Profiler = REACT_PROFILER_TYPE;
        exports.PureComponent = PureComponent;
        exports.StrictMode = REACT_STRICT_MODE_TYPE;
        exports.Suspense = REACT_SUSPENSE_TYPE;
        exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
        exports.cloneElement = cloneElement$1;
        exports.createContext = createContext;
        exports.createElement = createElement$1;
        exports.createFactory = createFactory;
        exports.createRef = createRef;
        exports.forwardRef = forwardRef;
        exports.isValidElement = isValidElement;
        exports.lazy = lazy;
        exports.memo = memo2;
        exports.startTransition = startTransition;
        exports.unstable_act = act;
        exports.useCallback = useCallback;
        exports.useContext = useContext;
        exports.useDebugValue = useDebugValue;
        exports.useDeferredValue = useDeferredValue;
        exports.useEffect = useEffect2;
        exports.useId = useId;
        exports.useImperativeHandle = useImperativeHandle;
        exports.useInsertionEffect = useInsertionEffect;
        exports.useLayoutEffect = useLayoutEffect;
        exports.useMemo = useMemo;
        exports.useReducer = useReducer;
        exports.useRef = useRef2;
        exports.useState = useState;
        exports.useSyncExternalStore = useSyncExternalStore2;
        exports.useTransition = useTransition;
        exports.version = ReactVersion;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  }
});

// node_modules/react/index.js
var require_react = __commonJS({
  "node_modules/react/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_development();
    }
  }
});

// node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "node_modules/fast-deep-equal/index.js"(exports, module) {
    "use strict";
    module.exports = function equal(a4, b3) {
      if (a4 === b3) return true;
      if (a4 && b3 && typeof a4 == "object" && typeof b3 == "object") {
        if (a4.constructor !== b3.constructor) return false;
        var length4, i6, keys;
        if (Array.isArray(a4)) {
          length4 = a4.length;
          if (length4 != b3.length) return false;
          for (i6 = length4; i6-- !== 0; )
            if (!equal(a4[i6], b3[i6])) return false;
          return true;
        }
        if (a4.constructor === RegExp) return a4.source === b3.source && a4.flags === b3.flags;
        if (a4.valueOf !== Object.prototype.valueOf) return a4.valueOf() === b3.valueOf();
        if (a4.toString !== Object.prototype.toString) return a4.toString() === b3.toString();
        keys = Object.keys(a4);
        length4 = keys.length;
        if (length4 !== Object.keys(b3).length) return false;
        for (i6 = length4; i6-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b3, keys[i6])) return false;
        for (i6 = length4; i6-- !== 0; ) {
          var key = keys[i6];
          if (!equal(a4[key], b3[key])) return false;
        }
        return true;
      }
      return a4 !== a4 && b3 !== b3;
    };
  }
});

// node_modules/object-keys/isArguments.js
var require_isArguments = __commonJS({
  "node_modules/object-keys/isArguments.js"(exports, module) {
    "use strict";
    var toStr = Object.prototype.toString;
    module.exports = function isArguments(value) {
      var str6 = toStr.call(value);
      var isArgs = str6 === "[object Arguments]";
      if (!isArgs) {
        isArgs = str6 !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr.call(value.callee) === "[object Function]";
      }
      return isArgs;
    };
  }
});

// node_modules/object-keys/implementation.js
var require_implementation = __commonJS({
  "node_modules/object-keys/implementation.js"(exports, module) {
    "use strict";
    var keysShim;
    if (!Object.keys) {
      has = Object.prototype.hasOwnProperty;
      toStr = Object.prototype.toString;
      isArgs = require_isArguments();
      isEnumerable = Object.prototype.propertyIsEnumerable;
      hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString");
      hasProtoEnumBug = isEnumerable.call(function() {
      }, "prototype");
      dontEnums = [
        "toString",
        "toLocaleString",
        "valueOf",
        "hasOwnProperty",
        "isPrototypeOf",
        "propertyIsEnumerable",
        "constructor"
      ];
      equalsConstructorPrototype = function(o11) {
        var ctor = o11.constructor;
        return ctor && ctor.prototype === o11;
      };
      excludedKeys = {
        $applicationCache: true,
        $console: true,
        $external: true,
        $frame: true,
        $frameElement: true,
        $frames: true,
        $innerHeight: true,
        $innerWidth: true,
        $onmozfullscreenchange: true,
        $onmozfullscreenerror: true,
        $outerHeight: true,
        $outerWidth: true,
        $pageXOffset: true,
        $pageYOffset: true,
        $parent: true,
        $scrollLeft: true,
        $scrollTop: true,
        $scrollX: true,
        $scrollY: true,
        $self: true,
        $webkitIndexedDB: true,
        $webkitStorageInfo: true,
        $window: true
      };
      hasAutomationEqualityBug = function() {
        if (typeof window === "undefined") {
          return false;
        }
        for (var k2 in window) {
          try {
            if (!excludedKeys["$" + k2] && has.call(window, k2) && window[k2] !== null && typeof window[k2] === "object") {
              try {
                equalsConstructorPrototype(window[k2]);
              } catch (e13) {
                return true;
              }
            }
          } catch (e13) {
            return true;
          }
        }
        return false;
      }();
      equalsConstructorPrototypeIfNotBuggy = function(o11) {
        if (typeof window === "undefined" || !hasAutomationEqualityBug) {
          return equalsConstructorPrototype(o11);
        }
        try {
          return equalsConstructorPrototype(o11);
        } catch (e13) {
          return false;
        }
      };
      keysShim = function keys(object) {
        var isObject3 = object !== null && typeof object === "object";
        var isFunction2 = toStr.call(object) === "[object Function]";
        var isArguments = isArgs(object);
        var isString2 = isObject3 && toStr.call(object) === "[object String]";
        var theKeys = [];
        if (!isObject3 && !isFunction2 && !isArguments) {
          throw new TypeError("Object.keys called on a non-object");
        }
        var skipProto = hasProtoEnumBug && isFunction2;
        if (isString2 && object.length > 0 && !has.call(object, 0)) {
          for (var i6 = 0; i6 < object.length; ++i6) {
            theKeys.push(String(i6));
          }
        }
        if (isArguments && object.length > 0) {
          for (var j2 = 0; j2 < object.length; ++j2) {
            theKeys.push(String(j2));
          }
        } else {
          for (var name in object) {
            if (!(skipProto && name === "prototype") && has.call(object, name)) {
              theKeys.push(String(name));
            }
          }
        }
        if (hasDontEnumBug) {
          var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
          for (var k2 = 0; k2 < dontEnums.length; ++k2) {
            if (!(skipConstructor && dontEnums[k2] === "constructor") && has.call(object, dontEnums[k2])) {
              theKeys.push(dontEnums[k2]);
            }
          }
        }
        return theKeys;
      };
    }
    var has;
    var toStr;
    var isArgs;
    var isEnumerable;
    var hasDontEnumBug;
    var hasProtoEnumBug;
    var dontEnums;
    var equalsConstructorPrototype;
    var excludedKeys;
    var hasAutomationEqualityBug;
    var equalsConstructorPrototypeIfNotBuggy;
    module.exports = keysShim;
  }
});

// node_modules/object-keys/index.js
var require_object_keys = __commonJS({
  "node_modules/object-keys/index.js"(exports, module) {
    "use strict";
    var slice = Array.prototype.slice;
    var isArgs = require_isArguments();
    var origKeys = Object.keys;
    var keysShim = origKeys ? function keys(o11) {
      return origKeys(o11);
    } : require_implementation();
    var originalKeys = Object.keys;
    keysShim.shim = function shimObjectKeys() {
      if (Object.keys) {
        var keysWorksWithArguments = function() {
          var args = Object.keys(arguments);
          return args && args.length === arguments.length;
        }(1, 2);
        if (!keysWorksWithArguments) {
          Object.keys = function keys(object) {
            if (isArgs(object)) {
              return originalKeys(slice.call(object));
            }
            return originalKeys(object);
          };
        }
      } else {
        Object.keys = keysShim;
      }
      return Object.keys || keysShim;
    };
    module.exports = keysShim;
  }
});

// node_modules/es-errors/index.js
var require_es_errors = __commonJS({
  "node_modules/es-errors/index.js"(exports, module) {
    "use strict";
    module.exports = Error;
  }
});

// node_modules/es-errors/eval.js
var require_eval = __commonJS({
  "node_modules/es-errors/eval.js"(exports, module) {
    "use strict";
    module.exports = EvalError;
  }
});

// node_modules/es-errors/range.js
var require_range = __commonJS({
  "node_modules/es-errors/range.js"(exports, module) {
    "use strict";
    module.exports = RangeError;
  }
});

// node_modules/es-errors/ref.js
var require_ref = __commonJS({
  "node_modules/es-errors/ref.js"(exports, module) {
    "use strict";
    module.exports = ReferenceError;
  }
});

// node_modules/es-errors/syntax.js
var require_syntax = __commonJS({
  "node_modules/es-errors/syntax.js"(exports, module) {
    "use strict";
    module.exports = SyntaxError;
  }
});

// node_modules/es-errors/type.js
var require_type = __commonJS({
  "node_modules/es-errors/type.js"(exports, module) {
    "use strict";
    module.exports = TypeError;
  }
});

// node_modules/es-errors/uri.js
var require_uri = __commonJS({
  "node_modules/es-errors/uri.js"(exports, module) {
    "use strict";
    module.exports = URIError;
  }
});

// node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "node_modules/has-symbols/shams.js"(exports, module) {
    "use strict";
    module.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj2 = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj2[sym] = symVal;
      for (sym in obj2) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj2).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj2).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj2);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj2, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = Object.getOwnPropertyDescriptor(obj2, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "node_modules/has-symbols/index.js"(exports, module) {
    "use strict";
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// node_modules/has-proto/index.js
var require_has_proto = __commonJS({
  "node_modules/has-proto/index.js"(exports, module) {
    "use strict";
    var test = {
      __proto__: null,
      foo: {}
    };
    var $Object = Object;
    module.exports = function hasProto() {
      return { __proto__: test }.foo === test.foo && !(test instanceof $Object);
    };
  }
});

// node_modules/function-bind/implementation.js
var require_implementation2 = __commonJS({
  "node_modules/function-bind/implementation.js"(exports, module) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var toStr = Object.prototype.toString;
    var max5 = Math.max;
    var funcType = "[object Function]";
    var concatty = function concatty2(a4, b3) {
      var arr = [];
      for (var i6 = 0; i6 < a4.length; i6 += 1) {
        arr[i6] = a4[i6];
      }
      for (var j2 = 0; j2 < b3.length; j2 += 1) {
        arr[j2 + a4.length] = b3[j2];
      }
      return arr;
    };
    var slicy = function slicy2(arrLike, offset3) {
      var arr = [];
      for (var i6 = offset3 || 0, j2 = 0; i6 < arrLike.length; i6 += 1, j2 += 1) {
        arr[j2] = arrLike[i6];
      }
      return arr;
    };
    var joiny = function(arr, joiner) {
      var str6 = "";
      for (var i6 = 0; i6 < arr.length; i6 += 1) {
        str6 += arr[i6];
        if (i6 + 1 < arr.length) {
          str6 += joiner;
        }
      }
      return str6;
    };
    module.exports = function bind2(that) {
      var target = this;
      if (typeof target !== "function" || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slicy(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            concatty(args, arguments)
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        }
        return target.apply(
          that,
          concatty(args, arguments)
        );
      };
      var boundLength = max5(0, target.length - args.length);
      var boundArgs = [];
      for (var i6 = 0; i6 < boundLength; i6++) {
        boundArgs[i6] = "$" + i6;
      }
      bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "node_modules/function-bind/index.js"(exports, module) {
    "use strict";
    var implementation = require_implementation2();
    module.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/hasown/index.js
var require_hasown = __commonJS({
  "node_modules/hasown/index.js"(exports, module) {
    "use strict";
    var call = Function.prototype.call;
    var $hasOwn = Object.prototype.hasOwnProperty;
    var bind2 = require_function_bind();
    module.exports = bind2.call(call, $hasOwn);
  }
});

// node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "node_modules/get-intrinsic/index.js"(exports, module) {
    "use strict";
    var undefined2;
    var $Error = require_es_errors();
    var $EvalError = require_eval();
    var $RangeError = require_range();
    var $ReferenceError = require_ref();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var $URIError = require_uri();
    var $Function = Function;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e13) {
      }
    };
    var $gOPD = Object.getOwnPropertyDescriptor;
    if ($gOPD) {
      try {
        $gOPD({}, "");
      } catch (e13) {
        $gOPD = null;
      }
    }
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var hasProto = require_has_proto()();
    var getProto = Object.getPrototypeOf || (hasProto ? function(x2) {
      return x2.__proto__;
    } : null);
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      __proto__: null,
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": $Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": $EvalError,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": Object,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": $RangeError,
      "%ReferenceError%": $ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": $URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
    };
    if (getProto) {
      try {
        null.error;
      } catch (e13) {
        errorProto = getProto(getProto(e13));
        INTRINSICS["%Error.prototype%"] = errorProto;
      }
    }
    var errorProto;
    var doEval = function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen && getProto) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      __proto__: null,
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind2 = require_function_bind();
    var hasOwn = require_hasown();
    var $concat = bind2.call(Function.call, Array.prototype.concat);
    var $spliceApply = bind2.call(Function.apply, Array.prototype.splice);
    var $replace = bind2.call(Function.call, String.prototype.replace);
    var $strSlice = bind2.call(Function.call, String.prototype.slice);
    var $exec = bind2.call(Function.call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string) {
      var first = $strSlice(string, 0, 1);
      var last = $strSlice(string, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    };
    module.exports = function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i6 = 1, isOwn = true; i6 < parts.length; i6 += 1) {
        var part = parts[i6];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            }
            return void 0;
          }
          if ($gOPD && i6 + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// node_modules/es-define-property/index.js
var require_es_define_property = __commonJS({
  "node_modules/es-define-property/index.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true) || false;
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e13) {
        $defineProperty = false;
      }
    }
    module.exports = $defineProperty;
  }
});

// node_modules/gopd/index.js
var require_gopd = __commonJS({
  "node_modules/gopd/index.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e13) {
        $gOPD = null;
      }
    }
    module.exports = $gOPD;
  }
});

// node_modules/define-data-property/index.js
var require_define_data_property = __commonJS({
  "node_modules/define-data-property/index.js"(exports, module) {
    "use strict";
    var $defineProperty = require_es_define_property();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var gopd = require_gopd();
    module.exports = function defineDataProperty(obj2, property, value) {
      if (!obj2 || typeof obj2 !== "object" && typeof obj2 !== "function") {
        throw new $TypeError("`obj` must be an object or a function`");
      }
      if (typeof property !== "string" && typeof property !== "symbol") {
        throw new $TypeError("`property` must be a string or a symbol`");
      }
      if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
        throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
        throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
        throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
        throw new $TypeError("`loose`, if provided, must be a boolean");
      }
      var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
      var nonWritable = arguments.length > 4 ? arguments[4] : null;
      var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
      var loose = arguments.length > 6 ? arguments[6] : false;
      var desc = !!gopd && gopd(obj2, property);
      if ($defineProperty) {
        $defineProperty(obj2, property, {
          configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
          enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
          value,
          writable: nonWritable === null && desc ? desc.writable : !nonWritable
        });
      } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
        obj2[property] = value;
      } else {
        throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
      }
    };
  }
});

// node_modules/has-property-descriptors/index.js
var require_has_property_descriptors = __commonJS({
  "node_modules/has-property-descriptors/index.js"(exports, module) {
    "use strict";
    var $defineProperty = require_es_define_property();
    var hasPropertyDescriptors = function hasPropertyDescriptors2() {
      return !!$defineProperty;
    };
    hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
      if (!$defineProperty) {
        return null;
      }
      try {
        return $defineProperty([], "length", { value: 1 }).length !== 1;
      } catch (e13) {
        return true;
      }
    };
    module.exports = hasPropertyDescriptors;
  }
});

// node_modules/define-properties/index.js
var require_define_properties = __commonJS({
  "node_modules/define-properties/index.js"(exports, module) {
    "use strict";
    var keys = require_object_keys();
    var hasSymbols = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
    var toStr = Object.prototype.toString;
    var concat = Array.prototype.concat;
    var defineDataProperty = require_define_data_property();
    var isFunction2 = function(fn) {
      return typeof fn === "function" && toStr.call(fn) === "[object Function]";
    };
    var supportsDescriptors = require_has_property_descriptors()();
    var defineProperty = function(object, name, value, predicate) {
      if (name in object) {
        if (predicate === true) {
          if (object[name] === value) {
            return;
          }
        } else if (!isFunction2(predicate) || !predicate()) {
          return;
        }
      }
      if (supportsDescriptors) {
        defineDataProperty(object, name, value, true);
      } else {
        defineDataProperty(object, name, value);
      }
    };
    var defineProperties = function(object, map) {
      var predicates2 = arguments.length > 2 ? arguments[2] : {};
      var props = keys(map);
      if (hasSymbols) {
        props = concat.call(props, Object.getOwnPropertySymbols(map));
      }
      for (var i6 = 0; i6 < props.length; i6 += 1) {
        defineProperty(object, props[i6], map[props[i6]], predicates2[props[i6]]);
      }
    };
    defineProperties.supportsDescriptors = !!supportsDescriptors;
    module.exports = defineProperties;
  }
});

// node_modules/globalthis/implementation.browser.js
var require_implementation_browser = __commonJS({
  "node_modules/globalthis/implementation.browser.js"(exports, module) {
    "use strict";
    if (typeof self !== "undefined") {
      module.exports = self;
    } else if (typeof window !== "undefined") {
      module.exports = window;
    } else {
      module.exports = Function("return this")();
    }
  }
});

// node_modules/globalthis/polyfill.js
var require_polyfill = __commonJS({
  "node_modules/globalthis/polyfill.js"(exports, module) {
    "use strict";
    var implementation = require_implementation_browser();
    module.exports = function getPolyfill() {
      if (typeof global !== "object" || !global || global.Math !== Math || global.Array !== Array) {
        return implementation;
      }
      return global;
    };
  }
});

// node_modules/globalthis/shim.js
var require_shim = __commonJS({
  "node_modules/globalthis/shim.js"(exports, module) {
    "use strict";
    var define2 = require_define_properties();
    var getPolyfill = require_polyfill();
    module.exports = function shimGlobal() {
      var polyfill = getPolyfill();
      if (define2.supportsDescriptors) {
        var descriptor = Object.getOwnPropertyDescriptor(polyfill, "globalThis");
        if (!descriptor || descriptor.configurable && (descriptor.enumerable || !descriptor.writable || globalThis !== polyfill)) {
          Object.defineProperty(polyfill, "globalThis", {
            configurable: true,
            enumerable: false,
            value: polyfill,
            writable: true
          });
        }
      } else if (typeof globalThis !== "object" || globalThis !== polyfill) {
        polyfill.globalThis = polyfill;
      }
      return polyfill;
    };
  }
});

// node_modules/globalthis/index.js
var require_globalthis = __commonJS({
  "node_modules/globalthis/index.js"(exports, module) {
    "use strict";
    var defineProperties = require_define_properties();
    var implementation = require_implementation_browser();
    var getPolyfill = require_polyfill();
    var shim = require_shim();
    var polyfill = getPolyfill();
    var getGlobal2 = function() {
      return polyfill;
    };
    defineProperties(getGlobal2, {
      getPolyfill,
      implementation,
      shim
    });
    module.exports = getGlobal2;
  }
});

// node_modules/seedrandom/lib/alea.js
var require_alea = __commonJS({
  "node_modules/seedrandom/lib/alea.js"(exports, module) {
    "use strict";
    (function(global2, module2, define2) {
      function Alea(seed) {
        var me = this, mash = Mash();
        me.next = function() {
          var t9 = 2091639 * me.s0 + me.c * 23283064365386963e-26;
          me.s0 = me.s1;
          me.s1 = me.s2;
          return me.s2 = t9 - (me.c = t9 | 0);
        };
        me.c = 1;
        me.s0 = mash(" ");
        me.s1 = mash(" ");
        me.s2 = mash(" ");
        me.s0 -= mash(seed);
        if (me.s0 < 0) {
          me.s0 += 1;
        }
        me.s1 -= mash(seed);
        if (me.s1 < 0) {
          me.s1 += 1;
        }
        me.s2 -= mash(seed);
        if (me.s2 < 0) {
          me.s2 += 1;
        }
        mash = null;
      }
      function copy6(f5, t9) {
        t9.c = f5.c;
        t9.s0 = f5.s0;
        t9.s1 = f5.s1;
        t9.s2 = f5.s2;
        return t9;
      }
      function impl(seed, opts) {
        var xg = new Alea(seed), state = opts && opts.state, prng = xg.next;
        prng.int32 = function() {
          return xg.next() * 4294967296 | 0;
        };
        prng.double = function() {
          return prng() + (prng() * 2097152 | 0) * 11102230246251565e-32;
        };
        prng.quick = prng;
        if (state) {
          if (typeof state == "object") copy6(state, xg);
          prng.state = function() {
            return copy6(xg, {});
          };
        }
        return prng;
      }
      function Mash() {
        var n9 = 4022871197;
        var mash = function(data) {
          data = String(data);
          for (var i6 = 0; i6 < data.length; i6++) {
            n9 += data.charCodeAt(i6);
            var h5 = 0.02519603282416938 * n9;
            n9 = h5 >>> 0;
            h5 -= n9;
            h5 *= n9;
            n9 = h5 >>> 0;
            h5 -= n9;
            n9 += h5 * 4294967296;
          }
          return (n9 >>> 0) * 23283064365386963e-26;
        };
        return mash;
      }
      if (module2 && module2.exports) {
        module2.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.alea = impl;
      }
    })(
      exports,
      typeof module == "object" && module,
      // present in node.js
      typeof define == "function" && define
      // present with an AMD loader
    );
  }
});

// node_modules/seedrandom/lib/xor128.js
var require_xor128 = __commonJS({
  "node_modules/seedrandom/lib/xor128.js"(exports, module) {
    "use strict";
    (function(global2, module2, define2) {
      function XorGen(seed) {
        var me = this, strseed = "";
        me.x = 0;
        me.y = 0;
        me.z = 0;
        me.w = 0;
        me.next = function() {
          var t9 = me.x ^ me.x << 11;
          me.x = me.y;
          me.y = me.z;
          me.z = me.w;
          return me.w ^= me.w >>> 19 ^ t9 ^ t9 >>> 8;
        };
        if (seed === (seed | 0)) {
          me.x = seed;
        } else {
          strseed += seed;
        }
        for (var k2 = 0; k2 < strseed.length + 64; k2++) {
          me.x ^= strseed.charCodeAt(k2) | 0;
          me.next();
        }
      }
      function copy6(f5, t9) {
        t9.x = f5.x;
        t9.y = f5.y;
        t9.z = f5.z;
        t9.w = f5.w;
        return t9;
      }
      function impl(seed, opts) {
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (typeof state == "object") copy6(state, xg);
          prng.state = function() {
            return copy6(xg, {});
          };
        }
        return prng;
      }
      if (module2 && module2.exports) {
        module2.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.xor128 = impl;
      }
    })(
      exports,
      typeof module == "object" && module,
      // present in node.js
      typeof define == "function" && define
      // present with an AMD loader
    );
  }
});

// node_modules/seedrandom/lib/xorwow.js
var require_xorwow = __commonJS({
  "node_modules/seedrandom/lib/xorwow.js"(exports, module) {
    "use strict";
    (function(global2, module2, define2) {
      function XorGen(seed) {
        var me = this, strseed = "";
        me.next = function() {
          var t9 = me.x ^ me.x >>> 2;
          me.x = me.y;
          me.y = me.z;
          me.z = me.w;
          me.w = me.v;
          return (me.d = me.d + 362437 | 0) + (me.v = me.v ^ me.v << 4 ^ (t9 ^ t9 << 1)) | 0;
        };
        me.x = 0;
        me.y = 0;
        me.z = 0;
        me.w = 0;
        me.v = 0;
        if (seed === (seed | 0)) {
          me.x = seed;
        } else {
          strseed += seed;
        }
        for (var k2 = 0; k2 < strseed.length + 64; k2++) {
          me.x ^= strseed.charCodeAt(k2) | 0;
          if (k2 == strseed.length) {
            me.d = me.x << 10 ^ me.x >>> 4;
          }
          me.next();
        }
      }
      function copy6(f5, t9) {
        t9.x = f5.x;
        t9.y = f5.y;
        t9.z = f5.z;
        t9.w = f5.w;
        t9.v = f5.v;
        t9.d = f5.d;
        return t9;
      }
      function impl(seed, opts) {
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (typeof state == "object") copy6(state, xg);
          prng.state = function() {
            return copy6(xg, {});
          };
        }
        return prng;
      }
      if (module2 && module2.exports) {
        module2.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.xorwow = impl;
      }
    })(
      exports,
      typeof module == "object" && module,
      // present in node.js
      typeof define == "function" && define
      // present with an AMD loader
    );
  }
});

// node_modules/seedrandom/lib/xorshift7.js
var require_xorshift7 = __commonJS({
  "node_modules/seedrandom/lib/xorshift7.js"(exports, module) {
    "use strict";
    (function(global2, module2, define2) {
      function XorGen(seed) {
        var me = this;
        me.next = function() {
          var X = me.x, i6 = me.i, t9, v2, w2;
          t9 = X[i6];
          t9 ^= t9 >>> 7;
          v2 = t9 ^ t9 << 24;
          t9 = X[i6 + 1 & 7];
          v2 ^= t9 ^ t9 >>> 10;
          t9 = X[i6 + 3 & 7];
          v2 ^= t9 ^ t9 >>> 3;
          t9 = X[i6 + 4 & 7];
          v2 ^= t9 ^ t9 << 7;
          t9 = X[i6 + 7 & 7];
          t9 = t9 ^ t9 << 13;
          v2 ^= t9 ^ t9 << 9;
          X[i6] = v2;
          me.i = i6 + 1 & 7;
          return v2;
        };
        function init(me2, seed2) {
          var j2, w2, X = [];
          if (seed2 === (seed2 | 0)) {
            w2 = X[0] = seed2;
          } else {
            seed2 = "" + seed2;
            for (j2 = 0; j2 < seed2.length; ++j2) {
              X[j2 & 7] = X[j2 & 7] << 15 ^ seed2.charCodeAt(j2) + X[j2 + 1 & 7] << 13;
            }
          }
          while (X.length < 8) X.push(0);
          for (j2 = 0; j2 < 8 && X[j2] === 0; ++j2) ;
          if (j2 == 8) w2 = X[7] = -1;
          else w2 = X[j2];
          me2.x = X;
          me2.i = 0;
          for (j2 = 256; j2 > 0; --j2) {
            me2.next();
          }
        }
        init(me, seed);
      }
      function copy6(f5, t9) {
        t9.x = f5.x.slice();
        t9.i = f5.i;
        return t9;
      }
      function impl(seed, opts) {
        if (seed == null) seed = +/* @__PURE__ */ new Date();
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (state.x) copy6(state, xg);
          prng.state = function() {
            return copy6(xg, {});
          };
        }
        return prng;
      }
      if (module2 && module2.exports) {
        module2.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.xorshift7 = impl;
      }
    })(
      exports,
      typeof module == "object" && module,
      // present in node.js
      typeof define == "function" && define
      // present with an AMD loader
    );
  }
});

// node_modules/seedrandom/lib/xor4096.js
var require_xor4096 = __commonJS({
  "node_modules/seedrandom/lib/xor4096.js"(exports, module) {
    "use strict";
    (function(global2, module2, define2) {
      function XorGen(seed) {
        var me = this;
        me.next = function() {
          var w2 = me.w, X = me.X, i6 = me.i, t9, v2;
          me.w = w2 = w2 + 1640531527 | 0;
          v2 = X[i6 + 34 & 127];
          t9 = X[i6 = i6 + 1 & 127];
          v2 ^= v2 << 13;
          t9 ^= t9 << 17;
          v2 ^= v2 >>> 15;
          t9 ^= t9 >>> 12;
          v2 = X[i6] = v2 ^ t9;
          me.i = i6;
          return v2 + (w2 ^ w2 >>> 16) | 0;
        };
        function init(me2, seed2) {
          var t9, v2, i6, j2, w2, X = [], limit = 128;
          if (seed2 === (seed2 | 0)) {
            v2 = seed2;
            seed2 = null;
          } else {
            seed2 = seed2 + "\0";
            v2 = 0;
            limit = Math.max(limit, seed2.length);
          }
          for (i6 = 0, j2 = -32; j2 < limit; ++j2) {
            if (seed2) v2 ^= seed2.charCodeAt((j2 + 32) % seed2.length);
            if (j2 === 0) w2 = v2;
            v2 ^= v2 << 10;
            v2 ^= v2 >>> 15;
            v2 ^= v2 << 4;
            v2 ^= v2 >>> 13;
            if (j2 >= 0) {
              w2 = w2 + 1640531527 | 0;
              t9 = X[j2 & 127] ^= v2 + w2;
              i6 = 0 == t9 ? i6 + 1 : 0;
            }
          }
          if (i6 >= 128) {
            X[(seed2 && seed2.length || 0) & 127] = -1;
          }
          i6 = 127;
          for (j2 = 4 * 128; j2 > 0; --j2) {
            v2 = X[i6 + 34 & 127];
            t9 = X[i6 = i6 + 1 & 127];
            v2 ^= v2 << 13;
            t9 ^= t9 << 17;
            v2 ^= v2 >>> 15;
            t9 ^= t9 >>> 12;
            X[i6] = v2 ^ t9;
          }
          me2.w = w2;
          me2.X = X;
          me2.i = i6;
        }
        init(me, seed);
      }
      function copy6(f5, t9) {
        t9.i = f5.i;
        t9.w = f5.w;
        t9.X = f5.X.slice();
        return t9;
      }
      ;
      function impl(seed, opts) {
        if (seed == null) seed = +/* @__PURE__ */ new Date();
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (state.X) copy6(state, xg);
          prng.state = function() {
            return copy6(xg, {});
          };
        }
        return prng;
      }
      if (module2 && module2.exports) {
        module2.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.xor4096 = impl;
      }
    })(
      exports,
      // window object or global
      typeof module == "object" && module,
      // present in node.js
      typeof define == "function" && define
      // present with an AMD loader
    );
  }
});

// node_modules/seedrandom/lib/tychei.js
var require_tychei = __commonJS({
  "node_modules/seedrandom/lib/tychei.js"(exports, module) {
    "use strict";
    (function(global2, module2, define2) {
      function XorGen(seed) {
        var me = this, strseed = "";
        me.next = function() {
          var b3 = me.b, c6 = me.c, d3 = me.d, a4 = me.a;
          b3 = b3 << 25 ^ b3 >>> 7 ^ c6;
          c6 = c6 - d3 | 0;
          d3 = d3 << 24 ^ d3 >>> 8 ^ a4;
          a4 = a4 - b3 | 0;
          me.b = b3 = b3 << 20 ^ b3 >>> 12 ^ c6;
          me.c = c6 = c6 - d3 | 0;
          me.d = d3 << 16 ^ c6 >>> 16 ^ a4;
          return me.a = a4 - b3 | 0;
        };
        me.a = 0;
        me.b = 0;
        me.c = 2654435769 | 0;
        me.d = 1367130551;
        if (seed === Math.floor(seed)) {
          me.a = seed / 4294967296 | 0;
          me.b = seed | 0;
        } else {
          strseed += seed;
        }
        for (var k2 = 0; k2 < strseed.length + 20; k2++) {
          me.b ^= strseed.charCodeAt(k2) | 0;
          me.next();
        }
      }
      function copy6(f5, t9) {
        t9.a = f5.a;
        t9.b = f5.b;
        t9.c = f5.c;
        t9.d = f5.d;
        return t9;
      }
      ;
      function impl(seed, opts) {
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (typeof state == "object") copy6(state, xg);
          prng.state = function() {
            return copy6(xg, {});
          };
        }
        return prng;
      }
      if (module2 && module2.exports) {
        module2.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.tychei = impl;
      }
    })(
      exports,
      typeof module == "object" && module,
      // present in node.js
      typeof define == "function" && define
      // present with an AMD loader
    );
  }
});

// (disabled):crypto
var require_crypto = __commonJS({
  "(disabled):crypto"() {
    "use strict";
  }
});

// node_modules/seedrandom/seedrandom.js
var require_seedrandom = __commonJS({
  "node_modules/seedrandom/seedrandom.js"(exports, module) {
    "use strict";
    (function(global2, pool, math) {
      var width = 256, chunks = 6, digits = 52, rngname = "random", startdenom = math.pow(width, chunks), significance = math.pow(2, digits), overflow = significance * 2, mask = width - 1, nodecrypto;
      function seedrandom2(seed, options, callback) {
        var key = [];
        options = options == true ? { entropy: true } : options || {};
        var shortseed = mixkey(flatten(
          options.entropy ? [seed, tostring(pool)] : seed == null ? autoseed() : seed,
          3
        ), key);
        var arc4 = new ARC4(key);
        var prng = function() {
          var n9 = arc4.g(chunks), d3 = startdenom, x2 = 0;
          while (n9 < significance) {
            n9 = (n9 + x2) * width;
            d3 *= width;
            x2 = arc4.g(1);
          }
          while (n9 >= overflow) {
            n9 /= 2;
            d3 /= 2;
            x2 >>>= 1;
          }
          return (n9 + x2) / d3;
        };
        prng.int32 = function() {
          return arc4.g(4) | 0;
        };
        prng.quick = function() {
          return arc4.g(4) / 4294967296;
        };
        prng.double = prng;
        mixkey(tostring(arc4.S), pool);
        return (options.pass || callback || function(prng2, seed2, is_math_call, state) {
          if (state) {
            if (state.S) {
              copy6(state, arc4);
            }
            prng2.state = function() {
              return copy6(arc4, {});
            };
          }
          if (is_math_call) {
            math[rngname] = prng2;
            return seed2;
          } else return prng2;
        })(
          prng,
          shortseed,
          "global" in options ? options.global : this == math,
          options.state
        );
      }
      function ARC4(key) {
        var t9, keylen = key.length, me = this, i6 = 0, j2 = me.i = me.j = 0, s9 = me.S = [];
        if (!keylen) {
          key = [keylen++];
        }
        while (i6 < width) {
          s9[i6] = i6++;
        }
        for (i6 = 0; i6 < width; i6++) {
          s9[i6] = s9[j2 = mask & j2 + key[i6 % keylen] + (t9 = s9[i6])];
          s9[j2] = t9;
        }
        (me.g = function(count) {
          var t10, r9 = 0, i7 = me.i, j3 = me.j, s10 = me.S;
          while (count--) {
            t10 = s10[i7 = mask & i7 + 1];
            r9 = r9 * width + s10[mask & (s10[i7] = s10[j3 = mask & j3 + t10]) + (s10[j3] = t10)];
          }
          me.i = i7;
          me.j = j3;
          return r9;
        })(width);
      }
      function copy6(f5, t9) {
        t9.i = f5.i;
        t9.j = f5.j;
        t9.S = f5.S.slice();
        return t9;
      }
      ;
      function flatten(obj2, depth) {
        var result = [], typ = typeof obj2, prop;
        if (depth && typ == "object") {
          for (prop in obj2) {
            try {
              result.push(flatten(obj2[prop], depth - 1));
            } catch (e13) {
            }
          }
        }
        return result.length ? result : typ == "string" ? obj2 : obj2 + "\0";
      }
      function mixkey(seed, key) {
        var stringseed = seed + "", smear, j2 = 0;
        while (j2 < stringseed.length) {
          key[mask & j2] = mask & (smear ^= key[mask & j2] * 19) + stringseed.charCodeAt(j2++);
        }
        return tostring(key);
      }
      function autoseed() {
        try {
          var out;
          if (nodecrypto && (out = nodecrypto.randomBytes)) {
            out = out(width);
          } else {
            out = new Uint8Array(width);
            (global2.crypto || global2.msCrypto).getRandomValues(out);
          }
          return tostring(out);
        } catch (e13) {
          var browser = global2.navigator, plugins = browser && browser.plugins;
          return [+/* @__PURE__ */ new Date(), global2, plugins, global2.screen, tostring(pool)];
        }
      }
      function tostring(a4) {
        return String.fromCharCode.apply(0, a4);
      }
      mixkey(math.random(), pool);
      if (typeof module == "object" && module.exports) {
        module.exports = seedrandom2;
        try {
          nodecrypto = require_crypto();
        } catch (ex) {
        }
      } else if (typeof define == "function" && define.amd) {
        define(function() {
          return seedrandom2;
        });
      } else {
        math["seed" + rngname] = seedrandom2;
      }
    })(
      // global: `self` in browsers (including strict mode and web workers),
      // otherwise `this` in Node and other environments
      typeof self !== "undefined" ? self : exports,
      [],
      // pool: entropy pool starts empty
      Math
      // math: package containing random, pow, and seedrandom
    );
  }
});

// node_modules/seedrandom/index.js
var require_seedrandom2 = __commonJS({
  "node_modules/seedrandom/index.js"(exports, module) {
    "use strict";
    var alea = require_alea();
    var xor128 = require_xor128();
    var xorwow = require_xorwow();
    var xorshift7 = require_xorshift7();
    var xor4096 = require_xor4096();
    var tychei = require_tychei();
    var sr = require_seedrandom();
    sr.alea = alea;
    sr.xor128 = xor128;
    sr.xorwow = xorwow;
    sr.xorshift7 = xorshift7;
    sr.xor4096 = xor4096;
    sr.tychei = tychei;
    module.exports = sr;
  }
});

// node_modules/spark-md5/spark-md5.js
var require_spark_md5 = __commonJS({
  "node_modules/spark-md5/spark-md5.js"(exports, module) {
    "use strict";
    (function(factory) {
      if (typeof exports === "object") {
        module.exports = factory();
      } else if (typeof define === "function" && define.amd) {
        define(factory);
      } else {
        var glob;
        try {
          glob = window;
        } catch (e13) {
          glob = self;
        }
        glob.SparkMD5 = factory();
      }
    })(function(undefined2) {
      "use strict";
      var add32 = function(a4, b3) {
        return a4 + b3 & 4294967295;
      }, hex_chr = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
      function cmn(q, a4, b3, x2, s9, t9) {
        a4 = add32(add32(a4, q), add32(x2, t9));
        return add32(a4 << s9 | a4 >>> 32 - s9, b3);
      }
      function md5cycle(x2, k2) {
        var a4 = x2[0], b3 = x2[1], c6 = x2[2], d3 = x2[3];
        a4 += (b3 & c6 | ~b3 & d3) + k2[0] - 680876936 | 0;
        a4 = (a4 << 7 | a4 >>> 25) + b3 | 0;
        d3 += (a4 & b3 | ~a4 & c6) + k2[1] - 389564586 | 0;
        d3 = (d3 << 12 | d3 >>> 20) + a4 | 0;
        c6 += (d3 & a4 | ~d3 & b3) + k2[2] + 606105819 | 0;
        c6 = (c6 << 17 | c6 >>> 15) + d3 | 0;
        b3 += (c6 & d3 | ~c6 & a4) + k2[3] - 1044525330 | 0;
        b3 = (b3 << 22 | b3 >>> 10) + c6 | 0;
        a4 += (b3 & c6 | ~b3 & d3) + k2[4] - 176418897 | 0;
        a4 = (a4 << 7 | a4 >>> 25) + b3 | 0;
        d3 += (a4 & b3 | ~a4 & c6) + k2[5] + 1200080426 | 0;
        d3 = (d3 << 12 | d3 >>> 20) + a4 | 0;
        c6 += (d3 & a4 | ~d3 & b3) + k2[6] - 1473231341 | 0;
        c6 = (c6 << 17 | c6 >>> 15) + d3 | 0;
        b3 += (c6 & d3 | ~c6 & a4) + k2[7] - 45705983 | 0;
        b3 = (b3 << 22 | b3 >>> 10) + c6 | 0;
        a4 += (b3 & c6 | ~b3 & d3) + k2[8] + 1770035416 | 0;
        a4 = (a4 << 7 | a4 >>> 25) + b3 | 0;
        d3 += (a4 & b3 | ~a4 & c6) + k2[9] - 1958414417 | 0;
        d3 = (d3 << 12 | d3 >>> 20) + a4 | 0;
        c6 += (d3 & a4 | ~d3 & b3) + k2[10] - 42063 | 0;
        c6 = (c6 << 17 | c6 >>> 15) + d3 | 0;
        b3 += (c6 & d3 | ~c6 & a4) + k2[11] - 1990404162 | 0;
        b3 = (b3 << 22 | b3 >>> 10) + c6 | 0;
        a4 += (b3 & c6 | ~b3 & d3) + k2[12] + 1804603682 | 0;
        a4 = (a4 << 7 | a4 >>> 25) + b3 | 0;
        d3 += (a4 & b3 | ~a4 & c6) + k2[13] - 40341101 | 0;
        d3 = (d3 << 12 | d3 >>> 20) + a4 | 0;
        c6 += (d3 & a4 | ~d3 & b3) + k2[14] - 1502002290 | 0;
        c6 = (c6 << 17 | c6 >>> 15) + d3 | 0;
        b3 += (c6 & d3 | ~c6 & a4) + k2[15] + 1236535329 | 0;
        b3 = (b3 << 22 | b3 >>> 10) + c6 | 0;
        a4 += (b3 & d3 | c6 & ~d3) + k2[1] - 165796510 | 0;
        a4 = (a4 << 5 | a4 >>> 27) + b3 | 0;
        d3 += (a4 & c6 | b3 & ~c6) + k2[6] - 1069501632 | 0;
        d3 = (d3 << 9 | d3 >>> 23) + a4 | 0;
        c6 += (d3 & b3 | a4 & ~b3) + k2[11] + 643717713 | 0;
        c6 = (c6 << 14 | c6 >>> 18) + d3 | 0;
        b3 += (c6 & a4 | d3 & ~a4) + k2[0] - 373897302 | 0;
        b3 = (b3 << 20 | b3 >>> 12) + c6 | 0;
        a4 += (b3 & d3 | c6 & ~d3) + k2[5] - 701558691 | 0;
        a4 = (a4 << 5 | a4 >>> 27) + b3 | 0;
        d3 += (a4 & c6 | b3 & ~c6) + k2[10] + 38016083 | 0;
        d3 = (d3 << 9 | d3 >>> 23) + a4 | 0;
        c6 += (d3 & b3 | a4 & ~b3) + k2[15] - 660478335 | 0;
        c6 = (c6 << 14 | c6 >>> 18) + d3 | 0;
        b3 += (c6 & a4 | d3 & ~a4) + k2[4] - 405537848 | 0;
        b3 = (b3 << 20 | b3 >>> 12) + c6 | 0;
        a4 += (b3 & d3 | c6 & ~d3) + k2[9] + 568446438 | 0;
        a4 = (a4 << 5 | a4 >>> 27) + b3 | 0;
        d3 += (a4 & c6 | b3 & ~c6) + k2[14] - 1019803690 | 0;
        d3 = (d3 << 9 | d3 >>> 23) + a4 | 0;
        c6 += (d3 & b3 | a4 & ~b3) + k2[3] - 187363961 | 0;
        c6 = (c6 << 14 | c6 >>> 18) + d3 | 0;
        b3 += (c6 & a4 | d3 & ~a4) + k2[8] + 1163531501 | 0;
        b3 = (b3 << 20 | b3 >>> 12) + c6 | 0;
        a4 += (b3 & d3 | c6 & ~d3) + k2[13] - 1444681467 | 0;
        a4 = (a4 << 5 | a4 >>> 27) + b3 | 0;
        d3 += (a4 & c6 | b3 & ~c6) + k2[2] - 51403784 | 0;
        d3 = (d3 << 9 | d3 >>> 23) + a4 | 0;
        c6 += (d3 & b3 | a4 & ~b3) + k2[7] + 1735328473 | 0;
        c6 = (c6 << 14 | c6 >>> 18) + d3 | 0;
        b3 += (c6 & a4 | d3 & ~a4) + k2[12] - 1926607734 | 0;
        b3 = (b3 << 20 | b3 >>> 12) + c6 | 0;
        a4 += (b3 ^ c6 ^ d3) + k2[5] - 378558 | 0;
        a4 = (a4 << 4 | a4 >>> 28) + b3 | 0;
        d3 += (a4 ^ b3 ^ c6) + k2[8] - 2022574463 | 0;
        d3 = (d3 << 11 | d3 >>> 21) + a4 | 0;
        c6 += (d3 ^ a4 ^ b3) + k2[11] + 1839030562 | 0;
        c6 = (c6 << 16 | c6 >>> 16) + d3 | 0;
        b3 += (c6 ^ d3 ^ a4) + k2[14] - 35309556 | 0;
        b3 = (b3 << 23 | b3 >>> 9) + c6 | 0;
        a4 += (b3 ^ c6 ^ d3) + k2[1] - 1530992060 | 0;
        a4 = (a4 << 4 | a4 >>> 28) + b3 | 0;
        d3 += (a4 ^ b3 ^ c6) + k2[4] + 1272893353 | 0;
        d3 = (d3 << 11 | d3 >>> 21) + a4 | 0;
        c6 += (d3 ^ a4 ^ b3) + k2[7] - 155497632 | 0;
        c6 = (c6 << 16 | c6 >>> 16) + d3 | 0;
        b3 += (c6 ^ d3 ^ a4) + k2[10] - 1094730640 | 0;
        b3 = (b3 << 23 | b3 >>> 9) + c6 | 0;
        a4 += (b3 ^ c6 ^ d3) + k2[13] + 681279174 | 0;
        a4 = (a4 << 4 | a4 >>> 28) + b3 | 0;
        d3 += (a4 ^ b3 ^ c6) + k2[0] - 358537222 | 0;
        d3 = (d3 << 11 | d3 >>> 21) + a4 | 0;
        c6 += (d3 ^ a4 ^ b3) + k2[3] - 722521979 | 0;
        c6 = (c6 << 16 | c6 >>> 16) + d3 | 0;
        b3 += (c6 ^ d3 ^ a4) + k2[6] + 76029189 | 0;
        b3 = (b3 << 23 | b3 >>> 9) + c6 | 0;
        a4 += (b3 ^ c6 ^ d3) + k2[9] - 640364487 | 0;
        a4 = (a4 << 4 | a4 >>> 28) + b3 | 0;
        d3 += (a4 ^ b3 ^ c6) + k2[12] - 421815835 | 0;
        d3 = (d3 << 11 | d3 >>> 21) + a4 | 0;
        c6 += (d3 ^ a4 ^ b3) + k2[15] + 530742520 | 0;
        c6 = (c6 << 16 | c6 >>> 16) + d3 | 0;
        b3 += (c6 ^ d3 ^ a4) + k2[2] - 995338651 | 0;
        b3 = (b3 << 23 | b3 >>> 9) + c6 | 0;
        a4 += (c6 ^ (b3 | ~d3)) + k2[0] - 198630844 | 0;
        a4 = (a4 << 6 | a4 >>> 26) + b3 | 0;
        d3 += (b3 ^ (a4 | ~c6)) + k2[7] + 1126891415 | 0;
        d3 = (d3 << 10 | d3 >>> 22) + a4 | 0;
        c6 += (a4 ^ (d3 | ~b3)) + k2[14] - 1416354905 | 0;
        c6 = (c6 << 15 | c6 >>> 17) + d3 | 0;
        b3 += (d3 ^ (c6 | ~a4)) + k2[5] - 57434055 | 0;
        b3 = (b3 << 21 | b3 >>> 11) + c6 | 0;
        a4 += (c6 ^ (b3 | ~d3)) + k2[12] + 1700485571 | 0;
        a4 = (a4 << 6 | a4 >>> 26) + b3 | 0;
        d3 += (b3 ^ (a4 | ~c6)) + k2[3] - 1894986606 | 0;
        d3 = (d3 << 10 | d3 >>> 22) + a4 | 0;
        c6 += (a4 ^ (d3 | ~b3)) + k2[10] - 1051523 | 0;
        c6 = (c6 << 15 | c6 >>> 17) + d3 | 0;
        b3 += (d3 ^ (c6 | ~a4)) + k2[1] - 2054922799 | 0;
        b3 = (b3 << 21 | b3 >>> 11) + c6 | 0;
        a4 += (c6 ^ (b3 | ~d3)) + k2[8] + 1873313359 | 0;
        a4 = (a4 << 6 | a4 >>> 26) + b3 | 0;
        d3 += (b3 ^ (a4 | ~c6)) + k2[15] - 30611744 | 0;
        d3 = (d3 << 10 | d3 >>> 22) + a4 | 0;
        c6 += (a4 ^ (d3 | ~b3)) + k2[6] - 1560198380 | 0;
        c6 = (c6 << 15 | c6 >>> 17) + d3 | 0;
        b3 += (d3 ^ (c6 | ~a4)) + k2[13] + 1309151649 | 0;
        b3 = (b3 << 21 | b3 >>> 11) + c6 | 0;
        a4 += (c6 ^ (b3 | ~d3)) + k2[4] - 145523070 | 0;
        a4 = (a4 << 6 | a4 >>> 26) + b3 | 0;
        d3 += (b3 ^ (a4 | ~c6)) + k2[11] - 1120210379 | 0;
        d3 = (d3 << 10 | d3 >>> 22) + a4 | 0;
        c6 += (a4 ^ (d3 | ~b3)) + k2[2] + 718787259 | 0;
        c6 = (c6 << 15 | c6 >>> 17) + d3 | 0;
        b3 += (d3 ^ (c6 | ~a4)) + k2[9] - 343485551 | 0;
        b3 = (b3 << 21 | b3 >>> 11) + c6 | 0;
        x2[0] = a4 + x2[0] | 0;
        x2[1] = b3 + x2[1] | 0;
        x2[2] = c6 + x2[2] | 0;
        x2[3] = d3 + x2[3] | 0;
      }
      function md5blk(s9) {
        var md5blks = [], i6;
        for (i6 = 0; i6 < 64; i6 += 4) {
          md5blks[i6 >> 2] = s9.charCodeAt(i6) + (s9.charCodeAt(i6 + 1) << 8) + (s9.charCodeAt(i6 + 2) << 16) + (s9.charCodeAt(i6 + 3) << 24);
        }
        return md5blks;
      }
      function md5blk_array(a4) {
        var md5blks = [], i6;
        for (i6 = 0; i6 < 64; i6 += 4) {
          md5blks[i6 >> 2] = a4[i6] + (a4[i6 + 1] << 8) + (a4[i6 + 2] << 16) + (a4[i6 + 3] << 24);
        }
        return md5blks;
      }
      function md51(s9) {
        var n9 = s9.length, state = [1732584193, -271733879, -1732584194, 271733878], i6, length4, tail, tmp, lo, hi;
        for (i6 = 64; i6 <= n9; i6 += 64) {
          md5cycle(state, md5blk(s9.substring(i6 - 64, i6)));
        }
        s9 = s9.substring(i6 - 64);
        length4 = s9.length;
        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        for (i6 = 0; i6 < length4; i6 += 1) {
          tail[i6 >> 2] |= s9.charCodeAt(i6) << (i6 % 4 << 3);
        }
        tail[i6 >> 2] |= 128 << (i6 % 4 << 3);
        if (i6 > 55) {
          md5cycle(state, tail);
          for (i6 = 0; i6 < 16; i6 += 1) {
            tail[i6] = 0;
          }
        }
        tmp = n9 * 8;
        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
        lo = parseInt(tmp[2], 16);
        hi = parseInt(tmp[1], 16) || 0;
        tail[14] = lo;
        tail[15] = hi;
        md5cycle(state, tail);
        return state;
      }
      function md51_array(a4) {
        var n9 = a4.length, state = [1732584193, -271733879, -1732584194, 271733878], i6, length4, tail, tmp, lo, hi;
        for (i6 = 64; i6 <= n9; i6 += 64) {
          md5cycle(state, md5blk_array(a4.subarray(i6 - 64, i6)));
        }
        a4 = i6 - 64 < n9 ? a4.subarray(i6 - 64) : new Uint8Array(0);
        length4 = a4.length;
        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        for (i6 = 0; i6 < length4; i6 += 1) {
          tail[i6 >> 2] |= a4[i6] << (i6 % 4 << 3);
        }
        tail[i6 >> 2] |= 128 << (i6 % 4 << 3);
        if (i6 > 55) {
          md5cycle(state, tail);
          for (i6 = 0; i6 < 16; i6 += 1) {
            tail[i6] = 0;
          }
        }
        tmp = n9 * 8;
        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
        lo = parseInt(tmp[2], 16);
        hi = parseInt(tmp[1], 16) || 0;
        tail[14] = lo;
        tail[15] = hi;
        md5cycle(state, tail);
        return state;
      }
      function rhex(n9) {
        var s9 = "", j2;
        for (j2 = 0; j2 < 4; j2 += 1) {
          s9 += hex_chr[n9 >> j2 * 8 + 4 & 15] + hex_chr[n9 >> j2 * 8 & 15];
        }
        return s9;
      }
      function hex(x2) {
        var i6;
        for (i6 = 0; i6 < x2.length; i6 += 1) {
          x2[i6] = rhex(x2[i6]);
        }
        return x2.join("");
      }
      if (hex(md51("hello")) !== "5d41402abc4b2a76b9719d911017c592") {
        add32 = function(x2, y3) {
          var lsw = (x2 & 65535) + (y3 & 65535), msw = (x2 >> 16) + (y3 >> 16) + (lsw >> 16);
          return msw << 16 | lsw & 65535;
        };
      }
      if (typeof ArrayBuffer !== "undefined" && !ArrayBuffer.prototype.slice) {
        (function() {
          function clamp2(val, length4) {
            val = val | 0 || 0;
            if (val < 0) {
              return Math.max(val + length4, 0);
            }
            return Math.min(val, length4);
          }
          ArrayBuffer.prototype.slice = function(from, to) {
            var length4 = this.byteLength, begin = clamp2(from, length4), end = length4, num, target, targetArray, sourceArray;
            if (to !== undefined2) {
              end = clamp2(to, length4);
            }
            if (begin > end) {
              return new ArrayBuffer(0);
            }
            num = end - begin;
            target = new ArrayBuffer(num);
            targetArray = new Uint8Array(target);
            sourceArray = new Uint8Array(this, begin, num);
            targetArray.set(sourceArray);
            return target;
          };
        })();
      }
      function toUtf8(str6) {
        if (/[\u0080-\uFFFF]/.test(str6)) {
          str6 = unescape(encodeURIComponent(str6));
        }
        return str6;
      }
      function utf8Str2ArrayBuffer(str6, returnUInt8Array) {
        var length4 = str6.length, buff = new ArrayBuffer(length4), arr = new Uint8Array(buff), i6;
        for (i6 = 0; i6 < length4; i6 += 1) {
          arr[i6] = str6.charCodeAt(i6);
        }
        return returnUInt8Array ? arr : buff;
      }
      function arrayBuffer2Utf8Str(buff) {
        return String.fromCharCode.apply(null, new Uint8Array(buff));
      }
      function concatenateArrayBuffers(first, second, returnUInt8Array) {
        var result = new Uint8Array(first.byteLength + second.byteLength);
        result.set(new Uint8Array(first));
        result.set(new Uint8Array(second), first.byteLength);
        return returnUInt8Array ? result : result.buffer;
      }
      function hexToBinaryString(hex2) {
        var bytes = [], length4 = hex2.length, x2;
        for (x2 = 0; x2 < length4 - 1; x2 += 2) {
          bytes.push(parseInt(hex2.substr(x2, 2), 16));
        }
        return String.fromCharCode.apply(String, bytes);
      }
      function SparkMD5() {
        this.reset();
      }
      SparkMD5.prototype.append = function(str6) {
        this.appendBinary(toUtf8(str6));
        return this;
      };
      SparkMD5.prototype.appendBinary = function(contents) {
        this._buff += contents;
        this._length += contents.length;
        var length4 = this._buff.length, i6;
        for (i6 = 64; i6 <= length4; i6 += 64) {
          md5cycle(this._hash, md5blk(this._buff.substring(i6 - 64, i6)));
        }
        this._buff = this._buff.substring(i6 - 64);
        return this;
      };
      SparkMD5.prototype.end = function(raw) {
        var buff = this._buff, length4 = buff.length, i6, tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], ret;
        for (i6 = 0; i6 < length4; i6 += 1) {
          tail[i6 >> 2] |= buff.charCodeAt(i6) << (i6 % 4 << 3);
        }
        this._finish(tail, length4);
        ret = hex(this._hash);
        if (raw) {
          ret = hexToBinaryString(ret);
        }
        this.reset();
        return ret;
      };
      SparkMD5.prototype.reset = function() {
        this._buff = "";
        this._length = 0;
        this._hash = [1732584193, -271733879, -1732584194, 271733878];
        return this;
      };
      SparkMD5.prototype.getState = function() {
        return {
          buff: this._buff,
          length: this._length,
          hash: this._hash.slice()
        };
      };
      SparkMD5.prototype.setState = function(state) {
        this._buff = state.buff;
        this._length = state.length;
        this._hash = state.hash;
        return this;
      };
      SparkMD5.prototype.destroy = function() {
        delete this._hash;
        delete this._buff;
        delete this._length;
      };
      SparkMD5.prototype._finish = function(tail, length4) {
        var i6 = length4, tmp, lo, hi;
        tail[i6 >> 2] |= 128 << (i6 % 4 << 3);
        if (i6 > 55) {
          md5cycle(this._hash, tail);
          for (i6 = 0; i6 < 16; i6 += 1) {
            tail[i6] = 0;
          }
        }
        tmp = this._length * 8;
        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
        lo = parseInt(tmp[2], 16);
        hi = parseInt(tmp[1], 16) || 0;
        tail[14] = lo;
        tail[15] = hi;
        md5cycle(this._hash, tail);
      };
      SparkMD5.hash = function(str6, raw) {
        return SparkMD5.hashBinary(toUtf8(str6), raw);
      };
      SparkMD5.hashBinary = function(content, raw) {
        var hash = md51(content), ret = hex(hash);
        return raw ? hexToBinaryString(ret) : ret;
      };
      SparkMD5.ArrayBuffer = function() {
        this.reset();
      };
      SparkMD5.ArrayBuffer.prototype.append = function(arr) {
        var buff = concatenateArrayBuffers(this._buff.buffer, arr, true), length4 = buff.length, i6;
        this._length += arr.byteLength;
        for (i6 = 64; i6 <= length4; i6 += 64) {
          md5cycle(this._hash, md5blk_array(buff.subarray(i6 - 64, i6)));
        }
        this._buff = i6 - 64 < length4 ? new Uint8Array(buff.buffer.slice(i6 - 64)) : new Uint8Array(0);
        return this;
      };
      SparkMD5.ArrayBuffer.prototype.end = function(raw) {
        var buff = this._buff, length4 = buff.length, tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], i6, ret;
        for (i6 = 0; i6 < length4; i6 += 1) {
          tail[i6 >> 2] |= buff[i6] << (i6 % 4 << 3);
        }
        this._finish(tail, length4);
        ret = hex(this._hash);
        if (raw) {
          ret = hexToBinaryString(ret);
        }
        this.reset();
        return ret;
      };
      SparkMD5.ArrayBuffer.prototype.reset = function() {
        this._buff = new Uint8Array(0);
        this._length = 0;
        this._hash = [1732584193, -271733879, -1732584194, 271733878];
        return this;
      };
      SparkMD5.ArrayBuffer.prototype.getState = function() {
        var state = SparkMD5.prototype.getState.call(this);
        state.buff = arrayBuffer2Utf8Str(state.buff);
        return state;
      };
      SparkMD5.ArrayBuffer.prototype.setState = function(state) {
        state.buff = utf8Str2ArrayBuffer(state.buff, true);
        return SparkMD5.prototype.setState.call(this, state);
      };
      SparkMD5.ArrayBuffer.prototype.destroy = SparkMD5.prototype.destroy;
      SparkMD5.ArrayBuffer.prototype._finish = SparkMD5.prototype._finish;
      SparkMD5.ArrayBuffer.hash = function(arr, raw) {
        var hash = md51_array(new Uint8Array(arr)), ret = hex(hash);
        return raw ? hexToBinaryString(ret) : ret;
      };
      return SparkMD5;
    });
  }
});

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event2, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event2 : event2;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0) return names;
      for (name in events = this._events) {
        if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter2.prototype.listeners = function listeners(event2) {
      var evt = prefix ? prefix + event2 : event2, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i6 = 0, l5 = handlers.length, ee = new Array(l5); i6 < l5; i6++) {
        ee[i6] = handlers[i6].fn;
      }
      return ee;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event2) {
      var evt = prefix ? prefix + event2 : event2, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter2.prototype.emit = function emit(event2, a1, a22, a32, a4, a5) {
      var evt = prefix ? prefix + event2 : event2;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt], len4 = arguments.length, args, i6;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event2, listeners.fn, void 0, true);
        switch (len4) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a22), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a22, a32), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a22, a32, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a22, a32, a4, a5), true;
        }
        for (i6 = 1, args = new Array(len4 - 1); i6 < len4; i6++) {
          args[i6 - 1] = arguments[i6];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length4 = listeners.length, j2;
        for (i6 = 0; i6 < length4; i6++) {
          if (listeners[i6].once) this.removeListener(event2, listeners[i6].fn, void 0, true);
          switch (len4) {
            case 1:
              listeners[i6].fn.call(listeners[i6].context);
              break;
            case 2:
              listeners[i6].fn.call(listeners[i6].context, a1);
              break;
            case 3:
              listeners[i6].fn.call(listeners[i6].context, a1, a22);
              break;
            case 4:
              listeners[i6].fn.call(listeners[i6].context, a1, a22, a32);
              break;
            default:
              if (!args) for (j2 = 1, args = new Array(len4 - 1); j2 < len4; j2++) {
                args[j2 - 1] = arguments[j2];
              }
              listeners[i6].fn.apply(listeners[i6].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on(event2, fn, context) {
      return addListener(this, event2, fn, context, false);
    };
    EventEmitter2.prototype.once = function once(event2, fn, context) {
      return addListener(this, event2, fn, context, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener(event2, fn, context, once) {
      var evt = prefix ? prefix + event2 : event2;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i6 = 0, events = [], length4 = listeners.length; i6 < length4; i6++) {
          if (listeners[i6].fn !== fn || once && !listeners[i6].once || context && listeners[i6].context !== context) {
            events.push(listeners[i6]);
          }
        }
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event2) {
      var evt;
      if (event2) {
        evt = prefix ? prefix + event2 : event2;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix;
    EventEmitter2.EventEmitter = EventEmitter2;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter2;
    }
  }
});

// node_modules/react/cjs/react-jsx-runtime.development.js
var require_react_jsx_runtime_development = __commonJS({
  "node_modules/react/cjs/react-jsx-runtime.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var React2 = require_react();
        var REACT_ELEMENT_TYPE = Symbol.for("react.element");
        var REACT_PORTAL_TYPE = Symbol.for("react.portal");
        var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
        var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
        var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
        var REACT_CONTEXT_TYPE = Symbol.for("react.context");
        var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
        var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
        var REACT_MEMO_TYPE = Symbol.for("react.memo");
        var REACT_LAZY_TYPE = Symbol.for("react.lazy");
        var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          if (maybeIterable === null || typeof maybeIterable !== "object") {
            return null;
          }
          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
          if (typeof maybeIterator === "function") {
            return maybeIterator;
          }
          return null;
        }
        var ReactSharedInternals = React2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        function error(format) {
          {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format, args);
            }
          }
        }
        function printWarning(level, format, args) {
          {
            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame2.getStackAddendum();
            if (stack !== "") {
              format += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        var enableScopeAPI = false;
        var enableCacheElement = false;
        var enableTransitionTracing = false;
        var enableLegacyHidden = false;
        var enableDebugTracing = false;
        var REACT_MODULE_REFERENCE;
        {
          REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
        }
        function isValidElementType(type) {
          if (typeof type === "string" || typeof type === "function") {
            return true;
          }
          if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
            return true;
          }
          if (typeof type === "object" && type !== null) {
            if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
            // types supported by any Flight configuration anywhere since
            // we don't know which Flight build this will end up being used
            // with.
            type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {
              return true;
            }
          }
          return false;
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var displayName = outerType.displayName;
          if (displayName) {
            return displayName;
          }
          var functionName = innerType.displayName || innerType.name || "";
          return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
        }
        function getContextName(type) {
          return type.displayName || "Context";
        }
        function getComponentNameFromType(type) {
          if (type == null) {
            return null;
          }
          {
            if (typeof type.tag === "number") {
              error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type === "function") {
            return type.displayName || type.name || null;
          }
          if (typeof type === "string") {
            return type;
          }
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_CONTEXT_TYPE:
                var context = type;
                return getContextName(context) + ".Consumer";
              case REACT_PROVIDER_TYPE:
                var provider = type;
                return getContextName(provider._context) + ".Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type, type.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                var outerName = type.displayName || null;
                if (outerName !== null) {
                  return outerName;
                }
                return getComponentNameFromType(type.type) || "Memo";
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return getComponentNameFromType(init(payload));
                } catch (x2) {
                  return null;
                }
              }
            }
          }
          return null;
        }
        var assign2 = Object.assign;
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {
        }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          {
            if (disabledDepth === 0) {
              prevLog = console.log;
              prevInfo = console.info;
              prevWarn = console.warn;
              prevError = console.error;
              prevGroup = console.group;
              prevGroupCollapsed = console.groupCollapsed;
              prevGroupEnd = console.groupEnd;
              var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
              };
              Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
              });
            }
            disabledDepth++;
          }
        }
        function reenableLogs() {
          {
            disabledDepth--;
            if (disabledDepth === 0) {
              var props = {
                configurable: true,
                enumerable: true,
                writable: true
              };
              Object.defineProperties(console, {
                log: assign2({}, props, {
                  value: prevLog
                }),
                info: assign2({}, props, {
                  value: prevInfo
                }),
                warn: assign2({}, props, {
                  value: prevWarn
                }),
                error: assign2({}, props, {
                  value: prevError
                }),
                group: assign2({}, props, {
                  value: prevGroup
                }),
                groupCollapsed: assign2({}, props, {
                  value: prevGroupCollapsed
                }),
                groupEnd: assign2({}, props, {
                  value: prevGroupEnd
                })
              });
            }
            if (disabledDepth < 0) {
              error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
            }
          }
        }
        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix;
        function describeBuiltInComponentFrame(name, source, ownerFn) {
          {
            if (prefix === void 0) {
              try {
                throw Error();
              } catch (x2) {
                var match = x2.stack.trim().match(/\n( *(at )?)/);
                prefix = match && match[1] || "";
              }
            }
            return "\n" + prefix + name;
          }
        }
        var reentry = false;
        var componentFrameCache;
        {
          var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
          componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) {
            return "";
          }
          {
            var frame = componentFrameCache.get(fn);
            if (frame !== void 0) {
              return frame;
            }
          }
          var control;
          reentry = true;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher;
          {
            previousDispatcher = ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current = null;
            disableLogs();
          }
          try {
            if (construct) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if (typeof Reflect === "object" && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x2) {
                  control = x2;
                }
                Reflect.construct(fn, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x2) {
                  control = x2;
                }
                fn.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x2) {
                control = x2;
              }
              fn();
            }
          } catch (sample) {
            if (sample && control && typeof sample.stack === "string") {
              var sampleLines = sample.stack.split("\n");
              var controlLines = control.stack.split("\n");
              var s9 = sampleLines.length - 1;
              var c6 = controlLines.length - 1;
              while (s9 >= 1 && c6 >= 0 && sampleLines[s9] !== controlLines[c6]) {
                c6--;
              }
              for (; s9 >= 1 && c6 >= 0; s9--, c6--) {
                if (sampleLines[s9] !== controlLines[c6]) {
                  if (s9 !== 1 || c6 !== 1) {
                    do {
                      s9--;
                      c6--;
                      if (c6 < 0 || sampleLines[s9] !== controlLines[c6]) {
                        var _frame = "\n" + sampleLines[s9].replace(" at new ", " at ");
                        if (fn.displayName && _frame.includes("<anonymous>")) {
                          _frame = _frame.replace("<anonymous>", fn.displayName);
                        }
                        {
                          if (typeof fn === "function") {
                            componentFrameCache.set(fn, _frame);
                          }
                        }
                        return _frame;
                      }
                    } while (s9 >= 1 && c6 >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            {
              ReactCurrentDispatcher.current = previousDispatcher;
              reenableLogs();
            }
            Error.prepareStackTrace = previousPrepareStackTrace;
          }
          var name = fn ? fn.displayName || fn.name : "";
          var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
          {
            if (typeof fn === "function") {
              componentFrameCache.set(fn, syntheticFrame);
            }
          }
          return syntheticFrame;
        }
        function describeFunctionComponentFrame(fn, source, ownerFn) {
          {
            return describeNativeComponentFrame(fn, false);
          }
        }
        function shouldConstruct(Component) {
          var prototype3 = Component.prototype;
          return !!(prototype3 && prototype3.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
          if (type == null) {
            return "";
          }
          if (typeof type === "function") {
            {
              return describeNativeComponentFrame(type, shouldConstruct(type));
            }
          }
          if (typeof type === "string") {
            return describeBuiltInComponentFrame(type);
          }
          switch (type) {
            case REACT_SUSPENSE_TYPE:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type.render);
              case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                } catch (x2) {
                }
              }
            }
          }
          return "";
        }
        var hasOwnProperty2 = Object.prototype.hasOwnProperty;
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame.setExtraStackFrame(null);
            }
          }
        }
        function checkPropTypes(typeSpecs, values, location, componentName, element) {
          {
            var has = Function.call.bind(hasOwnProperty2);
            for (var typeSpecName in typeSpecs) {
              if (has(typeSpecs, typeSpecName)) {
                var error$1 = void 0;
                try {
                  if (typeof typeSpecs[typeSpecName] !== "function") {
                    var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err.name = "Invariant Violation";
                    throw err;
                  }
                  error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (ex) {
                  error$1 = ex;
                }
                if (error$1 && !(error$1 instanceof Error)) {
                  setCurrentlyValidatingElement(element);
                  error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                  setCurrentlyValidatingElement(null);
                }
                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                  loggedTypeFailures[error$1.message] = true;
                  setCurrentlyValidatingElement(element);
                  error("Failed %s type: %s", location, error$1.message);
                  setCurrentlyValidatingElement(null);
                }
              }
            }
          }
        }
        var isArrayImpl = Array.isArray;
        function isArray3(a4) {
          return isArrayImpl(a4);
        }
        function typeName(value) {
          {
            var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
            var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            return type;
          }
        }
        function willCoercionThrow(value) {
          {
            try {
              testStringCoercion(value);
              return false;
            } catch (e13) {
              return true;
            }
          }
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkKeyStringCoercion(value) {
          {
            if (willCoercionThrow(value)) {
              error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
        var RESERVED_PROPS = {
          key: true,
          ref: true,
          __self: true,
          __source: true
        };
        var specialPropKeyWarningShown;
        var specialPropRefWarningShown;
        var didWarnAboutStringRefs;
        {
          didWarnAboutStringRefs = {};
        }
        function hasValidRef(config) {
          {
            if (hasOwnProperty2.call(config, "ref")) {
              var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config.ref !== void 0;
        }
        function hasValidKey(config) {
          {
            if (hasOwnProperty2.call(config, "key")) {
              var getter = Object.getOwnPropertyDescriptor(config, "key").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config.key !== void 0;
        }
        function warnIfStringRefCannotBeAutoConverted(config, self2) {
          {
            if (typeof config.ref === "string" && ReactCurrentOwner.current && self2 && ReactCurrentOwner.current.stateNode !== self2) {
              var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
              if (!didWarnAboutStringRefs[componentName]) {
                error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);
                didWarnAboutStringRefs[componentName] = true;
              }
            }
          }
        }
        function defineKeyPropWarningGetter(props, displayName) {
          {
            var warnAboutAccessingKey = function() {
              if (!specialPropKeyWarningShown) {
                specialPropKeyWarningShown = true;
                error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            };
            warnAboutAccessingKey.isReactWarning = true;
            Object.defineProperty(props, "key", {
              get: warnAboutAccessingKey,
              configurable: true
            });
          }
        }
        function defineRefPropWarningGetter(props, displayName) {
          {
            var warnAboutAccessingRef = function() {
              if (!specialPropRefWarningShown) {
                specialPropRefWarningShown = true;
                error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            };
            warnAboutAccessingRef.isReactWarning = true;
            Object.defineProperty(props, "ref", {
              get: warnAboutAccessingRef,
              configurable: true
            });
          }
        }
        var ReactElement = function(type, key, ref, self2, source, owner, props) {
          var element = {
            // This tag allows us to uniquely identify this as a React Element
            $$typeof: REACT_ELEMENT_TYPE,
            // Built-in properties that belong on the element
            type,
            key,
            ref,
            props,
            // Record the component responsible for creating this element.
            _owner: owner
          };
          {
            element._store = {};
            Object.defineProperty(element._store, "validated", {
              configurable: false,
              enumerable: false,
              writable: true,
              value: false
            });
            Object.defineProperty(element, "_self", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: self2
            });
            Object.defineProperty(element, "_source", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: source
            });
            if (Object.freeze) {
              Object.freeze(element.props);
              Object.freeze(element);
            }
          }
          return element;
        };
        function jsxDEV(type, config, maybeKey, source, self2) {
          {
            var propName;
            var props = {};
            var key = null;
            var ref = null;
            if (maybeKey !== void 0) {
              {
                checkKeyStringCoercion(maybeKey);
              }
              key = "" + maybeKey;
            }
            if (hasValidKey(config)) {
              {
                checkKeyStringCoercion(config.key);
              }
              key = "" + config.key;
            }
            if (hasValidRef(config)) {
              ref = config.ref;
              warnIfStringRefCannotBeAutoConverted(config, self2);
            }
            for (propName in config) {
              if (hasOwnProperty2.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                props[propName] = config[propName];
              }
            }
            if (type && type.defaultProps) {
              var defaultProps = type.defaultProps;
              for (propName in defaultProps) {
                if (props[propName] === void 0) {
                  props[propName] = defaultProps[propName];
                }
              }
            }
            if (key || ref) {
              var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
              if (key) {
                defineKeyPropWarningGetter(props, displayName);
              }
              if (ref) {
                defineRefPropWarningGetter(props, displayName);
              }
            }
            return ReactElement(type, key, ref, self2, source, ReactCurrentOwner.current, props);
          }
        }
        var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement$1(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame$1.setExtraStackFrame(null);
            }
          }
        }
        var propTypesMisspellWarningShown;
        {
          propTypesMisspellWarningShown = false;
        }
        function isValidElement(object) {
          {
            return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
          }
        }
        function getDeclarationErrorAddendum() {
          {
            if (ReactCurrentOwner$1.current) {
              var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);
              if (name) {
                return "\n\nCheck the render method of `" + name + "`.";
              }
            }
            return "";
          }
        }
        function getSourceInfoErrorAddendum(source) {
          {
            if (source !== void 0) {
              var fileName = source.fileName.replace(/^.*[\\\/]/, "");
              var lineNumber = source.lineNumber;
              return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
            }
            return "";
          }
        }
        var ownerHasKeyUseWarning = {};
        function getCurrentComponentErrorInfo(parentType) {
          {
            var info = getDeclarationErrorAddendum();
            if (!info) {
              var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
              if (parentName) {
                info = "\n\nCheck the top-level render call using <" + parentName + ">.";
              }
            }
            return info;
          }
        }
        function validateExplicitKey(element, parentType) {
          {
            if (!element._store || element._store.validated || element.key != null) {
              return;
            }
            element._store.validated = true;
            var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
            if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
              return;
            }
            ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
            var childOwner = "";
            if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
              childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
            }
            setCurrentlyValidatingElement$1(element);
            error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
            setCurrentlyValidatingElement$1(null);
          }
        }
        function validateChildKeys(node, parentType) {
          {
            if (typeof node !== "object") {
              return;
            }
            if (isArray3(node)) {
              for (var i6 = 0; i6 < node.length; i6++) {
                var child = node[i6];
                if (isValidElement(child)) {
                  validateExplicitKey(child, parentType);
                }
              }
            } else if (isValidElement(node)) {
              if (node._store) {
                node._store.validated = true;
              }
            } else if (node) {
              var iteratorFn = getIteratorFn(node);
              if (typeof iteratorFn === "function") {
                if (iteratorFn !== node.entries) {
                  var iterator = iteratorFn.call(node);
                  var step;
                  while (!(step = iterator.next()).done) {
                    if (isValidElement(step.value)) {
                      validateExplicitKey(step.value, parentType);
                    }
                  }
                }
              }
            }
          }
        }
        function validatePropTypes(element) {
          {
            var type = element.type;
            if (type === null || type === void 0 || typeof type === "string") {
              return;
            }
            var propTypes;
            if (typeof type === "function") {
              propTypes = type.propTypes;
            } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
            // Inner props are checked in the reconciler.
            type.$$typeof === REACT_MEMO_TYPE)) {
              propTypes = type.propTypes;
            } else {
              return;
            }
            if (propTypes) {
              var name = getComponentNameFromType(type);
              checkPropTypes(propTypes, element.props, "prop", name, element);
            } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
              propTypesMisspellWarningShown = true;
              var _name = getComponentNameFromType(type);
              error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
            }
            if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
              error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
            }
          }
        }
        function validateFragmentProps(fragment) {
          {
            var keys = Object.keys(fragment.props);
            for (var i6 = 0; i6 < keys.length; i6++) {
              var key = keys[i6];
              if (key !== "children" && key !== "key") {
                setCurrentlyValidatingElement$1(fragment);
                error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
                setCurrentlyValidatingElement$1(null);
                break;
              }
            }
            if (fragment.ref !== null) {
              setCurrentlyValidatingElement$1(fragment);
              error("Invalid attribute `ref` supplied to `React.Fragment`.");
              setCurrentlyValidatingElement$1(null);
            }
          }
        }
        function jsxWithValidation(type, props, key, isStaticChildren, source, self2) {
          {
            var validType = isValidElementType(type);
            if (!validType) {
              var info = "";
              if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
                info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
              }
              var sourceInfo = getSourceInfoErrorAddendum(source);
              if (sourceInfo) {
                info += sourceInfo;
              } else {
                info += getDeclarationErrorAddendum();
              }
              var typeString;
              if (type === null) {
                typeString = "null";
              } else if (isArray3(type)) {
                typeString = "array";
              } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
                typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />";
                info = " Did you accidentally export a JSX literal instead of a component?";
              } else {
                typeString = typeof type;
              }
              error("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
            }
            var element = jsxDEV(type, props, key, source, self2);
            if (element == null) {
              return element;
            }
            if (validType) {
              var children = props.children;
              if (children !== void 0) {
                if (isStaticChildren) {
                  if (isArray3(children)) {
                    for (var i6 = 0; i6 < children.length; i6++) {
                      validateChildKeys(children[i6], type);
                    }
                    if (Object.freeze) {
                      Object.freeze(children);
                    }
                  } else {
                    error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
                  }
                } else {
                  validateChildKeys(children, type);
                }
              }
            }
            if (type === REACT_FRAGMENT_TYPE) {
              validateFragmentProps(element);
            } else {
              validatePropTypes(element);
            }
            return element;
          }
        }
        function jsxWithValidationStatic(type, props, key) {
          {
            return jsxWithValidation(type, props, key, true);
          }
        }
        function jsxWithValidationDynamic(type, props, key) {
          {
            return jsxWithValidation(type, props, key, false);
          }
        }
        var jsx3 = jsxWithValidationDynamic;
        var jsxs = jsxWithValidationStatic;
        exports.Fragment = REACT_FRAGMENT_TYPE;
        exports.jsx = jsx3;
        exports.jsxs = jsxs;
      })();
    }
  }
});

// node_modules/react/jsx-runtime.js
var require_jsx_runtime = __commonJS({
  "node_modules/react/jsx-runtime.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_jsx_runtime_development();
    }
  }
});

// node_modules/remix-utils/build/react/client-only.js
var React = __toESM(require_react(), 1);

// node_modules/remix-utils/build/react/use-hydrated.js
var import_react = __toESM(require_react(), 1);
function subscribe() {
  return () => {
  };
}
function useHydrated() {
  return (0, import_react.useSyncExternalStore)(subscribe, () => true, () => false);
}

// node_modules/remix-utils/build/react/client-only.js
function ClientOnly({ children, fallback: fallback2 = null }) {
  return useHydrated() ? React.createElement(React.Fragment, null, children()) : React.createElement(React.Fragment, null, fallback2);
}

// src/viewer.client.tsx
var import_react2 = __toESM(require_react());

// node_modules/@lit/reactive-element/css-tag.js
var t = globalThis;
var e = t.ShadowRoot && (void 0 === t.ShadyCSS || t.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
var s = Symbol();
var o = /* @__PURE__ */ new WeakMap();
var n = class {
  constructor(t9, e13, o11) {
    if (this._$cssResult$ = true, o11 !== s) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t9, this.t = e13;
  }
  get styleSheet() {
    let t9 = this.o;
    const s9 = this.t;
    if (e && void 0 === t9) {
      const e13 = void 0 !== s9 && 1 === s9.length;
      e13 && (t9 = o.get(s9)), void 0 === t9 && ((this.o = t9 = new CSSStyleSheet()).replaceSync(this.cssText), e13 && o.set(s9, t9));
    }
    return t9;
  }
  toString() {
    return this.cssText;
  }
};
var r = (t9) => new n("string" == typeof t9 ? t9 : t9 + "", void 0, s);
var i = (t9, ...e13) => {
  const o11 = 1 === t9.length ? t9[0] : e13.reduce((e14, s9, o12) => e14 + ((t10) => {
    if (true === t10._$cssResult$) return t10.cssText;
    if ("number" == typeof t10) return t10;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + t10 + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(s9) + t9[o12 + 1], t9[0]);
  return new n(o11, t9, s);
};
var S = (s9, o11) => {
  if (e) s9.adoptedStyleSheets = o11.map((t9) => t9 instanceof CSSStyleSheet ? t9 : t9.styleSheet);
  else for (const e13 of o11) {
    const o12 = document.createElement("style"), n9 = t.litNonce;
    void 0 !== n9 && o12.setAttribute("nonce", n9), o12.textContent = e13.cssText, s9.appendChild(o12);
  }
};
var c = e ? (t9) => t9 : (t9) => t9 instanceof CSSStyleSheet ? ((t10) => {
  let e13 = "";
  for (const s9 of t10.cssRules) e13 += s9.cssText;
  return r(e13);
})(t9) : t9;

// node_modules/@lit/reactive-element/reactive-element.js
var { is: i2, defineProperty: e2, getOwnPropertyDescriptor: r2, getOwnPropertyNames: h, getOwnPropertySymbols: o2, getPrototypeOf: n2 } = Object;
var a = globalThis;
var c2 = a.trustedTypes;
var l = c2 ? c2.emptyScript : "";
var p = a.reactiveElementPolyfillSupport;
var d = (t9, s9) => t9;
var u = { toAttribute(t9, s9) {
  switch (s9) {
    case Boolean:
      t9 = t9 ? l : null;
      break;
    case Object:
    case Array:
      t9 = null == t9 ? t9 : JSON.stringify(t9);
  }
  return t9;
}, fromAttribute(t9, s9) {
  let i6 = t9;
  switch (s9) {
    case Boolean:
      i6 = null !== t9;
      break;
    case Number:
      i6 = null === t9 ? null : Number(t9);
      break;
    case Object:
    case Array:
      try {
        i6 = JSON.parse(t9);
      } catch (t10) {
        i6 = null;
      }
  }
  return i6;
} };
var f = (t9, s9) => !i2(t9, s9);
var y = { attribute: true, type: String, converter: u, reflect: false, hasChanged: f };
var _a, _b;
(_a = Symbol.metadata) != null ? _a : Symbol.metadata = Symbol("metadata"), (_b = a.litPropertyMetadata) != null ? _b : a.litPropertyMetadata = /* @__PURE__ */ new WeakMap();
var b = class extends HTMLElement {
  static addInitializer(t9) {
    var _a9;
    this._$Ei(), ((_a9 = this.l) != null ? _a9 : this.l = []).push(t9);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(t9, s9 = y) {
    if (s9.state && (s9.attribute = false), this._$Ei(), this.elementProperties.set(t9, s9), !s9.noAccessor) {
      const i6 = Symbol(), r9 = this.getPropertyDescriptor(t9, i6, s9);
      void 0 !== r9 && e2(this.prototype, t9, r9);
    }
  }
  static getPropertyDescriptor(t9, s9, i6) {
    var _a9;
    const { get: e13, set: h5 } = (_a9 = r2(this.prototype, t9)) != null ? _a9 : { get() {
      return this[s9];
    }, set(t10) {
      this[s9] = t10;
    } };
    return { get() {
      return e13 == null ? void 0 : e13.call(this);
    }, set(s10) {
      const r9 = e13 == null ? void 0 : e13.call(this);
      h5.call(this, s10), this.requestUpdate(t9, r9, i6);
    }, configurable: true, enumerable: true };
  }
  static getPropertyOptions(t9) {
    var _a9;
    return (_a9 = this.elementProperties.get(t9)) != null ? _a9 : y;
  }
  static _$Ei() {
    if (this.hasOwnProperty(d("elementProperties"))) return;
    const t9 = n2(this);
    t9.finalize(), void 0 !== t9.l && (this.l = [...t9.l]), this.elementProperties = new Map(t9.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(d("finalized"))) return;
    if (this.finalized = true, this._$Ei(), this.hasOwnProperty(d("properties"))) {
      const t10 = this.properties, s9 = [...h(t10), ...o2(t10)];
      for (const i6 of s9) this.createProperty(i6, t10[i6]);
    }
    const t9 = this[Symbol.metadata];
    if (null !== t9) {
      const s9 = litPropertyMetadata.get(t9);
      if (void 0 !== s9) for (const [t10, i6] of s9) this.elementProperties.set(t10, i6);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [t10, s9] of this.elementProperties) {
      const i6 = this._$Eu(t10, s9);
      void 0 !== i6 && this._$Eh.set(i6, t10);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(s9) {
    const i6 = [];
    if (Array.isArray(s9)) {
      const e13 = new Set(s9.flat(1 / 0).reverse());
      for (const s10 of e13) i6.unshift(c(s10));
    } else void 0 !== s9 && i6.push(c(s9));
    return i6;
  }
  static _$Eu(t9, s9) {
    const i6 = s9.attribute;
    return false === i6 ? void 0 : "string" == typeof i6 ? i6 : "string" == typeof t9 ? t9.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = false, this.hasUpdated = false, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    var _a9;
    this._$ES = new Promise((t9) => this.enableUpdating = t9), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), (_a9 = this.constructor.l) == null ? void 0 : _a9.forEach((t9) => t9(this));
  }
  addController(t9) {
    var _a9, _b3;
    ((_a9 = this._$EO) != null ? _a9 : this._$EO = /* @__PURE__ */ new Set()).add(t9), void 0 !== this.renderRoot && this.isConnected && ((_b3 = t9.hostConnected) == null ? void 0 : _b3.call(t9));
  }
  removeController(t9) {
    var _a9;
    (_a9 = this._$EO) == null ? void 0 : _a9.delete(t9);
  }
  _$E_() {
    const t9 = /* @__PURE__ */ new Map(), s9 = this.constructor.elementProperties;
    for (const i6 of s9.keys()) this.hasOwnProperty(i6) && (t9.set(i6, this[i6]), delete this[i6]);
    t9.size > 0 && (this._$Ep = t9);
  }
  createRenderRoot() {
    var _a9;
    const t9 = (_a9 = this.shadowRoot) != null ? _a9 : this.attachShadow(this.constructor.shadowRootOptions);
    return S(t9, this.constructor.elementStyles), t9;
  }
  connectedCallback() {
    var _a9, _b3;
    (_a9 = this.renderRoot) != null ? _a9 : this.renderRoot = this.createRenderRoot(), this.enableUpdating(true), (_b3 = this._$EO) == null ? void 0 : _b3.forEach((t9) => {
      var _a10;
      return (_a10 = t9.hostConnected) == null ? void 0 : _a10.call(t9);
    });
  }
  enableUpdating(t9) {
  }
  disconnectedCallback() {
    var _a9;
    (_a9 = this._$EO) == null ? void 0 : _a9.forEach((t9) => {
      var _a10;
      return (_a10 = t9.hostDisconnected) == null ? void 0 : _a10.call(t9);
    });
  }
  attributeChangedCallback(t9, s9, i6) {
    this._$AK(t9, i6);
  }
  _$EC(t9, s9) {
    var _a9;
    const i6 = this.constructor.elementProperties.get(t9), e13 = this.constructor._$Eu(t9, i6);
    if (void 0 !== e13 && true === i6.reflect) {
      const r9 = (void 0 !== ((_a9 = i6.converter) == null ? void 0 : _a9.toAttribute) ? i6.converter : u).toAttribute(s9, i6.type);
      this._$Em = t9, null == r9 ? this.removeAttribute(e13) : this.setAttribute(e13, r9), this._$Em = null;
    }
  }
  _$AK(t9, s9) {
    var _a9;
    const i6 = this.constructor, e13 = i6._$Eh.get(t9);
    if (void 0 !== e13 && this._$Em !== e13) {
      const t10 = i6.getPropertyOptions(e13), r9 = "function" == typeof t10.converter ? { fromAttribute: t10.converter } : void 0 !== ((_a9 = t10.converter) == null ? void 0 : _a9.fromAttribute) ? t10.converter : u;
      this._$Em = e13, this[e13] = r9.fromAttribute(s9, t10.type), this._$Em = null;
    }
  }
  requestUpdate(t9, s9, i6) {
    var _a9;
    if (void 0 !== t9) {
      if (i6 != null ? i6 : i6 = this.constructor.getPropertyOptions(t9), !((_a9 = i6.hasChanged) != null ? _a9 : f)(this[t9], s9)) return;
      this.P(t9, s9, i6);
    }
    false === this.isUpdatePending && (this._$ES = this._$ET());
  }
  P(t9, s9, i6) {
    var _a9;
    this._$AL.has(t9) || this._$AL.set(t9, s9), true === i6.reflect && this._$Em !== t9 && ((_a9 = this._$Ej) != null ? _a9 : this._$Ej = /* @__PURE__ */ new Set()).add(t9);
  }
  _$ET() {
    return __async(this, null, function* () {
      this.isUpdatePending = true;
      try {
        yield this._$ES;
      } catch (t10) {
        Promise.reject(t10);
      }
      const t9 = this.scheduleUpdate();
      return null != t9 && (yield t9), !this.isUpdatePending;
    });
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var _a9, _b3;
    if (!this.isUpdatePending) return;
    if (!this.hasUpdated) {
      if ((_a9 = this.renderRoot) != null ? _a9 : this.renderRoot = this.createRenderRoot(), this._$Ep) {
        for (const [t11, s10] of this._$Ep) this[t11] = s10;
        this._$Ep = void 0;
      }
      const t10 = this.constructor.elementProperties;
      if (t10.size > 0) for (const [s10, i6] of t10) true !== i6.wrapped || this._$AL.has(s10) || void 0 === this[s10] || this.P(s10, this[s10], i6);
    }
    let t9 = false;
    const s9 = this._$AL;
    try {
      t9 = this.shouldUpdate(s9), t9 ? (this.willUpdate(s9), (_b3 = this._$EO) == null ? void 0 : _b3.forEach((t10) => {
        var _a10;
        return (_a10 = t10.hostUpdate) == null ? void 0 : _a10.call(t10);
      }), this.update(s9)) : this._$EU();
    } catch (s10) {
      throw t9 = false, this._$EU(), s10;
    }
    t9 && this._$AE(s9);
  }
  willUpdate(t9) {
  }
  _$AE(t9) {
    var _a9;
    (_a9 = this._$EO) == null ? void 0 : _a9.forEach((t10) => {
      var _a10;
      return (_a10 = t10.hostUpdated) == null ? void 0 : _a10.call(t10);
    }), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(t9)), this.updated(t9);
  }
  _$EU() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = false;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(t9) {
    return true;
  }
  update(t9) {
    this._$Ej && (this._$Ej = this._$Ej.forEach((t10) => this._$EC(t10, this[t10]))), this._$EU();
  }
  updated(t9) {
  }
  firstUpdated(t9) {
  }
};
var _a2;
b.elementStyles = [], b.shadowRootOptions = { mode: "open" }, b[d("elementProperties")] = /* @__PURE__ */ new Map(), b[d("finalized")] = /* @__PURE__ */ new Map(), p == null ? void 0 : p({ ReactiveElement: b }), ((_a2 = a.reactiveElementVersions) != null ? _a2 : a.reactiveElementVersions = []).push("2.0.4");

// node_modules/lit-html/lit-html.js
var t2 = globalThis;
var i3 = t2.trustedTypes;
var s2 = i3 ? i3.createPolicy("lit-html", { createHTML: (t9) => t9 }) : void 0;
var e3 = "$lit$";
var h2 = `lit$${Math.random().toFixed(9).slice(2)}$`;
var o3 = "?" + h2;
var n3 = `<${o3}>`;
var r3 = document;
var l2 = () => r3.createComment("");
var c3 = (t9) => null === t9 || "object" != typeof t9 && "function" != typeof t9;
var a2 = Array.isArray;
var u2 = (t9) => a2(t9) || "function" == typeof (t9 == null ? void 0 : t9[Symbol.iterator]);
var d2 = "[ 	\n\f\r]";
var f2 = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
var v = /-->/g;
var _ = />/g;
var m = RegExp(`>|${d2}(?:([^\\s"'>=/]+)(${d2}*=${d2}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g");
var p2 = /'/g;
var g = /"/g;
var $ = /^(?:script|style|textarea|title)$/i;
var y2 = (t9) => (i6, ...s9) => ({ _$litType$: t9, strings: i6, values: s9 });
var x = y2(1);
var b2 = y2(2);
var w = Symbol.for("lit-noChange");
var T = Symbol.for("lit-nothing");
var A = /* @__PURE__ */ new WeakMap();
var E = r3.createTreeWalker(r3, 129);
function C(t9, i6) {
  if (!Array.isArray(t9) || !t9.hasOwnProperty("raw")) throw Error("invalid template strings array");
  return void 0 !== s2 ? s2.createHTML(i6) : i6;
}
var P = (t9, i6) => {
  const s9 = t9.length - 1, o11 = [];
  let r9, l5 = 2 === i6 ? "<svg>" : "", c6 = f2;
  for (let i7 = 0; i7 < s9; i7++) {
    const s10 = t9[i7];
    let a4, u5, d3 = -1, y3 = 0;
    for (; y3 < s10.length && (c6.lastIndex = y3, u5 = c6.exec(s10), null !== u5); ) y3 = c6.lastIndex, c6 === f2 ? "!--" === u5[1] ? c6 = v : void 0 !== u5[1] ? c6 = _ : void 0 !== u5[2] ? ($.test(u5[2]) && (r9 = RegExp("</" + u5[2], "g")), c6 = m) : void 0 !== u5[3] && (c6 = m) : c6 === m ? ">" === u5[0] ? (c6 = r9 != null ? r9 : f2, d3 = -1) : void 0 === u5[1] ? d3 = -2 : (d3 = c6.lastIndex - u5[2].length, a4 = u5[1], c6 = void 0 === u5[3] ? m : '"' === u5[3] ? g : p2) : c6 === g || c6 === p2 ? c6 = m : c6 === v || c6 === _ ? c6 = f2 : (c6 = m, r9 = void 0);
    const x2 = c6 === m && t9[i7 + 1].startsWith("/>") ? " " : "";
    l5 += c6 === f2 ? s10 + n3 : d3 >= 0 ? (o11.push(a4), s10.slice(0, d3) + e3 + s10.slice(d3) + h2 + x2) : s10 + h2 + (-2 === d3 ? i7 : x2);
  }
  return [C(t9, l5 + (t9[s9] || "<?>") + (2 === i6 ? "</svg>" : "")), o11];
};
var V = class _V {
  constructor({ strings: t9, _$litType$: s9 }, n9) {
    let r9;
    this.parts = [];
    let c6 = 0, a4 = 0;
    const u5 = t9.length - 1, d3 = this.parts, [f5, v2] = P(t9, s9);
    if (this.el = _V.createElement(f5, n9), E.currentNode = this.el.content, 2 === s9) {
      const t10 = this.el.content.firstChild;
      t10.replaceWith(...t10.childNodes);
    }
    for (; null !== (r9 = E.nextNode()) && d3.length < u5; ) {
      if (1 === r9.nodeType) {
        if (r9.hasAttributes()) for (const t10 of r9.getAttributeNames()) if (t10.endsWith(e3)) {
          const i6 = v2[a4++], s10 = r9.getAttribute(t10).split(h2), e13 = /([.?@])?(.*)/.exec(i6);
          d3.push({ type: 1, index: c6, name: e13[2], strings: s10, ctor: "." === e13[1] ? k : "?" === e13[1] ? H : "@" === e13[1] ? I : R }), r9.removeAttribute(t10);
        } else t10.startsWith(h2) && (d3.push({ type: 6, index: c6 }), r9.removeAttribute(t10));
        if ($.test(r9.tagName)) {
          const t10 = r9.textContent.split(h2), s10 = t10.length - 1;
          if (s10 > 0) {
            r9.textContent = i3 ? i3.emptyScript : "";
            for (let i6 = 0; i6 < s10; i6++) r9.append(t10[i6], l2()), E.nextNode(), d3.push({ type: 2, index: ++c6 });
            r9.append(t10[s10], l2());
          }
        }
      } else if (8 === r9.nodeType) if (r9.data === o3) d3.push({ type: 2, index: c6 });
      else {
        let t10 = -1;
        for (; -1 !== (t10 = r9.data.indexOf(h2, t10 + 1)); ) d3.push({ type: 7, index: c6 }), t10 += h2.length - 1;
      }
      c6++;
    }
  }
  static createElement(t9, i6) {
    const s9 = r3.createElement("template");
    return s9.innerHTML = t9, s9;
  }
};
function N(t9, i6, s9 = t9, e13) {
  var _a9, _b2, _c;
  if (i6 === w) return i6;
  let h5 = void 0 !== e13 ? (_a9 = s9._$Co) == null ? void 0 : _a9[e13] : s9._$Cl;
  const o11 = c3(i6) ? void 0 : i6._$litDirective$;
  return (h5 == null ? void 0 : h5.constructor) !== o11 && ((_b2 = h5 == null ? void 0 : h5._$AO) == null ? void 0 : _b2.call(h5, false), void 0 === o11 ? h5 = void 0 : (h5 = new o11(t9), h5._$AT(t9, s9, e13)), void 0 !== e13 ? ((_c = s9._$Co) != null ? _c : s9._$Co = [])[e13] = h5 : s9._$Cl = h5), void 0 !== h5 && (i6 = N(t9, h5._$AS(t9, i6.values), h5, e13)), i6;
}
var S2 = class {
  constructor(t9, i6) {
    this._$AV = [], this._$AN = void 0, this._$AD = t9, this._$AM = i6;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t9) {
    var _a9;
    const { el: { content: i6 }, parts: s9 } = this._$AD, e13 = ((_a9 = t9 == null ? void 0 : t9.creationScope) != null ? _a9 : r3).importNode(i6, true);
    E.currentNode = e13;
    let h5 = E.nextNode(), o11 = 0, n9 = 0, l5 = s9[0];
    for (; void 0 !== l5; ) {
      if (o11 === l5.index) {
        let i7;
        2 === l5.type ? i7 = new M(h5, h5.nextSibling, this, t9) : 1 === l5.type ? i7 = new l5.ctor(h5, l5.name, l5.strings, this, t9) : 6 === l5.type && (i7 = new L(h5, this, t9)), this._$AV.push(i7), l5 = s9[++n9];
      }
      o11 !== (l5 == null ? void 0 : l5.index) && (h5 = E.nextNode(), o11++);
    }
    return E.currentNode = r3, e13;
  }
  p(t9) {
    let i6 = 0;
    for (const s9 of this._$AV) void 0 !== s9 && (void 0 !== s9.strings ? (s9._$AI(t9, s9, i6), i6 += s9.strings.length - 2) : s9._$AI(t9[i6])), i6++;
  }
};
var M = class _M {
  get _$AU() {
    var _a9, _b2;
    return (_b2 = (_a9 = this._$AM) == null ? void 0 : _a9._$AU) != null ? _b2 : this._$Cv;
  }
  constructor(t9, i6, s9, e13) {
    var _a9;
    this.type = 2, this._$AH = T, this._$AN = void 0, this._$AA = t9, this._$AB = i6, this._$AM = s9, this.options = e13, this._$Cv = (_a9 = e13 == null ? void 0 : e13.isConnected) != null ? _a9 : true;
  }
  get parentNode() {
    let t9 = this._$AA.parentNode;
    const i6 = this._$AM;
    return void 0 !== i6 && 11 === (t9 == null ? void 0 : t9.nodeType) && (t9 = i6.parentNode), t9;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t9, i6 = this) {
    t9 = N(this, t9, i6), c3(t9) ? t9 === T || null == t9 || "" === t9 ? (this._$AH !== T && this._$AR(), this._$AH = T) : t9 !== this._$AH && t9 !== w && this._(t9) : void 0 !== t9._$litType$ ? this.$(t9) : void 0 !== t9.nodeType ? this.T(t9) : u2(t9) ? this.k(t9) : this._(t9);
  }
  S(t9) {
    return this._$AA.parentNode.insertBefore(t9, this._$AB);
  }
  T(t9) {
    this._$AH !== t9 && (this._$AR(), this._$AH = this.S(t9));
  }
  _(t9) {
    this._$AH !== T && c3(this._$AH) ? this._$AA.nextSibling.data = t9 : this.T(r3.createTextNode(t9)), this._$AH = t9;
  }
  $(t9) {
    var _a9;
    const { values: i6, _$litType$: s9 } = t9, e13 = "number" == typeof s9 ? this._$AC(t9) : (void 0 === s9.el && (s9.el = V.createElement(C(s9.h, s9.h[0]), this.options)), s9);
    if (((_a9 = this._$AH) == null ? void 0 : _a9._$AD) === e13) this._$AH.p(i6);
    else {
      const t10 = new S2(e13, this), s10 = t10.u(this.options);
      t10.p(i6), this.T(s10), this._$AH = t10;
    }
  }
  _$AC(t9) {
    let i6 = A.get(t9.strings);
    return void 0 === i6 && A.set(t9.strings, i6 = new V(t9)), i6;
  }
  k(t9) {
    a2(this._$AH) || (this._$AH = [], this._$AR());
    const i6 = this._$AH;
    let s9, e13 = 0;
    for (const h5 of t9) e13 === i6.length ? i6.push(s9 = new _M(this.S(l2()), this.S(l2()), this, this.options)) : s9 = i6[e13], s9._$AI(h5), e13++;
    e13 < i6.length && (this._$AR(s9 && s9._$AB.nextSibling, e13), i6.length = e13);
  }
  _$AR(t9 = this._$AA.nextSibling, i6) {
    var _a9;
    for ((_a9 = this._$AP) == null ? void 0 : _a9.call(this, false, true, i6); t9 && t9 !== this._$AB; ) {
      const i7 = t9.nextSibling;
      t9.remove(), t9 = i7;
    }
  }
  setConnected(t9) {
    var _a9;
    void 0 === this._$AM && (this._$Cv = t9, (_a9 = this._$AP) == null ? void 0 : _a9.call(this, t9));
  }
};
var R = class {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(t9, i6, s9, e13, h5) {
    this.type = 1, this._$AH = T, this._$AN = void 0, this.element = t9, this.name = i6, this._$AM = e13, this.options = h5, s9.length > 2 || "" !== s9[0] || "" !== s9[1] ? (this._$AH = Array(s9.length - 1).fill(new String()), this.strings = s9) : this._$AH = T;
  }
  _$AI(t9, i6 = this, s9, e13) {
    const h5 = this.strings;
    let o11 = false;
    if (void 0 === h5) t9 = N(this, t9, i6, 0), o11 = !c3(t9) || t9 !== this._$AH && t9 !== w, o11 && (this._$AH = t9);
    else {
      const e14 = t9;
      let n9, r9;
      for (t9 = h5[0], n9 = 0; n9 < h5.length - 1; n9++) r9 = N(this, e14[s9 + n9], i6, n9), r9 === w && (r9 = this._$AH[n9]), o11 || (o11 = !c3(r9) || r9 !== this._$AH[n9]), r9 === T ? t9 = T : t9 !== T && (t9 += (r9 != null ? r9 : "") + h5[n9 + 1]), this._$AH[n9] = r9;
    }
    o11 && !e13 && this.j(t9);
  }
  j(t9) {
    t9 === T ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t9 != null ? t9 : "");
  }
};
var k = class extends R {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(t9) {
    this.element[this.name] = t9 === T ? void 0 : t9;
  }
};
var H = class extends R {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(t9) {
    this.element.toggleAttribute(this.name, !!t9 && t9 !== T);
  }
};
var I = class extends R {
  constructor(t9, i6, s9, e13, h5) {
    super(t9, i6, s9, e13, h5), this.type = 5;
  }
  _$AI(t9, i6 = this) {
    var _a9;
    if ((t9 = (_a9 = N(this, t9, i6, 0)) != null ? _a9 : T) === w) return;
    const s9 = this._$AH, e13 = t9 === T && s9 !== T || t9.capture !== s9.capture || t9.once !== s9.once || t9.passive !== s9.passive, h5 = t9 !== T && (s9 === T || e13);
    e13 && this.element.removeEventListener(this.name, this, s9), h5 && this.element.addEventListener(this.name, this, t9), this._$AH = t9;
  }
  handleEvent(t9) {
    var _a9, _b2;
    "function" == typeof this._$AH ? this._$AH.call((_b2 = (_a9 = this.options) == null ? void 0 : _a9.host) != null ? _b2 : this.element, t9) : this._$AH.handleEvent(t9);
  }
};
var L = class {
  constructor(t9, i6, s9) {
    this.element = t9, this.type = 6, this._$AN = void 0, this._$AM = i6, this.options = s9;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t9) {
    N(this, t9);
  }
};
var z = { P: e3, A: h2, C: o3, M: 1, L: P, R: S2, D: u2, V: N, I: M, H: R, N: H, U: I, B: k, F: L };
var Z = t2.litHtmlPolyfillSupport;
var _a3;
Z == null ? void 0 : Z(V, M), ((_a3 = t2.litHtmlVersions) != null ? _a3 : t2.litHtmlVersions = []).push("3.1.4");
var j = (t9, i6, s9) => {
  var _a9, _b2;
  const e13 = (_a9 = s9 == null ? void 0 : s9.renderBefore) != null ? _a9 : i6;
  let h5 = e13._$litPart$;
  if (void 0 === h5) {
    const t10 = (_b2 = s9 == null ? void 0 : s9.renderBefore) != null ? _b2 : null;
    e13._$litPart$ = h5 = new M(i6.insertBefore(l2(), t10), t10, void 0, s9 != null ? s9 : {});
  }
  return h5._$AI(t9), h5;
};

// node_modules/lit-element/lit-element.js
var s3 = class extends b {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    var _a9, _b2;
    const t9 = super.createRenderRoot();
    return (_b2 = (_a9 = this.renderOptions).renderBefore) != null ? _b2 : _a9.renderBefore = t9.firstChild, t9;
  }
  update(t9) {
    const i6 = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t9), this._$Do = j(i6, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    var _a9;
    super.connectedCallback(), (_a9 = this._$Do) == null ? void 0 : _a9.setConnected(true);
  }
  disconnectedCallback() {
    var _a9;
    super.disconnectedCallback(), (_a9 = this._$Do) == null ? void 0 : _a9.setConnected(false);
  }
  render() {
    return w;
  }
};
var _a4;
s3._$litElement$ = true, s3["finalized", "finalized"] = true, (_a4 = globalThis.litElementHydrateSupport) == null ? void 0 : _a4.call(globalThis, { LitElement: s3 });
var r4 = globalThis.litElementPolyfillSupport;
r4 == null ? void 0 : r4({ LitElement: s3 });
var _a5;
((_a5 = globalThis.litElementVersions) != null ? _a5 : globalThis.litElementVersions = []).push("4.0.6");

// node_modules/@shoelace-style/shoelace/dist/chunks/chunk.A5D6FTFY.js
var card_styles_default = i`
  :host {
    --border-color: var(--sl-color-neutral-200);
    --border-radius: var(--sl-border-radius-medium);
    --border-width: 1px;
    --padding: var(--sl-spacing-large);

    display: inline-block;
  }

  .card {
    display: flex;
    flex-direction: column;
    background-color: var(--sl-panel-background-color);
    box-shadow: var(--sl-shadow-x-small);
    border: solid var(--border-width) var(--border-color);
    border-radius: var(--border-radius);
  }

  .card__image {
    display: flex;
    border-top-left-radius: var(--border-radius);
    border-top-right-radius: var(--border-radius);
    margin: calc(-1 * var(--border-width));
    overflow: hidden;
  }

  .card__image::slotted(img) {
    display: block;
    width: 100%;
  }

  .card:not(.card--has-image) .card__image {
    display: none;
  }

  .card__header {
    display: block;
    border-bottom: solid var(--border-width) var(--border-color);
    padding: calc(var(--padding) / 2) var(--padding);
  }

  .card:not(.card--has-header) .card__header {
    display: none;
  }

  .card:not(.card--has-image) .card__header {
    border-top-left-radius: var(--border-radius);
    border-top-right-radius: var(--border-radius);
  }

  .card__body {
    display: block;
    padding: var(--padding);
  }

  .card--has-footer .card__footer {
    display: block;
    border-top: solid var(--border-width) var(--border-color);
    padding: var(--padding);
  }

  .card:not(.card--has-footer) .card__footer {
    display: none;
  }
`;

// node_modules/@shoelace-style/shoelace/dist/chunks/chunk.NYIIDP5N.js
var HasSlotController = class {
  constructor(host, ...slotNames) {
    this.slotNames = [];
    this.handleSlotChange = (event2) => {
      const slot = event2.target;
      if (this.slotNames.includes("[default]") && !slot.name || slot.name && this.slotNames.includes(slot.name)) {
        this.host.requestUpdate();
      }
    };
    (this.host = host).addController(this);
    this.slotNames = slotNames;
  }
  hasDefaultSlot() {
    return [...this.host.childNodes].some((node) => {
      if (node.nodeType === node.TEXT_NODE && node.textContent.trim() !== "") {
        return true;
      }
      if (node.nodeType === node.ELEMENT_NODE) {
        const el = node;
        const tagName = el.tagName.toLowerCase();
        if (tagName === "sl-visually-hidden") {
          return false;
        }
        if (!el.hasAttribute("slot")) {
          return true;
        }
      }
      return false;
    });
  }
  hasNamedSlot(name) {
    return this.host.querySelector(`:scope > [slot="${name}"]`) !== null;
  }
  test(slotName) {
    return slotName === "[default]" ? this.hasDefaultSlot() : this.hasNamedSlot(slotName);
  }
  hostConnected() {
    this.host.shadowRoot.addEventListener("slotchange", this.handleSlotChange);
  }
  hostDisconnected() {
    this.host.shadowRoot.removeEventListener("slotchange", this.handleSlotChange);
  }
};

// node_modules/@shoelace-style/shoelace/dist/chunks/chunk.TUVJKY7S.js
var component_styles_default = i`
  :host {
    box-sizing: border-box;
  }

  :host *,
  :host *::before,
  :host *::after {
    box-sizing: inherit;
  }

  [hidden] {
    display: none !important;
  }
`;

// node_modules/@shoelace-style/shoelace/dist/chunks/chunk.IFDWM6P4.js
var __defProp2 = Object.defineProperty;
var __defProps2 = Object.defineProperties;
var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols2 = Object.getOwnPropertySymbols;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __propIsEnum2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp2 = (obj2, key, value) => key in obj2 ? __defProp2(obj2, key, { enumerable: true, configurable: true, writable: true, value }) : obj2[key] = value;
var __spreadValues2 = (a4, b3) => {
  for (var prop in b3 || (b3 = {}))
    if (__hasOwnProp2.call(b3, prop))
      __defNormalProp2(a4, prop, b3[prop]);
  if (__getOwnPropSymbols2)
    for (var prop of __getOwnPropSymbols2(b3)) {
      if (__propIsEnum2.call(b3, prop))
        __defNormalProp2(a4, prop, b3[prop]);
    }
  return a4;
};
var __spreadProps2 = (a4, b3) => __defProps2(a4, __getOwnPropDescs2(b3));
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc2(target, key) : target;
  for (var i6 = decorators.length - 1, decorator; i6 >= 0; i6--)
    if (decorator = decorators[i6])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp2(target, key, result);
  return result;
};

// node_modules/@lit/reactive-element/decorators/custom-element.js
var t3 = (t9) => (e13, o11) => {
  void 0 !== o11 ? o11.addInitializer(() => {
    customElements.define(t9, e13);
  }) : customElements.define(t9, e13);
};

// node_modules/@lit/reactive-element/decorators/property.js
var o4 = { attribute: true, type: String, converter: u, reflect: false, hasChanged: f };
var r5 = (t9 = o4, e13, r9) => {
  const { kind: n9, metadata: i6 } = r9;
  let s9 = globalThis.litPropertyMetadata.get(i6);
  if (void 0 === s9 && globalThis.litPropertyMetadata.set(i6, s9 = /* @__PURE__ */ new Map()), s9.set(r9.name, t9), "accessor" === n9) {
    const { name: o11 } = r9;
    return { set(r10) {
      const n10 = e13.get.call(this);
      e13.set.call(this, r10), this.requestUpdate(o11, n10, t9);
    }, init(e14) {
      return void 0 !== e14 && this.P(o11, void 0, t9), e14;
    } };
  }
  if ("setter" === n9) {
    const { name: o11 } = r9;
    return function(r10) {
      const n10 = this[o11];
      e13.call(this, r10), this.requestUpdate(o11, n10, t9);
    };
  }
  throw Error("Unsupported decorator location: " + n9);
};
function n4(t9) {
  return (e13, o11) => "object" == typeof o11 ? r5(t9, e13, o11) : ((t10, e14, o12) => {
    const r9 = e14.hasOwnProperty(o12);
    return e14.constructor.createProperty(o12, r9 ? __spreadProps(__spreadValues({}, t10), { wrapped: true }) : t10), r9 ? Object.getOwnPropertyDescriptor(e14, o12) : void 0;
  })(t9, e13, o11);
}

// node_modules/@lit/reactive-element/decorators/state.js
function r6(r9) {
  return n4(__spreadProps(__spreadValues({}, r9), { state: true, attribute: false }));
}

// node_modules/@lit/reactive-element/decorators/event-options.js
function t4(t9) {
  return (n9, o11) => {
    const c6 = "function" == typeof n9 ? n9 : n9[o11];
    Object.assign(c6, t9);
  };
}

// node_modules/@lit/reactive-element/decorators/base.js
var e4 = (e13, t9, c6) => (c6.configurable = true, c6.enumerable = true, Reflect.decorate && "object" != typeof t9 && Object.defineProperty(e13, t9, c6), c6);

// node_modules/@lit/reactive-element/decorators/query.js
function e5(e13, r9) {
  return (n9, s9, i6) => {
    const o11 = (t9) => {
      var _a9, _b2;
      return (_b2 = (_a9 = t9.renderRoot) == null ? void 0 : _a9.querySelector(e13)) != null ? _b2 : null;
    };
    if (r9) {
      const { get: e14, set: r10 } = "object" == typeof s9 ? n9 : i6 != null ? i6 : (() => {
        const t9 = Symbol();
        return { get() {
          return this[t9];
        }, set(e15) {
          this[t9] = e15;
        } };
      })();
      return e4(n9, s9, { get() {
        let t9 = e14.call(this);
        return void 0 === t9 && (t9 = o11(this), (null !== t9 || this.hasUpdated) && r10.call(this, t9)), t9;
      } });
    }
    return e4(n9, s9, { get() {
      return o11(this);
    } });
  };
}

// node_modules/@shoelace-style/shoelace/dist/chunks/chunk.TUZSOS6C.js
var ShoelaceElement = class extends s3 {
  constructor() {
    super();
    Object.entries(this.constructor.dependencies).forEach(([name, component]) => {
      this.constructor.define(name, component);
    });
  }
  emit(name, options) {
    const event2 = new CustomEvent(name, __spreadValues2({
      bubbles: true,
      cancelable: false,
      composed: true,
      detail: {}
    }, options));
    this.dispatchEvent(event2);
    return event2;
  }
  /* eslint-enable */
  static define(name, elementConstructor = this, options = {}) {
    const currentlyRegisteredConstructor = customElements.get(name);
    if (!currentlyRegisteredConstructor) {
      customElements.define(name, class extends elementConstructor {
      }, options);
      return;
    }
    let newVersion = " (unknown version)";
    let existingVersion = newVersion;
    if ("version" in elementConstructor && elementConstructor.version) {
      newVersion = " v" + elementConstructor.version;
    }
    if ("version" in currentlyRegisteredConstructor && currentlyRegisteredConstructor.version) {
      existingVersion = " v" + currentlyRegisteredConstructor.version;
    }
    if (newVersion && existingVersion && newVersion === existingVersion) {
      return;
    }
    console.warn(
      `Attempted to register <${name}>${newVersion}, but <${name}>${existingVersion} has already been registered.`
    );
  }
};
ShoelaceElement.version = "2.15.1";
ShoelaceElement.dependencies = {};
__decorateClass([
  n4()
], ShoelaceElement.prototype, "dir", 2);
__decorateClass([
  n4()
], ShoelaceElement.prototype, "lang", 2);

// node_modules/lit-html/directive.js
var t5 = { ATTRIBUTE: 1, CHILD: 2, PROPERTY: 3, BOOLEAN_ATTRIBUTE: 4, EVENT: 5, ELEMENT: 6 };
var e6 = (t9) => (...e13) => ({ _$litDirective$: t9, values: e13 });
var i4 = class {
  constructor(t9) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(t9, e13, i6) {
    this._$Ct = t9, this._$AM = e13, this._$Ci = i6;
  }
  _$AS(t9, e13) {
    return this.update(t9, e13);
  }
  update(t9, e13) {
    return this.render(...e13);
  }
};

// node_modules/lit-html/directives/class-map.js
var e7 = e6(class extends i4 {
  constructor(t9) {
    var _a9;
    if (super(t9), t9.type !== t5.ATTRIBUTE || "class" !== t9.name || ((_a9 = t9.strings) == null ? void 0 : _a9.length) > 2) throw Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.");
  }
  render(t9) {
    return " " + Object.keys(t9).filter((s9) => t9[s9]).join(" ") + " ";
  }
  update(s9, [i6]) {
    var _a9, _b2;
    if (void 0 === this.st) {
      this.st = /* @__PURE__ */ new Set(), void 0 !== s9.strings && (this.nt = new Set(s9.strings.join(" ").split(/\s/).filter((t9) => "" !== t9)));
      for (const t9 in i6) i6[t9] && !((_a9 = this.nt) == null ? void 0 : _a9.has(t9)) && this.st.add(t9);
      return this.render(i6);
    }
    const r9 = s9.element.classList;
    for (const t9 of this.st) t9 in i6 || (r9.remove(t9), this.st.delete(t9));
    for (const t9 in i6) {
      const s10 = !!i6[t9];
      s10 === this.st.has(t9) || ((_b2 = this.nt) == null ? void 0 : _b2.has(t9)) || (s10 ? (r9.add(t9), this.st.add(t9)) : (r9.remove(t9), this.st.delete(t9)));
    }
    return w;
  }
});

// node_modules/@shoelace-style/shoelace/dist/chunks/chunk.QXE4HSVY.js
var SlCard = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.hasSlotController = new HasSlotController(this, "footer", "header", "image");
  }
  render() {
    return x`
      <div
        part="base"
        class=${e7({
      card: true,
      "card--has-footer": this.hasSlotController.test("footer"),
      "card--has-image": this.hasSlotController.test("image"),
      "card--has-header": this.hasSlotController.test("header")
    })}
      >
        <slot name="image" part="image" class="card__image"></slot>
        <slot name="header" part="header" class="card__header"></slot>
        <slot part="body" class="card__body"></slot>
        <slot name="footer" part="footer" class="card__footer"></slot>
      </div>
    `;
  }
};
SlCard.styles = [component_styles_default, card_styles_default];

// node_modules/@shoelace-style/shoelace/dist/chunks/chunk.MGEAXYVX.js
SlCard.define("sl-card");

// node_modules/@shoelace-style/shoelace/dist/chunks/chunk.5D6IT2SR.js
var range_styles_default = i`
  :host {
    --thumb-size: 20px;
    --tooltip-offset: 10px;
    --track-color-active: var(--sl-color-neutral-200);
    --track-color-inactive: var(--sl-color-neutral-200);
    --track-active-offset: 0%;
    --track-height: 6px;

    display: block;
  }

  .range {
    position: relative;
  }

  .range__control {
    --percent: 0%;
    -webkit-appearance: none;
    border-radius: 3px;
    width: 100%;
    height: var(--track-height);
    background: transparent;
    line-height: var(--sl-input-height-medium);
    vertical-align: middle;
    margin: 0;

    background-image: linear-gradient(
      to right,
      var(--track-color-inactive) 0%,
      var(--track-color-inactive) min(var(--percent), var(--track-active-offset)),
      var(--track-color-active) min(var(--percent), var(--track-active-offset)),
      var(--track-color-active) max(var(--percent), var(--track-active-offset)),
      var(--track-color-inactive) max(var(--percent), var(--track-active-offset)),
      var(--track-color-inactive) 100%
    );
  }

  .range--rtl .range__control {
    background-image: linear-gradient(
      to left,
      var(--track-color-inactive) 0%,
      var(--track-color-inactive) min(var(--percent), var(--track-active-offset)),
      var(--track-color-active) min(var(--percent), var(--track-active-offset)),
      var(--track-color-active) max(var(--percent), var(--track-active-offset)),
      var(--track-color-inactive) max(var(--percent), var(--track-active-offset)),
      var(--track-color-inactive) 100%
    );
  }

  /* Webkit */
  .range__control::-webkit-slider-runnable-track {
    width: 100%;
    height: var(--track-height);
    border-radius: 3px;
    border: none;
  }

  .range__control::-webkit-slider-thumb {
    border: none;
    width: var(--thumb-size);
    height: var(--thumb-size);
    border-radius: 50%;
    background-color: var(--sl-color-primary-600);
    border: solid var(--sl-input-border-width) var(--sl-color-primary-600);
    -webkit-appearance: none;
    margin-top: calc(var(--thumb-size) / -2 + var(--track-height) / 2);
    cursor: pointer;
  }

  .range__control:enabled::-webkit-slider-thumb:hover {
    background-color: var(--sl-color-primary-500);
    border-color: var(--sl-color-primary-500);
  }

  .range__control:enabled:focus-visible::-webkit-slider-thumb {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .range__control:enabled::-webkit-slider-thumb:active {
    background-color: var(--sl-color-primary-500);
    border-color: var(--sl-color-primary-500);
    cursor: grabbing;
  }

  /* Firefox */
  .range__control::-moz-focus-outer {
    border: 0;
  }

  .range__control::-moz-range-progress {
    background-color: var(--track-color-active);
    border-radius: 3px;
    height: var(--track-height);
  }

  .range__control::-moz-range-track {
    width: 100%;
    height: var(--track-height);
    background-color: var(--track-color-inactive);
    border-radius: 3px;
    border: none;
  }

  .range__control::-moz-range-thumb {
    border: none;
    height: var(--thumb-size);
    width: var(--thumb-size);
    border-radius: 50%;
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
    transition:
      var(--sl-transition-fast) border-color,
      var(--sl-transition-fast) background-color,
      var(--sl-transition-fast) color,
      var(--sl-transition-fast) box-shadow;
    cursor: pointer;
  }

  .range__control:enabled::-moz-range-thumb:hover {
    background-color: var(--sl-color-primary-500);
    border-color: var(--sl-color-primary-500);
  }

  .range__control:enabled:focus-visible::-moz-range-thumb {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .range__control:enabled::-moz-range-thumb:active {
    background-color: var(--sl-color-primary-500);
    border-color: var(--sl-color-primary-500);
    cursor: grabbing;
  }

  /* States */
  .range__control:focus-visible {
    outline: none;
  }

  .range__control:disabled {
    opacity: 0.5;
  }

  .range__control:disabled::-webkit-slider-thumb {
    cursor: not-allowed;
  }

  .range__control:disabled::-moz-range-thumb {
    cursor: not-allowed;
  }

  /* Tooltip output */
  .range__tooltip {
    position: absolute;
    z-index: var(--sl-z-index-tooltip);
    left: 0;
    border-radius: var(--sl-tooltip-border-radius);
    background-color: var(--sl-tooltip-background-color);
    font-family: var(--sl-tooltip-font-family);
    font-size: var(--sl-tooltip-font-size);
    font-weight: var(--sl-tooltip-font-weight);
    line-height: var(--sl-tooltip-line-height);
    color: var(--sl-tooltip-color);
    opacity: 0;
    padding: var(--sl-tooltip-padding);
    transition: var(--sl-transition-fast) opacity;
    pointer-events: none;
  }

  .range__tooltip:after {
    content: '';
    position: absolute;
    width: 0;
    height: 0;
    left: 50%;
    translate: calc(-1 * var(--sl-tooltip-arrow-size));
  }

  .range--tooltip-visible .range__tooltip {
    opacity: 1;
  }

  /* Tooltip on top */
  .range--tooltip-top .range__tooltip {
    top: calc(-1 * var(--thumb-size) - var(--tooltip-offset));
  }

  .range--tooltip-top .range__tooltip:after {
    border-top: var(--sl-tooltip-arrow-size) solid var(--sl-tooltip-background-color);
    border-left: var(--sl-tooltip-arrow-size) solid transparent;
    border-right: var(--sl-tooltip-arrow-size) solid transparent;
    top: 100%;
  }

  /* Tooltip on bottom */
  .range--tooltip-bottom .range__tooltip {
    bottom: calc(-1 * var(--thumb-size) - var(--tooltip-offset));
  }

  .range--tooltip-bottom .range__tooltip:after {
    border-bottom: var(--sl-tooltip-arrow-size) solid var(--sl-tooltip-background-color);
    border-left: var(--sl-tooltip-arrow-size) solid transparent;
    border-right: var(--sl-tooltip-arrow-size) solid transparent;
    bottom: 100%;
  }

  @media (forced-colors: active) {
    .range__control,
    .range__tooltip {
      border: solid 1px transparent;
    }

    .range__control::-webkit-slider-thumb {
      border: solid 1px transparent;
    }

    .range__control::-moz-range-thumb {
      border: solid 1px transparent;
    }

    .range__tooltip:after {
      display: none;
    }
  }
`;

// node_modules/@shoelace-style/shoelace/dist/chunks/chunk.GI7VDIWX.js
var defaultValue = (propertyName = "value") => (proto2, key) => {
  const ctor = proto2.constructor;
  const attributeChangedCallback = ctor.prototype.attributeChangedCallback;
  ctor.prototype.attributeChangedCallback = function(name, old, value) {
    var _a9;
    const options = ctor.getPropertyOptions(propertyName);
    const attributeName = typeof options.attribute === "string" ? options.attribute : propertyName;
    if (name === attributeName) {
      const converter = options.converter || u;
      const fromAttribute = typeof converter === "function" ? converter : (_a9 = converter == null ? void 0 : converter.fromAttribute) != null ? _a9 : u.fromAttribute;
      const newValue = fromAttribute(value, options.type);
      if (this[propertyName] !== newValue) {
        this[key] = newValue;
      }
    }
    attributeChangedCallback.call(this, name, old, value);
  };
};

// node_modules/@shoelace-style/shoelace/dist/chunks/chunk.SI4ACBFK.js
var form_control_styles_default = i`
  .form-control .form-control__label {
    display: none;
  }

  .form-control .form-control__help-text {
    display: none;
  }

  /* Label */
  .form-control--has-label .form-control__label {
    display: inline-block;
    color: var(--sl-input-label-color);
    margin-bottom: var(--sl-spacing-3x-small);
  }

  .form-control--has-label.form-control--small .form-control__label {
    font-size: var(--sl-input-label-font-size-small);
  }

  .form-control--has-label.form-control--medium .form-control__label {
    font-size: var(--sl-input-label-font-size-medium);
  }

  .form-control--has-label.form-control--large .form-control__label {
    font-size: var(--sl-input-label-font-size-large);
  }

  :host([required]) .form-control--has-label .form-control__label::after {
    content: var(--sl-input-required-content);
    margin-inline-start: var(--sl-input-required-content-offset);
    color: var(--sl-input-required-content-color);
  }

  /* Help text */
  .form-control--has-help-text .form-control__help-text {
    display: block;
    color: var(--sl-input-help-text-color);
    margin-top: var(--sl-spacing-3x-small);
  }

  .form-control--has-help-text.form-control--small .form-control__help-text {
    font-size: var(--sl-input-help-text-font-size-small);
  }

  .form-control--has-help-text.form-control--medium .form-control__help-text {
    font-size: var(--sl-input-help-text-font-size-medium);
  }

  .form-control--has-help-text.form-control--large .form-control__help-text {
    font-size: var(--sl-input-help-text-font-size-large);
  }

  .form-control--has-help-text.form-control--radio-group .form-control__help-text {
    margin-top: var(--sl-spacing-2x-small);
  }
`;

// node_modules/@shoelace-style/shoelace/dist/chunks/chunk.KWPBDQ6I.js
var formCollections = /* @__PURE__ */ new WeakMap();
var reportValidityOverloads = /* @__PURE__ */ new WeakMap();
var checkValidityOverloads = /* @__PURE__ */ new WeakMap();
var userInteractedControls = /* @__PURE__ */ new WeakSet();
var interactions = /* @__PURE__ */ new WeakMap();
var FormControlController = class {
  constructor(host, options) {
    this.handleFormData = (event2) => {
      const disabled = this.options.disabled(this.host);
      const name = this.options.name(this.host);
      const value = this.options.value(this.host);
      const isButton = this.host.tagName.toLowerCase() === "sl-button";
      if (this.host.isConnected && !disabled && !isButton && typeof name === "string" && name.length > 0 && typeof value !== "undefined") {
        if (Array.isArray(value)) {
          value.forEach((val) => {
            event2.formData.append(name, val.toString());
          });
        } else {
          event2.formData.append(name, value.toString());
        }
      }
    };
    this.handleFormSubmit = (event2) => {
      var _a9;
      const disabled = this.options.disabled(this.host);
      const reportValidity = this.options.reportValidity;
      if (this.form && !this.form.noValidate) {
        (_a9 = formCollections.get(this.form)) == null ? void 0 : _a9.forEach((control) => {
          this.setUserInteracted(control, true);
        });
      }
      if (this.form && !this.form.noValidate && !disabled && !reportValidity(this.host)) {
        event2.preventDefault();
        event2.stopImmediatePropagation();
      }
    };
    this.handleFormReset = () => {
      this.options.setValue(this.host, this.options.defaultValue(this.host));
      this.setUserInteracted(this.host, false);
      interactions.set(this.host, []);
    };
    this.handleInteraction = (event2) => {
      const emittedEvents = interactions.get(this.host);
      if (!emittedEvents.includes(event2.type)) {
        emittedEvents.push(event2.type);
      }
      if (emittedEvents.length === this.options.assumeInteractionOn.length) {
        this.setUserInteracted(this.host, true);
      }
    };
    this.checkFormValidity = () => {
      if (this.form && !this.form.noValidate) {
        const elements = this.form.querySelectorAll("*");
        for (const element of elements) {
          if (typeof element.checkValidity === "function") {
            if (!element.checkValidity()) {
              return false;
            }
          }
        }
      }
      return true;
    };
    this.reportFormValidity = () => {
      if (this.form && !this.form.noValidate) {
        const elements = this.form.querySelectorAll("*");
        for (const element of elements) {
          if (typeof element.reportValidity === "function") {
            if (!element.reportValidity()) {
              return false;
            }
          }
        }
      }
      return true;
    };
    (this.host = host).addController(this);
    this.options = __spreadValues2({
      form: (input) => {
        const formId = input.form;
        if (formId) {
          const root = input.getRootNode();
          const form = root.querySelector(`#${formId}`);
          if (form) {
            return form;
          }
        }
        return input.closest("form");
      },
      name: (input) => input.name,
      value: (input) => input.value,
      defaultValue: (input) => input.defaultValue,
      disabled: (input) => {
        var _a9;
        return (_a9 = input.disabled) != null ? _a9 : false;
      },
      reportValidity: (input) => typeof input.reportValidity === "function" ? input.reportValidity() : true,
      checkValidity: (input) => typeof input.checkValidity === "function" ? input.checkValidity() : true,
      setValue: (input, value) => input.value = value,
      assumeInteractionOn: ["sl-input"]
    }, options);
  }
  hostConnected() {
    const form = this.options.form(this.host);
    if (form) {
      this.attachForm(form);
    }
    interactions.set(this.host, []);
    this.options.assumeInteractionOn.forEach((event2) => {
      this.host.addEventListener(event2, this.handleInteraction);
    });
  }
  hostDisconnected() {
    this.detachForm();
    interactions.delete(this.host);
    this.options.assumeInteractionOn.forEach((event2) => {
      this.host.removeEventListener(event2, this.handleInteraction);
    });
  }
  hostUpdated() {
    const form = this.options.form(this.host);
    if (!form) {
      this.detachForm();
    }
    if (form && this.form !== form) {
      this.detachForm();
      this.attachForm(form);
    }
    if (this.host.hasUpdated) {
      this.setValidity(this.host.validity.valid);
    }
  }
  attachForm(form) {
    if (form) {
      this.form = form;
      if (formCollections.has(this.form)) {
        formCollections.get(this.form).add(this.host);
      } else {
        formCollections.set(this.form, /* @__PURE__ */ new Set([this.host]));
      }
      this.form.addEventListener("formdata", this.handleFormData);
      this.form.addEventListener("submit", this.handleFormSubmit);
      this.form.addEventListener("reset", this.handleFormReset);
      if (!reportValidityOverloads.has(this.form)) {
        reportValidityOverloads.set(this.form, this.form.reportValidity);
        this.form.reportValidity = () => this.reportFormValidity();
      }
      if (!checkValidityOverloads.has(this.form)) {
        checkValidityOverloads.set(this.form, this.form.checkValidity);
        this.form.checkValidity = () => this.checkFormValidity();
      }
    } else {
      this.form = void 0;
    }
  }
  detachForm() {
    if (!this.form)
      return;
    const formCollection = formCollections.get(this.form);
    if (!formCollection) {
      return;
    }
    formCollection.delete(this.host);
    if (formCollection.size <= 0) {
      this.form.removeEventListener("formdata", this.handleFormData);
      this.form.removeEventListener("submit", this.handleFormSubmit);
      this.form.removeEventListener("reset", this.handleFormReset);
      if (reportValidityOverloads.has(this.form)) {
        this.form.reportValidity = reportValidityOverloads.get(this.form);
        reportValidityOverloads.delete(this.form);
      }
      if (checkValidityOverloads.has(this.form)) {
        this.form.checkValidity = checkValidityOverloads.get(this.form);
        checkValidityOverloads.delete(this.form);
      }
      this.form = void 0;
    }
  }
  setUserInteracted(el, hasInteracted) {
    if (hasInteracted) {
      userInteractedControls.add(el);
    } else {
      userInteractedControls.delete(el);
    }
    el.requestUpdate();
  }
  doAction(type, submitter) {
    if (this.form) {
      const button = document.createElement("button");
      button.type = type;
      button.style.position = "absolute";
      button.style.width = "0";
      button.style.height = "0";
      button.style.clipPath = "inset(50%)";
      button.style.overflow = "hidden";
      button.style.whiteSpace = "nowrap";
      if (submitter) {
        button.name = submitter.name;
        button.value = submitter.value;
        ["formaction", "formenctype", "formmethod", "formnovalidate", "formtarget"].forEach((attr) => {
          if (submitter.hasAttribute(attr)) {
            button.setAttribute(attr, submitter.getAttribute(attr));
          }
        });
      }
      this.form.append(button);
      button.click();
      button.remove();
    }
  }
  /** Returns the associated `<form>` element, if one exists. */
  getForm() {
    var _a9;
    return (_a9 = this.form) != null ? _a9 : null;
  }
  /** Resets the form, restoring all the control to their default value */
  reset(submitter) {
    this.doAction("reset", submitter);
  }
  /** Submits the form, triggering validation and form data injection. */
  submit(submitter) {
    this.doAction("submit", submitter);
  }
  /**
   * Synchronously sets the form control's validity. Call this when you know the future validity but need to update
   * the host element immediately, i.e. before Lit updates the component in the next update.
   */
  setValidity(isValid3) {
    const host = this.host;
    const hasInteracted = Boolean(userInteractedControls.has(host));
    const required = Boolean(host.required);
    host.toggleAttribute("data-required", required);
    host.toggleAttribute("data-optional", !required);
    host.toggleAttribute("data-invalid", !isValid3);
    host.toggleAttribute("data-valid", isValid3);
    host.toggleAttribute("data-user-invalid", !isValid3 && hasInteracted);
    host.toggleAttribute("data-user-valid", isValid3 && hasInteracted);
  }
  /**
   * Updates the form control's validity based on the current value of `host.validity.valid`. Call this when anything
   * that affects constraint validation changes so the component receives the correct validity states.
   */
  updateValidity() {
    const host = this.host;
    this.setValidity(host.validity.valid);
  }
  /**
   * Dispatches a non-bubbling, cancelable custom event of type `sl-invalid`.
   * If the `sl-invalid` event will be cancelled then the original `invalid`
   * event (which may have been passed as argument) will also be cancelled.
   * If no original `invalid` event has been passed then the `sl-invalid`
   * event will be cancelled before being dispatched.
   */
  emitInvalidEvent(originalInvalidEvent) {
    const slInvalidEvent = new CustomEvent("sl-invalid", {
      bubbles: false,
      composed: false,
      cancelable: true,
      detail: {}
    });
    if (!originalInvalidEvent) {
      slInvalidEvent.preventDefault();
    }
    if (!this.host.dispatchEvent(slInvalidEvent)) {
      originalInvalidEvent == null ? void 0 : originalInvalidEvent.preventDefault();
    }
  }
};
var validValidityState = Object.freeze({
  badInput: false,
  customError: false,
  patternMismatch: false,
  rangeOverflow: false,
  rangeUnderflow: false,
  stepMismatch: false,
  tooLong: false,
  tooShort: false,
  typeMismatch: false,
  valid: true,
  valueMissing: false
});
var valueMissingValidityState = Object.freeze(__spreadProps2(__spreadValues2({}, validValidityState), {
  valid: false,
  valueMissing: true
}));
var customErrorValidityState = Object.freeze(__spreadProps2(__spreadValues2({}, validValidityState), {
  valid: false,
  customError: true
}));

// node_modules/@shoelace-style/localize/dist/index.js
var connectedElements = /* @__PURE__ */ new Set();
var documentElementObserver = new MutationObserver(update);
var translations = /* @__PURE__ */ new Map();
var documentDirection = document.documentElement.dir || "ltr";
var documentLanguage = document.documentElement.lang || navigator.language;
var fallback;
documentElementObserver.observe(document.documentElement, {
  attributes: true,
  attributeFilter: ["dir", "lang"]
});
function registerTranslation(...translation2) {
  translation2.map((t9) => {
    const code = t9.$code.toLowerCase();
    if (translations.has(code)) {
      translations.set(code, Object.assign(Object.assign({}, translations.get(code)), t9));
    } else {
      translations.set(code, t9);
    }
    if (!fallback) {
      fallback = t9;
    }
  });
  update();
}
function update() {
  documentDirection = document.documentElement.dir || "ltr";
  documentLanguage = document.documentElement.lang || navigator.language;
  [...connectedElements.keys()].map((el) => {
    if (typeof el.requestUpdate === "function") {
      el.requestUpdate();
    }
  });
}
var LocalizeController = class {
  constructor(host) {
    this.host = host;
    this.host.addController(this);
  }
  hostConnected() {
    connectedElements.add(this.host);
  }
  hostDisconnected() {
    connectedElements.delete(this.host);
  }
  dir() {
    return `${this.host.dir || documentDirection}`.toLowerCase();
  }
  lang() {
    return `${this.host.lang || documentLanguage}`.toLowerCase();
  }
  getTranslationData(lang) {
    var _a9, _b2;
    const locale = new Intl.Locale(lang.replace(/_/g, "-"));
    const language = locale === null || locale === void 0 ? void 0 : locale.language.toLowerCase();
    const region = (_b2 = (_a9 = locale === null || locale === void 0 ? void 0 : locale.region) === null || _a9 === void 0 ? void 0 : _a9.toLowerCase()) !== null && _b2 !== void 0 ? _b2 : "";
    const primary = translations.get(`${language}-${region}`);
    const secondary = translations.get(language);
    return { locale, language, region, primary, secondary };
  }
  exists(key, options) {
    var _a9;
    const { primary, secondary } = this.getTranslationData((_a9 = options.lang) !== null && _a9 !== void 0 ? _a9 : this.lang());
    options = Object.assign({ includeFallback: false }, options);
    if (primary && primary[key] || secondary && secondary[key] || options.includeFallback && fallback && fallback[key]) {
      return true;
    }
    return false;
  }
  term(key, ...args) {
    const { primary, secondary } = this.getTranslationData(this.lang());
    let term;
    if (primary && primary[key]) {
      term = primary[key];
    } else if (secondary && secondary[key]) {
      term = secondary[key];
    } else if (fallback && fallback[key]) {
      term = fallback[key];
    } else {
      console.error(`No translation found for: ${String(key)}`);
      return String(key);
    }
    if (typeof term === "function") {
      return term(...args);
    }
    return term;
  }
  date(dateToFormat, options) {
    dateToFormat = new Date(dateToFormat);
    return new Intl.DateTimeFormat(this.lang(), options).format(dateToFormat);
  }
  number(numberToFormat, options) {
    numberToFormat = Number(numberToFormat);
    return isNaN(numberToFormat) ? "" : new Intl.NumberFormat(this.lang(), options).format(numberToFormat);
  }
  relativeTime(value, unit, options) {
    return new Intl.RelativeTimeFormat(this.lang(), options).format(value, unit);
  }
};

// node_modules/@shoelace-style/shoelace/dist/chunks/chunk.MAS2SHYD.js
var translation = {
  $code: "en",
  $name: "English",
  $dir: "ltr",
  carousel: "Carousel",
  clearEntry: "Clear entry",
  close: "Close",
  copied: "Copied",
  copy: "Copy",
  currentValue: "Current value",
  error: "Error",
  goToSlide: (slide, count) => `Go to slide ${slide} of ${count}`,
  hidePassword: "Hide password",
  loading: "Loading",
  nextSlide: "Next slide",
  numOptionsSelected: (num) => {
    if (num === 0)
      return "No options selected";
    if (num === 1)
      return "1 option selected";
    return `${num} options selected`;
  },
  previousSlide: "Previous slide",
  progress: "Progress",
  remove: "Remove",
  resize: "Resize",
  scrollToEnd: "Scroll to end",
  scrollToStart: "Scroll to start",
  selectAColorFromTheScreen: "Select a color from the screen",
  showPassword: "Show password",
  slideNum: (slide) => `Slide ${slide}`,
  toggleColorFormat: "Toggle color format"
};
registerTranslation(translation);
var en_default = translation;

// node_modules/@shoelace-style/shoelace/dist/chunks/chunk.WLV3FVBR.js
var LocalizeController2 = class extends LocalizeController {
};
registerTranslation(en_default);

// node_modules/@shoelace-style/shoelace/dist/chunks/chunk.2FB5TK5H.js
function watch(propertyName, options) {
  const resolvedOptions = __spreadValues2({
    waitUntilFirstUpdate: false
  }, options);
  return (proto2, decoratedFnName) => {
    const { update: update2 } = proto2;
    const watchedProperties = Array.isArray(propertyName) ? propertyName : [propertyName];
    proto2.update = function(changedProps) {
      watchedProperties.forEach((property) => {
        const key = property;
        if (changedProps.has(key)) {
          const oldValue = changedProps.get(key);
          const newValue = this[key];
          if (oldValue !== newValue) {
            if (!resolvedOptions.waitUntilFirstUpdate || this.hasUpdated) {
              this[decoratedFnName](oldValue, newValue);
            }
          }
        }
      });
      update2.call(this, changedProps);
    };
  };
}

// node_modules/lit-html/directives/if-defined.js
var o5 = (o11) => o11 != null ? o11 : T;

// node_modules/lit-html/directive-helpers.js
var { I: t6 } = z;
var e8 = (o11, t9) => void 0 === t9 ? void 0 !== (o11 == null ? void 0 : o11._$litType$) : (o11 == null ? void 0 : o11._$litType$) === t9;
var f3 = (o11) => void 0 === o11.strings;
var u3 = {};
var m2 = (o11, t9 = u3) => o11._$AH = t9;

// node_modules/lit-html/directives/live.js
var l3 = e6(class extends i4 {
  constructor(r9) {
    if (super(r9), r9.type !== t5.PROPERTY && r9.type !== t5.ATTRIBUTE && r9.type !== t5.BOOLEAN_ATTRIBUTE) throw Error("The `live` directive is not allowed on child or event bindings");
    if (!f3(r9)) throw Error("`live` bindings can only contain a single expression");
  }
  render(r9) {
    return r9;
  }
  update(i6, [t9]) {
    if (t9 === w || t9 === T) return t9;
    const o11 = i6.element, l5 = i6.name;
    if (i6.type === t5.PROPERTY) {
      if (t9 === o11[l5]) return w;
    } else if (i6.type === t5.BOOLEAN_ATTRIBUTE) {
      if (!!t9 === o11.hasAttribute(l5)) return w;
    } else if (i6.type === t5.ATTRIBUTE && o11.getAttribute(l5) === t9 + "") return w;
    return m2(i6), t9;
  }
});

// node_modules/@shoelace-style/shoelace/dist/chunks/chunk.JQPSQVKQ.js
var SlRange = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.formControlController = new FormControlController(this);
    this.hasSlotController = new HasSlotController(this, "help-text", "label");
    this.localize = new LocalizeController2(this);
    this.hasFocus = false;
    this.hasTooltip = false;
    this.title = "";
    this.name = "";
    this.value = 0;
    this.label = "";
    this.helpText = "";
    this.disabled = false;
    this.min = 0;
    this.max = 100;
    this.step = 1;
    this.tooltip = "top";
    this.tooltipFormatter = (value) => value.toString();
    this.form = "";
    this.defaultValue = 0;
  }
  /** Gets the validity state object */
  get validity() {
    return this.input.validity;
  }
  /** Gets the validation message */
  get validationMessage() {
    return this.input.validationMessage;
  }
  connectedCallback() {
    super.connectedCallback();
    this.resizeObserver = new ResizeObserver(() => this.syncRange());
    if (this.value < this.min) {
      this.value = this.min;
    }
    if (this.value > this.max) {
      this.value = this.max;
    }
    this.updateComplete.then(() => {
      this.syncRange();
      this.resizeObserver.observe(this.input);
    });
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.resizeObserver.unobserve(this.input);
  }
  handleChange() {
    this.emit("sl-change");
  }
  handleInput() {
    this.value = parseFloat(this.input.value);
    this.emit("sl-input");
    this.syncRange();
  }
  handleBlur() {
    this.hasFocus = false;
    this.hasTooltip = false;
    this.emit("sl-blur");
  }
  handleFocus() {
    this.hasFocus = true;
    this.hasTooltip = true;
    this.emit("sl-focus");
  }
  handleThumbDragStart() {
    this.hasTooltip = true;
  }
  handleThumbDragEnd() {
    this.hasTooltip = false;
  }
  syncProgress(percent) {
    this.input.style.setProperty("--percent", `${percent * 100}%`);
  }
  syncTooltip(percent) {
    if (this.output !== null) {
      const inputWidth = this.input.offsetWidth;
      const tooltipWidth = this.output.offsetWidth;
      const thumbSize = getComputedStyle(this.input).getPropertyValue("--thumb-size");
      const isRtl = this.localize.dir() === "rtl";
      const percentAsWidth = inputWidth * percent;
      if (isRtl) {
        const x2 = `${inputWidth - percentAsWidth}px + ${percent} * ${thumbSize}`;
        this.output.style.translate = `calc((${x2} - ${tooltipWidth / 2}px - ${thumbSize} / 2))`;
      } else {
        const x2 = `${percentAsWidth}px - ${percent} * ${thumbSize}`;
        this.output.style.translate = `calc(${x2} - ${tooltipWidth / 2}px + ${thumbSize} / 2)`;
      }
    }
  }
  handleValueChange() {
    this.formControlController.updateValidity();
    this.input.value = this.value.toString();
    this.value = parseFloat(this.input.value);
    this.syncRange();
  }
  handleDisabledChange() {
    this.formControlController.setValidity(this.disabled);
  }
  syncRange() {
    const percent = Math.max(0, (this.value - this.min) / (this.max - this.min));
    this.syncProgress(percent);
    if (this.tooltip !== "none") {
      this.updateComplete.then(() => this.syncTooltip(percent));
    }
  }
  handleInvalid(event2) {
    this.formControlController.setValidity(false);
    this.formControlController.emitInvalidEvent(event2);
  }
  /** Sets focus on the range. */
  focus(options) {
    this.input.focus(options);
  }
  /** Removes focus from the range. */
  blur() {
    this.input.blur();
  }
  /** Increments the value of the range by the value of the step attribute. */
  stepUp() {
    this.input.stepUp();
    if (this.value !== Number(this.input.value)) {
      this.value = Number(this.input.value);
    }
  }
  /** Decrements the value of the range by the value of the step attribute. */
  stepDown() {
    this.input.stepDown();
    if (this.value !== Number(this.input.value)) {
      this.value = Number(this.input.value);
    }
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    return this.input.checkValidity();
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    return this.input.reportValidity();
  }
  /** Sets a custom validation message. Pass an empty string to restore validity. */
  setCustomValidity(message) {
    this.input.setCustomValidity(message);
    this.formControlController.updateValidity();
  }
  render() {
    const hasLabelSlot = this.hasSlotController.test("label");
    const hasHelpTextSlot = this.hasSlotController.test("help-text");
    const hasLabel = this.label ? true : !!hasLabelSlot;
    const hasHelpText = this.helpText ? true : !!hasHelpTextSlot;
    return x`
      <div
        part="form-control"
        class=${e7({
      "form-control": true,
      "form-control--medium": true,
      // range only has one size
      "form-control--has-label": hasLabel,
      "form-control--has-help-text": hasHelpText
    })}
      >
        <label
          part="form-control-label"
          class="form-control__label"
          for="input"
          aria-hidden=${hasLabel ? "false" : "true"}
        >
          <slot name="label">${this.label}</slot>
        </label>

        <div part="form-control-input" class="form-control-input">
          <div
            part="base"
            class=${e7({
      range: true,
      "range--disabled": this.disabled,
      "range--focused": this.hasFocus,
      "range--rtl": this.localize.dir() === "rtl",
      "range--tooltip-visible": this.hasTooltip,
      "range--tooltip-top": this.tooltip === "top",
      "range--tooltip-bottom": this.tooltip === "bottom"
    })}
            @mousedown=${this.handleThumbDragStart}
            @mouseup=${this.handleThumbDragEnd}
            @touchstart=${this.handleThumbDragStart}
            @touchend=${this.handleThumbDragEnd}
          >
            <input
              part="input"
              id="input"
              class="range__control"
              title=${this.title}
              type="range"
              name=${o5(this.name)}
              ?disabled=${this.disabled}
              min=${o5(this.min)}
              max=${o5(this.max)}
              step=${o5(this.step)}
              .value=${l3(this.value.toString())}
              aria-describedby="help-text"
              @change=${this.handleChange}
              @focus=${this.handleFocus}
              @input=${this.handleInput}
              @invalid=${this.handleInvalid}
              @blur=${this.handleBlur}
            />
            ${this.tooltip !== "none" && !this.disabled ? x`
                  <output part="tooltip" class="range__tooltip">
                    ${typeof this.tooltipFormatter === "function" ? this.tooltipFormatter(this.value) : this.value}
                  </output>
                ` : ""}
          </div>
        </div>

        <div
          part="form-control-help-text"
          id="help-text"
          class="form-control__help-text"
          aria-hidden=${hasHelpText ? "false" : "true"}
        >
          <slot name="help-text">${this.helpText}</slot>
        </div>
      </div>
    `;
  }
};
SlRange.styles = [component_styles_default, form_control_styles_default, range_styles_default];
__decorateClass([
  e5(".range__control")
], SlRange.prototype, "input", 2);
__decorateClass([
  e5(".range__tooltip")
], SlRange.prototype, "output", 2);
__decorateClass([
  r6()
], SlRange.prototype, "hasFocus", 2);
__decorateClass([
  r6()
], SlRange.prototype, "hasTooltip", 2);
__decorateClass([
  n4()
], SlRange.prototype, "title", 2);
__decorateClass([
  n4()
], SlRange.prototype, "name", 2);
__decorateClass([
  n4({ type: Number })
], SlRange.prototype, "value", 2);
__decorateClass([
  n4()
], SlRange.prototype, "label", 2);
__decorateClass([
  n4({ attribute: "help-text" })
], SlRange.prototype, "helpText", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlRange.prototype, "disabled", 2);
__decorateClass([
  n4({ type: Number })
], SlRange.prototype, "min", 2);
__decorateClass([
  n4({ type: Number })
], SlRange.prototype, "max", 2);
__decorateClass([
  n4({ type: Number })
], SlRange.prototype, "step", 2);
__decorateClass([
  n4()
], SlRange.prototype, "tooltip", 2);
__decorateClass([
  n4({ attribute: false })
], SlRange.prototype, "tooltipFormatter", 2);
__decorateClass([
  n4({ reflect: true })
], SlRange.prototype, "form", 2);
__decorateClass([
  defaultValue()
], SlRange.prototype, "defaultValue", 2);
__decorateClass([
  t4({ passive: true })
], SlRange.prototype, "handleThumbDragStart", 1);
__decorateClass([
  watch("value", { waitUntilFirstUpdate: true })
], SlRange.prototype, "handleValueChange", 1);
__decorateClass([
  watch("disabled", { waitUntilFirstUpdate: true })
], SlRange.prototype, "handleDisabledChange", 1);
__decorateClass([
  watch("hasTooltip", { waitUntilFirstUpdate: true })
], SlRange.prototype, "syncRange", 1);

// node_modules/@shoelace-style/shoelace/dist/chunks/chunk.77REMD4E.js
SlRange.define("sl-range");

// node_modules/@shoelace-style/shoelace/dist/chunks/chunk.V2OL7VMD.js
var tag_styles_default = i`
  :host {
    display: inline-block;
  }

  .tag {
    display: flex;
    align-items: center;
    border: solid 1px;
    line-height: 1;
    white-space: nowrap;
    user-select: none;
    -webkit-user-select: none;
  }

  .tag__remove::part(base) {
    color: inherit;
    padding: 0;
  }

  /*
   * Variant modifiers
   */

  .tag--primary {
    background-color: var(--sl-color-primary-50);
    border-color: var(--sl-color-primary-200);
    color: var(--sl-color-primary-800);
  }

  .tag--primary:active > sl-icon-button {
    color: var(--sl-color-primary-600);
  }

  .tag--success {
    background-color: var(--sl-color-success-50);
    border-color: var(--sl-color-success-200);
    color: var(--sl-color-success-800);
  }

  .tag--success:active > sl-icon-button {
    color: var(--sl-color-success-600);
  }

  .tag--neutral {
    background-color: var(--sl-color-neutral-50);
    border-color: var(--sl-color-neutral-200);
    color: var(--sl-color-neutral-800);
  }

  .tag--neutral:active > sl-icon-button {
    color: var(--sl-color-neutral-600);
  }

  .tag--warning {
    background-color: var(--sl-color-warning-50);
    border-color: var(--sl-color-warning-200);
    color: var(--sl-color-warning-800);
  }

  .tag--warning:active > sl-icon-button {
    color: var(--sl-color-warning-600);
  }

  .tag--danger {
    background-color: var(--sl-color-danger-50);
    border-color: var(--sl-color-danger-200);
    color: var(--sl-color-danger-800);
  }

  .tag--danger:active > sl-icon-button {
    color: var(--sl-color-danger-600);
  }

  /*
   * Size modifiers
   */

  .tag--small {
    font-size: var(--sl-button-font-size-small);
    height: calc(var(--sl-input-height-small) * 0.8);
    line-height: calc(var(--sl-input-height-small) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-small);
    padding: 0 var(--sl-spacing-x-small);
  }

  .tag--medium {
    font-size: var(--sl-button-font-size-medium);
    height: calc(var(--sl-input-height-medium) * 0.8);
    line-height: calc(var(--sl-input-height-medium) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-medium);
    padding: 0 var(--sl-spacing-small);
  }

  .tag--large {
    font-size: var(--sl-button-font-size-large);
    height: calc(var(--sl-input-height-large) * 0.8);
    line-height: calc(var(--sl-input-height-large) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-large);
    padding: 0 var(--sl-spacing-medium);
  }

  .tag__remove {
    margin-inline-start: var(--sl-spacing-x-small);
  }

  /*
   * Pill modifier
   */

  .tag--pill {
    border-radius: var(--sl-border-radius-pill);
  }
`;

// node_modules/@shoelace-style/shoelace/dist/chunks/chunk.6I2T3DLI.js
var icon_button_styles_default = i`
  :host {
    display: inline-block;
    color: var(--sl-color-neutral-600);
  }

  .icon-button {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    background: none;
    border: none;
    border-radius: var(--sl-border-radius-medium);
    font-size: inherit;
    color: inherit;
    padding: var(--sl-spacing-x-small);
    cursor: pointer;
    transition: var(--sl-transition-x-fast) color;
    -webkit-appearance: none;
  }

  .icon-button:hover:not(.icon-button--disabled),
  .icon-button:focus-visible:not(.icon-button--disabled) {
    color: var(--sl-color-primary-600);
  }

  .icon-button:active:not(.icon-button--disabled) {
    color: var(--sl-color-primary-700);
  }

  .icon-button:focus {
    outline: none;
  }

  .icon-button--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .icon-button:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .icon-button__icon {
    pointer-events: none;
  }
`;

// node_modules/@shoelace-style/shoelace/dist/chunks/chunk.QLXRCYS4.js
var icon_styles_default = i`
  :host {
    display: inline-block;
    width: 1em;
    height: 1em;
    box-sizing: content-box !important;
  }

  svg {
    display: block;
    height: 100%;
    width: 100%;
  }
`;

// node_modules/@shoelace-style/shoelace/dist/chunks/chunk.3Y6SB6QS.js
var basePath = "";
function setBasePath(path) {
  basePath = path;
}
function getBasePath(subpath = "") {
  if (!basePath) {
    const scripts = [...document.getElementsByTagName("script")];
    const configScript = scripts.find((script) => script.hasAttribute("data-shoelace"));
    if (configScript) {
      setBasePath(configScript.getAttribute("data-shoelace"));
    } else {
      const fallbackScript = scripts.find((s9) => {
        return /shoelace(\.min)?\.js($|\?)/.test(s9.src) || /shoelace-autoloader(\.min)?\.js($|\?)/.test(s9.src);
      });
      let path = "";
      if (fallbackScript) {
        path = fallbackScript.getAttribute("src");
      }
      setBasePath(path.split("/").slice(0, -1).join("/"));
    }
  }
  return basePath.replace(/\/$/, "") + (subpath ? `/${subpath.replace(/^\//, "")}` : ``);
}

// node_modules/@shoelace-style/shoelace/dist/chunks/chunk.P7ZG6EMR.js
var library = {
  name: "default",
  resolver: (name) => getBasePath(`assets/icons/${name}.svg`)
};
var library_default_default = library;

// node_modules/@shoelace-style/shoelace/dist/chunks/chunk.3TFKS637.js
var icons = {
  caret: `
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <polyline points="6 9 12 15 18 9"></polyline>
    </svg>
  `,
  check: `
    <svg part="checked-icon" class="checkbox__icon" viewBox="0 0 16 16">
      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" stroke-linecap="round">
        <g stroke="currentColor">
          <g transform="translate(3.428571, 3.428571)">
            <path d="M0,5.71428571 L3.42857143,9.14285714"></path>
            <path d="M9.14285714,0 L3.42857143,9.14285714"></path>
          </g>
        </g>
      </g>
    </svg>
  `,
  "chevron-down": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-down" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z"/>
    </svg>
  `,
  "chevron-left": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-left" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M11.354 1.646a.5.5 0 0 1 0 .708L5.707 8l5.647 5.646a.5.5 0 0 1-.708.708l-6-6a.5.5 0 0 1 0-.708l6-6a.5.5 0 0 1 .708 0z"/>
    </svg>
  `,
  "chevron-right": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-right" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z"/>
    </svg>
  `,
  copy: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-copy" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M4 2a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V2Zm2-1a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1H6ZM2 5a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1v-1h1v1a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h1v1H2Z"/>
    </svg>
  `,
  eye: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eye" viewBox="0 0 16 16">
      <path d="M16 8s-3-5.5-8-5.5S0 8 0 8s3 5.5 8 5.5S16 8 16 8zM1.173 8a13.133 13.133 0 0 1 1.66-2.043C4.12 4.668 5.88 3.5 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.133 13.133 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755C11.879 11.332 10.119 12.5 8 12.5c-2.12 0-3.879-1.168-5.168-2.457A13.134 13.134 0 0 1 1.172 8z"/>
      <path d="M8 5.5a2.5 2.5 0 1 0 0 5 2.5 2.5 0 0 0 0-5zM4.5 8a3.5 3.5 0 1 1 7 0 3.5 3.5 0 0 1-7 0z"/>
    </svg>
  `,
  "eye-slash": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eye-slash" viewBox="0 0 16 16">
      <path d="M13.359 11.238C15.06 9.72 16 8 16 8s-3-5.5-8-5.5a7.028 7.028 0 0 0-2.79.588l.77.771A5.944 5.944 0 0 1 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.134 13.134 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755-.165.165-.337.328-.517.486l.708.709z"/>
      <path d="M11.297 9.176a3.5 3.5 0 0 0-4.474-4.474l.823.823a2.5 2.5 0 0 1 2.829 2.829l.822.822zm-2.943 1.299.822.822a3.5 3.5 0 0 1-4.474-4.474l.823.823a2.5 2.5 0 0 0 2.829 2.829z"/>
      <path d="M3.35 5.47c-.18.16-.353.322-.518.487A13.134 13.134 0 0 0 1.172 8l.195.288c.335.48.83 1.12 1.465 1.755C4.121 11.332 5.881 12.5 8 12.5c.716 0 1.39-.133 2.02-.36l.77.772A7.029 7.029 0 0 1 8 13.5C3 13.5 0 8 0 8s.939-1.721 2.641-3.238l.708.709zm10.296 8.884-12-12 .708-.708 12 12-.708.708z"/>
    </svg>
  `,
  eyedropper: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eyedropper" viewBox="0 0 16 16">
      <path d="M13.354.646a1.207 1.207 0 0 0-1.708 0L8.5 3.793l-.646-.647a.5.5 0 1 0-.708.708L8.293 5l-7.147 7.146A.5.5 0 0 0 1 12.5v1.793l-.854.853a.5.5 0 1 0 .708.707L1.707 15H3.5a.5.5 0 0 0 .354-.146L11 7.707l1.146 1.147a.5.5 0 0 0 .708-.708l-.647-.646 3.147-3.146a1.207 1.207 0 0 0 0-1.708l-2-2zM2 12.707l7-7L10.293 7l-7 7H2v-1.293z"></path>
    </svg>
  `,
  "grip-vertical": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-grip-vertical" viewBox="0 0 16 16">
      <path d="M7 2a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zM7 5a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zM7 8a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm-3 3a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm-3 3a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0z"></path>
    </svg>
  `,
  indeterminate: `
    <svg part="indeterminate-icon" class="checkbox__icon" viewBox="0 0 16 16">
      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" stroke-linecap="round">
        <g stroke="currentColor" stroke-width="2">
          <g transform="translate(2.285714, 6.857143)">
            <path d="M10.2857143,1.14285714 L1.14285714,1.14285714"></path>
          </g>
        </g>
      </g>
    </svg>
  `,
  "person-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-person-fill" viewBox="0 0 16 16">
      <path d="M3 14s-1 0-1-1 1-4 6-4 6 3 6 4-1 1-1 1H3zm5-6a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"/>
    </svg>
  `,
  "play-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-play-fill" viewBox="0 0 16 16">
      <path d="m11.596 8.697-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"></path>
    </svg>
  `,
  "pause-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-pause-fill" viewBox="0 0 16 16">
      <path d="M5.5 3.5A1.5 1.5 0 0 1 7 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5zm5 0A1.5 1.5 0 0 1 12 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5z"></path>
    </svg>
  `,
  radio: `
    <svg part="checked-icon" class="radio__icon" viewBox="0 0 16 16">
      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g fill="currentColor">
          <circle cx="8" cy="8" r="3.42857143"></circle>
        </g>
      </g>
    </svg>
  `,
  "star-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-star-fill" viewBox="0 0 16 16">
      <path d="M3.612 15.443c-.386.198-.824-.149-.746-.592l.83-4.73L.173 6.765c-.329-.314-.158-.888.283-.95l4.898-.696L7.538.792c.197-.39.73-.39.927 0l2.184 4.327 4.898.696c.441.062.612.636.282.95l-3.522 3.356.83 4.73c.078.443-.36.79-.746.592L8 13.187l-4.389 2.256z"/>
    </svg>
  `,
  "x-lg": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-x-lg" viewBox="0 0 16 16">
      <path d="M2.146 2.854a.5.5 0 1 1 .708-.708L8 7.293l5.146-5.147a.5.5 0 0 1 .708.708L8.707 8l5.147 5.146a.5.5 0 0 1-.708.708L8 8.707l-5.146 5.147a.5.5 0 0 1-.708-.708L7.293 8 2.146 2.854Z"/>
    </svg>
  `,
  "x-circle-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-x-circle-fill" viewBox="0 0 16 16">
      <path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zM5.354 4.646a.5.5 0 1 0-.708.708L7.293 8l-2.647 2.646a.5.5 0 0 0 .708.708L8 8.707l2.646 2.647a.5.5 0 0 0 .708-.708L8.707 8l2.647-2.646a.5.5 0 0 0-.708-.708L8 7.293 5.354 4.646z"></path>
    </svg>
  `
};
var systemLibrary = {
  name: "system",
  resolver: (name) => {
    if (name in icons) {
      return `data:image/svg+xml,${encodeURIComponent(icons[name])}`;
    }
    return "";
  }
};
var library_system_default = systemLibrary;

// node_modules/@shoelace-style/shoelace/dist/chunks/chunk.ZL53POKZ.js
var registry = [library_default_default, library_system_default];
var watchedIcons = [];
function watchIcon(icon) {
  watchedIcons.push(icon);
}
function unwatchIcon(icon) {
  watchedIcons = watchedIcons.filter((el) => el !== icon);
}
function getIconLibrary(name) {
  return registry.find((lib) => lib.name === name);
}

// node_modules/@shoelace-style/shoelace/dist/chunks/chunk.I6OQK3N3.js
var CACHEABLE_ERROR = Symbol();
var RETRYABLE_ERROR = Symbol();
var parser;
var iconCache = /* @__PURE__ */ new Map();
var SlIcon = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.initialRender = false;
    this.svg = null;
    this.label = "";
    this.library = "default";
  }
  /** Given a URL, this function returns the resulting SVG element or an appropriate error symbol. */
  resolveIcon(url, library2) {
    return __async(this, null, function* () {
      var _a9;
      let fileData;
      if (library2 == null ? void 0 : library2.spriteSheet) {
        this.svg = x`<svg part="svg">
        <use part="use" href="${url}"></use>
      </svg>`;
        yield this.updateComplete;
        const svg = this.shadowRoot.querySelector("[part='svg']");
        if (typeof library2.mutator === "function") {
          library2.mutator(svg);
        }
        return this.svg;
      }
      try {
        fileData = yield fetch(url, { mode: "cors" });
        if (!fileData.ok)
          return fileData.status === 410 ? CACHEABLE_ERROR : RETRYABLE_ERROR;
      } catch (e13) {
        return RETRYABLE_ERROR;
      }
      try {
        const div3 = document.createElement("div");
        div3.innerHTML = yield fileData.text();
        const svg = div3.firstElementChild;
        if (((_a9 = svg == null ? void 0 : svg.tagName) == null ? void 0 : _a9.toLowerCase()) !== "svg")
          return CACHEABLE_ERROR;
        if (!parser)
          parser = new DOMParser();
        const doc = parser.parseFromString(svg.outerHTML, "text/html");
        const svgEl = doc.body.querySelector("svg");
        if (!svgEl)
          return CACHEABLE_ERROR;
        svgEl.part.add("svg");
        return document.adoptNode(svgEl);
      } catch (e13) {
        return CACHEABLE_ERROR;
      }
    });
  }
  connectedCallback() {
    super.connectedCallback();
    watchIcon(this);
  }
  firstUpdated() {
    this.initialRender = true;
    this.setIcon();
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    unwatchIcon(this);
  }
  getIconSource() {
    const library2 = getIconLibrary(this.library);
    if (this.name && library2) {
      return {
        url: library2.resolver(this.name),
        fromLibrary: true
      };
    }
    return {
      url: this.src,
      fromLibrary: false
    };
  }
  handleLabelChange() {
    const hasLabel = typeof this.label === "string" && this.label.length > 0;
    if (hasLabel) {
      this.setAttribute("role", "img");
      this.setAttribute("aria-label", this.label);
      this.removeAttribute("aria-hidden");
    } else {
      this.removeAttribute("role");
      this.removeAttribute("aria-label");
      this.setAttribute("aria-hidden", "true");
    }
  }
  setIcon() {
    return __async(this, null, function* () {
      var _a9;
      const { url, fromLibrary } = this.getIconSource();
      const library2 = fromLibrary ? getIconLibrary(this.library) : void 0;
      if (!url) {
        this.svg = null;
        return;
      }
      let iconResolver = iconCache.get(url);
      if (!iconResolver) {
        iconResolver = this.resolveIcon(url, library2);
        iconCache.set(url, iconResolver);
      }
      if (!this.initialRender) {
        return;
      }
      const svg = yield iconResolver;
      if (svg === RETRYABLE_ERROR) {
        iconCache.delete(url);
      }
      if (url !== this.getIconSource().url) {
        return;
      }
      if (e8(svg)) {
        this.svg = svg;
        return;
      }
      switch (svg) {
        case RETRYABLE_ERROR:
        case CACHEABLE_ERROR:
          this.svg = null;
          this.emit("sl-error");
          break;
        default:
          this.svg = svg.cloneNode(true);
          (_a9 = library2 == null ? void 0 : library2.mutator) == null ? void 0 : _a9.call(library2, this.svg);
          this.emit("sl-load");
      }
    });
  }
  render() {
    return this.svg;
  }
};
SlIcon.styles = [component_styles_default, icon_styles_default];
__decorateClass([
  r6()
], SlIcon.prototype, "svg", 2);
__decorateClass([
  n4({ reflect: true })
], SlIcon.prototype, "name", 2);
__decorateClass([
  n4()
], SlIcon.prototype, "src", 2);
__decorateClass([
  n4()
], SlIcon.prototype, "label", 2);
__decorateClass([
  n4({ reflect: true })
], SlIcon.prototype, "library", 2);
__decorateClass([
  watch("label")
], SlIcon.prototype, "handleLabelChange", 1);
__decorateClass([
  watch(["name", "src", "library"])
], SlIcon.prototype, "setIcon", 1);

// node_modules/lit-html/static.js
var e9 = Symbol.for("");
var o6 = (t9) => {
  if ((t9 == null ? void 0 : t9.r) === e9) return t9 == null ? void 0 : t9._$litStatic$;
};
var s4 = (t9, ...r9) => ({ _$litStatic$: r9.reduce((r10, e13, o11) => r10 + ((t10) => {
  if (void 0 !== t10._$litStatic$) return t10._$litStatic$;
  throw Error(`Value passed to 'literal' function must be a 'literal' result: ${t10}. Use 'unsafeStatic' to pass non-literal values, but
            take care to ensure page security.`);
})(e13) + t9[o11 + 1], t9[0]), r: e9 });
var a3 = /* @__PURE__ */ new Map();
var l4 = (t9) => (r9, ...e13) => {
  const i6 = e13.length;
  let s9, l5;
  const n9 = [], u5 = [];
  let c6, $2 = 0, f5 = false;
  for (; $2 < i6; ) {
    for (c6 = r9[$2]; $2 < i6 && void 0 !== (l5 = e13[$2], s9 = o6(l5)); ) c6 += s9 + r9[++$2], f5 = true;
    $2 !== i6 && u5.push(l5), n9.push(c6), $2++;
  }
  if ($2 === i6 && n9.push(r9[i6]), f5) {
    const t10 = n9.join("$$lit$$");
    void 0 === (r9 = a3.get(t10)) && (n9.raw = n9, a3.set(t10, r9 = n9)), e13 = u5;
  }
  return t9(r9, ...e13);
};
var n5 = l4(x);
var u4 = l4(b2);

// node_modules/@shoelace-style/shoelace/dist/chunks/chunk.DBG7W4GS.js
var SlIconButton = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.hasFocus = false;
    this.label = "";
    this.disabled = false;
  }
  handleBlur() {
    this.hasFocus = false;
    this.emit("sl-blur");
  }
  handleFocus() {
    this.hasFocus = true;
    this.emit("sl-focus");
  }
  handleClick(event2) {
    if (this.disabled) {
      event2.preventDefault();
      event2.stopPropagation();
    }
  }
  /** Simulates a click on the icon button. */
  click() {
    this.button.click();
  }
  /** Sets focus on the icon button. */
  focus(options) {
    this.button.focus(options);
  }
  /** Removes focus from the icon button. */
  blur() {
    this.button.blur();
  }
  render() {
    const isLink = this.href ? true : false;
    const tag = isLink ? s4`a` : s4`button`;
    return n5`
      <${tag}
        part="base"
        class=${e7({
      "icon-button": true,
      "icon-button--disabled": !isLink && this.disabled,
      "icon-button--focused": this.hasFocus
    })}
        ?disabled=${o5(isLink ? void 0 : this.disabled)}
        type=${o5(isLink ? void 0 : "button")}
        href=${o5(isLink ? this.href : void 0)}
        target=${o5(isLink ? this.target : void 0)}
        download=${o5(isLink ? this.download : void 0)}
        rel=${o5(isLink && this.target ? "noreferrer noopener" : void 0)}
        role=${o5(isLink ? void 0 : "button")}
        aria-disabled=${this.disabled ? "true" : "false"}
        aria-label="${this.label}"
        tabindex=${this.disabled ? "-1" : "0"}
        @blur=${this.handleBlur}
        @focus=${this.handleFocus}
        @click=${this.handleClick}
      >
        <sl-icon
          class="icon-button__icon"
          name=${o5(this.name)}
          library=${o5(this.library)}
          src=${o5(this.src)}
          aria-hidden="true"
        ></sl-icon>
      </${tag}>
    `;
  }
};
SlIconButton.styles = [component_styles_default, icon_button_styles_default];
SlIconButton.dependencies = { "sl-icon": SlIcon };
__decorateClass([
  e5(".icon-button")
], SlIconButton.prototype, "button", 2);
__decorateClass([
  r6()
], SlIconButton.prototype, "hasFocus", 2);
__decorateClass([
  n4()
], SlIconButton.prototype, "name", 2);
__decorateClass([
  n4()
], SlIconButton.prototype, "library", 2);
__decorateClass([
  n4()
], SlIconButton.prototype, "src", 2);
__decorateClass([
  n4()
], SlIconButton.prototype, "href", 2);
__decorateClass([
  n4()
], SlIconButton.prototype, "target", 2);
__decorateClass([
  n4()
], SlIconButton.prototype, "download", 2);
__decorateClass([
  n4()
], SlIconButton.prototype, "label", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlIconButton.prototype, "disabled", 2);

// node_modules/@shoelace-style/shoelace/dist/chunks/chunk.DUWACTPH.js
var SlTag = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController2(this);
    this.variant = "neutral";
    this.size = "medium";
    this.pill = false;
    this.removable = false;
  }
  handleRemoveClick() {
    this.emit("sl-remove");
  }
  render() {
    return x`
      <span
        part="base"
        class=${e7({
      tag: true,
      // Types
      "tag--primary": this.variant === "primary",
      "tag--success": this.variant === "success",
      "tag--neutral": this.variant === "neutral",
      "tag--warning": this.variant === "warning",
      "tag--danger": this.variant === "danger",
      "tag--text": this.variant === "text",
      // Sizes
      "tag--small": this.size === "small",
      "tag--medium": this.size === "medium",
      "tag--large": this.size === "large",
      // Modifiers
      "tag--pill": this.pill,
      "tag--removable": this.removable
    })}
      >
        <slot part="content" class="tag__content"></slot>

        ${this.removable ? x`
              <sl-icon-button
                part="remove-button"
                exportparts="base:remove-button__base"
                name="x-lg"
                library="system"
                label=${this.localize.term("remove")}
                class="tag__remove"
                @click=${this.handleRemoveClick}
                tabindex="-1"
              ></sl-icon-button>
            ` : ""}
      </span>
    `;
  }
};
SlTag.styles = [component_styles_default, tag_styles_default];
SlTag.dependencies = { "sl-icon-button": SlIconButton };
__decorateClass([
  n4({ reflect: true })
], SlTag.prototype, "variant", 2);
__decorateClass([
  n4({ reflect: true })
], SlTag.prototype, "size", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlTag.prototype, "pill", 2);
__decorateClass([
  n4({ type: Boolean })
], SlTag.prototype, "removable", 2);

// node_modules/@shoelace-style/shoelace/dist/chunks/chunk.AN6YZWTU.js
var select_styles_default = i`
  :host {
    display: block;
  }

  /** The popup */
  .select {
    flex: 1 1 auto;
    display: inline-flex;
    width: 100%;
    position: relative;
    vertical-align: middle;
  }

  .select::part(popup) {
    z-index: var(--sl-z-index-dropdown);
  }

  .select[data-current-placement^='top']::part(popup) {
    transform-origin: bottom;
  }

  .select[data-current-placement^='bottom']::part(popup) {
    transform-origin: top;
  }

  /* Combobox */
  .select__combobox {
    flex: 1;
    display: flex;
    width: 100%;
    min-width: 0;
    position: relative;
    align-items: center;
    justify-content: start;
    font-family: var(--sl-input-font-family);
    font-weight: var(--sl-input-font-weight);
    letter-spacing: var(--sl-input-letter-spacing);
    vertical-align: middle;
    overflow: hidden;
    cursor: pointer;
    transition:
      var(--sl-transition-fast) color,
      var(--sl-transition-fast) border,
      var(--sl-transition-fast) box-shadow,
      var(--sl-transition-fast) background-color;
  }

  .select__display-input {
    position: relative;
    width: 100%;
    font: inherit;
    border: none;
    background: none;
    color: var(--sl-input-color);
    cursor: inherit;
    overflow: hidden;
    padding: 0;
    margin: 0;
    -webkit-appearance: none;
  }

  .select__display-input::placeholder {
    color: var(--sl-input-placeholder-color);
  }

  .select:not(.select--disabled):hover .select__display-input {
    color: var(--sl-input-color-hover);
  }

  .select__display-input:focus {
    outline: none;
  }

  /* Visually hide the display input when multiple is enabled */
  .select--multiple:not(.select--placeholder-visible) .select__display-input {
    position: absolute;
    z-index: -1;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    opacity: 0;
  }

  .select__value-input {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    padding: 0;
    margin: 0;
    opacity: 0;
    z-index: -1;
  }

  .select__tags {
    display: flex;
    flex: 1;
    align-items: center;
    flex-wrap: wrap;
    margin-inline-start: var(--sl-spacing-2x-small);
  }

  .select__tags::slotted(sl-tag) {
    cursor: pointer !important;
  }

  .select--disabled .select__tags,
  .select--disabled .select__tags::slotted(sl-tag) {
    cursor: not-allowed !important;
  }

  /* Standard selects */
  .select--standard .select__combobox {
    background-color: var(--sl-input-background-color);
    border: solid var(--sl-input-border-width) var(--sl-input-border-color);
  }

  .select--standard.select--disabled .select__combobox {
    background-color: var(--sl-input-background-color-disabled);
    border-color: var(--sl-input-border-color-disabled);
    color: var(--sl-input-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
    outline: none;
  }

  .select--standard:not(.select--disabled).select--open .select__combobox,
  .select--standard:not(.select--disabled).select--focused .select__combobox {
    background-color: var(--sl-input-background-color-focus);
    border-color: var(--sl-input-border-color-focus);
    box-shadow: 0 0 0 var(--sl-focus-ring-width) var(--sl-input-focus-ring-color);
  }

  /* Filled selects */
  .select--filled .select__combobox {
    border: none;
    background-color: var(--sl-input-filled-background-color);
    color: var(--sl-input-color);
  }

  .select--filled:hover:not(.select--disabled) .select__combobox {
    background-color: var(--sl-input-filled-background-color-hover);
  }

  .select--filled.select--disabled .select__combobox {
    background-color: var(--sl-input-filled-background-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
  }

  .select--filled:not(.select--disabled).select--open .select__combobox,
  .select--filled:not(.select--disabled).select--focused .select__combobox {
    background-color: var(--sl-input-filled-background-color-focus);
    outline: var(--sl-focus-ring);
  }

  /* Sizes */
  .select--small .select__combobox {
    border-radius: var(--sl-input-border-radius-small);
    font-size: var(--sl-input-font-size-small);
    min-height: var(--sl-input-height-small);
    padding-block: 0;
    padding-inline: var(--sl-input-spacing-small);
  }

  .select--small .select__clear {
    margin-inline-start: var(--sl-input-spacing-small);
  }

  .select--small .select__prefix::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-small);
  }

  .select--small.select--multiple:not(.select--placeholder-visible) .select__combobox {
    padding-block: 2px;
    padding-inline-start: 0;
  }

  .select--small .select__tags {
    gap: 2px;
  }

  .select--medium .select__combobox {
    border-radius: var(--sl-input-border-radius-medium);
    font-size: var(--sl-input-font-size-medium);
    min-height: var(--sl-input-height-medium);
    padding-block: 0;
    padding-inline: var(--sl-input-spacing-medium);
  }

  .select--medium .select__clear {
    margin-inline-start: var(--sl-input-spacing-medium);
  }

  .select--medium .select__prefix::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-medium);
  }

  .select--medium.select--multiple:not(.select--placeholder-visible) .select__combobox {
    padding-inline-start: 0;
    padding-block: 3px;
  }

  .select--medium .select__tags {
    gap: 3px;
  }

  .select--large .select__combobox {
    border-radius: var(--sl-input-border-radius-large);
    font-size: var(--sl-input-font-size-large);
    min-height: var(--sl-input-height-large);
    padding-block: 0;
    padding-inline: var(--sl-input-spacing-large);
  }

  .select--large .select__clear {
    margin-inline-start: var(--sl-input-spacing-large);
  }

  .select--large .select__prefix::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-large);
  }

  .select--large.select--multiple:not(.select--placeholder-visible) .select__combobox {
    padding-inline-start: 0;
    padding-block: 4px;
  }

  .select--large .select__tags {
    gap: 4px;
  }

  /* Pills */
  .select--pill.select--small .select__combobox {
    border-radius: var(--sl-input-height-small);
  }

  .select--pill.select--medium .select__combobox {
    border-radius: var(--sl-input-height-medium);
  }

  .select--pill.select--large .select__combobox {
    border-radius: var(--sl-input-height-large);
  }

  /* Prefix */
  .select__prefix {
    flex: 0;
    display: inline-flex;
    align-items: center;
    color: var(--sl-input-placeholder-color);
  }

  /* Clear button */
  .select__clear {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: inherit;
    color: var(--sl-input-icon-color);
    border: none;
    background: none;
    padding: 0;
    transition: var(--sl-transition-fast) color;
    cursor: pointer;
  }

  .select__clear:hover {
    color: var(--sl-input-icon-color-hover);
  }

  .select__clear:focus {
    outline: none;
  }

  /* Expand icon */
  .select__expand-icon {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    transition: var(--sl-transition-medium) rotate ease;
    rotate: 0;
    margin-inline-start: var(--sl-spacing-small);
  }

  .select--open .select__expand-icon {
    rotate: -180deg;
  }

  /* Listbox */
  .select__listbox {
    display: block;
    position: relative;
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-medium);
    font-weight: var(--sl-font-weight-normal);
    box-shadow: var(--sl-shadow-large);
    background: var(--sl-panel-background-color);
    border: solid var(--sl-panel-border-width) var(--sl-panel-border-color);
    border-radius: var(--sl-border-radius-medium);
    padding-block: var(--sl-spacing-x-small);
    padding-inline: 0;
    overflow: auto;
    overscroll-behavior: none;

    /* Make sure it adheres to the popup's auto size */
    max-width: var(--auto-size-available-width);
    max-height: var(--auto-size-available-height);
  }

  .select__listbox ::slotted(sl-divider) {
    --spacing: var(--sl-spacing-x-small);
  }

  .select__listbox ::slotted(small) {
    font-size: var(--sl-font-size-small);
    font-weight: var(--sl-font-weight-semibold);
    color: var(--sl-color-neutral-500);
    padding-block: var(--sl-spacing-x-small);
    padding-inline: var(--sl-spacing-x-large);
  }
`;

// node_modules/@shoelace-style/shoelace/dist/chunks/chunk.F5JVBNK3.js
function getOffset(element, parent) {
  return {
    top: Math.round(element.getBoundingClientRect().top - parent.getBoundingClientRect().top),
    left: Math.round(element.getBoundingClientRect().left - parent.getBoundingClientRect().left)
  };
}
function scrollIntoView(element, container, direction2 = "vertical", behavior = "smooth") {
  const offset3 = getOffset(element, container);
  const offsetTop = offset3.top + container.scrollTop;
  const offsetLeft = offset3.left + container.scrollLeft;
  const minX = container.scrollLeft;
  const maxX = container.scrollLeft + container.offsetWidth;
  const minY = container.scrollTop;
  const maxY = container.scrollTop + container.offsetHeight;
  if (direction2 === "horizontal" || direction2 === "both") {
    if (offsetLeft < minX) {
      container.scrollTo({ left: offsetLeft, behavior });
    } else if (offsetLeft + element.clientWidth > maxX) {
      container.scrollTo({ left: offsetLeft - container.offsetWidth + element.clientWidth, behavior });
    }
  }
  if (direction2 === "vertical" || direction2 === "both") {
    if (offsetTop < minY) {
      container.scrollTo({ top: offsetTop, behavior });
    } else if (offsetTop + element.clientHeight > maxY) {
      container.scrollTo({ top: offsetTop - container.offsetHeight + element.clientHeight, behavior });
    }
  }
}

// node_modules/@shoelace-style/shoelace/dist/chunks/chunk.3KSWVBQ5.js
var popup_styles_default = i`
  :host {
    --arrow-color: var(--sl-color-neutral-1000);
    --arrow-size: 6px;

    /*
     * These properties are computed to account for the arrow's dimensions after being rotated 45º. The constant
     * 0.7071 is derived from sin(45), which is the diagonal size of the arrow's container after rotating.
     */
    --arrow-size-diagonal: calc(var(--arrow-size) * 0.7071);
    --arrow-padding-offset: calc(var(--arrow-size-diagonal) - var(--arrow-size));

    display: contents;
  }

  .popup {
    position: absolute;
    isolation: isolate;
    max-width: var(--auto-size-available-width, none);
    max-height: var(--auto-size-available-height, none);
  }

  .popup--fixed {
    position: fixed;
  }

  .popup:not(.popup--active) {
    display: none;
  }

  .popup__arrow {
    position: absolute;
    width: calc(var(--arrow-size-diagonal) * 2);
    height: calc(var(--arrow-size-diagonal) * 2);
    rotate: 45deg;
    background: var(--arrow-color);
    z-index: -1;
  }

  /* Hover bridge */
  .popup-hover-bridge:not(.popup-hover-bridge--visible) {
    display: none;
  }

  .popup-hover-bridge {
    position: fixed;
    z-index: calc(var(--sl-z-index-dropdown) - 1);
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    clip-path: polygon(
      var(--hover-bridge-top-left-x, 0) var(--hover-bridge-top-left-y, 0),
      var(--hover-bridge-top-right-x, 0) var(--hover-bridge-top-right-y, 0),
      var(--hover-bridge-bottom-right-x, 0) var(--hover-bridge-bottom-right-y, 0),
      var(--hover-bridge-bottom-left-x, 0) var(--hover-bridge-bottom-left-y, 0)
    );
  }
`;

// node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var min = Math.min;
var max = Math.max;
var round = Math.round;
var floor = Math.floor;
var createCoords = (v2) => ({
  x: v2,
  y: v2
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis2) {
  return axis2 === "x" ? "y" : "x";
}
function getAxisLength(axis2) {
  return axis2 === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length4 = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length4] > rects.floating[length4]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction2, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction2 === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return __spreadValues({
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  }, padding);
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x: x2,
    y: y3,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y3,
    left: x2,
    right: x2 + width,
    bottom: y3 + height,
    x: x2,
    y: y3
  };
}

// node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = (reference, floating, config) => __async(void 0, null, function* () {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = yield platform2.isRTL == null ? void 0 : platform2.isRTL(floating);
  let rects = yield platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x: x2,
    y: y3
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i6 = 0; i6 < validMiddleware.length; i6++) {
    const {
      name,
      fn
    } = validMiddleware[i6];
    const {
      x: nextX,
      y: nextY,
      data,
      reset: reset2
    } = yield fn({
      x: x2,
      y: y3,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x2 = nextX != null ? nextX : x2;
    y3 = nextY != null ? nextY : y3;
    middlewareData = __spreadProps(__spreadValues({}, middlewareData), {
      [name]: __spreadValues(__spreadValues({}, middlewareData[name]), data)
    });
    if (reset2 && resetCount <= 50) {
      resetCount++;
      if (typeof reset2 === "object") {
        if (reset2.placement) {
          statefulPlacement = reset2.placement;
        }
        if (reset2.rects) {
          rects = reset2.rects === true ? yield platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset2.rects;
        }
        ({
          x: x2,
          y: y3
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i6 = -1;
    }
  }
  return {
    x: x2,
    y: y3,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
});
function detectOverflow(state, options) {
  return __async(this, null, function* () {
    var _await$platform$isEle;
    if (options === void 0) {
      options = {};
    }
    const {
      x: x2,
      y: y3,
      platform: platform2,
      rects,
      elements,
      strategy
    } = state;
    const {
      boundary = "clippingAncestors",
      rootBoundary = "viewport",
      elementContext = "floating",
      altBoundary = false,
      padding = 0
    } = evaluate(options, state);
    const paddingObject = getPaddingObject(padding);
    const altContext = elementContext === "floating" ? "reference" : "floating";
    const element = elements[altBoundary ? altContext : elementContext];
    const clippingClientRect = rectToClientRect(yield platform2.getClippingRect({
      element: ((_await$platform$isEle = yield platform2.isElement == null ? void 0 : platform2.isElement(element)) != null ? _await$platform$isEle : true) ? element : element.contextElement || (yield platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
      boundary,
      rootBoundary,
      strategy
    }));
    const rect = elementContext === "floating" ? {
      x: x2,
      y: y3,
      width: rects.floating.width,
      height: rects.floating.height
    } : rects.reference;
    const offsetParent = yield platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating);
    const offsetScale = (yield platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? (yield platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
      x: 1,
      y: 1
    } : {
      x: 1,
      y: 1
    };
    const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? yield platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
      elements,
      rect,
      offsetParent,
      strategy
    }) : rect);
    return {
      top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
      bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
      left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
      right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
    };
  });
}
var arrow = (options) => ({
  name: "arrow",
  options,
  fn(state) {
    return __async(this, null, function* () {
      const {
        x: x2,
        y: y3,
        placement,
        rects,
        platform: platform2,
        elements,
        middlewareData
      } = state;
      const {
        element,
        padding = 0
      } = evaluate(options, state) || {};
      if (element == null) {
        return {};
      }
      const paddingObject = getPaddingObject(padding);
      const coords = {
        x: x2,
        y: y3
      };
      const axis2 = getAlignmentAxis(placement);
      const length4 = getAxisLength(axis2);
      const arrowDimensions = yield platform2.getDimensions(element);
      const isYAxis = axis2 === "y";
      const minProp = isYAxis ? "top" : "left";
      const maxProp = isYAxis ? "bottom" : "right";
      const clientProp = isYAxis ? "clientHeight" : "clientWidth";
      const endDiff = rects.reference[length4] + rects.reference[axis2] - coords[axis2] - rects.floating[length4];
      const startDiff = coords[axis2] - rects.reference[axis2];
      const arrowOffsetParent = yield platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element);
      let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
      if (!clientSize || !(yield platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
        clientSize = elements.floating[clientProp] || rects.floating[length4];
      }
      const centerToReference = endDiff / 2 - startDiff / 2;
      const largestPossiblePadding = clientSize / 2 - arrowDimensions[length4] / 2 - 1;
      const minPadding = min(paddingObject[minProp], largestPossiblePadding);
      const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
      const min$1 = minPadding;
      const max5 = clientSize - arrowDimensions[length4] - maxPadding;
      const center = clientSize / 2 - arrowDimensions[length4] / 2 + centerToReference;
      const offset3 = clamp(min$1, center, max5);
      const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset3 && rects.reference[length4] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length4] / 2 < 0;
      const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max5 : 0;
      return {
        [axis2]: coords[axis2] + alignmentOffset,
        data: __spreadValues({
          [axis2]: offset3,
          centerOffset: center - offset3 - alignmentOffset
        }, shouldAddOffset && {
          alignmentOffset
        }),
        reset: shouldAddOffset
      };
    });
  }
});
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    fn(state) {
      return __async(this, null, function* () {
        var _middlewareData$arrow, _middlewareData$flip;
        const {
          placement,
          middlewareData,
          rects,
          initialPlacement,
          platform: platform2,
          elements
        } = state;
        const _a10 = evaluate(options, state), {
          mainAxis: checkMainAxis = true,
          crossAxis: checkCrossAxis = true,
          fallbackPlacements: specifiedFallbackPlacements,
          fallbackStrategy = "bestFit",
          fallbackAxisSideDirection = "none",
          flipAlignment = true
        } = _a10, detectOverflowOptions = __objRest(_a10, [
          "mainAxis",
          "crossAxis",
          "fallbackPlacements",
          "fallbackStrategy",
          "fallbackAxisSideDirection",
          "flipAlignment"
        ]);
        if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
          return {};
        }
        const side = getSide(placement);
        const isBasePlacement = getSide(initialPlacement) === initialPlacement;
        const rtl = yield platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating);
        const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
        if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== "none") {
          fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
        }
        const placements2 = [initialPlacement, ...fallbackPlacements];
        const overflow = yield detectOverflow(state, detectOverflowOptions);
        const overflows = [];
        let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
        if (checkMainAxis) {
          overflows.push(overflow[side]);
        }
        if (checkCrossAxis) {
          const sides2 = getAlignmentSides(placement, rects, rtl);
          overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
        }
        overflowsData = [...overflowsData, {
          placement,
          overflows
        }];
        if (!overflows.every((side2) => side2 <= 0)) {
          var _middlewareData$flip2, _overflowsData$filter;
          const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
          const nextPlacement = placements2[nextIndex];
          if (nextPlacement) {
            return {
              data: {
                index: nextIndex,
                overflows: overflowsData
              },
              reset: {
                placement: nextPlacement
              }
            };
          }
          let resetPlacement = (_overflowsData$filter = overflowsData.filter((d3) => d3.overflows[0] <= 0).sort((a4, b3) => a4.overflows[1] - b3.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
          if (!resetPlacement) {
            switch (fallbackStrategy) {
              case "bestFit": {
                var _overflowsData$map$so;
                const placement2 = (_overflowsData$map$so = overflowsData.map((d3) => [d3.placement, d3.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a4, b3) => a4[1] - b3[1])[0]) == null ? void 0 : _overflowsData$map$so[0];
                if (placement2) {
                  resetPlacement = placement2;
                }
                break;
              }
              case "initialPlacement":
                resetPlacement = initialPlacement;
                break;
            }
          }
          if (placement !== resetPlacement) {
            return {
              reset: {
                placement: resetPlacement
              }
            };
          }
        }
        return {};
      });
    }
  };
};
function convertValueToCoords(state, options) {
  return __async(this, null, function* () {
    const {
      placement,
      platform: platform2,
      elements
    } = state;
    const rtl = yield platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating);
    const side = getSide(placement);
    const alignment = getAlignment(placement);
    const isVertical = getSideAxis(placement) === "y";
    const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
    const crossAxisMulti = rtl && isVertical ? -1 : 1;
    const rawValue = evaluate(options, state);
    let {
      mainAxis,
      crossAxis,
      alignmentAxis
    } = typeof rawValue === "number" ? {
      mainAxis: rawValue,
      crossAxis: 0,
      alignmentAxis: null
    } : __spreadValues({
      mainAxis: 0,
      crossAxis: 0,
      alignmentAxis: null
    }, rawValue);
    if (alignment && typeof alignmentAxis === "number") {
      crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
    }
    return isVertical ? {
      x: crossAxis * crossAxisMulti,
      y: mainAxis * mainAxisMulti
    } : {
      x: mainAxis * mainAxisMulti,
      y: crossAxis * crossAxisMulti
    };
  });
}
var offset = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    fn(state) {
      return __async(this, null, function* () {
        var _middlewareData$offse, _middlewareData$arrow;
        const {
          x: x2,
          y: y3,
          placement,
          middlewareData
        } = state;
        const diffCoords = yield convertValueToCoords(state, options);
        if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
          return {};
        }
        return {
          x: x2 + diffCoords.x,
          y: y3 + diffCoords.y,
          data: __spreadProps(__spreadValues({}, diffCoords), {
            placement
          })
        };
      });
    }
  };
};
var shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    fn(state) {
      return __async(this, null, function* () {
        const {
          x: x2,
          y: y3,
          placement
        } = state;
        const _a10 = evaluate(options, state), {
          mainAxis: checkMainAxis = true,
          crossAxis: checkCrossAxis = false,
          limiter = {
            fn: (_ref) => {
              let {
                x: x3,
                y: y4
              } = _ref;
              return {
                x: x3,
                y: y4
              };
            }
          }
        } = _a10, detectOverflowOptions = __objRest(_a10, [
          "mainAxis",
          "crossAxis",
          "limiter"
        ]);
        const coords = {
          x: x2,
          y: y3
        };
        const overflow = yield detectOverflow(state, detectOverflowOptions);
        const crossAxis = getSideAxis(getSide(placement));
        const mainAxis = getOppositeAxis(crossAxis);
        let mainAxisCoord = coords[mainAxis];
        let crossAxisCoord = coords[crossAxis];
        if (checkMainAxis) {
          const minSide = mainAxis === "y" ? "top" : "left";
          const maxSide = mainAxis === "y" ? "bottom" : "right";
          const min5 = mainAxisCoord + overflow[minSide];
          const max5 = mainAxisCoord - overflow[maxSide];
          mainAxisCoord = clamp(min5, mainAxisCoord, max5);
        }
        if (checkCrossAxis) {
          const minSide = crossAxis === "y" ? "top" : "left";
          const maxSide = crossAxis === "y" ? "bottom" : "right";
          const min5 = crossAxisCoord + overflow[minSide];
          const max5 = crossAxisCoord - overflow[maxSide];
          crossAxisCoord = clamp(min5, crossAxisCoord, max5);
        }
        const limitedCoords = limiter.fn(__spreadProps(__spreadValues({}, state), {
          [mainAxis]: mainAxisCoord,
          [crossAxis]: crossAxisCoord
        }));
        return __spreadProps(__spreadValues({}, limitedCoords), {
          data: {
            x: limitedCoords.x - x2,
            y: limitedCoords.y - y3
          }
        });
      });
    }
  };
};
var size = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    fn(state) {
      return __async(this, null, function* () {
        const {
          placement,
          rects,
          platform: platform2,
          elements
        } = state;
        const _a10 = evaluate(options, state), {
          apply = () => {
          }
        } = _a10, detectOverflowOptions = __objRest(_a10, [
          "apply"
        ]);
        const overflow = yield detectOverflow(state, detectOverflowOptions);
        const side = getSide(placement);
        const alignment = getAlignment(placement);
        const isYAxis = getSideAxis(placement) === "y";
        const {
          width,
          height
        } = rects.floating;
        let heightSide;
        let widthSide;
        if (side === "top" || side === "bottom") {
          heightSide = side;
          widthSide = alignment === ((yield platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
        } else {
          widthSide = side;
          heightSide = alignment === "end" ? "top" : "bottom";
        }
        const maximumClippingHeight = height - overflow.top - overflow.bottom;
        const maximumClippingWidth = width - overflow.left - overflow.right;
        const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
        const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
        const noShift = !state.middlewareData.shift;
        let availableHeight = overflowAvailableHeight;
        let availableWidth = overflowAvailableWidth;
        if (isYAxis) {
          availableWidth = alignment || noShift ? min(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;
        } else {
          availableHeight = alignment || noShift ? min(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;
        }
        if (noShift && !alignment) {
          const xMin = max(overflow.left, 0);
          const xMax = max(overflow.right, 0);
          const yMin = max(overflow.top, 0);
          const yMax = max(overflow.bottom, 0);
          if (isYAxis) {
            availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
          } else {
            availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
          }
        }
        yield apply(__spreadProps(__spreadValues({}, state), {
          availableWidth,
          availableHeight
        }));
        const nextDimensions = yield platform2.getDimensions(elements.floating);
        if (width !== nextDimensions.width || height !== nextDimensions.height) {
          return {
            reset: {
              rects: true
            }
          };
        }
        return {};
      });
    }
  };
};

// node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle2(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isContainingBlock(element) {
  const webkit = isWebKit();
  const css = getComputedStyle2(element);
  return css.transform !== "none" || css.perspective !== "none" || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || ["transform", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
function getComputedStyle2(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.pageXOffset,
    scrollTop: element.pageYOffset
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}

// node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element) {
  const css = getComputedStyle2(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $: $2
  } = getCssDimensions(domElement);
  let x2 = ($2 ? round(rect.width) : rect.width) / width;
  let y3 = ($2 ? round(rect.height) : rect.height) / height;
  if (!x2 || !Number.isFinite(x2)) {
    x2 = 1;
  }
  if (!y3 || !Number.isFinite(y3)) {
    y3 = 1;
  }
  return {
    x: x2,
    y: y3
  };
}
var noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale7 = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale7 = getScale(offsetParent);
      }
    } else {
      scale7 = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x2 = (clientRect.left + visualOffsets.x) / scale7.x;
  let y3 = (clientRect.top + visualOffsets.y) / scale7.y;
  let width = clientRect.width / scale7.x;
  let height = clientRect.height / scale7.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = currentWin.frameElement;
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle2(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x2 *= iframeScale.x;
      y3 *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x2 += left;
      y3 += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = currentWin.frameElement;
    }
  }
  return rectToClientRect({
    width,
    height,
    x: x2,
    y: y3
  });
}
var topLayerSelectors = [":popover-open", ":modal"];
function isTopLayer(element) {
  return topLayerSelectors.some((selector) => {
    try {
      return element.matches(selector);
    } catch (e13) {
      return false;
    }
  });
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale7 = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale7 = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return {
    width: rect.width * scale7.x,
    height: rect.height * scale7.y,
    x: rect.x * scale7.x - scroll.scrollLeft * scale7.x + offsets.x,
    y: rect.y * scale7.y - scroll.scrollTop * scale7.y + offsets.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x2 = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y3 = -scroll.scrollTop;
  if (getComputedStyle2(body).direction === "rtl") {
    x2 += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x: x2,
    y: y3
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x2 = 0;
  let y3 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x2 = visualViewport.offsetLeft;
      y3 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x2,
    y: y3
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale7 = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale7.x;
  const height = element.clientHeight * scale7.y;
  const x2 = left * scale7.x;
  const y3 = top * scale7.y;
  return {
    width,
    height,
    x: x2,
    y: y3
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = __spreadProps(__spreadValues({}, clippingAncestor), {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y
    });
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle2(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache2) {
  const cachedResult = cache2.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle2(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle2(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache2.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  const x2 = rect.left + scroll.scrollLeft - offsets.x;
  const y3 = rect.top + scroll.scrollTop - offsets.y;
  return {
    x: x2,
    y: y3,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle2(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle2(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  return element.offsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
var getElementRects = function(data) {
  return __async(this, null, function* () {
    const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
    const getDimensionsFn = this.getDimensions;
    const floatingDimensions = yield getDimensionsFn(data.floating);
    return {
      reference: getRectRelativeToOffsetParent(data.reference, yield getOffsetParentFn(data.floating), data.strategy),
      floating: {
        x: 0,
        y: 0,
        width: floatingDimensions.width,
        height: floatingDimensions.height
      }
    };
  });
};
function isRTL(element) {
  return getComputedStyle2(element).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const {
      left,
      top,
      width,
      height
    } = element.getBoundingClientRect();
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, __spreadProps(__spreadValues({}, options), {
        // Handle <iframe>s
        root: root.ownerDocument
      }));
    } catch (e13) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update2, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update2, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update2);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update2) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update2();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update2();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update2();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update2);
      ancestorResize && ancestor.removeEventListener("resize", update2);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var offset2 = offset;
var shift2 = shift;
var flip2 = flip;
var size2 = size;
var arrow2 = arrow;
var computePosition2 = (reference, floating, options) => {
  const cache2 = /* @__PURE__ */ new Map();
  const mergedOptions = __spreadValues({
    platform
  }, options);
  const platformWithCache = __spreadProps(__spreadValues({}, mergedOptions.platform), {
    _c: cache2
  });
  return computePosition(reference, floating, __spreadProps(__spreadValues({}, mergedOptions), {
    platform: platformWithCache
  }));
};

// node_modules/composed-offset-position/dist/composed-offset-position.browser.min.mjs
function t7(t9) {
  return r7(t9);
}
function o7(t9) {
  return t9.assignedSlot ? t9.assignedSlot : t9.parentNode instanceof ShadowRoot ? t9.parentNode.host : t9.parentNode;
}
function r7(t9) {
  for (let e13 = t9; e13; e13 = o7(e13)) if (e13 instanceof Element && "none" === getComputedStyle(e13).display) return null;
  for (let e13 = o7(t9); e13; e13 = o7(e13)) {
    if (!(e13 instanceof Element)) continue;
    const t10 = getComputedStyle(e13);
    if ("contents" !== t10.display) {
      if ("static" !== t10.position || "none" !== t10.filter) return e13;
      if ("BODY" === e13.tagName) return e13;
    }
  }
  return null;
}

// node_modules/@shoelace-style/shoelace/dist/chunks/chunk.UFYD5JS6.js
function isVirtualElement(e13) {
  return e13 !== null && typeof e13 === "object" && "getBoundingClientRect" in e13 && ("contextElement" in e13 ? e13 instanceof Element : true);
}
var SlPopup = class _this extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.active = false;
    this.placement = "top";
    this.strategy = "absolute";
    this.distance = 0;
    this.skidding = 0;
    this.arrow = false;
    this.arrowPlacement = "anchor";
    this.arrowPadding = 10;
    this.flip = false;
    this.flipFallbackPlacements = "";
    this.flipFallbackStrategy = "best-fit";
    this.flipPadding = 0;
    this.shift = false;
    this.shiftPadding = 0;
    this.autoSizePadding = 0;
    this.hoverBridge = false;
    this.updateHoverBridge = () => {
      if (this.hoverBridge && this.anchorEl) {
        const anchorRect = this.anchorEl.getBoundingClientRect();
        const popupRect = this.popup.getBoundingClientRect();
        const isVertical = this.placement.includes("top") || this.placement.includes("bottom");
        let topLeftX = 0;
        let topLeftY = 0;
        let topRightX = 0;
        let topRightY = 0;
        let bottomLeftX = 0;
        let bottomLeftY = 0;
        let bottomRightX = 0;
        let bottomRightY = 0;
        if (isVertical) {
          if (anchorRect.top < popupRect.top) {
            topLeftX = anchorRect.left;
            topLeftY = anchorRect.bottom;
            topRightX = anchorRect.right;
            topRightY = anchorRect.bottom;
            bottomLeftX = popupRect.left;
            bottomLeftY = popupRect.top;
            bottomRightX = popupRect.right;
            bottomRightY = popupRect.top;
          } else {
            topLeftX = popupRect.left;
            topLeftY = popupRect.bottom;
            topRightX = popupRect.right;
            topRightY = popupRect.bottom;
            bottomLeftX = anchorRect.left;
            bottomLeftY = anchorRect.top;
            bottomRightX = anchorRect.right;
            bottomRightY = anchorRect.top;
          }
        } else {
          if (anchorRect.left < popupRect.left) {
            topLeftX = anchorRect.right;
            topLeftY = anchorRect.top;
            topRightX = popupRect.left;
            topRightY = popupRect.top;
            bottomLeftX = anchorRect.right;
            bottomLeftY = anchorRect.bottom;
            bottomRightX = popupRect.left;
            bottomRightY = popupRect.bottom;
          } else {
            topLeftX = popupRect.right;
            topLeftY = popupRect.top;
            topRightX = anchorRect.left;
            topRightY = anchorRect.top;
            bottomLeftX = popupRect.right;
            bottomLeftY = popupRect.bottom;
            bottomRightX = anchorRect.left;
            bottomRightY = anchorRect.bottom;
          }
        }
        this.style.setProperty("--hover-bridge-top-left-x", `${topLeftX}px`);
        this.style.setProperty("--hover-bridge-top-left-y", `${topLeftY}px`);
        this.style.setProperty("--hover-bridge-top-right-x", `${topRightX}px`);
        this.style.setProperty("--hover-bridge-top-right-y", `${topRightY}px`);
        this.style.setProperty("--hover-bridge-bottom-left-x", `${bottomLeftX}px`);
        this.style.setProperty("--hover-bridge-bottom-left-y", `${bottomLeftY}px`);
        this.style.setProperty("--hover-bridge-bottom-right-x", `${bottomRightX}px`);
        this.style.setProperty("--hover-bridge-bottom-right-y", `${bottomRightY}px`);
      }
    };
  }
  connectedCallback() {
    return __async(this, null, function* () {
      __superGet(_this.prototype, this, "connectedCallback").call(this);
      yield this.updateComplete;
      this.start();
    });
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.stop();
  }
  updated(changedProps) {
    return __async(this, null, function* () {
      __superGet(_this.prototype, this, "updated").call(this, changedProps);
      if (changedProps.has("active")) {
        if (this.active) {
          this.start();
        } else {
          this.stop();
        }
      }
      if (changedProps.has("anchor")) {
        this.handleAnchorChange();
      }
      if (this.active) {
        yield this.updateComplete;
        this.reposition();
      }
    });
  }
  handleAnchorChange() {
    return __async(this, null, function* () {
      yield this.stop();
      if (this.anchor && typeof this.anchor === "string") {
        const root = this.getRootNode();
        this.anchorEl = root.getElementById(this.anchor);
      } else if (this.anchor instanceof Element || isVirtualElement(this.anchor)) {
        this.anchorEl = this.anchor;
      } else {
        this.anchorEl = this.querySelector('[slot="anchor"]');
      }
      if (this.anchorEl instanceof HTMLSlotElement) {
        this.anchorEl = this.anchorEl.assignedElements({ flatten: true })[0];
      }
      if (this.anchorEl) {
        this.start();
      }
    });
  }
  start() {
    if (!this.anchorEl) {
      return;
    }
    this.cleanup = autoUpdate(this.anchorEl, this.popup, () => {
      this.reposition();
    });
  }
  stop() {
    return __async(this, null, function* () {
      return new Promise((resolve) => {
        if (this.cleanup) {
          this.cleanup();
          this.cleanup = void 0;
          this.removeAttribute("data-current-placement");
          this.style.removeProperty("--auto-size-available-width");
          this.style.removeProperty("--auto-size-available-height");
          requestAnimationFrame(() => resolve());
        } else {
          resolve();
        }
      });
    });
  }
  /** Forces the popup to recalculate and reposition itself. */
  reposition() {
    if (!this.active || !this.anchorEl) {
      return;
    }
    const middleware = [
      // The offset middleware goes first
      offset2({ mainAxis: this.distance, crossAxis: this.skidding })
    ];
    if (this.sync) {
      middleware.push(
        size2({
          apply: ({ rects }) => {
            const syncWidth = this.sync === "width" || this.sync === "both";
            const syncHeight = this.sync === "height" || this.sync === "both";
            this.popup.style.width = syncWidth ? `${rects.reference.width}px` : "";
            this.popup.style.height = syncHeight ? `${rects.reference.height}px` : "";
          }
        })
      );
    } else {
      this.popup.style.width = "";
      this.popup.style.height = "";
    }
    if (this.flip) {
      middleware.push(
        flip2({
          boundary: this.flipBoundary,
          // @ts-expect-error - We're converting a string attribute to an array here
          fallbackPlacements: this.flipFallbackPlacements,
          fallbackStrategy: this.flipFallbackStrategy === "best-fit" ? "bestFit" : "initialPlacement",
          padding: this.flipPadding
        })
      );
    }
    if (this.shift) {
      middleware.push(
        shift2({
          boundary: this.shiftBoundary,
          padding: this.shiftPadding
        })
      );
    }
    if (this.autoSize) {
      middleware.push(
        size2({
          boundary: this.autoSizeBoundary,
          padding: this.autoSizePadding,
          apply: ({ availableWidth, availableHeight }) => {
            if (this.autoSize === "vertical" || this.autoSize === "both") {
              this.style.setProperty("--auto-size-available-height", `${availableHeight}px`);
            } else {
              this.style.removeProperty("--auto-size-available-height");
            }
            if (this.autoSize === "horizontal" || this.autoSize === "both") {
              this.style.setProperty("--auto-size-available-width", `${availableWidth}px`);
            } else {
              this.style.removeProperty("--auto-size-available-width");
            }
          }
        })
      );
    } else {
      this.style.removeProperty("--auto-size-available-width");
      this.style.removeProperty("--auto-size-available-height");
    }
    if (this.arrow) {
      middleware.push(
        arrow2({
          element: this.arrowEl,
          padding: this.arrowPadding
        })
      );
    }
    const getOffsetParent2 = this.strategy === "absolute" ? (element) => platform.getOffsetParent(element, t7) : platform.getOffsetParent;
    computePosition2(this.anchorEl, this.popup, {
      placement: this.placement,
      middleware,
      strategy: this.strategy,
      platform: __spreadProps2(__spreadValues2({}, platform), {
        getOffsetParent: getOffsetParent2
      })
    }).then(({ x: x2, y: y3, middlewareData, placement }) => {
      const isRtl = getComputedStyle(this).direction === "rtl";
      const staticSide = { top: "bottom", right: "left", bottom: "top", left: "right" }[placement.split("-")[0]];
      this.setAttribute("data-current-placement", placement);
      Object.assign(this.popup.style, {
        left: `${x2}px`,
        top: `${y3}px`
      });
      if (this.arrow) {
        const arrowX = middlewareData.arrow.x;
        const arrowY = middlewareData.arrow.y;
        let top = "";
        let right = "";
        let bottom = "";
        let left = "";
        if (this.arrowPlacement === "start") {
          const value = typeof arrowX === "number" ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))` : "";
          top = typeof arrowY === "number" ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))` : "";
          right = isRtl ? value : "";
          left = isRtl ? "" : value;
        } else if (this.arrowPlacement === "end") {
          const value = typeof arrowX === "number" ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))` : "";
          right = isRtl ? "" : value;
          left = isRtl ? value : "";
          bottom = typeof arrowY === "number" ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))` : "";
        } else if (this.arrowPlacement === "center") {
          left = typeof arrowX === "number" ? `calc(50% - var(--arrow-size-diagonal))` : "";
          top = typeof arrowY === "number" ? `calc(50% - var(--arrow-size-diagonal))` : "";
        } else {
          left = typeof arrowX === "number" ? `${arrowX}px` : "";
          top = typeof arrowY === "number" ? `${arrowY}px` : "";
        }
        Object.assign(this.arrowEl.style, {
          top,
          right,
          bottom,
          left,
          [staticSide]: "calc(var(--arrow-size-diagonal) * -1)"
        });
      }
    });
    requestAnimationFrame(() => this.updateHoverBridge());
    this.emit("sl-reposition");
  }
  render() {
    return x`
      <slot name="anchor" @slotchange=${this.handleAnchorChange}></slot>

      <span
        part="hover-bridge"
        class=${e7({
      "popup-hover-bridge": true,
      "popup-hover-bridge--visible": this.hoverBridge && this.active
    })}
      ></span>

      <div
        part="popup"
        class=${e7({
      popup: true,
      "popup--active": this.active,
      "popup--fixed": this.strategy === "fixed",
      "popup--has-arrow": this.arrow
    })}
      >
        <slot></slot>
        ${this.arrow ? x`<div part="arrow" class="popup__arrow" role="presentation"></div>` : ""}
      </div>
    `;
  }
};
SlPopup.styles = [component_styles_default, popup_styles_default];
__decorateClass([
  e5(".popup")
], SlPopup.prototype, "popup", 2);
__decorateClass([
  e5(".popup__arrow")
], SlPopup.prototype, "arrowEl", 2);
__decorateClass([
  n4()
], SlPopup.prototype, "anchor", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlPopup.prototype, "active", 2);
__decorateClass([
  n4({ reflect: true })
], SlPopup.prototype, "placement", 2);
__decorateClass([
  n4({ reflect: true })
], SlPopup.prototype, "strategy", 2);
__decorateClass([
  n4({ type: Number })
], SlPopup.prototype, "distance", 2);
__decorateClass([
  n4({ type: Number })
], SlPopup.prototype, "skidding", 2);
__decorateClass([
  n4({ type: Boolean })
], SlPopup.prototype, "arrow", 2);
__decorateClass([
  n4({ attribute: "arrow-placement" })
], SlPopup.prototype, "arrowPlacement", 2);
__decorateClass([
  n4({ attribute: "arrow-padding", type: Number })
], SlPopup.prototype, "arrowPadding", 2);
__decorateClass([
  n4({ type: Boolean })
], SlPopup.prototype, "flip", 2);
__decorateClass([
  n4({
    attribute: "flip-fallback-placements",
    converter: {
      fromAttribute: (value) => {
        return value.split(" ").map((p3) => p3.trim()).filter((p3) => p3 !== "");
      },
      toAttribute: (value) => {
        return value.join(" ");
      }
    }
  })
], SlPopup.prototype, "flipFallbackPlacements", 2);
__decorateClass([
  n4({ attribute: "flip-fallback-strategy" })
], SlPopup.prototype, "flipFallbackStrategy", 2);
__decorateClass([
  n4({ type: Object })
], SlPopup.prototype, "flipBoundary", 2);
__decorateClass([
  n4({ attribute: "flip-padding", type: Number })
], SlPopup.prototype, "flipPadding", 2);
__decorateClass([
  n4({ type: Boolean })
], SlPopup.prototype, "shift", 2);
__decorateClass([
  n4({ type: Object })
], SlPopup.prototype, "shiftBoundary", 2);
__decorateClass([
  n4({ attribute: "shift-padding", type: Number })
], SlPopup.prototype, "shiftPadding", 2);
__decorateClass([
  n4({ attribute: "auto-size" })
], SlPopup.prototype, "autoSize", 2);
__decorateClass([
  n4()
], SlPopup.prototype, "sync", 2);
__decorateClass([
  n4({ type: Object })
], SlPopup.prototype, "autoSizeBoundary", 2);
__decorateClass([
  n4({ attribute: "auto-size-padding", type: Number })
], SlPopup.prototype, "autoSizePadding", 2);
__decorateClass([
  n4({ attribute: "hover-bridge", type: Boolean })
], SlPopup.prototype, "hoverBridge", 2);

// node_modules/@shoelace-style/shoelace/dist/chunks/chunk.DHU6MIVB.js
var defaultAnimationRegistry = /* @__PURE__ */ new Map();
var customAnimationRegistry = /* @__PURE__ */ new WeakMap();
function ensureAnimation(animation) {
  return animation != null ? animation : { keyframes: [], options: { duration: 0 } };
}
function getLogicalAnimation(animation, dir) {
  if (dir.toLowerCase() === "rtl") {
    return {
      keyframes: animation.rtlKeyframes || animation.keyframes,
      options: animation.options
    };
  }
  return animation;
}
function setDefaultAnimation(animationName, animation) {
  defaultAnimationRegistry.set(animationName, ensureAnimation(animation));
}
function getAnimation(el, animationName, options) {
  const customAnimation = customAnimationRegistry.get(el);
  if (customAnimation == null ? void 0 : customAnimation[animationName]) {
    return getLogicalAnimation(customAnimation[animationName], options.dir);
  }
  const defaultAnimation = defaultAnimationRegistry.get(animationName);
  if (defaultAnimation) {
    return getLogicalAnimation(defaultAnimation, options.dir);
  }
  return {
    keyframes: [],
    options: { duration: 0 }
  };
}

// node_modules/@shoelace-style/shoelace/dist/chunks/chunk.B4BZKR24.js
function waitForEvent(el, eventName) {
  return new Promise((resolve) => {
    function done(event2) {
      if (event2.target === el) {
        el.removeEventListener(eventName, done);
        resolve();
      }
    }
    el.addEventListener(eventName, done);
  });
}

// node_modules/@shoelace-style/shoelace/dist/chunks/chunk.LHI6QEL2.js
function animateTo(el, keyframes, options) {
  return new Promise((resolve) => {
    if ((options == null ? void 0 : options.duration) === Infinity) {
      throw new Error("Promise-based animations must be finite.");
    }
    const animation = el.animate(keyframes, __spreadProps2(__spreadValues2({}, options), {
      duration: prefersReducedMotion() ? 0 : options.duration
    }));
    animation.addEventListener("cancel", resolve, { once: true });
    animation.addEventListener("finish", resolve, { once: true });
  });
}
function prefersReducedMotion() {
  const query = window.matchMedia("(prefers-reduced-motion: reduce)");
  return query.matches;
}
function stopAnimations(el) {
  return Promise.all(
    el.getAnimations().map((animation) => {
      return new Promise((resolve) => {
        animation.cancel();
        requestAnimationFrame(resolve);
      });
    })
  );
}

// node_modules/lit-html/directives/unsafe-html.js
var e10 = class extends i4 {
  constructor(i6) {
    if (super(i6), this.it = T, i6.type !== t5.CHILD) throw Error(this.constructor.directiveName + "() can only be used in child bindings");
  }
  render(r9) {
    if (r9 === T || null == r9) return this._t = void 0, this.it = r9;
    if (r9 === w) return r9;
    if ("string" != typeof r9) throw Error(this.constructor.directiveName + "() called with a non-string value");
    if (r9 === this.it) return this._t;
    this.it = r9;
    const s9 = [r9];
    return s9.raw = s9, this._t = { _$litType$: this.constructor.resultType, strings: s9, values: [] };
  }
};
e10.directiveName = "unsafeHTML", e10.resultType = 1;
var o8 = e6(e10);

// node_modules/@shoelace-style/shoelace/dist/chunks/chunk.IMHWGJEP.js
var SlSelect = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.formControlController = new FormControlController(this, {
      assumeInteractionOn: ["sl-blur", "sl-input"]
    });
    this.hasSlotController = new HasSlotController(this, "help-text", "label");
    this.localize = new LocalizeController2(this);
    this.typeToSelectString = "";
    this.hasFocus = false;
    this.displayLabel = "";
    this.selectedOptions = [];
    this.name = "";
    this.value = "";
    this.defaultValue = "";
    this.size = "medium";
    this.placeholder = "";
    this.multiple = false;
    this.maxOptionsVisible = 3;
    this.disabled = false;
    this.clearable = false;
    this.open = false;
    this.hoist = false;
    this.filled = false;
    this.pill = false;
    this.label = "";
    this.placement = "bottom";
    this.helpText = "";
    this.form = "";
    this.required = false;
    this.getTag = (option) => {
      return x`
      <sl-tag
        part="tag"
        exportparts="
              base:tag__base,
              content:tag__content,
              remove-button:tag__remove-button,
              remove-button__base:tag__remove-button__base
            "
        ?pill=${this.pill}
        size=${this.size}
        removable
        @sl-remove=${(event2) => this.handleTagRemove(event2, option)}
      >
        ${option.getTextLabel()}
      </sl-tag>
    `;
    };
    this.handleDocumentFocusIn = (event2) => {
      const path = event2.composedPath();
      if (this && !path.includes(this)) {
        this.hide();
      }
    };
    this.handleDocumentKeyDown = (event2) => {
      const target = event2.target;
      const isClearButton = target.closest(".select__clear") !== null;
      const isIconButton = target.closest("sl-icon-button") !== null;
      if (isClearButton || isIconButton) {
        return;
      }
      if (event2.key === "Escape" && this.open && !this.closeWatcher) {
        event2.preventDefault();
        event2.stopPropagation();
        this.hide();
        this.displayInput.focus({ preventScroll: true });
      }
      if (event2.key === "Enter" || event2.key === " " && this.typeToSelectString === "") {
        event2.preventDefault();
        event2.stopImmediatePropagation();
        if (!this.open) {
          this.show();
          return;
        }
        if (this.currentOption && !this.currentOption.disabled) {
          if (this.multiple) {
            this.toggleOptionSelection(this.currentOption);
          } else {
            this.setSelectedOptions(this.currentOption);
          }
          this.updateComplete.then(() => {
            this.emit("sl-input");
            this.emit("sl-change");
          });
          if (!this.multiple) {
            this.hide();
            this.displayInput.focus({ preventScroll: true });
          }
        }
        return;
      }
      if (["ArrowUp", "ArrowDown", "Home", "End"].includes(event2.key)) {
        const allOptions = this.getAllOptions();
        const currentIndex = allOptions.indexOf(this.currentOption);
        let newIndex = Math.max(0, currentIndex);
        event2.preventDefault();
        if (!this.open) {
          this.show();
          if (this.currentOption) {
            return;
          }
        }
        if (event2.key === "ArrowDown") {
          newIndex = currentIndex + 1;
          if (newIndex > allOptions.length - 1)
            newIndex = 0;
        } else if (event2.key === "ArrowUp") {
          newIndex = currentIndex - 1;
          if (newIndex < 0)
            newIndex = allOptions.length - 1;
        } else if (event2.key === "Home") {
          newIndex = 0;
        } else if (event2.key === "End") {
          newIndex = allOptions.length - 1;
        }
        this.setCurrentOption(allOptions[newIndex]);
      }
      if (event2.key.length === 1 || event2.key === "Backspace") {
        const allOptions = this.getAllOptions();
        if (event2.metaKey || event2.ctrlKey || event2.altKey) {
          return;
        }
        if (!this.open) {
          if (event2.key === "Backspace") {
            return;
          }
          this.show();
        }
        event2.stopPropagation();
        event2.preventDefault();
        clearTimeout(this.typeToSelectTimeout);
        this.typeToSelectTimeout = window.setTimeout(() => this.typeToSelectString = "", 1e3);
        if (event2.key === "Backspace") {
          this.typeToSelectString = this.typeToSelectString.slice(0, -1);
        } else {
          this.typeToSelectString += event2.key.toLowerCase();
        }
        for (const option of allOptions) {
          const label = option.getTextLabel().toLowerCase();
          if (label.startsWith(this.typeToSelectString)) {
            this.setCurrentOption(option);
            break;
          }
        }
      }
    };
    this.handleDocumentMouseDown = (event2) => {
      const path = event2.composedPath();
      if (this && !path.includes(this)) {
        this.hide();
      }
    };
  }
  /** Gets the validity state object */
  get validity() {
    return this.valueInput.validity;
  }
  /** Gets the validation message */
  get validationMessage() {
    return this.valueInput.validationMessage;
  }
  connectedCallback() {
    super.connectedCallback();
    this.open = false;
  }
  addOpenListeners() {
    var _a9;
    document.addEventListener("focusin", this.handleDocumentFocusIn);
    document.addEventListener("keydown", this.handleDocumentKeyDown);
    document.addEventListener("mousedown", this.handleDocumentMouseDown);
    if (this.getRootNode() !== document) {
      this.getRootNode().addEventListener("focusin", this.handleDocumentFocusIn);
    }
    if ("CloseWatcher" in window) {
      (_a9 = this.closeWatcher) == null ? void 0 : _a9.destroy();
      this.closeWatcher = new CloseWatcher();
      this.closeWatcher.onclose = () => {
        if (this.open) {
          this.hide();
          this.displayInput.focus({ preventScroll: true });
        }
      };
    }
  }
  removeOpenListeners() {
    var _a9;
    document.removeEventListener("focusin", this.handleDocumentFocusIn);
    document.removeEventListener("keydown", this.handleDocumentKeyDown);
    document.removeEventListener("mousedown", this.handleDocumentMouseDown);
    if (this.getRootNode() !== document) {
      this.getRootNode().removeEventListener("focusin", this.handleDocumentFocusIn);
    }
    (_a9 = this.closeWatcher) == null ? void 0 : _a9.destroy();
  }
  handleFocus() {
    this.hasFocus = true;
    this.displayInput.setSelectionRange(0, 0);
    this.emit("sl-focus");
  }
  handleBlur() {
    this.hasFocus = false;
    this.emit("sl-blur");
  }
  handleLabelClick() {
    this.displayInput.focus();
  }
  handleComboboxMouseDown(event2) {
    const path = event2.composedPath();
    const isIconButton = path.some((el) => el instanceof Element && el.tagName.toLowerCase() === "sl-icon-button");
    if (this.disabled || isIconButton) {
      return;
    }
    event2.preventDefault();
    this.displayInput.focus({ preventScroll: true });
    this.open = !this.open;
  }
  handleComboboxKeyDown(event2) {
    if (event2.key === "Tab") {
      return;
    }
    event2.stopPropagation();
    this.handleDocumentKeyDown(event2);
  }
  handleClearClick(event2) {
    event2.stopPropagation();
    if (this.value !== "") {
      this.setSelectedOptions([]);
      this.displayInput.focus({ preventScroll: true });
      this.updateComplete.then(() => {
        this.emit("sl-clear");
        this.emit("sl-input");
        this.emit("sl-change");
      });
    }
  }
  handleClearMouseDown(event2) {
    event2.stopPropagation();
    event2.preventDefault();
  }
  handleOptionClick(event2) {
    const target = event2.target;
    const option = target.closest("sl-option");
    const oldValue = this.value;
    if (option && !option.disabled) {
      if (this.multiple) {
        this.toggleOptionSelection(option);
      } else {
        this.setSelectedOptions(option);
      }
      this.updateComplete.then(() => this.displayInput.focus({ preventScroll: true }));
      if (this.value !== oldValue) {
        this.updateComplete.then(() => {
          this.emit("sl-input");
          this.emit("sl-change");
        });
      }
      if (!this.multiple) {
        this.hide();
        this.displayInput.focus({ preventScroll: true });
      }
    }
  }
  handleDefaultSlotChange() {
    const allOptions = this.getAllOptions();
    const value = Array.isArray(this.value) ? this.value : [this.value];
    const values = [];
    if (customElements.get("sl-option")) {
      allOptions.forEach((option) => values.push(option.value));
      this.setSelectedOptions(allOptions.filter((el) => value.includes(el.value)));
    } else {
      customElements.whenDefined("sl-option").then(() => this.handleDefaultSlotChange());
    }
  }
  handleTagRemove(event2, option) {
    event2.stopPropagation();
    if (!this.disabled) {
      this.toggleOptionSelection(option, false);
      this.updateComplete.then(() => {
        this.emit("sl-input");
        this.emit("sl-change");
      });
    }
  }
  // Gets an array of all <sl-option> elements
  getAllOptions() {
    return [...this.querySelectorAll("sl-option")];
  }
  // Gets the first <sl-option> element
  getFirstOption() {
    return this.querySelector("sl-option");
  }
  // Sets the current option, which is the option the user is currently interacting with (e.g. via keyboard). Only one
  // option may be "current" at a time.
  setCurrentOption(option) {
    const allOptions = this.getAllOptions();
    allOptions.forEach((el) => {
      el.current = false;
      el.tabIndex = -1;
    });
    if (option) {
      this.currentOption = option;
      option.current = true;
      option.tabIndex = 0;
      option.focus();
    }
  }
  // Sets the selected option(s)
  setSelectedOptions(option) {
    const allOptions = this.getAllOptions();
    const newSelectedOptions = Array.isArray(option) ? option : [option];
    allOptions.forEach((el) => el.selected = false);
    if (newSelectedOptions.length) {
      newSelectedOptions.forEach((el) => el.selected = true);
    }
    this.selectionChanged();
  }
  // Toggles an option's selected state
  toggleOptionSelection(option, force) {
    if (force === true || force === false) {
      option.selected = force;
    } else {
      option.selected = !option.selected;
    }
    this.selectionChanged();
  }
  // This method must be called whenever the selection changes. It will update the selected options cache, the current
  // value, and the display value
  selectionChanged() {
    var _a9, _b2, _c, _d;
    this.selectedOptions = this.getAllOptions().filter((el) => el.selected);
    if (this.multiple) {
      this.value = this.selectedOptions.map((el) => el.value);
      if (this.placeholder && this.value.length === 0) {
        this.displayLabel = "";
      } else {
        this.displayLabel = this.localize.term("numOptionsSelected", this.selectedOptions.length);
      }
    } else {
      this.value = (_b2 = (_a9 = this.selectedOptions[0]) == null ? void 0 : _a9.value) != null ? _b2 : "";
      this.displayLabel = (_d = (_c = this.selectedOptions[0]) == null ? void 0 : _c.getTextLabel()) != null ? _d : "";
    }
    this.updateComplete.then(() => {
      this.formControlController.updateValidity();
    });
  }
  get tags() {
    return this.selectedOptions.map((option, index2) => {
      if (index2 < this.maxOptionsVisible || this.maxOptionsVisible <= 0) {
        const tag = this.getTag(option, index2);
        return x`<div @sl-remove=${(e13) => this.handleTagRemove(e13, option)}>
          ${typeof tag === "string" ? o8(tag) : tag}
        </div>`;
      } else if (index2 === this.maxOptionsVisible) {
        return x`<sl-tag size=${this.size}>+${this.selectedOptions.length - index2}</sl-tag>`;
      }
      return x``;
    });
  }
  handleInvalid(event2) {
    this.formControlController.setValidity(false);
    this.formControlController.emitInvalidEvent(event2);
  }
  handleDisabledChange() {
    if (this.disabled) {
      this.open = false;
      this.handleOpenChange();
    }
  }
  handleValueChange() {
    const allOptions = this.getAllOptions();
    const value = Array.isArray(this.value) ? this.value : [this.value];
    this.setSelectedOptions(allOptions.filter((el) => value.includes(el.value)));
  }
  handleOpenChange() {
    return __async(this, null, function* () {
      if (this.open && !this.disabled) {
        this.setCurrentOption(this.selectedOptions[0] || this.getFirstOption());
        this.emit("sl-show");
        this.addOpenListeners();
        yield stopAnimations(this);
        this.listbox.hidden = false;
        this.popup.active = true;
        requestAnimationFrame(() => {
          this.setCurrentOption(this.currentOption);
        });
        const { keyframes, options } = getAnimation(this, "select.show", { dir: this.localize.dir() });
        yield animateTo(this.popup.popup, keyframes, options);
        if (this.currentOption) {
          scrollIntoView(this.currentOption, this.listbox, "vertical", "auto");
        }
        this.emit("sl-after-show");
      } else {
        this.emit("sl-hide");
        this.removeOpenListeners();
        yield stopAnimations(this);
        const { keyframes, options } = getAnimation(this, "select.hide", { dir: this.localize.dir() });
        yield animateTo(this.popup.popup, keyframes, options);
        this.listbox.hidden = true;
        this.popup.active = false;
        this.emit("sl-after-hide");
      }
    });
  }
  /** Shows the listbox. */
  show() {
    return __async(this, null, function* () {
      if (this.open || this.disabled) {
        this.open = false;
        return void 0;
      }
      this.open = true;
      return waitForEvent(this, "sl-after-show");
    });
  }
  /** Hides the listbox. */
  hide() {
    return __async(this, null, function* () {
      if (!this.open || this.disabled) {
        this.open = false;
        return void 0;
      }
      this.open = false;
      return waitForEvent(this, "sl-after-hide");
    });
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    return this.valueInput.checkValidity();
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    return this.valueInput.reportValidity();
  }
  /** Sets a custom validation message. Pass an empty string to restore validity. */
  setCustomValidity(message) {
    this.valueInput.setCustomValidity(message);
    this.formControlController.updateValidity();
  }
  /** Sets focus on the control. */
  focus(options) {
    this.displayInput.focus(options);
  }
  /** Removes focus from the control. */
  blur() {
    this.displayInput.blur();
  }
  render() {
    const hasLabelSlot = this.hasSlotController.test("label");
    const hasHelpTextSlot = this.hasSlotController.test("help-text");
    const hasLabel = this.label ? true : !!hasLabelSlot;
    const hasHelpText = this.helpText ? true : !!hasHelpTextSlot;
    const hasClearIcon = this.clearable && !this.disabled && this.value.length > 0;
    const isPlaceholderVisible = this.placeholder && this.value.length === 0;
    return x`
      <div
        part="form-control"
        class=${e7({
      "form-control": true,
      "form-control--small": this.size === "small",
      "form-control--medium": this.size === "medium",
      "form-control--large": this.size === "large",
      "form-control--has-label": hasLabel,
      "form-control--has-help-text": hasHelpText
    })}
      >
        <label
          id="label"
          part="form-control-label"
          class="form-control__label"
          aria-hidden=${hasLabel ? "false" : "true"}
          @click=${this.handleLabelClick}
        >
          <slot name="label">${this.label}</slot>
        </label>

        <div part="form-control-input" class="form-control-input">
          <sl-popup
            class=${e7({
      select: true,
      "select--standard": true,
      "select--filled": this.filled,
      "select--pill": this.pill,
      "select--open": this.open,
      "select--disabled": this.disabled,
      "select--multiple": this.multiple,
      "select--focused": this.hasFocus,
      "select--placeholder-visible": isPlaceholderVisible,
      "select--top": this.placement === "top",
      "select--bottom": this.placement === "bottom",
      "select--small": this.size === "small",
      "select--medium": this.size === "medium",
      "select--large": this.size === "large"
    })}
            placement=${this.placement}
            strategy=${this.hoist ? "fixed" : "absolute"}
            flip
            shift
            sync="width"
            auto-size="vertical"
            auto-size-padding="10"
          >
            <div
              part="combobox"
              class="select__combobox"
              slot="anchor"
              @keydown=${this.handleComboboxKeyDown}
              @mousedown=${this.handleComboboxMouseDown}
            >
              <slot part="prefix" name="prefix" class="select__prefix"></slot>

              <input
                part="display-input"
                class="select__display-input"
                type="text"
                placeholder=${this.placeholder}
                .disabled=${this.disabled}
                .value=${this.displayLabel}
                autocomplete="off"
                spellcheck="false"
                autocapitalize="off"
                readonly
                aria-controls="listbox"
                aria-expanded=${this.open ? "true" : "false"}
                aria-haspopup="listbox"
                aria-labelledby="label"
                aria-disabled=${this.disabled ? "true" : "false"}
                aria-describedby="help-text"
                role="combobox"
                tabindex="0"
                @focus=${this.handleFocus}
                @blur=${this.handleBlur}
              />

              ${this.multiple ? x`<div part="tags" class="select__tags">${this.tags}</div>` : ""}

              <input
                class="select__value-input"
                type="text"
                ?disabled=${this.disabled}
                ?required=${this.required}
                .value=${Array.isArray(this.value) ? this.value.join(", ") : this.value}
                tabindex="-1"
                aria-hidden="true"
                @focus=${() => this.focus()}
                @invalid=${this.handleInvalid}
              />

              ${hasClearIcon ? x`
                    <button
                      part="clear-button"
                      class="select__clear"
                      type="button"
                      aria-label=${this.localize.term("clearEntry")}
                      @mousedown=${this.handleClearMouseDown}
                      @click=${this.handleClearClick}
                      tabindex="-1"
                    >
                      <slot name="clear-icon">
                        <sl-icon name="x-circle-fill" library="system"></sl-icon>
                      </slot>
                    </button>
                  ` : ""}

              <slot name="expand-icon" part="expand-icon" class="select__expand-icon">
                <sl-icon library="system" name="chevron-down"></sl-icon>
              </slot>
            </div>

            <div
              id="listbox"
              role="listbox"
              aria-expanded=${this.open ? "true" : "false"}
              aria-multiselectable=${this.multiple ? "true" : "false"}
              aria-labelledby="label"
              part="listbox"
              class="select__listbox"
              tabindex="-1"
              @mouseup=${this.handleOptionClick}
              @slotchange=${this.handleDefaultSlotChange}
            >
              <slot></slot>
            </div>
          </sl-popup>
        </div>

        <div
          part="form-control-help-text"
          id="help-text"
          class="form-control__help-text"
          aria-hidden=${hasHelpText ? "false" : "true"}
        >
          <slot name="help-text">${this.helpText}</slot>
        </div>
      </div>
    `;
  }
};
SlSelect.styles = [component_styles_default, form_control_styles_default, select_styles_default];
SlSelect.dependencies = {
  "sl-icon": SlIcon,
  "sl-popup": SlPopup,
  "sl-tag": SlTag
};
__decorateClass([
  e5(".select")
], SlSelect.prototype, "popup", 2);
__decorateClass([
  e5(".select__combobox")
], SlSelect.prototype, "combobox", 2);
__decorateClass([
  e5(".select__display-input")
], SlSelect.prototype, "displayInput", 2);
__decorateClass([
  e5(".select__value-input")
], SlSelect.prototype, "valueInput", 2);
__decorateClass([
  e5(".select__listbox")
], SlSelect.prototype, "listbox", 2);
__decorateClass([
  r6()
], SlSelect.prototype, "hasFocus", 2);
__decorateClass([
  r6()
], SlSelect.prototype, "displayLabel", 2);
__decorateClass([
  r6()
], SlSelect.prototype, "currentOption", 2);
__decorateClass([
  r6()
], SlSelect.prototype, "selectedOptions", 2);
__decorateClass([
  n4()
], SlSelect.prototype, "name", 2);
__decorateClass([
  n4({
    converter: {
      fromAttribute: (value) => value.split(" "),
      toAttribute: (value) => value.join(" ")
    }
  })
], SlSelect.prototype, "value", 2);
__decorateClass([
  defaultValue()
], SlSelect.prototype, "defaultValue", 2);
__decorateClass([
  n4({ reflect: true })
], SlSelect.prototype, "size", 2);
__decorateClass([
  n4()
], SlSelect.prototype, "placeholder", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlSelect.prototype, "multiple", 2);
__decorateClass([
  n4({ attribute: "max-options-visible", type: Number })
], SlSelect.prototype, "maxOptionsVisible", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlSelect.prototype, "disabled", 2);
__decorateClass([
  n4({ type: Boolean })
], SlSelect.prototype, "clearable", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlSelect.prototype, "open", 2);
__decorateClass([
  n4({ type: Boolean })
], SlSelect.prototype, "hoist", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlSelect.prototype, "filled", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlSelect.prototype, "pill", 2);
__decorateClass([
  n4()
], SlSelect.prototype, "label", 2);
__decorateClass([
  n4({ reflect: true })
], SlSelect.prototype, "placement", 2);
__decorateClass([
  n4({ attribute: "help-text" })
], SlSelect.prototype, "helpText", 2);
__decorateClass([
  n4({ reflect: true })
], SlSelect.prototype, "form", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlSelect.prototype, "required", 2);
__decorateClass([
  n4()
], SlSelect.prototype, "getTag", 2);
__decorateClass([
  watch("disabled", { waitUntilFirstUpdate: true })
], SlSelect.prototype, "handleDisabledChange", 1);
__decorateClass([
  watch("value", { waitUntilFirstUpdate: true })
], SlSelect.prototype, "handleValueChange", 1);
__decorateClass([
  watch("open", { waitUntilFirstUpdate: true })
], SlSelect.prototype, "handleOpenChange", 1);
setDefaultAnimation("select.show", {
  keyframes: [
    { opacity: 0, scale: 0.9 },
    { opacity: 1, scale: 1 }
  ],
  options: { duration: 100, easing: "ease" }
});
setDefaultAnimation("select.hide", {
  keyframes: [
    { opacity: 1, scale: 1 },
    { opacity: 0, scale: 0.9 }
  ],
  options: { duration: 100, easing: "ease" }
});

// node_modules/@shoelace-style/shoelace/dist/chunks/chunk.EKFQULHE.js
SlSelect.define("sl-select");

// node_modules/@shoelace-style/shoelace/dist/chunks/chunk.FXXKMG2P.js
var option_styles_default = i`
  :host {
    display: block;
    user-select: none;
    -webkit-user-select: none;
  }

  :host(:focus) {
    outline: none;
  }

  .option {
    position: relative;
    display: flex;
    align-items: center;
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-medium);
    font-weight: var(--sl-font-weight-normal);
    line-height: var(--sl-line-height-normal);
    letter-spacing: var(--sl-letter-spacing-normal);
    color: var(--sl-color-neutral-700);
    padding: var(--sl-spacing-x-small) var(--sl-spacing-medium) var(--sl-spacing-x-small) var(--sl-spacing-x-small);
    transition: var(--sl-transition-fast) fill;
    cursor: pointer;
  }

  .option--hover:not(.option--current):not(.option--disabled) {
    background-color: var(--sl-color-neutral-100);
    color: var(--sl-color-neutral-1000);
  }

  .option--current,
  .option--current.option--disabled {
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
    opacity: 1;
  }

  .option--disabled {
    outline: none;
    opacity: 0.5;
    cursor: not-allowed;
  }

  .option__label {
    flex: 1 1 auto;
    display: inline-block;
    line-height: var(--sl-line-height-dense);
  }

  .option .option__check {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    justify-content: center;
    visibility: hidden;
    padding-inline-end: var(--sl-spacing-2x-small);
  }

  .option--selected .option__check {
    visibility: visible;
  }

  .option__prefix,
  .option__suffix {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
  }

  .option__prefix::slotted(*) {
    margin-inline-end: var(--sl-spacing-x-small);
  }

  .option__suffix::slotted(*) {
    margin-inline-start: var(--sl-spacing-x-small);
  }

  @media (forced-colors: active) {
    :host(:hover:not([aria-disabled='true'])) .option {
      outline: dashed 1px SelectedItem;
      outline-offset: -1px;
    }
  }
`;

// node_modules/@shoelace-style/shoelace/dist/chunks/chunk.LKS3JKGH.js
var SlOption = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController2(this);
    this.current = false;
    this.selected = false;
    this.hasHover = false;
    this.value = "";
    this.disabled = false;
  }
  connectedCallback() {
    super.connectedCallback();
    this.setAttribute("role", "option");
    this.setAttribute("aria-selected", "false");
  }
  handleDefaultSlotChange() {
    const textLabel = this.getTextLabel();
    if (typeof this.cachedTextLabel === "undefined") {
      this.cachedTextLabel = textLabel;
      return;
    }
    if (textLabel !== this.cachedTextLabel) {
      this.cachedTextLabel = textLabel;
      this.emit("slotchange", { bubbles: true, composed: false, cancelable: false });
    }
  }
  handleMouseEnter() {
    this.hasHover = true;
  }
  handleMouseLeave() {
    this.hasHover = false;
  }
  handleDisabledChange() {
    this.setAttribute("aria-disabled", this.disabled ? "true" : "false");
  }
  handleSelectedChange() {
    this.setAttribute("aria-selected", this.selected ? "true" : "false");
  }
  handleValueChange() {
    if (typeof this.value !== "string") {
      this.value = String(this.value);
    }
    if (this.value.includes(" ")) {
      console.error(`Option values cannot include a space. All spaces have been replaced with underscores.`, this);
      this.value = this.value.replace(/ /g, "_");
    }
  }
  /** Returns a plain text label based on the option's content. */
  getTextLabel() {
    const nodes = this.childNodes;
    let label = "";
    [...nodes].forEach((node) => {
      if (node.nodeType === Node.ELEMENT_NODE) {
        if (!node.hasAttribute("slot")) {
          label += node.textContent;
        }
      }
      if (node.nodeType === Node.TEXT_NODE) {
        label += node.textContent;
      }
    });
    return label.trim();
  }
  render() {
    return x`
      <div
        part="base"
        class=${e7({
      option: true,
      "option--current": this.current,
      "option--disabled": this.disabled,
      "option--selected": this.selected,
      "option--hover": this.hasHover
    })}
        @mouseenter=${this.handleMouseEnter}
        @mouseleave=${this.handleMouseLeave}
      >
        <sl-icon part="checked-icon" class="option__check" name="check" library="system" aria-hidden="true"></sl-icon>
        <slot part="prefix" name="prefix" class="option__prefix"></slot>
        <slot part="label" class="option__label" @slotchange=${this.handleDefaultSlotChange}></slot>
        <slot part="suffix" name="suffix" class="option__suffix"></slot>
      </div>
    `;
  }
};
SlOption.styles = [component_styles_default, option_styles_default];
SlOption.dependencies = { "sl-icon": SlIcon };
__decorateClass([
  e5(".option__label")
], SlOption.prototype, "defaultSlot", 2);
__decorateClass([
  r6()
], SlOption.prototype, "current", 2);
__decorateClass([
  r6()
], SlOption.prototype, "selected", 2);
__decorateClass([
  r6()
], SlOption.prototype, "hasHover", 2);
__decorateClass([
  n4({ reflect: true })
], SlOption.prototype, "value", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlOption.prototype, "disabled", 2);
__decorateClass([
  watch("disabled")
], SlOption.prototype, "handleDisabledChange", 1);
__decorateClass([
  watch("selected")
], SlOption.prototype, "handleSelectedChange", 1);
__decorateClass([
  watch("value")
], SlOption.prototype, "handleValueChange", 1);

// node_modules/@shoelace-style/shoelace/dist/chunks/chunk.Q7QMGYJL.js
SlOption.define("sl-option");

// node_modules/lit-html/async-directive.js
var s5 = (i6, t9) => {
  var _a9;
  const e13 = i6._$AN;
  if (void 0 === e13) return false;
  for (const i7 of e13) (_a9 = i7._$AO) == null ? void 0 : _a9.call(i7, t9, false), s5(i7, t9);
  return true;
};
var o9 = (i6) => {
  let t9, e13;
  do {
    if (void 0 === (t9 = i6._$AM)) break;
    e13 = t9._$AN, e13.delete(i6), i6 = t9;
  } while (0 === (e13 == null ? void 0 : e13.size));
};
var r8 = (i6) => {
  for (let t9; t9 = i6._$AM; i6 = t9) {
    let e13 = t9._$AN;
    if (void 0 === e13) t9._$AN = e13 = /* @__PURE__ */ new Set();
    else if (e13.has(i6)) break;
    e13.add(i6), c4(t9);
  }
};
function h3(i6) {
  void 0 !== this._$AN ? (o9(this), this._$AM = i6, r8(this)) : this._$AM = i6;
}
function n6(i6, t9 = false, e13 = 0) {
  const r9 = this._$AH, h5 = this._$AN;
  if (void 0 !== h5 && 0 !== h5.size) if (t9) if (Array.isArray(r9)) for (let i7 = e13; i7 < r9.length; i7++) s5(r9[i7], false), o9(r9[i7]);
  else null != r9 && (s5(r9, false), o9(r9));
  else s5(this, i6);
}
var c4 = (i6) => {
  var _a9, _b2;
  i6.type == t5.CHILD && ((_a9 = i6._$AP) != null ? _a9 : i6._$AP = n6, (_b2 = i6._$AQ) != null ? _b2 : i6._$AQ = h3);
};
var f4 = class extends i4 {
  constructor() {
    super(...arguments), this._$AN = void 0;
  }
  _$AT(i6, t9, e13) {
    super._$AT(i6, t9, e13), r8(this), this.isConnected = i6._$AU;
  }
  _$AO(i6, t9 = true) {
    var _a9, _b2;
    i6 !== this.isConnected && (this.isConnected = i6, i6 ? (_a9 = this.reconnected) == null ? void 0 : _a9.call(this) : (_b2 = this.disconnected) == null ? void 0 : _b2.call(this)), t9 && (s5(this, i6), o9(this));
  }
  setValue(t9) {
    if (f3(this._$Ct)) this._$Ct._$AI(t9, this);
    else {
      const i6 = [...this._$Ct._$AH];
      i6[this._$Ci] = t9, this._$Ct._$AI(i6, this, 0);
    }
  }
  disconnected() {
  }
  reconnected() {
  }
};

// node_modules/lit-html/directives/ref.js
var e11 = () => new h4();
var h4 = class {
};
var o10 = /* @__PURE__ */ new WeakMap();
var n7 = e6(class extends f4 {
  render(i6) {
    return T;
  }
  update(i6, [s9]) {
    var _a9;
    const e13 = s9 !== this.Y;
    return e13 && void 0 !== this.Y && this.rt(void 0), (e13 || this.lt !== this.ct) && (this.Y = s9, this.ht = (_a9 = i6.options) == null ? void 0 : _a9.host, this.rt(this.ct = i6.element)), T;
  }
  rt(t9) {
    var _a9;
    if (this.isConnected || (t9 = void 0), "function" == typeof this.Y) {
      const i6 = (_a9 = this.ht) != null ? _a9 : globalThis;
      let s9 = o10.get(i6);
      void 0 === s9 && (s9 = /* @__PURE__ */ new WeakMap(), o10.set(i6, s9)), void 0 !== s9.get(this.Y) && this.Y.call(this.ht, void 0), s9.set(this.Y, t9), void 0 !== t9 && this.Y.call(this.ht, t9);
    } else this.Y.value = t9;
  }
  get lt() {
    var _a9, _b2, _c;
    return "function" == typeof this.Y ? (_b2 = o10.get((_a9 = this.ht) != null ? _a9 : globalThis)) == null ? void 0 : _b2.get(this.Y) : (_c = this.Y) == null ? void 0 : _c.value;
  }
  disconnected() {
    this.lt === this.ct && this.rt(void 0);
  }
  reconnected() {
    this.rt(this.ct);
  }
});

// node_modules/xstate/dev/dist/xstate-dev.esm.js
function getGlobal() {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
}
function getDevTools() {
  const w2 = getGlobal();
  if (!!w2.__xstate__) {
    return w2.__xstate__;
  }
  return void 0;
}
var devToolsAdapter = (service) => {
  if (typeof window === "undefined") {
    return;
  }
  const devTools = getDevTools();
  if (devTools) {
    devTools.register(service);
  }
};

// node_modules/xstate/dist/raise-cdf69ebb.esm.js
var Mailbox = class {
  constructor(_process) {
    this._process = _process;
    this._active = false;
    this._current = null;
    this._last = null;
  }
  start() {
    this._active = true;
    this.flush();
  }
  clear() {
    if (this._current) {
      this._current.next = null;
      this._last = this._current;
    }
  }
  enqueue(event2) {
    const enqueued = {
      value: event2,
      next: null
    };
    if (this._current) {
      this._last.next = enqueued;
      this._last = enqueued;
      return;
    }
    this._current = enqueued;
    this._last = enqueued;
    if (this._active) {
      this.flush();
    }
  }
  flush() {
    while (this._current) {
      const consumed = this._current;
      this._process(consumed.value);
      this._current = consumed.next;
    }
    this._last = null;
  }
};
var STATE_DELIMITER = ".";
var TARGETLESS_KEY = "";
var NULL_EVENT = "";
var STATE_IDENTIFIER = "#";
var WILDCARD = "*";
var XSTATE_INIT = "xstate.init";
var XSTATE_ERROR = "xstate.error";
var XSTATE_STOP = "xstate.stop";
function createAfterEvent(delayRef, id) {
  return {
    type: `xstate.after.${delayRef}.${id}`
  };
}
function createDoneStateEvent(id, output) {
  return {
    type: `xstate.done.state.${id}`,
    output
  };
}
function createDoneActorEvent(invokeId, output) {
  return {
    type: `xstate.done.actor.${invokeId}`,
    output
  };
}
function createErrorActorEvent(id, error) {
  return {
    type: `xstate.error.actor.${id}`,
    error
  };
}
function createInitEvent(input) {
  return {
    type: XSTATE_INIT,
    input
  };
}
function reportUnhandledError(err) {
  setTimeout(() => {
    throw err;
  });
}
var symbolObservable = (() => typeof Symbol === "function" && Symbol.observable || "@@observable")();
function createScheduledEventId(actorRef, id) {
  return `${actorRef.sessionId}.${id}`;
}
var idCounter = 0;
function createSystem(rootActor, options) {
  var _a9;
  const children = /* @__PURE__ */ new Map();
  const keyedActors = /* @__PURE__ */ new Map();
  const reverseKeyedActors = /* @__PURE__ */ new WeakMap();
  const observers = /* @__PURE__ */ new Set();
  const timerMap = {};
  const clock = options.clock;
  const scheduler = {
    schedule: (source, target, event2, delay, id = Math.random().toString(36).slice(2)) => {
      const scheduledEvent = {
        source,
        target,
        event: event2,
        delay,
        id,
        startedAt: Date.now()
      };
      const scheduledEventId = createScheduledEventId(source, id);
      system._snapshot._scheduledEvents[scheduledEventId] = scheduledEvent;
      const timeout = clock.setTimeout(() => {
        delete timerMap[scheduledEventId];
        delete system._snapshot._scheduledEvents[scheduledEventId];
        system._relay(source, target, event2);
      }, delay);
      timerMap[scheduledEventId] = timeout;
    },
    cancel: (source, id) => {
      const scheduledEventId = createScheduledEventId(source, id);
      const timeout = timerMap[scheduledEventId];
      delete timerMap[scheduledEventId];
      delete system._snapshot._scheduledEvents[scheduledEventId];
      clock.clearTimeout(timeout);
    },
    cancelAll: (actorRef) => {
      for (const scheduledEventId in system._snapshot._scheduledEvents) {
        const scheduledEvent = system._snapshot._scheduledEvents[scheduledEventId];
        if (scheduledEvent.source === actorRef) {
          scheduler.cancel(actorRef, scheduledEvent.id);
        }
      }
    }
  };
  const system = {
    _snapshot: {
      _scheduledEvents: (_a9 = (options == null ? void 0 : options.snapshot) && options.snapshot.scheduler) != null ? _a9 : {}
    },
    _bookId: () => `x:${idCounter++}`,
    _register: (sessionId, actorRef) => {
      children.set(sessionId, actorRef);
      return sessionId;
    },
    _unregister: (actorRef) => {
      children.delete(actorRef.sessionId);
      const systemId = reverseKeyedActors.get(actorRef);
      if (systemId !== void 0) {
        keyedActors.delete(systemId);
        reverseKeyedActors.delete(actorRef);
      }
    },
    get: (systemId) => {
      return keyedActors.get(systemId);
    },
    _set: (systemId, actorRef) => {
      const existing = keyedActors.get(systemId);
      if (existing && existing !== actorRef) {
        throw new Error(`Actor with system ID '${systemId}' already exists.`);
      }
      keyedActors.set(systemId, actorRef);
      reverseKeyedActors.set(actorRef, systemId);
    },
    inspect: (observer) => {
      observers.add(observer);
    },
    _sendInspectionEvent: (event2) => {
      const resolvedInspectionEvent = __spreadProps(__spreadValues({}, event2), {
        rootId: rootActor.sessionId
      });
      observers.forEach((observer) => {
        var _a10;
        return (_a10 = observer.next) == null ? void 0 : _a10.call(observer, resolvedInspectionEvent);
      });
    },
    _relay: (source, target, event2) => {
      system._sendInspectionEvent({
        type: "@xstate.event",
        sourceRef: source,
        actorRef: target,
        event: event2
      });
      target._send(event2);
    },
    scheduler,
    getSnapshot: () => {
      return {
        _scheduledEvents: __spreadValues({}, system._snapshot._scheduledEvents)
      };
    },
    start: () => {
      const scheduledEvets = system._snapshot._scheduledEvents;
      system._snapshot._scheduledEvents = {};
      for (const scheduledId in scheduledEvets) {
        const {
          source,
          target,
          event: event2,
          delay,
          id
        } = scheduledEvets[scheduledId];
        scheduler.schedule(source, target, event2, delay, id);
      }
    }
  };
  return system;
}
function matchesState(parentStateId, childStateId) {
  const parentStateValue = toStateValue(parentStateId);
  const childStateValue = toStateValue(childStateId);
  if (typeof childStateValue === "string") {
    if (typeof parentStateValue === "string") {
      return childStateValue === parentStateValue;
    }
    return false;
  }
  if (typeof parentStateValue === "string") {
    return parentStateValue in childStateValue;
  }
  return Object.keys(parentStateValue).every((key) => {
    if (!(key in childStateValue)) {
      return false;
    }
    return matchesState(parentStateValue[key], childStateValue[key]);
  });
}
function toStatePath(stateId) {
  if (isArray(stateId)) {
    return stateId;
  }
  let result = [];
  let segment = "";
  for (let i6 = 0; i6 < stateId.length; i6++) {
    const char = stateId.charCodeAt(i6);
    switch (char) {
      case 92:
        segment += stateId[i6 + 1];
        i6++;
        continue;
      case 46:
        result.push(segment);
        segment = "";
        continue;
    }
    segment += stateId[i6];
  }
  result.push(segment);
  return result;
}
function toStateValue(stateValue) {
  if (isMachineSnapshot(stateValue)) {
    return stateValue.value;
  }
  if (typeof stateValue !== "string") {
    return stateValue;
  }
  const statePath = toStatePath(stateValue);
  return pathToStateValue(statePath);
}
function pathToStateValue(statePath) {
  if (statePath.length === 1) {
    return statePath[0];
  }
  const value = {};
  let marker = value;
  for (let i6 = 0; i6 < statePath.length - 1; i6++) {
    if (i6 === statePath.length - 2) {
      marker[statePath[i6]] = statePath[i6 + 1];
    } else {
      const previous = marker;
      marker = {};
      previous[statePath[i6]] = marker;
    }
  }
  return value;
}
function mapValues(collection, iteratee) {
  const result = {};
  const collectionKeys = Object.keys(collection);
  for (let i6 = 0; i6 < collectionKeys.length; i6++) {
    const key = collectionKeys[i6];
    result[key] = iteratee(collection[key], key, collection, i6);
  }
  return result;
}
function toArrayStrict(value) {
  if (isArray(value)) {
    return value;
  }
  return [value];
}
function toArray(value) {
  if (value === void 0) {
    return [];
  }
  return toArrayStrict(value);
}
function resolveOutput(mapper, context, event2, self2) {
  if (typeof mapper === "function") {
    return mapper({
      context,
      event: event2,
      self: self2
    });
  }
  return mapper;
}
function isArray(value) {
  return Array.isArray(value);
}
function isErrorActorEvent(event2) {
  return event2.type.startsWith("xstate.error.actor");
}
function toTransitionConfigArray(configLike) {
  return toArrayStrict(configLike).map((transitionLike) => {
    if (typeof transitionLike === "undefined" || typeof transitionLike === "string") {
      return {
        target: transitionLike
      };
    }
    return transitionLike;
  });
}
function normalizeTarget(target) {
  if (target === void 0 || target === TARGETLESS_KEY) {
    return void 0;
  }
  return toArray(target);
}
function toObserver(nextHandler, errorHandler, completionHandler) {
  var _a9, _b2, _c;
  const isObserver = typeof nextHandler === "object";
  const self2 = isObserver ? nextHandler : void 0;
  return {
    next: (_a9 = isObserver ? nextHandler.next : nextHandler) == null ? void 0 : _a9.bind(self2),
    error: (_b2 = isObserver ? nextHandler.error : errorHandler) == null ? void 0 : _b2.bind(self2),
    complete: (_c = isObserver ? nextHandler.complete : completionHandler) == null ? void 0 : _c.bind(self2)
  };
}
function createInvokeId(stateNodeId, index2) {
  return `${index2}.${stateNodeId}`;
}
function resolveReferencedActor(machine, src) {
  const match = src.match(/^xstate\.invoke\.(\d+)\.(.*)/);
  if (!match) {
    return machine.implementations.actors[src];
  }
  const [, indexStr, nodeId] = match;
  const node = machine.getStateNodeById(nodeId);
  const invokeConfig = node.config.invoke;
  return (Array.isArray(invokeConfig) ? invokeConfig[indexStr] : invokeConfig).src;
}
var $$ACTOR_TYPE = 1;
var ProcessingStatus = /* @__PURE__ */ function(ProcessingStatus2) {
  ProcessingStatus2[ProcessingStatus2["NotStarted"] = 0] = "NotStarted";
  ProcessingStatus2[ProcessingStatus2["Running"] = 1] = "Running";
  ProcessingStatus2[ProcessingStatus2["Stopped"] = 2] = "Stopped";
  return ProcessingStatus2;
}({});
var defaultOptions = {
  clock: {
    setTimeout: (fn, ms) => {
      return setTimeout(fn, ms);
    },
    clearTimeout: (id) => {
      return clearTimeout(id);
    }
  },
  logger: console.log.bind(console),
  devTools: false
};
var Actor = class {
  /**
   * Creates a new actor instance for the given logic with the provided options, if any.
   *
   * @param logic The logic to create an actor from
   * @param options Actor options
   */
  constructor(logic, options) {
    var _a9, _b2;
    this.logic = logic;
    this._snapshot = void 0;
    this.clock = void 0;
    this.options = void 0;
    this.id = void 0;
    this.mailbox = new Mailbox(this._process.bind(this));
    this.observers = /* @__PURE__ */ new Set();
    this.logger = void 0;
    this._processingStatus = ProcessingStatus.NotStarted;
    this._parent = void 0;
    this._syncSnapshot = void 0;
    this.ref = void 0;
    this._actorScope = void 0;
    this._systemId = void 0;
    this.sessionId = void 0;
    this.system = void 0;
    this._doneEvent = void 0;
    this.src = void 0;
    this._deferred = [];
    const resolvedOptions = __spreadValues(__spreadValues({}, defaultOptions), options);
    const {
      clock,
      logger,
      parent,
      syncSnapshot,
      id,
      systemId,
      inspect
    } = resolvedOptions;
    this.system = parent ? parent.system : createSystem(this, {
      clock
    });
    if (inspect && !parent) {
      this.system.inspect(toObserver(inspect));
    }
    this.sessionId = this.system._bookId();
    this.id = id != null ? id : this.sessionId;
    this.logger = logger;
    this.clock = clock;
    this._parent = parent;
    this._syncSnapshot = syncSnapshot;
    this.options = resolvedOptions;
    this.src = (_a9 = resolvedOptions.src) != null ? _a9 : logic;
    this.ref = this;
    this._actorScope = {
      self: this,
      id: this.id,
      sessionId: this.sessionId,
      logger: this.logger,
      defer: (fn) => {
        this._deferred.push(fn);
      },
      system: this.system,
      stopChild: (child) => {
        if (child._parent !== this) {
          throw new Error(`Cannot stop child actor ${child.id} of ${this.id} because it is not a child`);
        }
        child._stop();
      }
    };
    this.send = this.send.bind(this);
    this.system._sendInspectionEvent({
      type: "@xstate.actor",
      actorRef: this
    });
    if (systemId) {
      this._systemId = systemId;
      this.system._set(systemId, this);
    }
    this._initState((_b2 = options == null ? void 0 : options.snapshot) != null ? _b2 : options == null ? void 0 : options.state);
    if (systemId && this._snapshot.status !== "active") {
      this.system._unregister(this);
    }
  }
  _initState(persistedState) {
    var _a9;
    try {
      this._snapshot = persistedState ? this.logic.restoreSnapshot ? this.logic.restoreSnapshot(persistedState, this._actorScope) : persistedState : this.logic.getInitialSnapshot(this._actorScope, (_a9 = this.options) == null ? void 0 : _a9.input);
    } catch (err) {
      this._snapshot = {
        status: "error",
        output: void 0,
        error: err
      };
    }
  }
  update(snapshot, event2) {
    var _a9, _b2;
    this._snapshot = snapshot;
    let deferredFn;
    while (deferredFn = this._deferred.shift()) {
      try {
        deferredFn();
      } catch (err) {
        this._deferred.length = 0;
        this._snapshot = __spreadProps(__spreadValues({}, snapshot), {
          status: "error",
          error: err
        });
      }
    }
    switch (this._snapshot.status) {
      case "active":
        for (const observer of this.observers) {
          try {
            (_a9 = observer.next) == null ? void 0 : _a9.call(observer, snapshot);
          } catch (err) {
            reportUnhandledError(err);
          }
        }
        break;
      case "done":
        for (const observer of this.observers) {
          try {
            (_b2 = observer.next) == null ? void 0 : _b2.call(observer, snapshot);
          } catch (err) {
            reportUnhandledError(err);
          }
        }
        this._stopProcedure();
        this._complete();
        this._doneEvent = createDoneActorEvent(this.id, this._snapshot.output);
        if (this._parent) {
          this.system._relay(this, this._parent, this._doneEvent);
        }
        break;
      case "error":
        this._error(this._snapshot.error);
        break;
    }
    this.system._sendInspectionEvent({
      type: "@xstate.snapshot",
      actorRef: this,
      event: event2,
      snapshot
    });
  }
  /**
   * Subscribe an observer to an actor’s snapshot values.
   *
   * @remarks
   * The observer will receive the actor’s snapshot value when it is emitted. The observer can be:
   * - A plain function that receives the latest snapshot, or
   * - An observer object whose `.next(snapshot)` method receives the latest snapshot
   *
   * @example
   * ```ts
   * // Observer as a plain function
   * const subscription = actor.subscribe((snapshot) => {
   *   console.log(snapshot);
   * });
   * ```
   *
   * @example
   * ```ts
   * // Observer as an object
   * const subscription = actor.subscribe({
   *   next(snapshot) {
   *     console.log(snapshot);
   *   },
   *   error(err) {
   *     // ...
   *   },
   *   complete() {
   *     // ...
   *   },
   * });
   * ```
   *
   * The return value of `actor.subscribe(observer)` is a subscription object that has an `.unsubscribe()` method. You can call `subscription.unsubscribe()` to unsubscribe the observer:
   *
   * @example
   * ```ts
   * const subscription = actor.subscribe((snapshot) => {
   *   // ...
   * });
   *
   * // Unsubscribe the observer
   * subscription.unsubscribe();
   * ```
   *
   * When the actor is stopped, all of its observers will automatically be unsubscribed.
   *
   * @param observer - Either a plain function that receives the latest snapshot, or an observer object whose `.next(snapshot)` method receives the latest snapshot
   */
  subscribe(nextListenerOrObserver, errorListener, completeListener) {
    var _a9;
    const observer = toObserver(nextListenerOrObserver, errorListener, completeListener);
    if (this._processingStatus !== ProcessingStatus.Stopped) {
      this.observers.add(observer);
    } else {
      switch (this._snapshot.status) {
        case "done":
          try {
            (_a9 = observer.complete) == null ? void 0 : _a9.call(observer);
          } catch (err) {
            reportUnhandledError(err);
          }
          break;
        case "error": {
          const err = this._snapshot.error;
          if (!observer.error) {
            reportUnhandledError(err);
          } else {
            try {
              observer.error(err);
            } catch (err2) {
              reportUnhandledError(err2);
            }
          }
          break;
        }
      }
    }
    return {
      unsubscribe: () => {
        this.observers.delete(observer);
      }
    };
  }
  /**
   * Starts the Actor from the initial state
   */
  start() {
    if (this._processingStatus === ProcessingStatus.Running) {
      return this;
    }
    if (this._syncSnapshot) {
      this.subscribe({
        next: (snapshot) => {
          if (snapshot.status === "active") {
            this.system._relay(this, this._parent, {
              type: `xstate.snapshot.${this.id}`,
              snapshot
            });
          }
        },
        error: () => {
        }
      });
    }
    this.system._register(this.sessionId, this);
    if (this._systemId) {
      this.system._set(this._systemId, this);
    }
    this._processingStatus = ProcessingStatus.Running;
    const initEvent = createInitEvent(this.options.input);
    this.system._sendInspectionEvent({
      type: "@xstate.event",
      sourceRef: this._parent,
      actorRef: this,
      event: initEvent
    });
    const status = this._snapshot.status;
    switch (status) {
      case "done":
        this.update(this._snapshot, initEvent);
        return this;
      case "error":
        this._error(this._snapshot.error);
        return this;
    }
    if (!this._parent) {
      this.system.start();
    }
    if (this.logic.start) {
      try {
        this.logic.start(this._snapshot, this._actorScope);
      } catch (err) {
        this._snapshot = __spreadProps(__spreadValues({}, this._snapshot), {
          status: "error",
          error: err
        });
        this._error(err);
        return this;
      }
    }
    this.update(this._snapshot, initEvent);
    if (this.options.devTools) {
      this.attachDevTools();
    }
    this.mailbox.start();
    return this;
  }
  _process(event2) {
    let nextState;
    let caughtError;
    try {
      nextState = this.logic.transition(this._snapshot, event2, this._actorScope);
    } catch (err) {
      caughtError = {
        err
      };
    }
    if (caughtError) {
      const {
        err
      } = caughtError;
      this._snapshot = __spreadProps(__spreadValues({}, this._snapshot), {
        status: "error",
        error: err
      });
      this._error(err);
      return;
    }
    this.update(nextState, event2);
    if (event2.type === XSTATE_STOP) {
      this._stopProcedure();
      this._complete();
    }
  }
  _stop() {
    if (this._processingStatus === ProcessingStatus.Stopped) {
      return this;
    }
    this.mailbox.clear();
    if (this._processingStatus === ProcessingStatus.NotStarted) {
      this._processingStatus = ProcessingStatus.Stopped;
      return this;
    }
    this.mailbox.enqueue({
      type: XSTATE_STOP
    });
    return this;
  }
  /**
   * Stops the Actor and unsubscribe all listeners.
   */
  stop() {
    if (this._parent) {
      throw new Error("A non-root actor cannot be stopped directly.");
    }
    return this._stop();
  }
  _complete() {
    var _a9;
    for (const observer of this.observers) {
      try {
        (_a9 = observer.complete) == null ? void 0 : _a9.call(observer);
      } catch (err) {
        reportUnhandledError(err);
      }
    }
    this.observers.clear();
  }
  _reportError(err) {
    if (!this.observers.size) {
      if (!this._parent) {
        reportUnhandledError(err);
      }
      return;
    }
    let reportError = false;
    for (const observer of this.observers) {
      const errorListener = observer.error;
      reportError || (reportError = !errorListener);
      try {
        errorListener == null ? void 0 : errorListener(err);
      } catch (err2) {
        reportUnhandledError(err2);
      }
    }
    this.observers.clear();
    if (reportError) {
      reportUnhandledError(err);
    }
  }
  _error(err) {
    this._stopProcedure();
    this._reportError(err);
    if (this._parent) {
      this.system._relay(this, this._parent, createErrorActorEvent(this.id, err));
    }
  }
  // TODO: atm children don't belong entirely to the actor so
  // in a way - it's not even super aware of them
  // so we can't stop them from here but we really should!
  // right now, they are being stopped within the machine's transition
  // but that could throw and leave us with "orphaned" active actors
  _stopProcedure() {
    if (this._processingStatus !== ProcessingStatus.Running) {
      return this;
    }
    this.system.scheduler.cancelAll(this);
    this.mailbox.clear();
    this.mailbox = new Mailbox(this._process.bind(this));
    this._processingStatus = ProcessingStatus.Stopped;
    this.system._unregister(this);
    return this;
  }
  /**
   * @internal
   */
  _send(event2) {
    if (this._processingStatus === ProcessingStatus.Stopped) {
      return;
    }
    this.mailbox.enqueue(event2);
  }
  /**
   * Sends an event to the running Actor to trigger a transition.
   *
   * @param event The event to send
   */
  send(event2) {
    this.system._relay(void 0, this, event2);
  }
  attachDevTools() {
    const {
      devTools
    } = this.options;
    if (devTools) {
      const resolvedDevToolsAdapter = typeof devTools === "function" ? devTools : devToolsAdapter;
      resolvedDevToolsAdapter(this);
    }
  }
  toJSON() {
    return {
      xstate$$type: $$ACTOR_TYPE,
      id: this.id
    };
  }
  /**
   * Obtain the internal state of the actor, which can be persisted.
   *
   * @remarks
   * The internal state can be persisted from any actor, not only machines.
   *
   * Note that the persisted state is not the same as the snapshot from {@link Actor.getSnapshot}. Persisted state represents the internal state of the actor, while snapshots represent the actor's last emitted value.
   *
   * Can be restored with {@link ActorOptions.state}
   *
   * @see https://stately.ai/docs/persistence
   */
  getPersistedSnapshot(options) {
    return this.logic.getPersistedSnapshot(this._snapshot, options);
  }
  [symbolObservable]() {
    return this;
  }
  /**
   * Read an actor’s snapshot synchronously.
   *
   * @remarks
   * The snapshot represent an actor's last emitted value.
   *
   * When an actor receives an event, its internal state may change.
   * An actor may emit a snapshot when a state transition occurs.
   *
   * Note that some actors, such as callback actors generated with `fromCallback`, will not emit snapshots.
   *
   * @see {@link Actor.subscribe} to subscribe to an actor’s snapshot values.
   * @see {@link Actor.getPersistedSnapshot} to persist the internal state of an actor (which is more than just a snapshot).
   */
  getSnapshot() {
    return this._snapshot;
  }
};
function createActor(logic, options) {
  return new Actor(logic, options);
}
function resolveCancel(_2, snapshot, actionArgs, actionParams, {
  sendId
}) {
  const resolvedSendId = typeof sendId === "function" ? sendId(actionArgs, actionParams) : sendId;
  return [snapshot, resolvedSendId];
}
function executeCancel(actorScope, resolvedSendId) {
  actorScope.defer(() => {
    actorScope.system.scheduler.cancel(actorScope.self, resolvedSendId);
  });
}
function cancel(sendId) {
  function cancel2(args, params) {
  }
  cancel2.type = "xstate.cancel";
  cancel2.sendId = sendId;
  cancel2.resolve = resolveCancel;
  cancel2.execute = executeCancel;
  return cancel2;
}
function resolveSpawn(actorScope, snapshot, actionArgs, _actionParams, {
  id,
  systemId,
  src,
  input,
  syncSnapshot
}) {
  const logic = typeof src === "string" ? resolveReferencedActor(snapshot.machine, src) : src;
  const resolvedId = typeof id === "function" ? id(actionArgs) : id;
  let actorRef;
  if (logic) {
    actorRef = createActor(logic, {
      id: resolvedId,
      src,
      parent: actorScope.self,
      syncSnapshot,
      systemId,
      input: typeof input === "function" ? input({
        context: snapshot.context,
        event: actionArgs.event,
        self: actorScope.self
      }) : input
    });
  }
  return [cloneMachineSnapshot(snapshot, {
    children: __spreadProps(__spreadValues({}, snapshot.children), {
      [resolvedId]: actorRef
    })
  }), {
    id,
    actorRef
  }];
}
function executeSpawn(actorScope, {
  id,
  actorRef
}) {
  if (!actorRef) {
    return;
  }
  actorScope.defer(() => {
    if (actorRef._processingStatus === ProcessingStatus.Stopped) {
      return;
    }
    actorRef.start();
  });
}
function spawnChild(...[src, {
  id,
  systemId,
  input,
  syncSnapshot = false
} = {}]) {
  function spawnChild2(args, params) {
  }
  spawnChild2.type = "snapshot.spawnChild";
  spawnChild2.id = id;
  spawnChild2.systemId = systemId;
  spawnChild2.src = src;
  spawnChild2.input = input;
  spawnChild2.syncSnapshot = syncSnapshot;
  spawnChild2.resolve = resolveSpawn;
  spawnChild2.execute = executeSpawn;
  return spawnChild2;
}
function resolveStop(_2, snapshot, args, actionParams, {
  actorRef
}) {
  const actorRefOrString = typeof actorRef === "function" ? actorRef(args, actionParams) : actorRef;
  const resolvedActorRef = typeof actorRefOrString === "string" ? snapshot.children[actorRefOrString] : actorRefOrString;
  let children = snapshot.children;
  if (resolvedActorRef) {
    children = __spreadValues({}, children);
    delete children[resolvedActorRef.id];
  }
  return [cloneMachineSnapshot(snapshot, {
    children
  }), resolvedActorRef];
}
function executeStop(actorScope, actorRef) {
  if (!actorRef) {
    return;
  }
  actorScope.system._unregister(actorRef);
  if (actorRef._processingStatus !== ProcessingStatus.Running) {
    actorScope.stopChild(actorRef);
    return;
  }
  actorScope.defer(() => {
    actorScope.stopChild(actorRef);
  });
}
function stopChild(actorRef) {
  function stop2(args, params) {
  }
  stop2.type = "xstate.stopChild";
  stop2.actorRef = actorRef;
  stop2.resolve = resolveStop;
  stop2.execute = executeStop;
  return stop2;
}
function evaluateGuard(guard, context, event2, snapshot) {
  const {
    machine
  } = snapshot;
  const isInline = typeof guard === "function";
  const resolved = isInline ? guard : machine.implementations.guards[typeof guard === "string" ? guard : guard.type];
  if (!isInline && !resolved) {
    throw new Error(`Guard '${typeof guard === "string" ? guard : guard.type}' is not implemented.'.`);
  }
  if (typeof resolved !== "function") {
    return evaluateGuard(resolved, context, event2, snapshot);
  }
  const guardArgs = {
    context,
    event: event2
  };
  const guardParams = isInline || typeof guard === "string" ? void 0 : "params" in guard ? typeof guard.params === "function" ? guard.params({
    context,
    event: event2
  }) : guard.params : void 0;
  if (!("check" in resolved)) {
    return resolved(guardArgs, guardParams);
  }
  const builtinGuard = resolved;
  return builtinGuard.check(
    snapshot,
    guardArgs,
    resolved
    // this holds all params
  );
}
var isAtomicStateNode = (stateNode) => stateNode.type === "atomic" || stateNode.type === "final";
function getChildren(stateNode) {
  return Object.values(stateNode.states).filter((sn) => sn.type !== "history");
}
function getProperAncestors(stateNode, toStateNode) {
  const ancestors = [];
  if (toStateNode === stateNode) {
    return ancestors;
  }
  let m3 = stateNode.parent;
  while (m3 && m3 !== toStateNode) {
    ancestors.push(m3);
    m3 = m3.parent;
  }
  return ancestors;
}
function getAllStateNodes(stateNodes) {
  const nodeSet = new Set(stateNodes);
  const adjList = getAdjList(nodeSet);
  for (const s9 of nodeSet) {
    if (s9.type === "compound" && (!adjList.get(s9) || !adjList.get(s9).length)) {
      getInitialStateNodesWithTheirAncestors(s9).forEach((sn) => nodeSet.add(sn));
    } else {
      if (s9.type === "parallel") {
        for (const child of getChildren(s9)) {
          if (child.type === "history") {
            continue;
          }
          if (!nodeSet.has(child)) {
            const initialStates = getInitialStateNodesWithTheirAncestors(child);
            for (const initialStateNode of initialStates) {
              nodeSet.add(initialStateNode);
            }
          }
        }
      }
    }
  }
  for (const s9 of nodeSet) {
    let m3 = s9.parent;
    while (m3) {
      nodeSet.add(m3);
      m3 = m3.parent;
    }
  }
  return nodeSet;
}
function getValueFromAdj(baseNode, adjList) {
  const childStateNodes = adjList.get(baseNode);
  if (!childStateNodes) {
    return {};
  }
  if (baseNode.type === "compound") {
    const childStateNode = childStateNodes[0];
    if (childStateNode) {
      if (isAtomicStateNode(childStateNode)) {
        return childStateNode.key;
      }
    } else {
      return {};
    }
  }
  const stateValue = {};
  for (const childStateNode of childStateNodes) {
    stateValue[childStateNode.key] = getValueFromAdj(childStateNode, adjList);
  }
  return stateValue;
}
function getAdjList(stateNodes) {
  const adjList = /* @__PURE__ */ new Map();
  for (const s9 of stateNodes) {
    if (!adjList.has(s9)) {
      adjList.set(s9, []);
    }
    if (s9.parent) {
      if (!adjList.has(s9.parent)) {
        adjList.set(s9.parent, []);
      }
      adjList.get(s9.parent).push(s9);
    }
  }
  return adjList;
}
function getStateValue(rootNode, stateNodes) {
  const config = getAllStateNodes(stateNodes);
  return getValueFromAdj(rootNode, getAdjList(config));
}
function isInFinalState(stateNodeSet, stateNode) {
  if (stateNode.type === "compound") {
    return getChildren(stateNode).some((s9) => s9.type === "final" && stateNodeSet.has(s9));
  }
  if (stateNode.type === "parallel") {
    return getChildren(stateNode).every((sn) => isInFinalState(stateNodeSet, sn));
  }
  return stateNode.type === "final";
}
var isStateId = (str6) => str6[0] === STATE_IDENTIFIER;
function getCandidates(stateNode, receivedEventType) {
  const candidates = stateNode.transitions.get(receivedEventType) || [...stateNode.transitions.keys()].filter((eventDescriptor) => {
    if (eventDescriptor === WILDCARD) {
      return true;
    }
    if (!eventDescriptor.endsWith(".*")) {
      return false;
    }
    const partialEventTokens = eventDescriptor.split(".");
    const eventTokens = receivedEventType.split(".");
    for (let tokenIndex = 0; tokenIndex < partialEventTokens.length; tokenIndex++) {
      const partialEventToken = partialEventTokens[tokenIndex];
      const eventToken = eventTokens[tokenIndex];
      if (partialEventToken === "*") {
        const isLastToken = tokenIndex === partialEventTokens.length - 1;
        return isLastToken;
      }
      if (partialEventToken !== eventToken) {
        return false;
      }
    }
    return true;
  }).sort((a4, b3) => b3.length - a4.length).flatMap((key) => stateNode.transitions.get(key));
  return candidates;
}
function getDelayedTransitions(stateNode) {
  const afterConfig = stateNode.config.after;
  if (!afterConfig) {
    return [];
  }
  const mutateEntryExit = (delay, i6) => {
    const afterEvent = createAfterEvent(delay, stateNode.id);
    const eventType = afterEvent.type;
    stateNode.entry.push(raise(afterEvent, {
      id: eventType,
      delay
    }));
    stateNode.exit.push(cancel(eventType));
    return eventType;
  };
  const delayedTransitions = Object.keys(afterConfig).flatMap((delay, i6) => {
    const configTransition = afterConfig[delay];
    const resolvedTransition = typeof configTransition === "string" ? {
      target: configTransition
    } : configTransition;
    const resolvedDelay = Number.isNaN(+delay) ? delay : +delay;
    const eventType = mutateEntryExit(resolvedDelay);
    return toArray(resolvedTransition).map((transition) => __spreadProps(__spreadValues({}, transition), {
      event: eventType,
      delay: resolvedDelay
    }));
  });
  return delayedTransitions.map((delayedTransition) => {
    const {
      delay
    } = delayedTransition;
    return __spreadProps(__spreadValues({}, formatTransition(stateNode, delayedTransition.event, delayedTransition)), {
      delay
    });
  });
}
function formatTransition(stateNode, descriptor, transitionConfig) {
  var _a9;
  const normalizedTarget = normalizeTarget(transitionConfig.target);
  const reenter = (_a9 = transitionConfig.reenter) != null ? _a9 : false;
  const target = resolveTarget(stateNode, normalizedTarget);
  const transition = __spreadProps(__spreadValues({}, transitionConfig), {
    actions: toArray(transitionConfig.actions),
    guard: transitionConfig.guard,
    target,
    source: stateNode,
    reenter,
    eventType: descriptor,
    toJSON: () => __spreadProps(__spreadValues({}, transition), {
      source: `#${stateNode.id}`,
      target: target ? target.map((t9) => `#${t9.id}`) : void 0
    })
  });
  return transition;
}
function formatTransitions(stateNode) {
  const transitions = /* @__PURE__ */ new Map();
  if (stateNode.config.on) {
    for (const descriptor of Object.keys(stateNode.config.on)) {
      if (descriptor === NULL_EVENT) {
        throw new Error('Null events ("") cannot be specified as a transition key. Use `always: { ... }` instead.');
      }
      const transitionsConfig = stateNode.config.on[descriptor];
      transitions.set(descriptor, toTransitionConfigArray(transitionsConfig).map((t9) => formatTransition(stateNode, descriptor, t9)));
    }
  }
  if (stateNode.config.onDone) {
    const descriptor = `xstate.done.state.${stateNode.id}`;
    transitions.set(descriptor, toTransitionConfigArray(stateNode.config.onDone).map((t9) => formatTransition(stateNode, descriptor, t9)));
  }
  for (const invokeDef of stateNode.invoke) {
    if (invokeDef.onDone) {
      const descriptor = `xstate.done.actor.${invokeDef.id}`;
      transitions.set(descriptor, toTransitionConfigArray(invokeDef.onDone).map((t9) => formatTransition(stateNode, descriptor, t9)));
    }
    if (invokeDef.onError) {
      const descriptor = `xstate.error.actor.${invokeDef.id}`;
      transitions.set(descriptor, toTransitionConfigArray(invokeDef.onError).map((t9) => formatTransition(stateNode, descriptor, t9)));
    }
    if (invokeDef.onSnapshot) {
      const descriptor = `xstate.snapshot.${invokeDef.id}`;
      transitions.set(descriptor, toTransitionConfigArray(invokeDef.onSnapshot).map((t9) => formatTransition(stateNode, descriptor, t9)));
    }
  }
  for (const delayedTransition of stateNode.after) {
    let existing = transitions.get(delayedTransition.eventType);
    if (!existing) {
      existing = [];
      transitions.set(delayedTransition.eventType, existing);
    }
    existing.push(delayedTransition);
  }
  return transitions;
}
function formatInitialTransition(stateNode, _target) {
  const resolvedTarget = typeof _target === "string" ? stateNode.states[_target] : _target ? stateNode.states[_target.target] : void 0;
  if (!resolvedTarget && _target) {
    throw new Error(`Initial state node "${_target}" not found on parent state node #${stateNode.id}`);
  }
  const transition = {
    source: stateNode,
    actions: !_target || typeof _target === "string" ? [] : toArray(_target.actions),
    eventType: null,
    reenter: false,
    target: resolvedTarget ? [resolvedTarget] : [],
    toJSON: () => __spreadProps(__spreadValues({}, transition), {
      source: `#${stateNode.id}`,
      target: resolvedTarget ? [`#${resolvedTarget.id}`] : []
    })
  };
  return transition;
}
function resolveTarget(stateNode, targets) {
  if (targets === void 0) {
    return void 0;
  }
  return targets.map((target) => {
    if (typeof target !== "string") {
      return target;
    }
    if (isStateId(target)) {
      return stateNode.machine.getStateNodeById(target);
    }
    const isInternalTarget = target[0] === STATE_DELIMITER;
    if (isInternalTarget && !stateNode.parent) {
      return getStateNodeByPath(stateNode, target.slice(1));
    }
    const resolvedTarget = isInternalTarget ? stateNode.key + target : target;
    if (stateNode.parent) {
      try {
        const targetStateNode = getStateNodeByPath(stateNode.parent, resolvedTarget);
        return targetStateNode;
      } catch (err) {
        throw new Error(`Invalid transition definition for state node '${stateNode.id}':
${err.message}`);
      }
    } else {
      throw new Error(`Invalid target: "${target}" is not a valid target from the root node. Did you mean ".${target}"?`);
    }
  });
}
function resolveHistoryDefaultTransition(stateNode) {
  const normalizedTarget = normalizeTarget(stateNode.config.target);
  if (!normalizedTarget) {
    return stateNode.parent.initial;
  }
  return {
    target: normalizedTarget.map((t9) => typeof t9 === "string" ? getStateNodeByPath(stateNode.parent, t9) : t9)
  };
}
function isHistoryNode(stateNode) {
  return stateNode.type === "history";
}
function getInitialStateNodesWithTheirAncestors(stateNode) {
  const states = getInitialStateNodes(stateNode);
  for (const initialState of states) {
    for (const ancestor of getProperAncestors(initialState, stateNode)) {
      states.add(ancestor);
    }
  }
  return states;
}
function getInitialStateNodes(stateNode) {
  const set7 = /* @__PURE__ */ new Set();
  function iter(descStateNode) {
    if (set7.has(descStateNode)) {
      return;
    }
    set7.add(descStateNode);
    if (descStateNode.type === "compound") {
      iter(descStateNode.initial.target[0]);
    } else if (descStateNode.type === "parallel") {
      for (const child of getChildren(descStateNode)) {
        iter(child);
      }
    }
  }
  iter(stateNode);
  return set7;
}
function getStateNode(stateNode, stateKey) {
  if (isStateId(stateKey)) {
    return stateNode.machine.getStateNodeById(stateKey);
  }
  if (!stateNode.states) {
    throw new Error(`Unable to retrieve child state '${stateKey}' from '${stateNode.id}'; no child states exist.`);
  }
  const result = stateNode.states[stateKey];
  if (!result) {
    throw new Error(`Child state '${stateKey}' does not exist on '${stateNode.id}'`);
  }
  return result;
}
function getStateNodeByPath(stateNode, statePath) {
  if (typeof statePath === "string" && isStateId(statePath)) {
    try {
      return stateNode.machine.getStateNodeById(statePath);
    } catch (e13) {
    }
  }
  const arrayStatePath = toStatePath(statePath).slice();
  let currentStateNode = stateNode;
  while (arrayStatePath.length) {
    const key = arrayStatePath.shift();
    if (!key.length) {
      break;
    }
    currentStateNode = getStateNode(currentStateNode, key);
  }
  return currentStateNode;
}
function getStateNodes(stateNode, stateValue) {
  if (typeof stateValue === "string") {
    return [stateNode, stateNode.states[stateValue]];
  }
  const childStateKeys = Object.keys(stateValue);
  const childStateNodes = childStateKeys.map((subStateKey) => getStateNode(stateNode, subStateKey)).filter(Boolean);
  return [stateNode.machine.root, stateNode].concat(childStateNodes, childStateKeys.reduce((allSubStateNodes, subStateKey) => {
    const subStateNode = getStateNode(stateNode, subStateKey);
    if (!subStateNode) {
      return allSubStateNodes;
    }
    const subStateNodes = getStateNodes(subStateNode, stateValue[subStateKey]);
    return allSubStateNodes.concat(subStateNodes);
  }, []));
}
function transitionAtomicNode(stateNode, stateValue, snapshot, event2) {
  const childStateNode = getStateNode(stateNode, stateValue);
  const next = childStateNode.next(snapshot, event2);
  if (!next || !next.length) {
    return stateNode.next(snapshot, event2);
  }
  return next;
}
function transitionCompoundNode(stateNode, stateValue, snapshot, event2) {
  const subStateKeys = Object.keys(stateValue);
  const childStateNode = getStateNode(stateNode, subStateKeys[0]);
  const next = transitionNode(childStateNode, stateValue[subStateKeys[0]], snapshot, event2);
  if (!next || !next.length) {
    return stateNode.next(snapshot, event2);
  }
  return next;
}
function transitionParallelNode(stateNode, stateValue, snapshot, event2) {
  const allInnerTransitions = [];
  for (const subStateKey of Object.keys(stateValue)) {
    const subStateValue = stateValue[subStateKey];
    if (!subStateValue) {
      continue;
    }
    const subStateNode = getStateNode(stateNode, subStateKey);
    const innerTransitions = transitionNode(subStateNode, subStateValue, snapshot, event2);
    if (innerTransitions) {
      allInnerTransitions.push(...innerTransitions);
    }
  }
  if (!allInnerTransitions.length) {
    return stateNode.next(snapshot, event2);
  }
  return allInnerTransitions;
}
function transitionNode(stateNode, stateValue, snapshot, event2) {
  if (typeof stateValue === "string") {
    return transitionAtomicNode(stateNode, stateValue, snapshot, event2);
  }
  if (Object.keys(stateValue).length === 1) {
    return transitionCompoundNode(stateNode, stateValue, snapshot, event2);
  }
  return transitionParallelNode(stateNode, stateValue, snapshot, event2);
}
function getHistoryNodes(stateNode) {
  return Object.keys(stateNode.states).map((key) => stateNode.states[key]).filter((sn) => sn.type === "history");
}
function isDescendant(childStateNode, parentStateNode) {
  let marker = childStateNode;
  while (marker.parent && marker.parent !== parentStateNode) {
    marker = marker.parent;
  }
  return marker.parent === parentStateNode;
}
function hasIntersection(s1, s22) {
  const set1 = new Set(s1);
  const set22 = new Set(s22);
  for (const item of set1) {
    if (set22.has(item)) {
      return true;
    }
  }
  for (const item of set22) {
    if (set1.has(item)) {
      return true;
    }
  }
  return false;
}
function removeConflictingTransitions(enabledTransitions, stateNodeSet, historyValue) {
  const filteredTransitions = /* @__PURE__ */ new Set();
  for (const t1 of enabledTransitions) {
    let t1Preempted = false;
    const transitionsToRemove = /* @__PURE__ */ new Set();
    for (const t22 of filteredTransitions) {
      if (hasIntersection(computeExitSet([t1], stateNodeSet, historyValue), computeExitSet([t22], stateNodeSet, historyValue))) {
        if (isDescendant(t1.source, t22.source)) {
          transitionsToRemove.add(t22);
        } else {
          t1Preempted = true;
          break;
        }
      }
    }
    if (!t1Preempted) {
      for (const t32 of transitionsToRemove) {
        filteredTransitions.delete(t32);
      }
      filteredTransitions.add(t1);
    }
  }
  return Array.from(filteredTransitions);
}
function findLeastCommonAncestor(stateNodes) {
  const [head, ...tail] = stateNodes;
  for (const ancestor of getProperAncestors(head, void 0)) {
    if (tail.every((sn) => isDescendant(sn, ancestor))) {
      return ancestor;
    }
  }
}
function getEffectiveTargetStates(transition, historyValue) {
  if (!transition.target) {
    return [];
  }
  const targets = /* @__PURE__ */ new Set();
  for (const targetNode of transition.target) {
    if (isHistoryNode(targetNode)) {
      if (historyValue[targetNode.id]) {
        for (const node of historyValue[targetNode.id]) {
          targets.add(node);
        }
      } else {
        for (const node of getEffectiveTargetStates(resolveHistoryDefaultTransition(targetNode), historyValue)) {
          targets.add(node);
        }
      }
    } else {
      targets.add(targetNode);
    }
  }
  return [...targets];
}
function getTransitionDomain(transition, historyValue) {
  const targetStates = getEffectiveTargetStates(transition, historyValue);
  if (!targetStates) {
    return;
  }
  if (!transition.reenter && targetStates.every((target) => target === transition.source || isDescendant(target, transition.source))) {
    return transition.source;
  }
  const lca = findLeastCommonAncestor(targetStates.concat(transition.source));
  if (lca) {
    return lca;
  }
  if (transition.reenter) {
    return;
  }
  return transition.source.machine.root;
}
function computeExitSet(transitions, stateNodeSet, historyValue) {
  var _a9;
  const statesToExit = /* @__PURE__ */ new Set();
  for (const t9 of transitions) {
    if ((_a9 = t9.target) == null ? void 0 : _a9.length) {
      const domain = getTransitionDomain(t9, historyValue);
      if (t9.reenter && t9.source === domain) {
        statesToExit.add(domain);
      }
      for (const stateNode of stateNodeSet) {
        if (isDescendant(stateNode, domain)) {
          statesToExit.add(stateNode);
        }
      }
    }
  }
  return [...statesToExit];
}
function areStateNodeCollectionsEqual(prevStateNodes, nextStateNodeSet) {
  if (prevStateNodes.length !== nextStateNodeSet.size) {
    return false;
  }
  for (const node of prevStateNodes) {
    if (!nextStateNodeSet.has(node)) {
      return false;
    }
  }
  return true;
}
function microstep(transitions, currentSnapshot, actorScope, event2, isInitial, internalQueue) {
  if (!transitions.length) {
    return currentSnapshot;
  }
  const mutStateNodeSet = new Set(currentSnapshot._nodes);
  let historyValue = currentSnapshot.historyValue;
  const filteredTransitions = removeConflictingTransitions(transitions, mutStateNodeSet, historyValue);
  let nextState = currentSnapshot;
  if (!isInitial) {
    [nextState, historyValue] = exitStates(nextState, event2, actorScope, filteredTransitions, mutStateNodeSet, historyValue, internalQueue);
  }
  nextState = resolveActionsAndContext(nextState, event2, actorScope, filteredTransitions.flatMap((t9) => t9.actions), internalQueue);
  nextState = enterStates(nextState, event2, actorScope, filteredTransitions, mutStateNodeSet, internalQueue, historyValue, isInitial);
  const nextStateNodes = [...mutStateNodeSet];
  if (nextState.status === "done") {
    nextState = resolveActionsAndContext(nextState, event2, actorScope, nextStateNodes.sort((a4, b3) => b3.order - a4.order).flatMap((state) => state.exit), internalQueue);
  }
  try {
    if (historyValue === currentSnapshot.historyValue && areStateNodeCollectionsEqual(currentSnapshot._nodes, mutStateNodeSet)) {
      return nextState;
    }
    return cloneMachineSnapshot(nextState, {
      _nodes: nextStateNodes,
      historyValue
    });
  } catch (e13) {
    throw e13;
  }
}
function getMachineOutput(snapshot, event2, actorScope, rootNode, rootCompletionNode) {
  if (!rootNode.output) {
    return;
  }
  const doneStateEvent = createDoneStateEvent(rootCompletionNode.id, rootCompletionNode.output && rootCompletionNode.parent ? resolveOutput(rootCompletionNode.output, snapshot.context, event2, actorScope.self) : void 0);
  return resolveOutput(rootNode.output, snapshot.context, doneStateEvent, actorScope.self);
}
function enterStates(currentSnapshot, event2, actorScope, filteredTransitions, mutStateNodeSet, internalQueue, historyValue, isInitial) {
  let nextSnapshot = currentSnapshot;
  const statesToEnter = /* @__PURE__ */ new Set();
  const statesForDefaultEntry = /* @__PURE__ */ new Set();
  computeEntrySet(filteredTransitions, historyValue, statesForDefaultEntry, statesToEnter);
  if (isInitial) {
    statesForDefaultEntry.add(currentSnapshot.machine.root);
  }
  const completedNodes = /* @__PURE__ */ new Set();
  for (const stateNodeToEnter of [...statesToEnter].sort((a4, b3) => a4.order - b3.order)) {
    mutStateNodeSet.add(stateNodeToEnter);
    const actions = [];
    actions.push(...stateNodeToEnter.entry);
    for (const invokeDef of stateNodeToEnter.invoke) {
      actions.push(spawnChild(invokeDef.src, __spreadProps(__spreadValues({}, invokeDef), {
        syncSnapshot: !!invokeDef.onSnapshot
      })));
    }
    if (statesForDefaultEntry.has(stateNodeToEnter)) {
      const initialActions = stateNodeToEnter.initial.actions;
      actions.push(...initialActions);
    }
    nextSnapshot = resolveActionsAndContext(nextSnapshot, event2, actorScope, actions, internalQueue, stateNodeToEnter.invoke.map((invokeDef) => invokeDef.id));
    if (stateNodeToEnter.type === "final") {
      const parent = stateNodeToEnter.parent;
      let ancestorMarker = (parent == null ? void 0 : parent.type) === "parallel" ? parent : parent == null ? void 0 : parent.parent;
      let rootCompletionNode = ancestorMarker || stateNodeToEnter;
      if ((parent == null ? void 0 : parent.type) === "compound") {
        internalQueue.push(createDoneStateEvent(parent.id, stateNodeToEnter.output ? resolveOutput(stateNodeToEnter.output, nextSnapshot.context, event2, actorScope.self) : void 0));
      }
      while ((ancestorMarker == null ? void 0 : ancestorMarker.type) === "parallel" && !completedNodes.has(ancestorMarker) && isInFinalState(mutStateNodeSet, ancestorMarker)) {
        completedNodes.add(ancestorMarker);
        internalQueue.push(createDoneStateEvent(ancestorMarker.id));
        rootCompletionNode = ancestorMarker;
        ancestorMarker = ancestorMarker.parent;
      }
      if (ancestorMarker) {
        continue;
      }
      nextSnapshot = cloneMachineSnapshot(nextSnapshot, {
        status: "done",
        output: getMachineOutput(nextSnapshot, event2, actorScope, nextSnapshot.machine.root, rootCompletionNode)
      });
    }
  }
  return nextSnapshot;
}
function computeEntrySet(transitions, historyValue, statesForDefaultEntry, statesToEnter) {
  for (const t9 of transitions) {
    const domain = getTransitionDomain(t9, historyValue);
    for (const s9 of t9.target || []) {
      if (!isHistoryNode(s9) && // if the target is different than the source then it will *definitely* be entered
      (t9.source !== s9 || // we know that the domain can't lie within the source
      // if it's different than the source then it's outside of it and it means that the target has to be entered as well
      t9.source !== domain || // reentering transitions always enter the target, even if it's the source itself
      t9.reenter)) {
        statesToEnter.add(s9);
        statesForDefaultEntry.add(s9);
      }
      addDescendantStatesToEnter(s9, historyValue, statesForDefaultEntry, statesToEnter);
    }
    const targetStates = getEffectiveTargetStates(t9, historyValue);
    for (const s9 of targetStates) {
      const ancestors = getProperAncestors(s9, domain);
      if ((domain == null ? void 0 : domain.type) === "parallel") {
        ancestors.push(domain);
      }
      addAncestorStatesToEnter(statesToEnter, historyValue, statesForDefaultEntry, ancestors, !t9.source.parent && t9.reenter ? void 0 : domain);
    }
  }
}
function addDescendantStatesToEnter(stateNode, historyValue, statesForDefaultEntry, statesToEnter) {
  var _a9;
  if (isHistoryNode(stateNode)) {
    if (historyValue[stateNode.id]) {
      const historyStateNodes = historyValue[stateNode.id];
      for (const s9 of historyStateNodes) {
        statesToEnter.add(s9);
        addDescendantStatesToEnter(s9, historyValue, statesForDefaultEntry, statesToEnter);
      }
      for (const s9 of historyStateNodes) {
        addProperAncestorStatesToEnter(s9, stateNode.parent, statesToEnter, historyValue, statesForDefaultEntry);
      }
    } else {
      const historyDefaultTransition = resolveHistoryDefaultTransition(stateNode);
      for (const s9 of historyDefaultTransition.target) {
        statesToEnter.add(s9);
        if (historyDefaultTransition === ((_a9 = stateNode.parent) == null ? void 0 : _a9.initial)) {
          statesForDefaultEntry.add(stateNode.parent);
        }
        addDescendantStatesToEnter(s9, historyValue, statesForDefaultEntry, statesToEnter);
      }
      for (const s9 of historyDefaultTransition.target) {
        addProperAncestorStatesToEnter(s9, stateNode.parent, statesToEnter, historyValue, statesForDefaultEntry);
      }
    }
  } else {
    if (stateNode.type === "compound") {
      const [initialState] = stateNode.initial.target;
      if (!isHistoryNode(initialState)) {
        statesToEnter.add(initialState);
        statesForDefaultEntry.add(initialState);
      }
      addDescendantStatesToEnter(initialState, historyValue, statesForDefaultEntry, statesToEnter);
      addProperAncestorStatesToEnter(initialState, stateNode, statesToEnter, historyValue, statesForDefaultEntry);
    } else {
      if (stateNode.type === "parallel") {
        for (const child of getChildren(stateNode).filter((sn) => !isHistoryNode(sn))) {
          if (![...statesToEnter].some((s9) => isDescendant(s9, child))) {
            if (!isHistoryNode(child)) {
              statesToEnter.add(child);
              statesForDefaultEntry.add(child);
            }
            addDescendantStatesToEnter(child, historyValue, statesForDefaultEntry, statesToEnter);
          }
        }
      }
    }
  }
}
function addAncestorStatesToEnter(statesToEnter, historyValue, statesForDefaultEntry, ancestors, reentrancyDomain) {
  for (const anc of ancestors) {
    if (!reentrancyDomain || isDescendant(anc, reentrancyDomain)) {
      statesToEnter.add(anc);
    }
    if (anc.type === "parallel") {
      for (const child of getChildren(anc).filter((sn) => !isHistoryNode(sn))) {
        if (![...statesToEnter].some((s9) => isDescendant(s9, child))) {
          statesToEnter.add(child);
          addDescendantStatesToEnter(child, historyValue, statesForDefaultEntry, statesToEnter);
        }
      }
    }
  }
}
function addProperAncestorStatesToEnter(stateNode, toStateNode, statesToEnter, historyValue, statesForDefaultEntry) {
  addAncestorStatesToEnter(statesToEnter, historyValue, statesForDefaultEntry, getProperAncestors(stateNode, toStateNode));
}
function exitStates(currentSnapshot, event2, actorScope, transitions, mutStateNodeSet, historyValue, internalQueue) {
  let nextSnapshot = currentSnapshot;
  const statesToExit = computeExitSet(transitions, mutStateNodeSet, historyValue);
  statesToExit.sort((a4, b3) => b3.order - a4.order);
  let changedHistory;
  for (const exitStateNode of statesToExit) {
    for (const historyNode of getHistoryNodes(exitStateNode)) {
      let predicate;
      if (historyNode.history === "deep") {
        predicate = (sn) => isAtomicStateNode(sn) && isDescendant(sn, exitStateNode);
      } else {
        predicate = (sn) => {
          return sn.parent === exitStateNode;
        };
      }
      changedHistory != null ? changedHistory : changedHistory = __spreadValues({}, historyValue);
      changedHistory[historyNode.id] = Array.from(mutStateNodeSet).filter(predicate);
    }
  }
  for (const s9 of statesToExit) {
    nextSnapshot = resolveActionsAndContext(nextSnapshot, event2, actorScope, [...s9.exit, ...s9.invoke.map((def) => stopChild(def.id))], internalQueue);
    mutStateNodeSet.delete(s9);
  }
  return [nextSnapshot, changedHistory || historyValue];
}
function resolveActionsAndContextWorker(currentSnapshot, event2, actorScope, actions, extra, retries) {
  const {
    machine
  } = currentSnapshot;
  let intermediateSnapshot = currentSnapshot;
  for (const action of actions) {
    const isInline = typeof action === "function";
    const resolvedAction = isInline ? action : (
      // the existing type of `.actions` assumes non-nullable `TExpressionAction`
      // it's fine to cast this here to get a common type and lack of errors in the rest of the code
      // our logic below makes sure that we call those 2 "variants" correctly
      machine.implementations.actions[typeof action === "string" ? action : action.type]
    );
    if (!resolvedAction) {
      continue;
    }
    const actionArgs = {
      context: intermediateSnapshot.context,
      event: event2,
      self: actorScope.self,
      system: actorScope.system
    };
    const actionParams = isInline || typeof action === "string" ? void 0 : "params" in action ? typeof action.params === "function" ? action.params({
      context: intermediateSnapshot.context,
      event: event2
    }) : action.params : void 0;
    if (!("resolve" in resolvedAction)) {
      if (actorScope.self._processingStatus === ProcessingStatus.Running) {
        resolvedAction(actionArgs, actionParams);
      } else {
        actorScope.defer(() => {
          resolvedAction(actionArgs, actionParams);
        });
      }
      continue;
    }
    const builtinAction = resolvedAction;
    const [nextState, params, actions2] = builtinAction.resolve(
      actorScope,
      intermediateSnapshot,
      actionArgs,
      actionParams,
      resolvedAction,
      // this holds all params
      extra
    );
    intermediateSnapshot = nextState;
    if ("retryResolve" in builtinAction) {
      retries == null ? void 0 : retries.push([builtinAction, params]);
    }
    if ("execute" in builtinAction) {
      if (actorScope.self._processingStatus === ProcessingStatus.Running) {
        builtinAction.execute(actorScope, params);
      } else {
        actorScope.defer(builtinAction.execute.bind(null, actorScope, params));
      }
    }
    if (actions2) {
      intermediateSnapshot = resolveActionsAndContextWorker(intermediateSnapshot, event2, actorScope, actions2, extra, retries);
    }
  }
  return intermediateSnapshot;
}
function resolveActionsAndContext(currentSnapshot, event2, actorScope, actions, internalQueue, deferredActorIds) {
  const retries = deferredActorIds ? [] : void 0;
  const nextState = resolveActionsAndContextWorker(currentSnapshot, event2, actorScope, actions, {
    internalQueue,
    deferredActorIds
  }, retries);
  retries == null ? void 0 : retries.forEach(([builtinAction, params]) => {
    builtinAction.retryResolve(actorScope, nextState, params);
  });
  return nextState;
}
function macrostep(snapshot, event2, actorScope, internalQueue = []) {
  let nextSnapshot = snapshot;
  const states = [];
  if (event2.type === XSTATE_STOP) {
    nextSnapshot = cloneMachineSnapshot(stopChildren(nextSnapshot, event2, actorScope), {
      status: "stopped"
    });
    states.push(nextSnapshot);
    return {
      snapshot: nextSnapshot,
      microstates: states
    };
  }
  let nextEvent = event2;
  if (nextEvent.type !== XSTATE_INIT) {
    const currentEvent = nextEvent;
    const isErr = isErrorActorEvent(currentEvent);
    const transitions = selectTransitions(currentEvent, nextSnapshot);
    if (isErr && !transitions.length) {
      nextSnapshot = cloneMachineSnapshot(snapshot, {
        status: "error",
        error: currentEvent.error
      });
      states.push(nextSnapshot);
      return {
        snapshot: nextSnapshot,
        microstates: states
      };
    }
    nextSnapshot = microstep(
      transitions,
      snapshot,
      actorScope,
      nextEvent,
      false,
      // isInitial
      internalQueue
    );
    states.push(nextSnapshot);
  }
  let shouldSelectEventlessTransitions = true;
  while (nextSnapshot.status === "active") {
    let enabledTransitions = shouldSelectEventlessTransitions ? selectEventlessTransitions(nextSnapshot, nextEvent) : [];
    const previousState = enabledTransitions.length ? nextSnapshot : void 0;
    if (!enabledTransitions.length) {
      if (!internalQueue.length) {
        break;
      }
      nextEvent = internalQueue.shift();
      enabledTransitions = selectTransitions(nextEvent, nextSnapshot);
    }
    nextSnapshot = microstep(enabledTransitions, nextSnapshot, actorScope, nextEvent, false, internalQueue);
    shouldSelectEventlessTransitions = nextSnapshot !== previousState;
    states.push(nextSnapshot);
  }
  if (nextSnapshot.status !== "active") {
    stopChildren(nextSnapshot, nextEvent, actorScope);
  }
  return {
    snapshot: nextSnapshot,
    microstates: states
  };
}
function stopChildren(nextState, event2, actorScope) {
  return resolveActionsAndContext(nextState, event2, actorScope, Object.values(nextState.children).map((child) => stopChild(child)), []);
}
function selectTransitions(event2, nextState) {
  return nextState.machine.getTransitionData(nextState, event2);
}
function selectEventlessTransitions(nextState, event2) {
  const enabledTransitionSet = /* @__PURE__ */ new Set();
  const atomicStates = nextState._nodes.filter(isAtomicStateNode);
  for (const stateNode of atomicStates) {
    loop: for (const s9 of [stateNode].concat(getProperAncestors(stateNode, void 0))) {
      if (!s9.always) {
        continue;
      }
      for (const transition of s9.always) {
        if (transition.guard === void 0 || evaluateGuard(transition.guard, nextState.context, event2, nextState)) {
          enabledTransitionSet.add(transition);
          break loop;
        }
      }
    }
  }
  return removeConflictingTransitions(Array.from(enabledTransitionSet), new Set(nextState._nodes), nextState.historyValue);
}
function resolveStateValue(rootNode, stateValue) {
  const allStateNodes = getAllStateNodes(getStateNodes(rootNode, stateValue));
  return getStateValue(rootNode, [...allStateNodes]);
}
function isMachineSnapshot(value) {
  return !!value && typeof value === "object" && "machine" in value && "value" in value;
}
var machineSnapshotMatches = function matches(testValue) {
  return matchesState(testValue, this.value);
};
var machineSnapshotHasTag = function hasTag(tag) {
  return this.tags.has(tag);
};
var machineSnapshotCan = function can(event2) {
  const transitionData = this.machine.getTransitionData(this, event2);
  return !!(transitionData == null ? void 0 : transitionData.length) && // Check that at least one transition is not forbidden
  transitionData.some((t9) => t9.target !== void 0 || t9.actions.length);
};
var machineSnapshotToJSON = function toJSON() {
  const _a9 = this, {
    _nodes: nodes,
    tags,
    machine,
    getMeta: getMeta2,
    toJSON: toJSON3,
    can: can2,
    hasTag: hasTag2,
    matches: matches2
  } = _a9, jsonValues = __objRest(_a9, [
    "_nodes",
    "tags",
    "machine",
    "getMeta",
    "toJSON",
    "can",
    "hasTag",
    "matches"
  ]);
  return __spreadProps(__spreadValues({}, jsonValues), {
    tags: Array.from(tags)
  });
};
var machineSnapshotGetMeta = function getMeta() {
  return this._nodes.reduce((acc, stateNode) => {
    if (stateNode.meta !== void 0) {
      acc[stateNode.id] = stateNode.meta;
    }
    return acc;
  }, {});
};
function createMachineSnapshot(config, machine) {
  return {
    status: config.status,
    output: config.output,
    error: config.error,
    machine,
    context: config.context,
    _nodes: config._nodes,
    value: getStateValue(machine.root, config._nodes),
    tags: new Set(config._nodes.flatMap((sn) => sn.tags)),
    children: config.children,
    historyValue: config.historyValue || {},
    matches: machineSnapshotMatches,
    hasTag: machineSnapshotHasTag,
    can: machineSnapshotCan,
    getMeta: machineSnapshotGetMeta,
    toJSON: machineSnapshotToJSON
  };
}
function cloneMachineSnapshot(snapshot, config = {}) {
  return createMachineSnapshot(__spreadValues(__spreadValues({}, snapshot), config), snapshot.machine);
}
function getPersistedSnapshot(snapshot, options) {
  const _a9 = snapshot, {
    _nodes: nodes,
    tags,
    machine,
    children,
    context,
    can: can2,
    hasTag: hasTag2,
    matches: matches2,
    getMeta: getMeta2,
    toJSON: toJSON3
  } = _a9, jsonValues = __objRest(_a9, [
    "_nodes",
    "tags",
    "machine",
    "children",
    "context",
    "can",
    "hasTag",
    "matches",
    "getMeta",
    "toJSON"
  ]);
  const childrenJson = {};
  for (const id in children) {
    const child = children[id];
    childrenJson[id] = {
      snapshot: child.getPersistedSnapshot(options),
      src: child.src,
      systemId: child._systemId,
      syncSnapshot: child._syncSnapshot
    };
  }
  const persisted = __spreadProps(__spreadValues({}, jsonValues), {
    context: persistContext(context),
    children: childrenJson
  });
  return persisted;
}
function persistContext(contextPart) {
  let copy6;
  for (const key in contextPart) {
    const value = contextPart[key];
    if (value && typeof value === "object") {
      if ("sessionId" in value && "send" in value && "ref" in value) {
        copy6 != null ? copy6 : copy6 = Array.isArray(contextPart) ? contextPart.slice() : __spreadValues({}, contextPart);
        copy6[key] = {
          xstate$$type: $$ACTOR_TYPE,
          id: value.id
        };
      } else {
        const result = persistContext(value);
        if (result !== value) {
          copy6 != null ? copy6 : copy6 = Array.isArray(contextPart) ? contextPart.slice() : __spreadValues({}, contextPart);
          copy6[key] = result;
        }
      }
    }
  }
  return copy6 != null ? copy6 : contextPart;
}
function resolveRaise(_2, snapshot, args, actionParams, {
  event: eventOrExpr,
  id,
  delay
}, {
  internalQueue
}) {
  const delaysMap = snapshot.machine.implementations.delays;
  if (typeof eventOrExpr === "string") {
    throw new Error(`Only event objects may be used with raise; use raise({ type: "${eventOrExpr}" }) instead`);
  }
  const resolvedEvent = typeof eventOrExpr === "function" ? eventOrExpr(args, actionParams) : eventOrExpr;
  let resolvedDelay;
  if (typeof delay === "string") {
    const configDelay = delaysMap && delaysMap[delay];
    resolvedDelay = typeof configDelay === "function" ? configDelay(args, actionParams) : configDelay;
  } else {
    resolvedDelay = typeof delay === "function" ? delay(args, actionParams) : delay;
  }
  if (typeof resolvedDelay !== "number") {
    internalQueue.push(resolvedEvent);
  }
  return [snapshot, {
    event: resolvedEvent,
    id,
    delay: resolvedDelay
  }];
}
function executeRaise(actorScope, params) {
  const {
    event: event2,
    delay,
    id
  } = params;
  if (typeof delay === "number") {
    actorScope.defer(() => {
      const self2 = actorScope.self;
      actorScope.system.scheduler.schedule(self2, self2, event2, delay, id);
    });
    return;
  }
}
function raise(eventOrExpr, options) {
  function raise2(args, params) {
  }
  raise2.type = "xstate.raise";
  raise2.event = eventOrExpr;
  raise2.id = options == null ? void 0 : options.id;
  raise2.delay = options == null ? void 0 : options.delay;
  raise2.resolve = resolveRaise;
  raise2.execute = executeRaise;
  return raise2;
}

// node_modules/xstate/actors/dist/xstate-actors.esm.js
function fromTransition(transition, initialContext) {
  return {
    config: transition,
    transition: (snapshot, event2, actorScope) => {
      return __spreadProps(__spreadValues({}, snapshot), {
        context: transition(snapshot.context, event2, actorScope)
      });
    },
    getInitialSnapshot: (_2, input) => {
      return {
        status: "active",
        output: void 0,
        error: void 0,
        context: typeof initialContext === "function" ? initialContext({
          input
        }) : initialContext
      };
    },
    getPersistedSnapshot: (snapshot) => snapshot,
    restoreSnapshot: (snapshot) => snapshot
  };
}
var XSTATE_PROMISE_RESOLVE = "xstate.promise.resolve";
var XSTATE_PROMISE_REJECT = "xstate.promise.reject";
function fromPromise(promiseCreator) {
  const logic = {
    config: promiseCreator,
    transition: (state, event2) => {
      if (state.status !== "active") {
        return state;
      }
      switch (event2.type) {
        case XSTATE_PROMISE_RESOLVE: {
          const resolvedValue = event2.data;
          return __spreadProps(__spreadValues({}, state), {
            status: "done",
            output: resolvedValue,
            input: void 0
          });
        }
        case XSTATE_PROMISE_REJECT:
          return __spreadProps(__spreadValues({}, state), {
            status: "error",
            error: event2.data,
            input: void 0
          });
        case XSTATE_STOP:
          return __spreadProps(__spreadValues({}, state), {
            status: "stopped",
            input: void 0
          });
        default:
          return state;
      }
    },
    start: (state, {
      self: self2,
      system
    }) => {
      if (state.status !== "active") {
        return;
      }
      const resolvedPromise = Promise.resolve(promiseCreator({
        input: state.input,
        system,
        self: self2
      }));
      resolvedPromise.then((response) => {
        if (self2.getSnapshot().status !== "active") {
          return;
        }
        system._relay(self2, self2, {
          type: XSTATE_PROMISE_RESOLVE,
          data: response
        });
      }, (errorData) => {
        if (self2.getSnapshot().status !== "active") {
          return;
        }
        system._relay(self2, self2, {
          type: XSTATE_PROMISE_REJECT,
          data: errorData
        });
      });
    },
    getInitialSnapshot: (_2, input) => {
      return {
        status: "active",
        output: void 0,
        error: void 0,
        input
      };
    },
    getPersistedSnapshot: (snapshot) => snapshot,
    restoreSnapshot: (snapshot) => snapshot
  };
  return logic;
}
var emptyLogic = fromTransition((_2) => void 0, void 0);

// node_modules/xstate/dist/log-97cf155c.esm.js
function createSpawner(actorScope, {
  machine,
  context
}, event2, spawnedChildren) {
  const spawn = (src, options = {}) => {
    const {
      systemId,
      input
    } = options;
    if (typeof src === "string") {
      const logic = resolveReferencedActor(machine, src);
      if (!logic) {
        throw new Error(`Actor logic '${src}' not implemented in machine '${machine.id}'`);
      }
      const actorRef = createActor(logic, {
        id: options.id,
        parent: actorScope.self,
        syncSnapshot: options.syncSnapshot,
        input: typeof input === "function" ? input({
          context,
          event: event2,
          self: actorScope.self
        }) : input,
        src,
        systemId
      });
      spawnedChildren[actorRef.id] = actorRef;
      return actorRef;
    } else {
      const actorRef = createActor(src, {
        id: options.id,
        parent: actorScope.self,
        syncSnapshot: options.syncSnapshot,
        input: options.input,
        src,
        systemId
      });
      return actorRef;
    }
  };
  return (src, options) => {
    const actorRef = spawn(src, options);
    spawnedChildren[actorRef.id] = actorRef;
    actorScope.defer(() => {
      if (actorRef._processingStatus === ProcessingStatus.Stopped) {
        return;
      }
      actorRef.start();
    });
    return actorRef;
  };
}
function resolveAssign(actorScope, snapshot, actionArgs, actionParams, {
  assignment
}) {
  if (!snapshot.context) {
    throw new Error("Cannot assign to undefined `context`. Ensure that `context` is defined in the machine config.");
  }
  const spawnedChildren = {};
  const assignArgs = {
    context: snapshot.context,
    event: actionArgs.event,
    spawn: createSpawner(actorScope, snapshot, actionArgs.event, spawnedChildren),
    self: actorScope.self,
    system: actorScope.system
  };
  let partialUpdate = {};
  if (typeof assignment === "function") {
    partialUpdate = assignment(assignArgs, actionParams);
  } else {
    for (const key of Object.keys(assignment)) {
      const propAssignment = assignment[key];
      partialUpdate[key] = typeof propAssignment === "function" ? propAssignment(assignArgs, actionParams) : propAssignment;
    }
  }
  const updatedContext = Object.assign({}, snapshot.context, partialUpdate);
  return [cloneMachineSnapshot(snapshot, {
    context: updatedContext,
    children: Object.keys(spawnedChildren).length ? __spreadValues(__spreadValues({}, snapshot.children), spawnedChildren) : snapshot.children
  })];
}
function assign(assignment) {
  function assign2(args, params) {
  }
  assign2.type = "xstate.assign";
  assign2.assignment = assignment;
  assign2.resolve = resolveAssign;
  return assign2;
}
var SpecialTargets = /* @__PURE__ */ function(SpecialTargets2) {
  SpecialTargets2["Parent"] = "#_parent";
  SpecialTargets2["Internal"] = "#_internal";
  return SpecialTargets2;
}({});
function resolveSendTo(actorScope, snapshot, args, actionParams, {
  to,
  event: eventOrExpr,
  id,
  delay
}, extra) {
  var _a9;
  const delaysMap = snapshot.machine.implementations.delays;
  if (typeof eventOrExpr === "string") {
    throw new Error(`Only event objects may be used with sendTo; use sendTo({ type: "${eventOrExpr}" }) instead`);
  }
  const resolvedEvent = typeof eventOrExpr === "function" ? eventOrExpr(args, actionParams) : eventOrExpr;
  let resolvedDelay;
  if (typeof delay === "string") {
    const configDelay = delaysMap && delaysMap[delay];
    resolvedDelay = typeof configDelay === "function" ? configDelay(args, actionParams) : configDelay;
  } else {
    resolvedDelay = typeof delay === "function" ? delay(args, actionParams) : delay;
  }
  const resolvedTarget = typeof to === "function" ? to(args, actionParams) : to;
  let targetActorRef;
  if (typeof resolvedTarget === "string") {
    if (resolvedTarget === SpecialTargets.Parent) {
      targetActorRef = actorScope.self._parent;
    } else if (resolvedTarget === SpecialTargets.Internal) {
      targetActorRef = actorScope.self;
    } else if (resolvedTarget.startsWith("#_")) {
      targetActorRef = snapshot.children[resolvedTarget.slice(2)];
    } else {
      targetActorRef = ((_a9 = extra.deferredActorIds) == null ? void 0 : _a9.includes(resolvedTarget)) ? resolvedTarget : snapshot.children[resolvedTarget];
    }
    if (!targetActorRef) {
      throw new Error(`Unable to send event to actor '${resolvedTarget}' from machine '${snapshot.machine.id}'.`);
    }
  } else {
    targetActorRef = resolvedTarget || actorScope.self;
  }
  return [snapshot, {
    to: targetActorRef,
    event: resolvedEvent,
    id,
    delay: resolvedDelay
  }];
}
function retryResolveSendTo(_2, snapshot, params) {
  if (typeof params.to === "string") {
    params.to = snapshot.children[params.to];
  }
}
function executeSendTo(actorScope, params) {
  actorScope.defer(() => {
    const {
      to,
      event: event2,
      delay,
      id
    } = params;
    if (typeof delay === "number") {
      actorScope.system.scheduler.schedule(actorScope.self, to, event2, delay, id);
      return;
    }
    actorScope.system._relay(
      actorScope.self,
      // at this point, in a deferred task, it should already be mutated by retryResolveSendTo
      // if it initially started as a string
      to,
      event2.type === XSTATE_ERROR ? createErrorActorEvent(actorScope.self.id, event2.data) : event2
    );
  });
}
function sendTo(to, eventOrExpr, options) {
  function sendTo2(args, params) {
  }
  sendTo2.type = "xsnapshot.sendTo";
  sendTo2.to = to;
  sendTo2.event = eventOrExpr;
  sendTo2.id = options == null ? void 0 : options.id;
  sendTo2.delay = options == null ? void 0 : options.delay;
  sendTo2.resolve = resolveSendTo;
  sendTo2.retryResolve = retryResolveSendTo;
  sendTo2.execute = executeSendTo;
  return sendTo2;
}
function sendParent(event2, options) {
  return sendTo(SpecialTargets.Parent, event2, options);
}
function resolveEnqueueActions(actorScope, snapshot, args, _actionParams, {
  collect
}) {
  const actions = [];
  const enqueue = function enqueue2(action) {
    actions.push(action);
  };
  enqueue.assign = (...args2) => {
    actions.push(assign(...args2));
  };
  enqueue.cancel = (...args2) => {
    actions.push(cancel(...args2));
  };
  enqueue.raise = (...args2) => {
    actions.push(raise(...args2));
  };
  enqueue.sendTo = (...args2) => {
    actions.push(sendTo(...args2));
  };
  enqueue.spawnChild = (...args2) => {
    actions.push(spawnChild(...args2));
  };
  enqueue.stopChild = (...args2) => {
    actions.push(stopChild(...args2));
  };
  collect({
    context: args.context,
    event: args.event,
    enqueue,
    check: (guard) => evaluateGuard(guard, snapshot.context, args.event, snapshot),
    self: actorScope.self,
    system: actorScope.system
  });
  return [snapshot, void 0, actions];
}
function enqueueActions(collect) {
  function enqueueActions2(args, params) {
  }
  enqueueActions2.type = "xstate.enqueueActions";
  enqueueActions2.collect = collect;
  enqueueActions2.resolve = resolveEnqueueActions;
  return enqueueActions2;
}

// node_modules/xstate/dist/xstate.esm.js
var cache = /* @__PURE__ */ new WeakMap();
function memo(object, key, fn) {
  let memoizedData = cache.get(object);
  if (!memoizedData) {
    memoizedData = {
      [key]: fn()
    };
    cache.set(object, memoizedData);
  } else if (!(key in memoizedData)) {
    memoizedData[key] = fn();
  }
  return memoizedData[key];
}
var EMPTY_OBJECT = {};
var toSerializableAction = (action) => {
  if (typeof action === "string") {
    return {
      type: action
    };
  }
  if (typeof action === "function") {
    if ("resolve" in action) {
      return {
        type: action.type
      };
    }
    return {
      type: action.name
    };
  }
  return action;
};
var StateNode = class _StateNode {
  constructor(config, options) {
    this.config = config;
    this.key = void 0;
    this.id = void 0;
    this.type = void 0;
    this.path = void 0;
    this.states = void 0;
    this.history = void 0;
    this.entry = void 0;
    this.exit = void 0;
    this.parent = void 0;
    this.machine = void 0;
    this.meta = void 0;
    this.output = void 0;
    this.order = -1;
    this.description = void 0;
    this.tags = [];
    this.transitions = void 0;
    this.always = void 0;
    this.parent = options._parent;
    this.key = options._key;
    this.machine = options._machine;
    this.path = this.parent ? this.parent.path.concat(this.key) : [];
    this.id = this.config.id || [this.machine.id, ...this.path].join(STATE_DELIMITER);
    this.type = this.config.type || (this.config.states && Object.keys(this.config.states).length ? "compound" : this.config.history ? "history" : "atomic");
    this.description = this.config.description;
    this.order = this.machine.idMap.size;
    this.machine.idMap.set(this.id, this);
    this.states = this.config.states ? mapValues(this.config.states, (stateConfig, key) => {
      const stateNode = new _StateNode(stateConfig, {
        _parent: this,
        _key: key,
        _machine: this.machine
      });
      return stateNode;
    }) : EMPTY_OBJECT;
    if (this.type === "compound" && !this.config.initial) {
      throw new Error(`No initial state specified for compound state node "#${this.id}". Try adding { initial: "${Object.keys(this.states)[0]}" } to the state config.`);
    }
    this.history = this.config.history === true ? "shallow" : this.config.history || false;
    this.entry = toArray(this.config.entry).slice();
    this.exit = toArray(this.config.exit).slice();
    this.meta = this.config.meta;
    this.output = this.type === "final" || !this.parent ? this.config.output : void 0;
    this.tags = toArray(config.tags).slice();
  }
  /** @internal */
  _initialize() {
    this.transitions = formatTransitions(this);
    if (this.config.always) {
      this.always = toTransitionConfigArray(this.config.always).map((t9) => formatTransition(this, NULL_EVENT, t9));
    }
    Object.keys(this.states).forEach((key) => {
      this.states[key]._initialize();
    });
  }
  /**
   * The well-structured state node definition.
   */
  get definition() {
    return {
      id: this.id,
      key: this.key,
      version: this.machine.version,
      type: this.type,
      initial: this.initial ? {
        target: this.initial.target,
        source: this,
        actions: this.initial.actions.map(toSerializableAction),
        eventType: null,
        reenter: false,
        toJSON: () => ({
          target: this.initial.target.map((t9) => `#${t9.id}`),
          source: `#${this.id}`,
          actions: this.initial.actions.map(toSerializableAction),
          eventType: null
        })
      } : void 0,
      history: this.history,
      states: mapValues(this.states, (state) => {
        return state.definition;
      }),
      on: this.on,
      transitions: [...this.transitions.values()].flat().map((t9) => __spreadProps(__spreadValues({}, t9), {
        actions: t9.actions.map(toSerializableAction)
      })),
      entry: this.entry.map(toSerializableAction),
      exit: this.exit.map(toSerializableAction),
      meta: this.meta,
      order: this.order || -1,
      output: this.output,
      invoke: this.invoke,
      description: this.description,
      tags: this.tags
    };
  }
  /** @internal */
  toJSON() {
    return this.definition;
  }
  /**
   * The logic invoked as actors by this state node.
   */
  get invoke() {
    return memo(this, "invoke", () => toArray(this.config.invoke).map((invokeConfig, i6) => {
      var _a9;
      const {
        src,
        systemId
      } = invokeConfig;
      const resolvedId = (_a9 = invokeConfig.id) != null ? _a9 : createInvokeId(this.id, i6);
      const resolvedSrc = typeof src === "string" ? src : `xstate.invoke.${createInvokeId(this.id, i6)}`;
      return __spreadProps(__spreadValues({}, invokeConfig), {
        src: resolvedSrc,
        id: resolvedId,
        systemId,
        toJSON() {
          const _a10 = invokeConfig, {
            onDone,
            onError
          } = _a10, invokeDefValues = __objRest(_a10, [
            "onDone",
            "onError"
          ]);
          return __spreadProps(__spreadValues({}, invokeDefValues), {
            type: "xstate.invoke",
            src: resolvedSrc,
            id: resolvedId
          });
        }
      });
    }));
  }
  /**
   * The mapping of events to transitions.
   */
  get on() {
    return memo(this, "on", () => {
      const transitions = this.transitions;
      return [...transitions].flatMap(([descriptor, t9]) => t9.map((t10) => [descriptor, t10])).reduce((map, [descriptor, transition]) => {
        map[descriptor] = map[descriptor] || [];
        map[descriptor].push(transition);
        return map;
      }, {});
    });
  }
  get after() {
    return memo(this, "delayedTransitions", () => getDelayedTransitions(this));
  }
  get initial() {
    return memo(this, "initial", () => formatInitialTransition(this, this.config.initial));
  }
  /** @internal */
  next(snapshot, event2) {
    const eventType = event2.type;
    const actions = [];
    let selectedTransition;
    const candidates = memo(this, `candidates-${eventType}`, () => getCandidates(this, eventType));
    for (const candidate of candidates) {
      const {
        guard
      } = candidate;
      const resolvedContext = snapshot.context;
      let guardPassed = false;
      try {
        guardPassed = !guard || evaluateGuard(guard, resolvedContext, event2, snapshot);
      } catch (err) {
        const guardType = typeof guard === "string" ? guard : typeof guard === "object" ? guard.type : void 0;
        throw new Error(`Unable to evaluate guard ${guardType ? `'${guardType}' ` : ""}in transition for event '${eventType}' in state node '${this.id}':
${err.message}`);
      }
      if (guardPassed) {
        actions.push(...candidate.actions);
        selectedTransition = candidate;
        break;
      }
    }
    return selectedTransition ? [selectedTransition] : void 0;
  }
  /**
   * All the event types accepted by this state node and its descendants.
   */
  get events() {
    return memo(this, "events", () => {
      const {
        states
      } = this;
      const events = new Set(this.ownEvents);
      if (states) {
        for (const stateId of Object.keys(states)) {
          const state = states[stateId];
          if (state.states) {
            for (const event2 of state.events) {
              events.add(`${event2}`);
            }
          }
        }
      }
      return Array.from(events);
    });
  }
  /**
   * All the events that have transitions directly from this state node.
   *
   * Excludes any inert events.
   */
  get ownEvents() {
    const events = new Set([...this.transitions.keys()].filter((descriptor) => {
      return this.transitions.get(descriptor).some((transition) => !(!transition.target && !transition.actions.length && !transition.reenter));
    }));
    return Array.from(events);
  }
};
var STATE_IDENTIFIER2 = "#";
var StateMachine = class _StateMachine {
  constructor(config, implementations) {
    var _a9, _b2, _c, _d;
    this.config = config;
    this.version = void 0;
    this.implementations = void 0;
    this.__xstatenode = true;
    this.idMap = /* @__PURE__ */ new Map();
    this.root = void 0;
    this.id = void 0;
    this.states = void 0;
    this.events = void 0;
    this.__TResolvedTypesMeta = void 0;
    this.id = config.id || "(machine)";
    this.implementations = {
      actors: (_a9 = implementations == null ? void 0 : implementations.actors) != null ? _a9 : {},
      actions: (_b2 = implementations == null ? void 0 : implementations.actions) != null ? _b2 : {},
      delays: (_c = implementations == null ? void 0 : implementations.delays) != null ? _c : {},
      guards: (_d = implementations == null ? void 0 : implementations.guards) != null ? _d : {}
    };
    this.version = this.config.version;
    this.transition = this.transition.bind(this);
    this.getInitialSnapshot = this.getInitialSnapshot.bind(this);
    this.getPersistedSnapshot = this.getPersistedSnapshot.bind(this);
    this.restoreSnapshot = this.restoreSnapshot.bind(this);
    this.start = this.start.bind(this);
    this.root = new StateNode(config, {
      _key: this.id,
      _machine: this
    });
    this.root._initialize();
    this.states = this.root.states;
    this.events = this.root.events;
  }
  /**
   * Clones this state machine with the provided implementations
   * and merges the `context` (if provided).
   *
   * @param implementations Options (`actions`, `guards`, `actors`, `delays`, `context`)
   *  to recursively merge with the existing options.
   *
   * @returns A new `StateMachine` instance with the provided implementations.
   */
  provide(implementations) {
    const {
      actions,
      guards,
      actors,
      delays
    } = this.implementations;
    return new _StateMachine(this.config, {
      actions: __spreadValues(__spreadValues({}, actions), implementations.actions),
      guards: __spreadValues(__spreadValues({}, guards), implementations.guards),
      actors: __spreadValues(__spreadValues({}, actors), implementations.actors),
      delays: __spreadValues(__spreadValues({}, delays), implementations.delays)
    });
  }
  resolveState(config) {
    const resolvedStateValue = resolveStateValue(this.root, config.value);
    const nodeSet = getAllStateNodes(getStateNodes(this.root, resolvedStateValue));
    return createMachineSnapshot({
      _nodes: [...nodeSet],
      context: config.context || {},
      children: {},
      status: isInFinalState(nodeSet, this.root) ? "done" : config.status || "active",
      output: config.output,
      error: config.error,
      historyValue: config.historyValue
    }, this);
  }
  /**
   * Determines the next snapshot given the current `snapshot` and received `event`.
   * Calculates a full macrostep from all microsteps.
   *
   * @param snapshot The current snapshot
   * @param event The received event
   */
  transition(snapshot, event2, actorScope) {
    return macrostep(snapshot, event2, actorScope).snapshot;
  }
  /**
   * Determines the next state given the current `state` and `event`.
   * Calculates a microstep.
   *
   * @param state The current state
   * @param event The received event
   */
  microstep(snapshot, event2, actorScope) {
    return macrostep(snapshot, event2, actorScope).microstates;
  }
  getTransitionData(snapshot, event2) {
    return transitionNode(this.root, snapshot.value, snapshot, event2) || [];
  }
  /**
   * The initial state _before_ evaluating any microsteps.
   * This "pre-initial" state is provided to initial actions executed in the initial state.
   */
  getPreInitialState(actorScope, initEvent, internalQueue) {
    const {
      context
    } = this.config;
    const preInitial = createMachineSnapshot({
      context: typeof context !== "function" && context ? context : {},
      _nodes: [this.root],
      children: {},
      status: "active"
    }, this);
    if (typeof context === "function") {
      const assignment = ({
        spawn,
        event: event2,
        self: self2
      }) => context({
        spawn,
        input: event2.input,
        self: self2
      });
      return resolveActionsAndContext(preInitial, initEvent, actorScope, [assign(assignment)], internalQueue);
    }
    return preInitial;
  }
  /**
   * Returns the initial `State` instance, with reference to `self` as an `ActorRef`.
   */
  getInitialSnapshot(actorScope, input) {
    const initEvent = createInitEvent(input);
    const internalQueue = [];
    const preInitialState = this.getPreInitialState(actorScope, initEvent, internalQueue);
    const nextState = microstep([{
      target: [...getInitialStateNodes(this.root)],
      source: this.root,
      reenter: true,
      actions: [],
      eventType: null,
      toJSON: null
      // TODO: fix
    }], preInitialState, actorScope, initEvent, true, internalQueue);
    const {
      snapshot: macroState
    } = macrostep(nextState, initEvent, actorScope, internalQueue);
    return macroState;
  }
  start(snapshot) {
    Object.values(snapshot.children).forEach((child) => {
      if (child.getSnapshot().status === "active") {
        child.start();
      }
    });
  }
  getStateNodeById(stateId) {
    const fullPath = toStatePath(stateId);
    const relativePath = fullPath.slice(1);
    const resolvedStateId = isStateId(fullPath[0]) ? fullPath[0].slice(STATE_IDENTIFIER2.length) : fullPath[0];
    const stateNode = this.idMap.get(resolvedStateId);
    if (!stateNode) {
      throw new Error(`Child state node '#${resolvedStateId}' does not exist on machine '${this.id}'`);
    }
    return getStateNodeByPath(stateNode, relativePath);
  }
  get definition() {
    return this.root.definition;
  }
  toJSON() {
    return this.definition;
  }
  getPersistedSnapshot(snapshot, options) {
    return getPersistedSnapshot(snapshot, options);
  }
  restoreSnapshot(snapshot, _actorScope) {
    const children = {};
    const snapshotChildren = snapshot.children;
    Object.keys(snapshotChildren).forEach((actorId) => {
      const actorData = snapshotChildren[actorId];
      const childState = actorData.snapshot;
      const src = actorData.src;
      const logic = typeof src === "string" ? resolveReferencedActor(this, src) : src;
      if (!logic) {
        return;
      }
      const actorRef = createActor(logic, {
        id: actorId,
        parent: _actorScope.self,
        syncSnapshot: actorData.syncSnapshot,
        snapshot: childState,
        src,
        systemId: actorData.systemId
      });
      children[actorId] = actorRef;
    });
    const restoredSnapshot = createMachineSnapshot(__spreadProps(__spreadValues({}, snapshot), {
      children,
      _nodes: Array.from(getAllStateNodes(getStateNodes(this.root, snapshot.value)))
    }), this);
    let seen = /* @__PURE__ */ new Set();
    function reviveContext(contextPart, children2) {
      if (seen.has(contextPart)) {
        return;
      }
      seen.add(contextPart);
      for (let key in contextPart) {
        const value = contextPart[key];
        if (value && typeof value === "object") {
          if ("xstate$$type" in value && value.xstate$$type === $$ACTOR_TYPE) {
            contextPart[key] = children2[value.id];
            continue;
          }
          reviveContext(value, children2);
        }
      }
    }
    reviveContext(restoredSnapshot.context, children);
    return restoredSnapshot;
  }
};
function createMachine(config, implementations) {
  return new StateMachine(config, implementations);
}
function setup({
  actors,
  actions,
  guards,
  delays
}) {
  return {
    createMachine: (config) => createMachine(config, {
      actors,
      actions,
      guards,
      delays
    })
  };
}

// node_modules/@itk-viewer/viewer/dist/viewer.js
var viewerMachine = setup({
  types: {}
}).createMachine({
  id: "viewer",
  initial: "active",
  context: {
    spawned: {},
    images: {}
  },
  states: {
    active: {
      on: {
        createChild: {
          actions: [
            assign({
              spawned: ({ spawn, context: { spawned }, event: { logic, onActor } }) => {
                const child = spawn(logic);
                const id = Object.keys(spawned).length.toString();
                onActor(child);
                return __spreadProps(__spreadValues({}, spawned), {
                  [id]: child
                });
              }
            })
          ]
        },
        setImage: {
          actions: [
            assign({
              images: ({ event: { image: image2, name = "image" }, context }) => __spreadProps(__spreadValues({}, context.images), {
                [name]: image2
              })
            }),
            raise(({ context }) => ({
              type: "sendImageToViewports",
              image: Object.values(context.images).at(-1)
            }))
          ]
        },
        sendImageToViewports: {
          actions: [
            ({ context, event: { image: image2 } }) => {
              Object.values(context.spawned).forEach((viewport) => {
                viewport.send({
                  type: "setImage",
                  image: image2
                });
              });
            }
          ]
        }
      }
    }
  }
});

// node_modules/@itk-viewer/element/dist/spawn-controller.js
var dispatchSpawn = (host, eventType, logic, onActor) => {
  const event2 = new CustomEvent(eventType, {
    bubbles: true,
    composed: true,
    detail: {
      logic,
      onActor
    }
  });
  host.dispatchEvent(event2);
};
var handleLogic = (parentActor) => {
  return (e13) => {
    if (!parentActor)
      throw new Error("Parent actor not available");
    e13.stopPropagation();
    const logic = e13.detail.logic;
    parentActor.send({
      type: "createChild",
      //@ts-expect-error childType not expected on EventObject
      childType: e13.type,
      logic,
      onActor: e13.detail.onActor
    });
  };
};

// node_modules/@itk-viewer/element/dist/itk-viewer-element.js
var __decorate = function(decorators, target, key, desc) {
  var c6 = arguments.length, r9 = c6 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
  else for (var i6 = decorators.length - 1; i6 >= 0; i6--) if (d3 = decorators[i6]) r9 = (c6 < 3 ? d3(r9) : c6 > 3 ? d3(target, key, r9) : d3(target, key)) || r9;
  return c6 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
};
var ItkViewer = class ItkViewer2 extends s3 {
  constructor() {
    super(...arguments);
    this.actor = createActor(viewerMachine).start();
  }
  getActor() {
    return this.actor;
  }
  render() {
    return x`<slot @viewport=${handleLogic(this.actor)}></slot>`;
  }
};
ItkViewer = __decorate([
  t3("itk-viewer")
], ItkViewer);

// node_modules/@itk-viewer/utils/dist/bounding-box.js
var INIT_BOUNDS = Object.freeze([
  Number.MAX_VALUE,
  -Number.MAX_VALUE,
  // X
  Number.MAX_VALUE,
  -Number.MAX_VALUE,
  // Y
  Number.MAX_VALUE,
  -Number.MAX_VALUE
  // Z
]);
var createBounds = () => [...INIT_BOUNDS];
function addPoint(bounds, x2, y3, z3) {
  const [xMin, xMax, yMin, yMax, zMin, zMax] = bounds;
  bounds[0] = xMin < x2 ? xMin : x2;
  bounds[1] = xMax > x2 ? xMax : x2;
  bounds[2] = yMin < y3 ? yMin : y3;
  bounds[3] = yMax > y3 ? yMax : y3;
  bounds[4] = zMin < z3 ? zMin : z3;
  bounds[5] = zMax > z3 ? zMax : z3;
  return bounds;
}
function getCorners(bounds) {
  const corners = new Array(8);
  let count = 0;
  for (let ix = 0; ix < 2; ix++) {
    for (let iy = 2; iy < 4; iy++) {
      for (let iz = 4; iz < 6; iz++) {
        corners[count++] = [bounds[ix], bounds[iy], bounds[iz]];
      }
    }
  }
  return corners;
}
function getLength(bounds, index2) {
  return bounds[index2 * 2 + 1] - bounds[index2 * 2];
}

// node_modules/gl-matrix/esm/common.js
var common_exports = {};
__export(common_exports, {
  ARRAY_TYPE: () => ARRAY_TYPE,
  EPSILON: () => EPSILON,
  RANDOM: () => RANDOM,
  equals: () => equals,
  setMatrixArrayType: () => setMatrixArrayType,
  toRadian: () => toRadian
});
var EPSILON = 1e-6;
var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
var RANDOM = Math.random;
function setMatrixArrayType(type) {
  ARRAY_TYPE = type;
}
var degree = Math.PI / 180;
function toRadian(a4) {
  return a4 * degree;
}
function equals(a4, b3) {
  return Math.abs(a4 - b3) <= EPSILON * Math.max(1, Math.abs(a4), Math.abs(b3));
}
if (!Math.hypot) Math.hypot = function() {
  var y3 = 0, i6 = arguments.length;
  while (i6--) {
    y3 += arguments[i6] * arguments[i6];
  }
  return Math.sqrt(y3);
};

// node_modules/gl-matrix/esm/mat3.js
var mat3_exports = {};
__export(mat3_exports, {
  add: () => add,
  adjoint: () => adjoint,
  clone: () => clone,
  copy: () => copy,
  create: () => create,
  determinant: () => determinant,
  equals: () => equals2,
  exactEquals: () => exactEquals,
  frob: () => frob,
  fromMat2d: () => fromMat2d,
  fromMat4: () => fromMat4,
  fromQuat: () => fromQuat,
  fromRotation: () => fromRotation,
  fromScaling: () => fromScaling,
  fromTranslation: () => fromTranslation,
  fromValues: () => fromValues,
  identity: () => identity,
  invert: () => invert,
  mul: () => mul,
  multiply: () => multiply,
  multiplyScalar: () => multiplyScalar,
  multiplyScalarAndAdd: () => multiplyScalarAndAdd,
  normalFromMat4: () => normalFromMat4,
  projection: () => projection,
  rotate: () => rotate,
  scale: () => scale,
  set: () => set,
  str: () => str,
  sub: () => sub,
  subtract: () => subtract,
  translate: () => translate,
  transpose: () => transpose
});
function create() {
  var out = new ARRAY_TYPE(9);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }
  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
function fromMat4(out, a4) {
  out[0] = a4[0];
  out[1] = a4[1];
  out[2] = a4[2];
  out[3] = a4[4];
  out[4] = a4[5];
  out[5] = a4[6];
  out[6] = a4[8];
  out[7] = a4[9];
  out[8] = a4[10];
  return out;
}
function clone(a4) {
  var out = new ARRAY_TYPE(9);
  out[0] = a4[0];
  out[1] = a4[1];
  out[2] = a4[2];
  out[3] = a4[3];
  out[4] = a4[4];
  out[5] = a4[5];
  out[6] = a4[6];
  out[7] = a4[7];
  out[8] = a4[8];
  return out;
}
function copy(out, a4) {
  out[0] = a4[0];
  out[1] = a4[1];
  out[2] = a4[2];
  out[3] = a4[3];
  out[4] = a4[4];
  out[5] = a4[5];
  out[6] = a4[6];
  out[7] = a4[7];
  out[8] = a4[8];
  return out;
}
function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  var out = new ARRAY_TYPE(9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function transpose(out, a4) {
  if (out === a4) {
    var a01 = a4[1], a02 = a4[2], a12 = a4[5];
    out[1] = a4[3];
    out[2] = a4[6];
    out[3] = a01;
    out[5] = a4[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a4[0];
    out[1] = a4[3];
    out[2] = a4[6];
    out[3] = a4[1];
    out[4] = a4[4];
    out[5] = a4[7];
    out[6] = a4[2];
    out[7] = a4[5];
    out[8] = a4[8];
  }
  return out;
}
function invert(out, a4) {
  var a00 = a4[0], a01 = a4[1], a02 = a4[2];
  var a10 = a4[3], a11 = a4[4], a12 = a4[5];
  var a20 = a4[6], a21 = a4[7], a22 = a4[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20;
  var det = a00 * b01 + a01 * b11 + a02 * b21;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}
function adjoint(out, a4) {
  var a00 = a4[0], a01 = a4[1], a02 = a4[2];
  var a10 = a4[3], a11 = a4[4], a12 = a4[5];
  var a20 = a4[6], a21 = a4[7], a22 = a4[8];
  out[0] = a11 * a22 - a12 * a21;
  out[1] = a02 * a21 - a01 * a22;
  out[2] = a01 * a12 - a02 * a11;
  out[3] = a12 * a20 - a10 * a22;
  out[4] = a00 * a22 - a02 * a20;
  out[5] = a02 * a10 - a00 * a12;
  out[6] = a10 * a21 - a11 * a20;
  out[7] = a01 * a20 - a00 * a21;
  out[8] = a00 * a11 - a01 * a10;
  return out;
}
function determinant(a4) {
  var a00 = a4[0], a01 = a4[1], a02 = a4[2];
  var a10 = a4[3], a11 = a4[4], a12 = a4[5];
  var a20 = a4[6], a21 = a4[7], a22 = a4[8];
  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}
function multiply(out, a4, b3) {
  var a00 = a4[0], a01 = a4[1], a02 = a4[2];
  var a10 = a4[3], a11 = a4[4], a12 = a4[5];
  var a20 = a4[6], a21 = a4[7], a22 = a4[8];
  var b00 = b3[0], b01 = b3[1], b02 = b3[2];
  var b10 = b3[3], b11 = b3[4], b12 = b3[5];
  var b20 = b3[6], b21 = b3[7], b22 = b3[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
function translate(out, a4, v2) {
  var a00 = a4[0], a01 = a4[1], a02 = a4[2], a10 = a4[3], a11 = a4[4], a12 = a4[5], a20 = a4[6], a21 = a4[7], a22 = a4[8], x2 = v2[0], y3 = v2[1];
  out[0] = a00;
  out[1] = a01;
  out[2] = a02;
  out[3] = a10;
  out[4] = a11;
  out[5] = a12;
  out[6] = x2 * a00 + y3 * a10 + a20;
  out[7] = x2 * a01 + y3 * a11 + a21;
  out[8] = x2 * a02 + y3 * a12 + a22;
  return out;
}
function rotate(out, a4, rad) {
  var a00 = a4[0], a01 = a4[1], a02 = a4[2], a10 = a4[3], a11 = a4[4], a12 = a4[5], a20 = a4[6], a21 = a4[7], a22 = a4[8], s9 = Math.sin(rad), c6 = Math.cos(rad);
  out[0] = c6 * a00 + s9 * a10;
  out[1] = c6 * a01 + s9 * a11;
  out[2] = c6 * a02 + s9 * a12;
  out[3] = c6 * a10 - s9 * a00;
  out[4] = c6 * a11 - s9 * a01;
  out[5] = c6 * a12 - s9 * a02;
  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
}
function scale(out, a4, v2) {
  var x2 = v2[0], y3 = v2[1];
  out[0] = x2 * a4[0];
  out[1] = x2 * a4[1];
  out[2] = x2 * a4[2];
  out[3] = y3 * a4[3];
  out[4] = y3 * a4[4];
  out[5] = y3 * a4[5];
  out[6] = a4[6];
  out[7] = a4[7];
  out[8] = a4[8];
  return out;
}
function fromTranslation(out, v2) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v2[0];
  out[7] = v2[1];
  out[8] = 1;
  return out;
}
function fromRotation(out, rad) {
  var s9 = Math.sin(rad), c6 = Math.cos(rad);
  out[0] = c6;
  out[1] = s9;
  out[2] = 0;
  out[3] = -s9;
  out[4] = c6;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function fromScaling(out, v2) {
  out[0] = v2[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = v2[1];
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function fromMat2d(out, a4) {
  out[0] = a4[0];
  out[1] = a4[1];
  out[2] = 0;
  out[3] = a4[2];
  out[4] = a4[3];
  out[5] = 0;
  out[6] = a4[4];
  out[7] = a4[5];
  out[8] = 1;
  return out;
}
function fromQuat(out, q) {
  var x2 = q[0], y3 = q[1], z3 = q[2], w2 = q[3];
  var x22 = x2 + x2;
  var y22 = y3 + y3;
  var z22 = z3 + z3;
  var xx = x2 * x22;
  var yx = y3 * x22;
  var yy = y3 * y22;
  var zx = z3 * x22;
  var zy = z3 * y22;
  var zz = z3 * z22;
  var wx = w2 * x22;
  var wy = w2 * y22;
  var wz = w2 * z22;
  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;
  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;
  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;
  return out;
}
function normalFromMat4(out, a4) {
  var a00 = a4[0], a01 = a4[1], a02 = a4[2], a03 = a4[3];
  var a10 = a4[4], a11 = a4[5], a12 = a4[6], a13 = a4[7];
  var a20 = a4[8], a21 = a4[9], a22 = a4[10], a23 = a4[11];
  var a30 = a4[12], a31 = a4[13], a32 = a4[14], a33 = a4[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  return out;
}
function projection(out, width, height) {
  out[0] = 2 / width;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = -2 / height;
  out[5] = 0;
  out[6] = -1;
  out[7] = 1;
  out[8] = 1;
  return out;
}
function str(a4) {
  return "mat3(" + a4[0] + ", " + a4[1] + ", " + a4[2] + ", " + a4[3] + ", " + a4[4] + ", " + a4[5] + ", " + a4[6] + ", " + a4[7] + ", " + a4[8] + ")";
}
function frob(a4) {
  return Math.hypot(a4[0], a4[1], a4[2], a4[3], a4[4], a4[5], a4[6], a4[7], a4[8]);
}
function add(out, a4, b3) {
  out[0] = a4[0] + b3[0];
  out[1] = a4[1] + b3[1];
  out[2] = a4[2] + b3[2];
  out[3] = a4[3] + b3[3];
  out[4] = a4[4] + b3[4];
  out[5] = a4[5] + b3[5];
  out[6] = a4[6] + b3[6];
  out[7] = a4[7] + b3[7];
  out[8] = a4[8] + b3[8];
  return out;
}
function subtract(out, a4, b3) {
  out[0] = a4[0] - b3[0];
  out[1] = a4[1] - b3[1];
  out[2] = a4[2] - b3[2];
  out[3] = a4[3] - b3[3];
  out[4] = a4[4] - b3[4];
  out[5] = a4[5] - b3[5];
  out[6] = a4[6] - b3[6];
  out[7] = a4[7] - b3[7];
  out[8] = a4[8] - b3[8];
  return out;
}
function multiplyScalar(out, a4, b3) {
  out[0] = a4[0] * b3;
  out[1] = a4[1] * b3;
  out[2] = a4[2] * b3;
  out[3] = a4[3] * b3;
  out[4] = a4[4] * b3;
  out[5] = a4[5] * b3;
  out[6] = a4[6] * b3;
  out[7] = a4[7] * b3;
  out[8] = a4[8] * b3;
  return out;
}
function multiplyScalarAndAdd(out, a4, b3, scale7) {
  out[0] = a4[0] + b3[0] * scale7;
  out[1] = a4[1] + b3[1] * scale7;
  out[2] = a4[2] + b3[2] * scale7;
  out[3] = a4[3] + b3[3] * scale7;
  out[4] = a4[4] + b3[4] * scale7;
  out[5] = a4[5] + b3[5] * scale7;
  out[6] = a4[6] + b3[6] * scale7;
  out[7] = a4[7] + b3[7] * scale7;
  out[8] = a4[8] + b3[8] * scale7;
  return out;
}
function exactEquals(a4, b3) {
  return a4[0] === b3[0] && a4[1] === b3[1] && a4[2] === b3[2] && a4[3] === b3[3] && a4[4] === b3[4] && a4[5] === b3[5] && a4[6] === b3[6] && a4[7] === b3[7] && a4[8] === b3[8];
}
function equals2(a4, b3) {
  var a0 = a4[0], a1 = a4[1], a22 = a4[2], a32 = a4[3], a42 = a4[4], a5 = a4[5], a6 = a4[6], a7 = a4[7], a8 = a4[8];
  var b0 = b3[0], b1 = b3[1], b22 = b3[2], b32 = b3[3], b4 = b3[4], b5 = b3[5], b6 = b3[6], b7 = b3[7], b8 = b3[8];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a22 - b22) <= EPSILON * Math.max(1, Math.abs(a22), Math.abs(b22)) && Math.abs(a32 - b32) <= EPSILON * Math.max(1, Math.abs(a32), Math.abs(b32)) && Math.abs(a42 - b4) <= EPSILON * Math.max(1, Math.abs(a42), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8));
}
var mul = multiply;
var sub = subtract;

// node_modules/gl-matrix/esm/mat4.js
var mat4_exports = {};
__export(mat4_exports, {
  add: () => add2,
  adjoint: () => adjoint2,
  clone: () => clone2,
  copy: () => copy2,
  create: () => create2,
  determinant: () => determinant2,
  equals: () => equals3,
  exactEquals: () => exactEquals2,
  frob: () => frob2,
  fromQuat: () => fromQuat3,
  fromQuat2: () => fromQuat2,
  fromRotation: () => fromRotation2,
  fromRotationTranslation: () => fromRotationTranslation,
  fromRotationTranslationScale: () => fromRotationTranslationScale,
  fromRotationTranslationScaleOrigin: () => fromRotationTranslationScaleOrigin,
  fromScaling: () => fromScaling2,
  fromTranslation: () => fromTranslation2,
  fromValues: () => fromValues2,
  fromXRotation: () => fromXRotation,
  fromYRotation: () => fromYRotation,
  fromZRotation: () => fromZRotation,
  frustum: () => frustum,
  getRotation: () => getRotation,
  getScaling: () => getScaling,
  getTranslation: () => getTranslation,
  identity: () => identity2,
  invert: () => invert2,
  lookAt: () => lookAt,
  mul: () => mul2,
  multiply: () => multiply2,
  multiplyScalar: () => multiplyScalar2,
  multiplyScalarAndAdd: () => multiplyScalarAndAdd2,
  ortho: () => ortho,
  orthoNO: () => orthoNO,
  orthoZO: () => orthoZO,
  perspective: () => perspective,
  perspectiveFromFieldOfView: () => perspectiveFromFieldOfView,
  perspectiveNO: () => perspectiveNO,
  perspectiveZO: () => perspectiveZO,
  rotate: () => rotate2,
  rotateX: () => rotateX,
  rotateY: () => rotateY,
  rotateZ: () => rotateZ,
  scale: () => scale2,
  set: () => set2,
  str: () => str2,
  sub: () => sub2,
  subtract: () => subtract2,
  targetTo: () => targetTo,
  translate: () => translate2,
  transpose: () => transpose2
});
function create2() {
  var out = new ARRAY_TYPE(16);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }
  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
function clone2(a4) {
  var out = new ARRAY_TYPE(16);
  out[0] = a4[0];
  out[1] = a4[1];
  out[2] = a4[2];
  out[3] = a4[3];
  out[4] = a4[4];
  out[5] = a4[5];
  out[6] = a4[6];
  out[7] = a4[7];
  out[8] = a4[8];
  out[9] = a4[9];
  out[10] = a4[10];
  out[11] = a4[11];
  out[12] = a4[12];
  out[13] = a4[13];
  out[14] = a4[14];
  out[15] = a4[15];
  return out;
}
function copy2(out, a4) {
  out[0] = a4[0];
  out[1] = a4[1];
  out[2] = a4[2];
  out[3] = a4[3];
  out[4] = a4[4];
  out[5] = a4[5];
  out[6] = a4[6];
  out[7] = a4[7];
  out[8] = a4[8];
  out[9] = a4[9];
  out[10] = a4[10];
  out[11] = a4[11];
  out[12] = a4[12];
  out[13] = a4[13];
  out[14] = a4[14];
  out[15] = a4[15];
  return out;
}
function fromValues2(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  var out = new ARRAY_TYPE(16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
function set2(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
function identity2(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function transpose2(out, a4) {
  if (out === a4) {
    var a01 = a4[1], a02 = a4[2], a03 = a4[3];
    var a12 = a4[6], a13 = a4[7];
    var a23 = a4[11];
    out[1] = a4[4];
    out[2] = a4[8];
    out[3] = a4[12];
    out[4] = a01;
    out[6] = a4[9];
    out[7] = a4[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a4[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a4[0];
    out[1] = a4[4];
    out[2] = a4[8];
    out[3] = a4[12];
    out[4] = a4[1];
    out[5] = a4[5];
    out[6] = a4[9];
    out[7] = a4[13];
    out[8] = a4[2];
    out[9] = a4[6];
    out[10] = a4[10];
    out[11] = a4[14];
    out[12] = a4[3];
    out[13] = a4[7];
    out[14] = a4[11];
    out[15] = a4[15];
  }
  return out;
}
function invert2(out, a4) {
  var a00 = a4[0], a01 = a4[1], a02 = a4[2], a03 = a4[3];
  var a10 = a4[4], a11 = a4[5], a12 = a4[6], a13 = a4[7];
  var a20 = a4[8], a21 = a4[9], a22 = a4[10], a23 = a4[11];
  var a30 = a4[12], a31 = a4[13], a32 = a4[14], a33 = a4[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
function adjoint2(out, a4) {
  var a00 = a4[0], a01 = a4[1], a02 = a4[2], a03 = a4[3];
  var a10 = a4[4], a11 = a4[5], a12 = a4[6], a13 = a4[7];
  var a20 = a4[8], a21 = a4[9], a22 = a4[10], a23 = a4[11];
  var a30 = a4[12], a31 = a4[13], a32 = a4[14], a33 = a4[15];
  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
  return out;
}
function determinant2(a4) {
  var a00 = a4[0], a01 = a4[1], a02 = a4[2], a03 = a4[3];
  var a10 = a4[4], a11 = a4[5], a12 = a4[6], a13 = a4[7];
  var a20 = a4[8], a21 = a4[9], a22 = a4[10], a23 = a4[11];
  var a30 = a4[12], a31 = a4[13], a32 = a4[14], a33 = a4[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}
function multiply2(out, a4, b3) {
  var a00 = a4[0], a01 = a4[1], a02 = a4[2], a03 = a4[3];
  var a10 = a4[4], a11 = a4[5], a12 = a4[6], a13 = a4[7];
  var a20 = a4[8], a21 = a4[9], a22 = a4[10], a23 = a4[11];
  var a30 = a4[12], a31 = a4[13], a32 = a4[14], a33 = a4[15];
  var b0 = b3[0], b1 = b3[1], b22 = b3[2], b32 = b3[3];
  out[0] = b0 * a00 + b1 * a10 + b22 * a20 + b32 * a30;
  out[1] = b0 * a01 + b1 * a11 + b22 * a21 + b32 * a31;
  out[2] = b0 * a02 + b1 * a12 + b22 * a22 + b32 * a32;
  out[3] = b0 * a03 + b1 * a13 + b22 * a23 + b32 * a33;
  b0 = b3[4];
  b1 = b3[5];
  b22 = b3[6];
  b32 = b3[7];
  out[4] = b0 * a00 + b1 * a10 + b22 * a20 + b32 * a30;
  out[5] = b0 * a01 + b1 * a11 + b22 * a21 + b32 * a31;
  out[6] = b0 * a02 + b1 * a12 + b22 * a22 + b32 * a32;
  out[7] = b0 * a03 + b1 * a13 + b22 * a23 + b32 * a33;
  b0 = b3[8];
  b1 = b3[9];
  b22 = b3[10];
  b32 = b3[11];
  out[8] = b0 * a00 + b1 * a10 + b22 * a20 + b32 * a30;
  out[9] = b0 * a01 + b1 * a11 + b22 * a21 + b32 * a31;
  out[10] = b0 * a02 + b1 * a12 + b22 * a22 + b32 * a32;
  out[11] = b0 * a03 + b1 * a13 + b22 * a23 + b32 * a33;
  b0 = b3[12];
  b1 = b3[13];
  b22 = b3[14];
  b32 = b3[15];
  out[12] = b0 * a00 + b1 * a10 + b22 * a20 + b32 * a30;
  out[13] = b0 * a01 + b1 * a11 + b22 * a21 + b32 * a31;
  out[14] = b0 * a02 + b1 * a12 + b22 * a22 + b32 * a32;
  out[15] = b0 * a03 + b1 * a13 + b22 * a23 + b32 * a33;
  return out;
}
function translate2(out, a4, v2) {
  var x2 = v2[0], y3 = v2[1], z3 = v2[2];
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  if (a4 === out) {
    out[12] = a4[0] * x2 + a4[4] * y3 + a4[8] * z3 + a4[12];
    out[13] = a4[1] * x2 + a4[5] * y3 + a4[9] * z3 + a4[13];
    out[14] = a4[2] * x2 + a4[6] * y3 + a4[10] * z3 + a4[14];
    out[15] = a4[3] * x2 + a4[7] * y3 + a4[11] * z3 + a4[15];
  } else {
    a00 = a4[0];
    a01 = a4[1];
    a02 = a4[2];
    a03 = a4[3];
    a10 = a4[4];
    a11 = a4[5];
    a12 = a4[6];
    a13 = a4[7];
    a20 = a4[8];
    a21 = a4[9];
    a22 = a4[10];
    a23 = a4[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x2 + a10 * y3 + a20 * z3 + a4[12];
    out[13] = a01 * x2 + a11 * y3 + a21 * z3 + a4[13];
    out[14] = a02 * x2 + a12 * y3 + a22 * z3 + a4[14];
    out[15] = a03 * x2 + a13 * y3 + a23 * z3 + a4[15];
  }
  return out;
}
function scale2(out, a4, v2) {
  var x2 = v2[0], y3 = v2[1], z3 = v2[2];
  out[0] = a4[0] * x2;
  out[1] = a4[1] * x2;
  out[2] = a4[2] * x2;
  out[3] = a4[3] * x2;
  out[4] = a4[4] * y3;
  out[5] = a4[5] * y3;
  out[6] = a4[6] * y3;
  out[7] = a4[7] * y3;
  out[8] = a4[8] * z3;
  out[9] = a4[9] * z3;
  out[10] = a4[10] * z3;
  out[11] = a4[11] * z3;
  out[12] = a4[12];
  out[13] = a4[13];
  out[14] = a4[14];
  out[15] = a4[15];
  return out;
}
function rotate2(out, a4, rad, axis2) {
  var x2 = axis2[0], y3 = axis2[1], z3 = axis2[2];
  var len4 = Math.hypot(x2, y3, z3);
  var s9, c6, t9;
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  var b00, b01, b02;
  var b10, b11, b12;
  var b20, b21, b22;
  if (len4 < EPSILON) {
    return null;
  }
  len4 = 1 / len4;
  x2 *= len4;
  y3 *= len4;
  z3 *= len4;
  s9 = Math.sin(rad);
  c6 = Math.cos(rad);
  t9 = 1 - c6;
  a00 = a4[0];
  a01 = a4[1];
  a02 = a4[2];
  a03 = a4[3];
  a10 = a4[4];
  a11 = a4[5];
  a12 = a4[6];
  a13 = a4[7];
  a20 = a4[8];
  a21 = a4[9];
  a22 = a4[10];
  a23 = a4[11];
  b00 = x2 * x2 * t9 + c6;
  b01 = y3 * x2 * t9 + z3 * s9;
  b02 = z3 * x2 * t9 - y3 * s9;
  b10 = x2 * y3 * t9 - z3 * s9;
  b11 = y3 * y3 * t9 + c6;
  b12 = z3 * y3 * t9 + x2 * s9;
  b20 = x2 * z3 * t9 + y3 * s9;
  b21 = y3 * z3 * t9 - x2 * s9;
  b22 = z3 * z3 * t9 + c6;
  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;
  if (a4 !== out) {
    out[12] = a4[12];
    out[13] = a4[13];
    out[14] = a4[14];
    out[15] = a4[15];
  }
  return out;
}
function rotateX(out, a4, rad) {
  var s9 = Math.sin(rad);
  var c6 = Math.cos(rad);
  var a10 = a4[4];
  var a11 = a4[5];
  var a12 = a4[6];
  var a13 = a4[7];
  var a20 = a4[8];
  var a21 = a4[9];
  var a22 = a4[10];
  var a23 = a4[11];
  if (a4 !== out) {
    out[0] = a4[0];
    out[1] = a4[1];
    out[2] = a4[2];
    out[3] = a4[3];
    out[12] = a4[12];
    out[13] = a4[13];
    out[14] = a4[14];
    out[15] = a4[15];
  }
  out[4] = a10 * c6 + a20 * s9;
  out[5] = a11 * c6 + a21 * s9;
  out[6] = a12 * c6 + a22 * s9;
  out[7] = a13 * c6 + a23 * s9;
  out[8] = a20 * c6 - a10 * s9;
  out[9] = a21 * c6 - a11 * s9;
  out[10] = a22 * c6 - a12 * s9;
  out[11] = a23 * c6 - a13 * s9;
  return out;
}
function rotateY(out, a4, rad) {
  var s9 = Math.sin(rad);
  var c6 = Math.cos(rad);
  var a00 = a4[0];
  var a01 = a4[1];
  var a02 = a4[2];
  var a03 = a4[3];
  var a20 = a4[8];
  var a21 = a4[9];
  var a22 = a4[10];
  var a23 = a4[11];
  if (a4 !== out) {
    out[4] = a4[4];
    out[5] = a4[5];
    out[6] = a4[6];
    out[7] = a4[7];
    out[12] = a4[12];
    out[13] = a4[13];
    out[14] = a4[14];
    out[15] = a4[15];
  }
  out[0] = a00 * c6 - a20 * s9;
  out[1] = a01 * c6 - a21 * s9;
  out[2] = a02 * c6 - a22 * s9;
  out[3] = a03 * c6 - a23 * s9;
  out[8] = a00 * s9 + a20 * c6;
  out[9] = a01 * s9 + a21 * c6;
  out[10] = a02 * s9 + a22 * c6;
  out[11] = a03 * s9 + a23 * c6;
  return out;
}
function rotateZ(out, a4, rad) {
  var s9 = Math.sin(rad);
  var c6 = Math.cos(rad);
  var a00 = a4[0];
  var a01 = a4[1];
  var a02 = a4[2];
  var a03 = a4[3];
  var a10 = a4[4];
  var a11 = a4[5];
  var a12 = a4[6];
  var a13 = a4[7];
  if (a4 !== out) {
    out[8] = a4[8];
    out[9] = a4[9];
    out[10] = a4[10];
    out[11] = a4[11];
    out[12] = a4[12];
    out[13] = a4[13];
    out[14] = a4[14];
    out[15] = a4[15];
  }
  out[0] = a00 * c6 + a10 * s9;
  out[1] = a01 * c6 + a11 * s9;
  out[2] = a02 * c6 + a12 * s9;
  out[3] = a03 * c6 + a13 * s9;
  out[4] = a10 * c6 - a00 * s9;
  out[5] = a11 * c6 - a01 * s9;
  out[6] = a12 * c6 - a02 * s9;
  out[7] = a13 * c6 - a03 * s9;
  return out;
}
function fromTranslation2(out, v2) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v2[0];
  out[13] = v2[1];
  out[14] = v2[2];
  out[15] = 1;
  return out;
}
function fromScaling2(out, v2) {
  out[0] = v2[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v2[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v2[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromRotation2(out, rad, axis2) {
  var x2 = axis2[0], y3 = axis2[1], z3 = axis2[2];
  var len4 = Math.hypot(x2, y3, z3);
  var s9, c6, t9;
  if (len4 < EPSILON) {
    return null;
  }
  len4 = 1 / len4;
  x2 *= len4;
  y3 *= len4;
  z3 *= len4;
  s9 = Math.sin(rad);
  c6 = Math.cos(rad);
  t9 = 1 - c6;
  out[0] = x2 * x2 * t9 + c6;
  out[1] = y3 * x2 * t9 + z3 * s9;
  out[2] = z3 * x2 * t9 - y3 * s9;
  out[3] = 0;
  out[4] = x2 * y3 * t9 - z3 * s9;
  out[5] = y3 * y3 * t9 + c6;
  out[6] = z3 * y3 * t9 + x2 * s9;
  out[7] = 0;
  out[8] = x2 * z3 * t9 + y3 * s9;
  out[9] = y3 * z3 * t9 - x2 * s9;
  out[10] = z3 * z3 * t9 + c6;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromXRotation(out, rad) {
  var s9 = Math.sin(rad);
  var c6 = Math.cos(rad);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = c6;
  out[6] = s9;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s9;
  out[10] = c6;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromYRotation(out, rad) {
  var s9 = Math.sin(rad);
  var c6 = Math.cos(rad);
  out[0] = c6;
  out[1] = 0;
  out[2] = -s9;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s9;
  out[9] = 0;
  out[10] = c6;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromZRotation(out, rad) {
  var s9 = Math.sin(rad);
  var c6 = Math.cos(rad);
  out[0] = c6;
  out[1] = s9;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s9;
  out[5] = c6;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromRotationTranslation(out, q, v2) {
  var x2 = q[0], y3 = q[1], z3 = q[2], w2 = q[3];
  var x22 = x2 + x2;
  var y22 = y3 + y3;
  var z22 = z3 + z3;
  var xx = x2 * x22;
  var xy = x2 * y22;
  var xz = x2 * z22;
  var yy = y3 * y22;
  var yz = y3 * z22;
  var zz = z3 * z22;
  var wx = w2 * x22;
  var wy = w2 * y22;
  var wz = w2 * z22;
  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v2[0];
  out[13] = v2[1];
  out[14] = v2[2];
  out[15] = 1;
  return out;
}
function fromQuat2(out, a4) {
  var translation2 = new ARRAY_TYPE(3);
  var bx = -a4[0], by = -a4[1], bz = -a4[2], bw = a4[3], ax = a4[4], ay = a4[5], az = a4[6], aw = a4[7];
  var magnitude = bx * bx + by * by + bz * bz + bw * bw;
  if (magnitude > 0) {
    translation2[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
    translation2[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
    translation2[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
  } else {
    translation2[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    translation2[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    translation2[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  }
  fromRotationTranslation(out, a4, translation2);
  return out;
}
function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];
  return out;
}
function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out[0] = Math.hypot(m11, m12, m13);
  out[1] = Math.hypot(m21, m22, m23);
  out[2] = Math.hypot(m31, m32, m33);
  return out;
}
function getRotation(out, mat) {
  var scaling = new ARRAY_TYPE(3);
  getScaling(scaling, mat);
  var is1 = 1 / scaling[0];
  var is2 = 1 / scaling[1];
  var is3 = 1 / scaling[2];
  var sm11 = mat[0] * is1;
  var sm12 = mat[1] * is2;
  var sm13 = mat[2] * is3;
  var sm21 = mat[4] * is1;
  var sm22 = mat[5] * is2;
  var sm23 = mat[6] * is3;
  var sm31 = mat[8] * is1;
  var sm32 = mat[9] * is2;
  var sm33 = mat[10] * is3;
  var trace = sm11 + sm22 + sm33;
  var S3 = 0;
  if (trace > 0) {
    S3 = Math.sqrt(trace + 1) * 2;
    out[3] = 0.25 * S3;
    out[0] = (sm23 - sm32) / S3;
    out[1] = (sm31 - sm13) / S3;
    out[2] = (sm12 - sm21) / S3;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S3 = Math.sqrt(1 + sm11 - sm22 - sm33) * 2;
    out[3] = (sm23 - sm32) / S3;
    out[0] = 0.25 * S3;
    out[1] = (sm12 + sm21) / S3;
    out[2] = (sm31 + sm13) / S3;
  } else if (sm22 > sm33) {
    S3 = Math.sqrt(1 + sm22 - sm11 - sm33) * 2;
    out[3] = (sm31 - sm13) / S3;
    out[0] = (sm12 + sm21) / S3;
    out[1] = 0.25 * S3;
    out[2] = (sm23 + sm32) / S3;
  } else {
    S3 = Math.sqrt(1 + sm33 - sm11 - sm22) * 2;
    out[3] = (sm12 - sm21) / S3;
    out[0] = (sm31 + sm13) / S3;
    out[1] = (sm23 + sm32) / S3;
    out[2] = 0.25 * S3;
  }
  return out;
}
function fromRotationTranslationScale(out, q, v2, s9) {
  var x2 = q[0], y3 = q[1], z3 = q[2], w2 = q[3];
  var x22 = x2 + x2;
  var y22 = y3 + y3;
  var z22 = z3 + z3;
  var xx = x2 * x22;
  var xy = x2 * y22;
  var xz = x2 * z22;
  var yy = y3 * y22;
  var yz = y3 * z22;
  var zz = z3 * z22;
  var wx = w2 * x22;
  var wy = w2 * y22;
  var wz = w2 * z22;
  var sx = s9[0];
  var sy = s9[1];
  var sz = s9[2];
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v2[0];
  out[13] = v2[1];
  out[14] = v2[2];
  out[15] = 1;
  return out;
}
function fromRotationTranslationScaleOrigin(out, q, v2, s9, o11) {
  var x2 = q[0], y3 = q[1], z3 = q[2], w2 = q[3];
  var x22 = x2 + x2;
  var y22 = y3 + y3;
  var z22 = z3 + z3;
  var xx = x2 * x22;
  var xy = x2 * y22;
  var xz = x2 * z22;
  var yy = y3 * y22;
  var yz = y3 * z22;
  var zz = z3 * z22;
  var wx = w2 * x22;
  var wy = w2 * y22;
  var wz = w2 * z22;
  var sx = s9[0];
  var sy = s9[1];
  var sz = s9[2];
  var ox = o11[0];
  var oy = o11[1];
  var oz = o11[2];
  var out0 = (1 - (yy + zz)) * sx;
  var out1 = (xy + wz) * sx;
  var out2 = (xz - wy) * sx;
  var out4 = (xy - wz) * sy;
  var out5 = (1 - (xx + zz)) * sy;
  var out6 = (yz + wx) * sy;
  var out8 = (xz + wy) * sz;
  var out9 = (yz - wx) * sz;
  var out10 = (1 - (xx + yy)) * sz;
  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = 0;
  out[4] = out4;
  out[5] = out5;
  out[6] = out6;
  out[7] = 0;
  out[8] = out8;
  out[9] = out9;
  out[10] = out10;
  out[11] = 0;
  out[12] = v2[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
  out[13] = v2[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
  out[14] = v2[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
  out[15] = 1;
  return out;
}
function fromQuat3(out, q) {
  var x2 = q[0], y3 = q[1], z3 = q[2], w2 = q[3];
  var x22 = x2 + x2;
  var y22 = y3 + y3;
  var z22 = z3 + z3;
  var xx = x2 * x22;
  var yx = y3 * x22;
  var yy = y3 * y22;
  var zx = z3 * x22;
  var zy = z3 * y22;
  var zz = z3 * z22;
  var wx = w2 * x22;
  var wy = w2 * y22;
  var wz = w2 * z22;
  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function frustum(out, left, right, bottom, top, near, far) {
  var rl = 1 / (right - left);
  var tb = 1 / (top - bottom);
  var nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
}
function perspectiveNO(out, fovy, aspect, near, far) {
  var f5 = 1 / Math.tan(fovy / 2), nf;
  out[0] = f5 / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f5;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }
  return out;
}
var perspective = perspectiveNO;
function perspectiveZO(out, fovy, aspect, near, far) {
  var f5 = 1 / Math.tan(fovy / 2), nf;
  out[0] = f5 / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f5;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = far * nf;
    out[14] = far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -near;
  }
  return out;
}
function perspectiveFromFieldOfView(out, fov, near, far) {
  var upTan = Math.tan(fov.upDegrees * Math.PI / 180);
  var downTan = Math.tan(fov.downDegrees * Math.PI / 180);
  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180);
  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180);
  var xScale = 2 / (leftTan + rightTan);
  var yScale = 2 / (upTan + downTan);
  out[0] = xScale;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = yScale;
  out[6] = 0;
  out[7] = 0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = (upTan - downTan) * yScale * 0.5;
  out[10] = far / (near - far);
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near / (near - far);
  out[15] = 0;
  return out;
}
function orthoNO(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}
var ortho = orthoNO;
function orthoZO(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = near * nf;
  out[15] = 1;
  return out;
}
function lookAt(out, eye, center, up) {
  var x0, x1, x2, y0, y1, y22, z0, z1, z22, len4;
  var eyex = eye[0];
  var eyey = eye[1];
  var eyez = eye[2];
  var upx = up[0];
  var upy = up[1];
  var upz = up[2];
  var centerx = center[0];
  var centery = center[1];
  var centerz = center[2];
  if (Math.abs(eyex - centerx) < EPSILON && Math.abs(eyey - centery) < EPSILON && Math.abs(eyez - centerz) < EPSILON) {
    return identity2(out);
  }
  z0 = eyex - centerx;
  z1 = eyey - centery;
  z22 = eyez - centerz;
  len4 = 1 / Math.hypot(z0, z1, z22);
  z0 *= len4;
  z1 *= len4;
  z22 *= len4;
  x0 = upy * z22 - upz * z1;
  x1 = upz * z0 - upx * z22;
  x2 = upx * z1 - upy * z0;
  len4 = Math.hypot(x0, x1, x2);
  if (!len4) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len4 = 1 / len4;
    x0 *= len4;
    x1 *= len4;
    x2 *= len4;
  }
  y0 = z1 * x2 - z22 * x1;
  y1 = z22 * x0 - z0 * x2;
  y22 = z0 * x1 - z1 * x0;
  len4 = Math.hypot(y0, y1, y22);
  if (!len4) {
    y0 = 0;
    y1 = 0;
    y22 = 0;
  } else {
    len4 = 1 / len4;
    y0 *= len4;
    y1 *= len4;
    y22 *= len4;
  }
  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y22;
  out[10] = z22;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y22 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z22 * eyez);
  out[15] = 1;
  return out;
}
function targetTo(out, eye, target, up) {
  var eyex = eye[0], eyey = eye[1], eyez = eye[2], upx = up[0], upy = up[1], upz = up[2];
  var z0 = eyex - target[0], z1 = eyey - target[1], z22 = eyez - target[2];
  var len4 = z0 * z0 + z1 * z1 + z22 * z22;
  if (len4 > 0) {
    len4 = 1 / Math.sqrt(len4);
    z0 *= len4;
    z1 *= len4;
    z22 *= len4;
  }
  var x0 = upy * z22 - upz * z1, x1 = upz * z0 - upx * z22, x2 = upx * z1 - upy * z0;
  len4 = x0 * x0 + x1 * x1 + x2 * x2;
  if (len4 > 0) {
    len4 = 1 / Math.sqrt(len4);
    x0 *= len4;
    x1 *= len4;
    x2 *= len4;
  }
  out[0] = x0;
  out[1] = x1;
  out[2] = x2;
  out[3] = 0;
  out[4] = z1 * x2 - z22 * x1;
  out[5] = z22 * x0 - z0 * x2;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z22;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
}
function str2(a4) {
  return "mat4(" + a4[0] + ", " + a4[1] + ", " + a4[2] + ", " + a4[3] + ", " + a4[4] + ", " + a4[5] + ", " + a4[6] + ", " + a4[7] + ", " + a4[8] + ", " + a4[9] + ", " + a4[10] + ", " + a4[11] + ", " + a4[12] + ", " + a4[13] + ", " + a4[14] + ", " + a4[15] + ")";
}
function frob2(a4) {
  return Math.hypot(a4[0], a4[1], a4[2], a4[3], a4[4], a4[5], a4[6], a4[7], a4[8], a4[9], a4[10], a4[11], a4[12], a4[13], a4[14], a4[15]);
}
function add2(out, a4, b3) {
  out[0] = a4[0] + b3[0];
  out[1] = a4[1] + b3[1];
  out[2] = a4[2] + b3[2];
  out[3] = a4[3] + b3[3];
  out[4] = a4[4] + b3[4];
  out[5] = a4[5] + b3[5];
  out[6] = a4[6] + b3[6];
  out[7] = a4[7] + b3[7];
  out[8] = a4[8] + b3[8];
  out[9] = a4[9] + b3[9];
  out[10] = a4[10] + b3[10];
  out[11] = a4[11] + b3[11];
  out[12] = a4[12] + b3[12];
  out[13] = a4[13] + b3[13];
  out[14] = a4[14] + b3[14];
  out[15] = a4[15] + b3[15];
  return out;
}
function subtract2(out, a4, b3) {
  out[0] = a4[0] - b3[0];
  out[1] = a4[1] - b3[1];
  out[2] = a4[2] - b3[2];
  out[3] = a4[3] - b3[3];
  out[4] = a4[4] - b3[4];
  out[5] = a4[5] - b3[5];
  out[6] = a4[6] - b3[6];
  out[7] = a4[7] - b3[7];
  out[8] = a4[8] - b3[8];
  out[9] = a4[9] - b3[9];
  out[10] = a4[10] - b3[10];
  out[11] = a4[11] - b3[11];
  out[12] = a4[12] - b3[12];
  out[13] = a4[13] - b3[13];
  out[14] = a4[14] - b3[14];
  out[15] = a4[15] - b3[15];
  return out;
}
function multiplyScalar2(out, a4, b3) {
  out[0] = a4[0] * b3;
  out[1] = a4[1] * b3;
  out[2] = a4[2] * b3;
  out[3] = a4[3] * b3;
  out[4] = a4[4] * b3;
  out[5] = a4[5] * b3;
  out[6] = a4[6] * b3;
  out[7] = a4[7] * b3;
  out[8] = a4[8] * b3;
  out[9] = a4[9] * b3;
  out[10] = a4[10] * b3;
  out[11] = a4[11] * b3;
  out[12] = a4[12] * b3;
  out[13] = a4[13] * b3;
  out[14] = a4[14] * b3;
  out[15] = a4[15] * b3;
  return out;
}
function multiplyScalarAndAdd2(out, a4, b3, scale7) {
  out[0] = a4[0] + b3[0] * scale7;
  out[1] = a4[1] + b3[1] * scale7;
  out[2] = a4[2] + b3[2] * scale7;
  out[3] = a4[3] + b3[3] * scale7;
  out[4] = a4[4] + b3[4] * scale7;
  out[5] = a4[5] + b3[5] * scale7;
  out[6] = a4[6] + b3[6] * scale7;
  out[7] = a4[7] + b3[7] * scale7;
  out[8] = a4[8] + b3[8] * scale7;
  out[9] = a4[9] + b3[9] * scale7;
  out[10] = a4[10] + b3[10] * scale7;
  out[11] = a4[11] + b3[11] * scale7;
  out[12] = a4[12] + b3[12] * scale7;
  out[13] = a4[13] + b3[13] * scale7;
  out[14] = a4[14] + b3[14] * scale7;
  out[15] = a4[15] + b3[15] * scale7;
  return out;
}
function exactEquals2(a4, b3) {
  return a4[0] === b3[0] && a4[1] === b3[1] && a4[2] === b3[2] && a4[3] === b3[3] && a4[4] === b3[4] && a4[5] === b3[5] && a4[6] === b3[6] && a4[7] === b3[7] && a4[8] === b3[8] && a4[9] === b3[9] && a4[10] === b3[10] && a4[11] === b3[11] && a4[12] === b3[12] && a4[13] === b3[13] && a4[14] === b3[14] && a4[15] === b3[15];
}
function equals3(a4, b3) {
  var a0 = a4[0], a1 = a4[1], a22 = a4[2], a32 = a4[3];
  var a42 = a4[4], a5 = a4[5], a6 = a4[6], a7 = a4[7];
  var a8 = a4[8], a9 = a4[9], a10 = a4[10], a11 = a4[11];
  var a12 = a4[12], a13 = a4[13], a14 = a4[14], a15 = a4[15];
  var b0 = b3[0], b1 = b3[1], b22 = b3[2], b32 = b3[3];
  var b4 = b3[4], b5 = b3[5], b6 = b3[6], b7 = b3[7];
  var b8 = b3[8], b9 = b3[9], b10 = b3[10], b11 = b3[11];
  var b12 = b3[12], b13 = b3[13], b14 = b3[14], b15 = b3[15];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a22 - b22) <= EPSILON * Math.max(1, Math.abs(a22), Math.abs(b22)) && Math.abs(a32 - b32) <= EPSILON * Math.max(1, Math.abs(a32), Math.abs(b32)) && Math.abs(a42 - b4) <= EPSILON * Math.max(1, Math.abs(a42), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= EPSILON * Math.max(1, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= EPSILON * Math.max(1, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= EPSILON * Math.max(1, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= EPSILON * Math.max(1, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= EPSILON * Math.max(1, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= EPSILON * Math.max(1, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= EPSILON * Math.max(1, Math.abs(a15), Math.abs(b15));
}
var mul2 = multiply2;
var sub2 = subtract2;

// node_modules/gl-matrix/esm/quat.js
var quat_exports = {};
__export(quat_exports, {
  add: () => add5,
  calculateW: () => calculateW,
  clone: () => clone5,
  conjugate: () => conjugate,
  copy: () => copy5,
  create: () => create5,
  dot: () => dot3,
  equals: () => equals6,
  exactEquals: () => exactEquals5,
  exp: () => exp,
  fromEuler: () => fromEuler,
  fromMat3: () => fromMat3,
  fromValues: () => fromValues5,
  getAngle: () => getAngle,
  getAxisAngle: () => getAxisAngle,
  identity: () => identity3,
  invert: () => invert3,
  len: () => len3,
  length: () => length3,
  lerp: () => lerp3,
  ln: () => ln,
  mul: () => mul5,
  multiply: () => multiply5,
  normalize: () => normalize3,
  pow: () => pow,
  random: () => random3,
  rotateX: () => rotateX3,
  rotateY: () => rotateY3,
  rotateZ: () => rotateZ3,
  rotationTo: () => rotationTo,
  scale: () => scale5,
  set: () => set5,
  setAxes: () => setAxes,
  setAxisAngle: () => setAxisAngle,
  slerp: () => slerp,
  sqlerp: () => sqlerp,
  sqrLen: () => sqrLen3,
  squaredLength: () => squaredLength3,
  str: () => str5
});

// node_modules/gl-matrix/esm/vec3.js
var vec3_exports = {};
__export(vec3_exports, {
  add: () => add3,
  angle: () => angle,
  bezier: () => bezier,
  ceil: () => ceil,
  clone: () => clone3,
  copy: () => copy3,
  create: () => create3,
  cross: () => cross,
  dist: () => dist,
  distance: () => distance,
  div: () => div,
  divide: () => divide,
  dot: () => dot,
  equals: () => equals4,
  exactEquals: () => exactEquals3,
  floor: () => floor2,
  forEach: () => forEach,
  fromValues: () => fromValues3,
  hermite: () => hermite,
  inverse: () => inverse,
  len: () => len,
  length: () => length,
  lerp: () => lerp,
  max: () => max2,
  min: () => min2,
  mul: () => mul3,
  multiply: () => multiply3,
  negate: () => negate,
  normalize: () => normalize,
  random: () => random,
  rotateX: () => rotateX2,
  rotateY: () => rotateY2,
  rotateZ: () => rotateZ2,
  round: () => round2,
  scale: () => scale3,
  scaleAndAdd: () => scaleAndAdd,
  set: () => set3,
  sqrDist: () => sqrDist,
  sqrLen: () => sqrLen,
  squaredDistance: () => squaredDistance,
  squaredLength: () => squaredLength,
  str: () => str3,
  sub: () => sub3,
  subtract: () => subtract3,
  transformMat3: () => transformMat3,
  transformMat4: () => transformMat4,
  transformQuat: () => transformQuat,
  zero: () => zero
});
function create3() {
  var out = new ARRAY_TYPE(3);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  return out;
}
function clone3(a4) {
  var out = new ARRAY_TYPE(3);
  out[0] = a4[0];
  out[1] = a4[1];
  out[2] = a4[2];
  return out;
}
function length(a4) {
  var x2 = a4[0];
  var y3 = a4[1];
  var z3 = a4[2];
  return Math.hypot(x2, y3, z3);
}
function fromValues3(x2, y3, z3) {
  var out = new ARRAY_TYPE(3);
  out[0] = x2;
  out[1] = y3;
  out[2] = z3;
  return out;
}
function copy3(out, a4) {
  out[0] = a4[0];
  out[1] = a4[1];
  out[2] = a4[2];
  return out;
}
function set3(out, x2, y3, z3) {
  out[0] = x2;
  out[1] = y3;
  out[2] = z3;
  return out;
}
function add3(out, a4, b3) {
  out[0] = a4[0] + b3[0];
  out[1] = a4[1] + b3[1];
  out[2] = a4[2] + b3[2];
  return out;
}
function subtract3(out, a4, b3) {
  out[0] = a4[0] - b3[0];
  out[1] = a4[1] - b3[1];
  out[2] = a4[2] - b3[2];
  return out;
}
function multiply3(out, a4, b3) {
  out[0] = a4[0] * b3[0];
  out[1] = a4[1] * b3[1];
  out[2] = a4[2] * b3[2];
  return out;
}
function divide(out, a4, b3) {
  out[0] = a4[0] / b3[0];
  out[1] = a4[1] / b3[1];
  out[2] = a4[2] / b3[2];
  return out;
}
function ceil(out, a4) {
  out[0] = Math.ceil(a4[0]);
  out[1] = Math.ceil(a4[1]);
  out[2] = Math.ceil(a4[2]);
  return out;
}
function floor2(out, a4) {
  out[0] = Math.floor(a4[0]);
  out[1] = Math.floor(a4[1]);
  out[2] = Math.floor(a4[2]);
  return out;
}
function min2(out, a4, b3) {
  out[0] = Math.min(a4[0], b3[0]);
  out[1] = Math.min(a4[1], b3[1]);
  out[2] = Math.min(a4[2], b3[2]);
  return out;
}
function max2(out, a4, b3) {
  out[0] = Math.max(a4[0], b3[0]);
  out[1] = Math.max(a4[1], b3[1]);
  out[2] = Math.max(a4[2], b3[2]);
  return out;
}
function round2(out, a4) {
  out[0] = Math.round(a4[0]);
  out[1] = Math.round(a4[1]);
  out[2] = Math.round(a4[2]);
  return out;
}
function scale3(out, a4, b3) {
  out[0] = a4[0] * b3;
  out[1] = a4[1] * b3;
  out[2] = a4[2] * b3;
  return out;
}
function scaleAndAdd(out, a4, b3, scale7) {
  out[0] = a4[0] + b3[0] * scale7;
  out[1] = a4[1] + b3[1] * scale7;
  out[2] = a4[2] + b3[2] * scale7;
  return out;
}
function distance(a4, b3) {
  var x2 = b3[0] - a4[0];
  var y3 = b3[1] - a4[1];
  var z3 = b3[2] - a4[2];
  return Math.hypot(x2, y3, z3);
}
function squaredDistance(a4, b3) {
  var x2 = b3[0] - a4[0];
  var y3 = b3[1] - a4[1];
  var z3 = b3[2] - a4[2];
  return x2 * x2 + y3 * y3 + z3 * z3;
}
function squaredLength(a4) {
  var x2 = a4[0];
  var y3 = a4[1];
  var z3 = a4[2];
  return x2 * x2 + y3 * y3 + z3 * z3;
}
function negate(out, a4) {
  out[0] = -a4[0];
  out[1] = -a4[1];
  out[2] = -a4[2];
  return out;
}
function inverse(out, a4) {
  out[0] = 1 / a4[0];
  out[1] = 1 / a4[1];
  out[2] = 1 / a4[2];
  return out;
}
function normalize(out, a4) {
  var x2 = a4[0];
  var y3 = a4[1];
  var z3 = a4[2];
  var len4 = x2 * x2 + y3 * y3 + z3 * z3;
  if (len4 > 0) {
    len4 = 1 / Math.sqrt(len4);
  }
  out[0] = a4[0] * len4;
  out[1] = a4[1] * len4;
  out[2] = a4[2] * len4;
  return out;
}
function dot(a4, b3) {
  return a4[0] * b3[0] + a4[1] * b3[1] + a4[2] * b3[2];
}
function cross(out, a4, b3) {
  var ax = a4[0], ay = a4[1], az = a4[2];
  var bx = b3[0], by = b3[1], bz = b3[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
function lerp(out, a4, b3, t9) {
  var ax = a4[0];
  var ay = a4[1];
  var az = a4[2];
  out[0] = ax + t9 * (b3[0] - ax);
  out[1] = ay + t9 * (b3[1] - ay);
  out[2] = az + t9 * (b3[2] - az);
  return out;
}
function hermite(out, a4, b3, c6, d3, t9) {
  var factorTimes2 = t9 * t9;
  var factor1 = factorTimes2 * (2 * t9 - 3) + 1;
  var factor2 = factorTimes2 * (t9 - 2) + t9;
  var factor3 = factorTimes2 * (t9 - 1);
  var factor4 = factorTimes2 * (3 - 2 * t9);
  out[0] = a4[0] * factor1 + b3[0] * factor2 + c6[0] * factor3 + d3[0] * factor4;
  out[1] = a4[1] * factor1 + b3[1] * factor2 + c6[1] * factor3 + d3[1] * factor4;
  out[2] = a4[2] * factor1 + b3[2] * factor2 + c6[2] * factor3 + d3[2] * factor4;
  return out;
}
function bezier(out, a4, b3, c6, d3, t9) {
  var inverseFactor = 1 - t9;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t9 * t9;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t9 * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t9;
  out[0] = a4[0] * factor1 + b3[0] * factor2 + c6[0] * factor3 + d3[0] * factor4;
  out[1] = a4[1] * factor1 + b3[1] * factor2 + c6[1] * factor3 + d3[1] * factor4;
  out[2] = a4[2] * factor1 + b3[2] * factor2 + c6[2] * factor3 + d3[2] * factor4;
  return out;
}
function random(out, scale7) {
  scale7 = scale7 || 1;
  var r9 = RANDOM() * 2 * Math.PI;
  var z3 = RANDOM() * 2 - 1;
  var zScale = Math.sqrt(1 - z3 * z3) * scale7;
  out[0] = Math.cos(r9) * zScale;
  out[1] = Math.sin(r9) * zScale;
  out[2] = z3 * scale7;
  return out;
}
function transformMat4(out, a4, m3) {
  var x2 = a4[0], y3 = a4[1], z3 = a4[2];
  var w2 = m3[3] * x2 + m3[7] * y3 + m3[11] * z3 + m3[15];
  w2 = w2 || 1;
  out[0] = (m3[0] * x2 + m3[4] * y3 + m3[8] * z3 + m3[12]) / w2;
  out[1] = (m3[1] * x2 + m3[5] * y3 + m3[9] * z3 + m3[13]) / w2;
  out[2] = (m3[2] * x2 + m3[6] * y3 + m3[10] * z3 + m3[14]) / w2;
  return out;
}
function transformMat3(out, a4, m3) {
  var x2 = a4[0], y3 = a4[1], z3 = a4[2];
  out[0] = x2 * m3[0] + y3 * m3[3] + z3 * m3[6];
  out[1] = x2 * m3[1] + y3 * m3[4] + z3 * m3[7];
  out[2] = x2 * m3[2] + y3 * m3[5] + z3 * m3[8];
  return out;
}
function transformQuat(out, a4, q) {
  var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
  var x2 = a4[0], y3 = a4[1], z3 = a4[2];
  var uvx = qy * z3 - qz * y3, uvy = qz * x2 - qx * z3, uvz = qx * y3 - qy * x2;
  var uuvx = qy * uvz - qz * uvy, uuvy = qz * uvx - qx * uvz, uuvz = qx * uvy - qy * uvx;
  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2;
  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2;
  out[0] = x2 + uvx + uuvx;
  out[1] = y3 + uvy + uuvy;
  out[2] = z3 + uvz + uuvz;
  return out;
}
function rotateX2(out, a4, b3, rad) {
  var p3 = [], r9 = [];
  p3[0] = a4[0] - b3[0];
  p3[1] = a4[1] - b3[1];
  p3[2] = a4[2] - b3[2];
  r9[0] = p3[0];
  r9[1] = p3[1] * Math.cos(rad) - p3[2] * Math.sin(rad);
  r9[2] = p3[1] * Math.sin(rad) + p3[2] * Math.cos(rad);
  out[0] = r9[0] + b3[0];
  out[1] = r9[1] + b3[1];
  out[2] = r9[2] + b3[2];
  return out;
}
function rotateY2(out, a4, b3, rad) {
  var p3 = [], r9 = [];
  p3[0] = a4[0] - b3[0];
  p3[1] = a4[1] - b3[1];
  p3[2] = a4[2] - b3[2];
  r9[0] = p3[2] * Math.sin(rad) + p3[0] * Math.cos(rad);
  r9[1] = p3[1];
  r9[2] = p3[2] * Math.cos(rad) - p3[0] * Math.sin(rad);
  out[0] = r9[0] + b3[0];
  out[1] = r9[1] + b3[1];
  out[2] = r9[2] + b3[2];
  return out;
}
function rotateZ2(out, a4, b3, rad) {
  var p3 = [], r9 = [];
  p3[0] = a4[0] - b3[0];
  p3[1] = a4[1] - b3[1];
  p3[2] = a4[2] - b3[2];
  r9[0] = p3[0] * Math.cos(rad) - p3[1] * Math.sin(rad);
  r9[1] = p3[0] * Math.sin(rad) + p3[1] * Math.cos(rad);
  r9[2] = p3[2];
  out[0] = r9[0] + b3[0];
  out[1] = r9[1] + b3[1];
  out[2] = r9[2] + b3[2];
  return out;
}
function angle(a4, b3) {
  var ax = a4[0], ay = a4[1], az = a4[2], bx = b3[0], by = b3[1], bz = b3[2], mag1 = Math.sqrt(ax * ax + ay * ay + az * az), mag2 = Math.sqrt(bx * bx + by * by + bz * bz), mag = mag1 * mag2, cosine = mag && dot(a4, b3) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function zero(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  return out;
}
function str3(a4) {
  return "vec3(" + a4[0] + ", " + a4[1] + ", " + a4[2] + ")";
}
function exactEquals3(a4, b3) {
  return a4[0] === b3[0] && a4[1] === b3[1] && a4[2] === b3[2];
}
function equals4(a4, b3) {
  var a0 = a4[0], a1 = a4[1], a22 = a4[2];
  var b0 = b3[0], b1 = b3[1], b22 = b3[2];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a22 - b22) <= EPSILON * Math.max(1, Math.abs(a22), Math.abs(b22));
}
var sub3 = subtract3;
var mul3 = multiply3;
var div = divide;
var dist = distance;
var sqrDist = squaredDistance;
var len = length;
var sqrLen = squaredLength;
var forEach = function() {
  var vec = create3();
  return function(a4, stride, offset3, count, fn, arg) {
    var i6, l5;
    if (!stride) {
      stride = 3;
    }
    if (!offset3) {
      offset3 = 0;
    }
    if (count) {
      l5 = Math.min(count * stride + offset3, a4.length);
    } else {
      l5 = a4.length;
    }
    for (i6 = offset3; i6 < l5; i6 += stride) {
      vec[0] = a4[i6];
      vec[1] = a4[i6 + 1];
      vec[2] = a4[i6 + 2];
      fn(vec, vec, arg);
      a4[i6] = vec[0];
      a4[i6 + 1] = vec[1];
      a4[i6 + 2] = vec[2];
    }
    return a4;
  };
}();

// node_modules/gl-matrix/esm/vec4.js
var vec4_exports = {};
__export(vec4_exports, {
  add: () => add4,
  ceil: () => ceil2,
  clone: () => clone4,
  copy: () => copy4,
  create: () => create4,
  cross: () => cross2,
  dist: () => dist2,
  distance: () => distance2,
  div: () => div2,
  divide: () => divide2,
  dot: () => dot2,
  equals: () => equals5,
  exactEquals: () => exactEquals4,
  floor: () => floor3,
  forEach: () => forEach2,
  fromValues: () => fromValues4,
  inverse: () => inverse2,
  len: () => len2,
  length: () => length2,
  lerp: () => lerp2,
  max: () => max3,
  min: () => min3,
  mul: () => mul4,
  multiply: () => multiply4,
  negate: () => negate2,
  normalize: () => normalize2,
  random: () => random2,
  round: () => round3,
  scale: () => scale4,
  scaleAndAdd: () => scaleAndAdd2,
  set: () => set4,
  sqrDist: () => sqrDist2,
  sqrLen: () => sqrLen2,
  squaredDistance: () => squaredDistance2,
  squaredLength: () => squaredLength2,
  str: () => str4,
  sub: () => sub4,
  subtract: () => subtract4,
  transformMat4: () => transformMat42,
  transformQuat: () => transformQuat2,
  zero: () => zero2
});
function create4() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }
  return out;
}
function clone4(a4) {
  var out = new ARRAY_TYPE(4);
  out[0] = a4[0];
  out[1] = a4[1];
  out[2] = a4[2];
  out[3] = a4[3];
  return out;
}
function fromValues4(x2, y3, z3, w2) {
  var out = new ARRAY_TYPE(4);
  out[0] = x2;
  out[1] = y3;
  out[2] = z3;
  out[3] = w2;
  return out;
}
function copy4(out, a4) {
  out[0] = a4[0];
  out[1] = a4[1];
  out[2] = a4[2];
  out[3] = a4[3];
  return out;
}
function set4(out, x2, y3, z3, w2) {
  out[0] = x2;
  out[1] = y3;
  out[2] = z3;
  out[3] = w2;
  return out;
}
function add4(out, a4, b3) {
  out[0] = a4[0] + b3[0];
  out[1] = a4[1] + b3[1];
  out[2] = a4[2] + b3[2];
  out[3] = a4[3] + b3[3];
  return out;
}
function subtract4(out, a4, b3) {
  out[0] = a4[0] - b3[0];
  out[1] = a4[1] - b3[1];
  out[2] = a4[2] - b3[2];
  out[3] = a4[3] - b3[3];
  return out;
}
function multiply4(out, a4, b3) {
  out[0] = a4[0] * b3[0];
  out[1] = a4[1] * b3[1];
  out[2] = a4[2] * b3[2];
  out[3] = a4[3] * b3[3];
  return out;
}
function divide2(out, a4, b3) {
  out[0] = a4[0] / b3[0];
  out[1] = a4[1] / b3[1];
  out[2] = a4[2] / b3[2];
  out[3] = a4[3] / b3[3];
  return out;
}
function ceil2(out, a4) {
  out[0] = Math.ceil(a4[0]);
  out[1] = Math.ceil(a4[1]);
  out[2] = Math.ceil(a4[2]);
  out[3] = Math.ceil(a4[3]);
  return out;
}
function floor3(out, a4) {
  out[0] = Math.floor(a4[0]);
  out[1] = Math.floor(a4[1]);
  out[2] = Math.floor(a4[2]);
  out[3] = Math.floor(a4[3]);
  return out;
}
function min3(out, a4, b3) {
  out[0] = Math.min(a4[0], b3[0]);
  out[1] = Math.min(a4[1], b3[1]);
  out[2] = Math.min(a4[2], b3[2]);
  out[3] = Math.min(a4[3], b3[3]);
  return out;
}
function max3(out, a4, b3) {
  out[0] = Math.max(a4[0], b3[0]);
  out[1] = Math.max(a4[1], b3[1]);
  out[2] = Math.max(a4[2], b3[2]);
  out[3] = Math.max(a4[3], b3[3]);
  return out;
}
function round3(out, a4) {
  out[0] = Math.round(a4[0]);
  out[1] = Math.round(a4[1]);
  out[2] = Math.round(a4[2]);
  out[3] = Math.round(a4[3]);
  return out;
}
function scale4(out, a4, b3) {
  out[0] = a4[0] * b3;
  out[1] = a4[1] * b3;
  out[2] = a4[2] * b3;
  out[3] = a4[3] * b3;
  return out;
}
function scaleAndAdd2(out, a4, b3, scale7) {
  out[0] = a4[0] + b3[0] * scale7;
  out[1] = a4[1] + b3[1] * scale7;
  out[2] = a4[2] + b3[2] * scale7;
  out[3] = a4[3] + b3[3] * scale7;
  return out;
}
function distance2(a4, b3) {
  var x2 = b3[0] - a4[0];
  var y3 = b3[1] - a4[1];
  var z3 = b3[2] - a4[2];
  var w2 = b3[3] - a4[3];
  return Math.hypot(x2, y3, z3, w2);
}
function squaredDistance2(a4, b3) {
  var x2 = b3[0] - a4[0];
  var y3 = b3[1] - a4[1];
  var z3 = b3[2] - a4[2];
  var w2 = b3[3] - a4[3];
  return x2 * x2 + y3 * y3 + z3 * z3 + w2 * w2;
}
function length2(a4) {
  var x2 = a4[0];
  var y3 = a4[1];
  var z3 = a4[2];
  var w2 = a4[3];
  return Math.hypot(x2, y3, z3, w2);
}
function squaredLength2(a4) {
  var x2 = a4[0];
  var y3 = a4[1];
  var z3 = a4[2];
  var w2 = a4[3];
  return x2 * x2 + y3 * y3 + z3 * z3 + w2 * w2;
}
function negate2(out, a4) {
  out[0] = -a4[0];
  out[1] = -a4[1];
  out[2] = -a4[2];
  out[3] = -a4[3];
  return out;
}
function inverse2(out, a4) {
  out[0] = 1 / a4[0];
  out[1] = 1 / a4[1];
  out[2] = 1 / a4[2];
  out[3] = 1 / a4[3];
  return out;
}
function normalize2(out, a4) {
  var x2 = a4[0];
  var y3 = a4[1];
  var z3 = a4[2];
  var w2 = a4[3];
  var len4 = x2 * x2 + y3 * y3 + z3 * z3 + w2 * w2;
  if (len4 > 0) {
    len4 = 1 / Math.sqrt(len4);
  }
  out[0] = x2 * len4;
  out[1] = y3 * len4;
  out[2] = z3 * len4;
  out[3] = w2 * len4;
  return out;
}
function dot2(a4, b3) {
  return a4[0] * b3[0] + a4[1] * b3[1] + a4[2] * b3[2] + a4[3] * b3[3];
}
function cross2(out, u5, v2, w2) {
  var A2 = v2[0] * w2[1] - v2[1] * w2[0], B = v2[0] * w2[2] - v2[2] * w2[0], C2 = v2[0] * w2[3] - v2[3] * w2[0], D = v2[1] * w2[2] - v2[2] * w2[1], E2 = v2[1] * w2[3] - v2[3] * w2[1], F = v2[2] * w2[3] - v2[3] * w2[2];
  var G = u5[0];
  var H2 = u5[1];
  var I2 = u5[2];
  var J = u5[3];
  out[0] = H2 * F - I2 * E2 + J * D;
  out[1] = -(G * F) + I2 * C2 - J * B;
  out[2] = G * E2 - H2 * C2 + J * A2;
  out[3] = -(G * D) + H2 * B - I2 * A2;
  return out;
}
function lerp2(out, a4, b3, t9) {
  var ax = a4[0];
  var ay = a4[1];
  var az = a4[2];
  var aw = a4[3];
  out[0] = ax + t9 * (b3[0] - ax);
  out[1] = ay + t9 * (b3[1] - ay);
  out[2] = az + t9 * (b3[2] - az);
  out[3] = aw + t9 * (b3[3] - aw);
  return out;
}
function random2(out, scale7) {
  scale7 = scale7 || 1;
  var v1, v2, v3, v4;
  var s1, s22;
  do {
    v1 = RANDOM() * 2 - 1;
    v2 = RANDOM() * 2 - 1;
    s1 = v1 * v1 + v2 * v2;
  } while (s1 >= 1);
  do {
    v3 = RANDOM() * 2 - 1;
    v4 = RANDOM() * 2 - 1;
    s22 = v3 * v3 + v4 * v4;
  } while (s22 >= 1);
  var d3 = Math.sqrt((1 - s1) / s22);
  out[0] = scale7 * v1;
  out[1] = scale7 * v2;
  out[2] = scale7 * v3 * d3;
  out[3] = scale7 * v4 * d3;
  return out;
}
function transformMat42(out, a4, m3) {
  var x2 = a4[0], y3 = a4[1], z3 = a4[2], w2 = a4[3];
  out[0] = m3[0] * x2 + m3[4] * y3 + m3[8] * z3 + m3[12] * w2;
  out[1] = m3[1] * x2 + m3[5] * y3 + m3[9] * z3 + m3[13] * w2;
  out[2] = m3[2] * x2 + m3[6] * y3 + m3[10] * z3 + m3[14] * w2;
  out[3] = m3[3] * x2 + m3[7] * y3 + m3[11] * z3 + m3[15] * w2;
  return out;
}
function transformQuat2(out, a4, q) {
  var x2 = a4[0], y3 = a4[1], z3 = a4[2];
  var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
  var ix = qw * x2 + qy * z3 - qz * y3;
  var iy = qw * y3 + qz * x2 - qx * z3;
  var iz = qw * z3 + qx * y3 - qy * x2;
  var iw = -qx * x2 - qy * y3 - qz * z3;
  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  out[3] = a4[3];
  return out;
}
function zero2(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  return out;
}
function str4(a4) {
  return "vec4(" + a4[0] + ", " + a4[1] + ", " + a4[2] + ", " + a4[3] + ")";
}
function exactEquals4(a4, b3) {
  return a4[0] === b3[0] && a4[1] === b3[1] && a4[2] === b3[2] && a4[3] === b3[3];
}
function equals5(a4, b3) {
  var a0 = a4[0], a1 = a4[1], a22 = a4[2], a32 = a4[3];
  var b0 = b3[0], b1 = b3[1], b22 = b3[2], b32 = b3[3];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a22 - b22) <= EPSILON * Math.max(1, Math.abs(a22), Math.abs(b22)) && Math.abs(a32 - b32) <= EPSILON * Math.max(1, Math.abs(a32), Math.abs(b32));
}
var sub4 = subtract4;
var mul4 = multiply4;
var div2 = divide2;
var dist2 = distance2;
var sqrDist2 = squaredDistance2;
var len2 = length2;
var sqrLen2 = squaredLength2;
var forEach2 = function() {
  var vec = create4();
  return function(a4, stride, offset3, count, fn, arg) {
    var i6, l5;
    if (!stride) {
      stride = 4;
    }
    if (!offset3) {
      offset3 = 0;
    }
    if (count) {
      l5 = Math.min(count * stride + offset3, a4.length);
    } else {
      l5 = a4.length;
    }
    for (i6 = offset3; i6 < l5; i6 += stride) {
      vec[0] = a4[i6];
      vec[1] = a4[i6 + 1];
      vec[2] = a4[i6 + 2];
      vec[3] = a4[i6 + 3];
      fn(vec, vec, arg);
      a4[i6] = vec[0];
      a4[i6 + 1] = vec[1];
      a4[i6 + 2] = vec[2];
      a4[i6 + 3] = vec[3];
    }
    return a4;
  };
}();

// node_modules/gl-matrix/esm/quat.js
function create5() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  out[3] = 1;
  return out;
}
function identity3(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
function setAxisAngle(out, axis2, rad) {
  rad = rad * 0.5;
  var s9 = Math.sin(rad);
  out[0] = s9 * axis2[0];
  out[1] = s9 * axis2[1];
  out[2] = s9 * axis2[2];
  out[3] = Math.cos(rad);
  return out;
}
function getAxisAngle(out_axis, q) {
  var rad = Math.acos(q[3]) * 2;
  var s9 = Math.sin(rad / 2);
  if (s9 > EPSILON) {
    out_axis[0] = q[0] / s9;
    out_axis[1] = q[1] / s9;
    out_axis[2] = q[2] / s9;
  } else {
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }
  return rad;
}
function getAngle(a4, b3) {
  var dotproduct = dot3(a4, b3);
  return Math.acos(2 * dotproduct * dotproduct - 1);
}
function multiply5(out, a4, b3) {
  var ax = a4[0], ay = a4[1], az = a4[2], aw = a4[3];
  var bx = b3[0], by = b3[1], bz = b3[2], bw = b3[3];
  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
function rotateX3(out, a4, rad) {
  rad *= 0.5;
  var ax = a4[0], ay = a4[1], az = a4[2], aw = a4[3];
  var bx = Math.sin(rad), bw = Math.cos(rad);
  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}
function rotateY3(out, a4, rad) {
  rad *= 0.5;
  var ax = a4[0], ay = a4[1], az = a4[2], aw = a4[3];
  var by = Math.sin(rad), bw = Math.cos(rad);
  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}
function rotateZ3(out, a4, rad) {
  rad *= 0.5;
  var ax = a4[0], ay = a4[1], az = a4[2], aw = a4[3];
  var bz = Math.sin(rad), bw = Math.cos(rad);
  out[0] = ax * bw + ay * bz;
  out[1] = ay * bw - ax * bz;
  out[2] = az * bw + aw * bz;
  out[3] = aw * bw - az * bz;
  return out;
}
function calculateW(out, a4) {
  var x2 = a4[0], y3 = a4[1], z3 = a4[2];
  out[0] = x2;
  out[1] = y3;
  out[2] = z3;
  out[3] = Math.sqrt(Math.abs(1 - x2 * x2 - y3 * y3 - z3 * z3));
  return out;
}
function exp(out, a4) {
  var x2 = a4[0], y3 = a4[1], z3 = a4[2], w2 = a4[3];
  var r9 = Math.sqrt(x2 * x2 + y3 * y3 + z3 * z3);
  var et = Math.exp(w2);
  var s9 = r9 > 0 ? et * Math.sin(r9) / r9 : 0;
  out[0] = x2 * s9;
  out[1] = y3 * s9;
  out[2] = z3 * s9;
  out[3] = et * Math.cos(r9);
  return out;
}
function ln(out, a4) {
  var x2 = a4[0], y3 = a4[1], z3 = a4[2], w2 = a4[3];
  var r9 = Math.sqrt(x2 * x2 + y3 * y3 + z3 * z3);
  var t9 = r9 > 0 ? Math.atan2(r9, w2) / r9 : 0;
  out[0] = x2 * t9;
  out[1] = y3 * t9;
  out[2] = z3 * t9;
  out[3] = 0.5 * Math.log(x2 * x2 + y3 * y3 + z3 * z3 + w2 * w2);
  return out;
}
function pow(out, a4, b3) {
  ln(out, a4);
  scale5(out, out, b3);
  exp(out, out);
  return out;
}
function slerp(out, a4, b3, t9) {
  var ax = a4[0], ay = a4[1], az = a4[2], aw = a4[3];
  var bx = b3[0], by = b3[1], bz = b3[2], bw = b3[3];
  var omega, cosom, sinom, scale0, scale1;
  cosom = ax * bx + ay * by + az * bz + aw * bw;
  if (cosom < 0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  }
  if (1 - cosom > EPSILON) {
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1 - t9) * omega) / sinom;
    scale1 = Math.sin(t9 * omega) / sinom;
  } else {
    scale0 = 1 - t9;
    scale1 = t9;
  }
  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
function random3(out) {
  var u1 = RANDOM();
  var u22 = RANDOM();
  var u32 = RANDOM();
  var sqrt1MinusU1 = Math.sqrt(1 - u1);
  var sqrtU1 = Math.sqrt(u1);
  out[0] = sqrt1MinusU1 * Math.sin(2 * Math.PI * u22);
  out[1] = sqrt1MinusU1 * Math.cos(2 * Math.PI * u22);
  out[2] = sqrtU1 * Math.sin(2 * Math.PI * u32);
  out[3] = sqrtU1 * Math.cos(2 * Math.PI * u32);
  return out;
}
function invert3(out, a4) {
  var a0 = a4[0], a1 = a4[1], a22 = a4[2], a32 = a4[3];
  var dot5 = a0 * a0 + a1 * a1 + a22 * a22 + a32 * a32;
  var invDot = dot5 ? 1 / dot5 : 0;
  out[0] = -a0 * invDot;
  out[1] = -a1 * invDot;
  out[2] = -a22 * invDot;
  out[3] = a32 * invDot;
  return out;
}
function conjugate(out, a4) {
  out[0] = -a4[0];
  out[1] = -a4[1];
  out[2] = -a4[2];
  out[3] = a4[3];
  return out;
}
function fromMat3(out, m3) {
  var fTrace = m3[0] + m3[4] + m3[8];
  var fRoot;
  if (fTrace > 0) {
    fRoot = Math.sqrt(fTrace + 1);
    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[0] = (m3[5] - m3[7]) * fRoot;
    out[1] = (m3[6] - m3[2]) * fRoot;
    out[2] = (m3[1] - m3[3]) * fRoot;
  } else {
    var i6 = 0;
    if (m3[4] > m3[0]) i6 = 1;
    if (m3[8] > m3[i6 * 3 + i6]) i6 = 2;
    var j2 = (i6 + 1) % 3;
    var k2 = (i6 + 2) % 3;
    fRoot = Math.sqrt(m3[i6 * 3 + i6] - m3[j2 * 3 + j2] - m3[k2 * 3 + k2] + 1);
    out[i6] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m3[j2 * 3 + k2] - m3[k2 * 3 + j2]) * fRoot;
    out[j2] = (m3[j2 * 3 + i6] + m3[i6 * 3 + j2]) * fRoot;
    out[k2] = (m3[k2 * 3 + i6] + m3[i6 * 3 + k2]) * fRoot;
  }
  return out;
}
function fromEuler(out, x2, y3, z3) {
  var halfToRad = 0.5 * Math.PI / 180;
  x2 *= halfToRad;
  y3 *= halfToRad;
  z3 *= halfToRad;
  var sx = Math.sin(x2);
  var cx = Math.cos(x2);
  var sy = Math.sin(y3);
  var cy = Math.cos(y3);
  var sz = Math.sin(z3);
  var cz = Math.cos(z3);
  out[0] = sx * cy * cz - cx * sy * sz;
  out[1] = cx * sy * cz + sx * cy * sz;
  out[2] = cx * cy * sz - sx * sy * cz;
  out[3] = cx * cy * cz + sx * sy * sz;
  return out;
}
function str5(a4) {
  return "quat(" + a4[0] + ", " + a4[1] + ", " + a4[2] + ", " + a4[3] + ")";
}
var clone5 = clone4;
var fromValues5 = fromValues4;
var copy5 = copy4;
var set5 = set4;
var add5 = add4;
var mul5 = multiply5;
var scale5 = scale4;
var dot3 = dot2;
var lerp3 = lerp2;
var length3 = length2;
var len3 = length3;
var squaredLength3 = squaredLength2;
var sqrLen3 = squaredLength3;
var normalize3 = normalize2;
var exactEquals5 = exactEquals4;
var equals6 = equals5;
var rotationTo = function() {
  var tmpvec3 = create3();
  var xUnitVec3 = fromValues3(1, 0, 0);
  var yUnitVec3 = fromValues3(0, 1, 0);
  return function(out, a4, b3) {
    var dot5 = dot(a4, b3);
    if (dot5 < -0.999999) {
      cross(tmpvec3, xUnitVec3, a4);
      if (len(tmpvec3) < 1e-6) cross(tmpvec3, yUnitVec3, a4);
      normalize(tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot5 > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      cross(tmpvec3, a4, b3);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot5;
      return normalize3(out, out);
    }
  };
}();
var sqlerp = function() {
  var temp1 = create5();
  var temp2 = create5();
  return function(out, a4, b3, c6, d3, t9) {
    slerp(temp1, a4, d3, t9);
    slerp(temp2, b3, c6, t9);
    slerp(out, temp1, temp2, 2 * t9 * (1 - t9));
    return out;
  };
}();
var setAxes = function() {
  var matr = create();
  return function(out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize3(out, fromMat3(out, matr));
  };
}();

// node_modules/@itk-viewer/viewer/dist/camera.js
var createPose = () => ({
  center: vec3_exports.create(),
  rotation: quat_exports.create(),
  distance: 1
});
var copyPose = (out, source) => {
  return {
    center: vec3_exports.copy(out.center, source.center),
    rotation: quat_exports.copy(out.rotation, source.rotation),
    distance: source.distance
  };
};
var toMat4 = (() => {
  const scratch02 = new Float32Array(4);
  const scratch12 = new Float32Array(3);
  const matTemp = mat4_exports.create();
  return (out, pose) => {
    scratch12[0] = scratch12[1] = 0;
    scratch12[2] = -pose.distance;
    mat4_exports.fromRotationTranslation(matTemp, quat_exports.conjugate(scratch02, pose.rotation), scratch12);
    mat4_exports.translate(out, matTemp, vec3_exports.negate(scratch02, pose.center));
    return out;
  };
})();
var cameraMachine = setup({
  types: {},
  actions: {
    emitNewPose: ({ context: { poseWatchers } }, params) => {
      Object.values(poseWatchers).forEach((actor) => {
        actor.send({
          type: "setCameraPose",
          pose: params.pose,
          parallelScaleRatio: params.parallelScaleRatio
        });
      });
    }
  }
}).createMachine({
  id: "camera",
  initial: "active",
  context: () => ({
    pose: createPose(),
    enableRotation: true,
    parallelScaleRatio: 1,
    verticalFieldOfView: 50,
    poseWatchers: []
  }),
  states: {
    active: {
      on: {
        setPose: {
          actions: [
            assign({
              pose: ({ event: { pose }, context }) => {
                const clampedPose = __spreadProps(__spreadValues({}, pose), {
                  rotation: context.enableRotation ? pose.rotation : context.pose.rotation
                });
                return copyPose(context.pose, clampedPose);
              },
              parallelScaleRatio: ({ event: { pose }, context }) => {
                const { distance: distance3, parallelScale = void 0 } = pose;
                if (parallelScale === void 0)
                  return context.parallelScaleRatio;
                return parallelScale / distance3;
              }
            }),
            {
              type: "emitNewPose",
              params: ({ context: { pose, parallelScaleRatio } }) => ({
                pose,
                parallelScaleRatio
              })
            }
          ]
        },
        watchPose: {
          actions: [
            assign({
              poseWatchers: ({ context: { poseWatchers }, event: { watcher } }) => {
                return [...poseWatchers, watcher];
              }
            }),
            ({ context: { pose, parallelScaleRatio }, event: { watcher } }) => {
              watcher.send({ type: "setCameraPose", pose, parallelScaleRatio });
            }
          ]
        },
        watchPoseStop: {
          actions: [
            assign({
              poseWatchers: ({ context: { poseWatchers }, event: { watcher } }) => {
                return poseWatchers.filter((w2) => w2 !== watcher);
              }
            })
          ]
        },
        setEnableRotation: {
          actions: assign({
            enableRotation: ({ event: event2 }) => event2.enable
          })
        }
      }
    }
  }
});
var reset3d = (pose, verticalFieldOfView, bounds, aspect) => {
  const center = vec3_exports.fromValues((bounds[0] + bounds[1]) / 2, (bounds[2] + bounds[3]) / 2, (bounds[4] + bounds[5]) / 2);
  let w1 = bounds[1] - bounds[0];
  let w2 = bounds[3] - bounds[2];
  let w3 = bounds[5] - bounds[4];
  w1 *= w1;
  w2 *= w2;
  w3 *= w3;
  let radius = w1 + w2 + w3;
  radius = radius === 0 ? 1 : radius;
  radius = Math.sqrt(radius) * 0.5;
  const limitingDegrees = Math.min(
    verticalFieldOfView * aspect,
    // horizontal field of view
    verticalFieldOfView
  );
  const radians = limitingDegrees * (Math.PI / 180);
  const distance3 = radius / Math.tan(radians * 0.5);
  return { center, rotation: pose.rotation, distance: distance3 };
};
var reset2d = (pose, verticalFieldOfView, bounds, aspect) => {
  const center = vec3_exports.fromValues((bounds[0] + bounds[1]) / 2, (bounds[2] + bounds[3]) / 2, (bounds[4] + bounds[5]) / 2);
  const viewBounds = createBounds();
  const visiblePoints = getCorners(bounds);
  const viewMat = mat4_exports.create();
  toMat4(viewMat, pose);
  for (let i6 = 0; i6 < visiblePoints.length; ++i6) {
    const point = visiblePoints[i6];
    vec3_exports.transformMat4(point, point, viewMat);
    addPoint(viewBounds, ...point);
  }
  const xLength = getLength(viewBounds, 0);
  const yLength = getLength(viewBounds, 1);
  const parallelScale = 0.5 * Math.max(yLength, xLength / aspect);
  const radians = verticalFieldOfView * (Math.PI / 180);
  const distance3 = parallelScale / Math.tan(radians * 0.5);
  return { center, rotation: pose.rotation, distance: distance3, parallelScale };
};

// node_modules/@itk-viewer/viewer/dist/viewport.js
var viewportMachine = setup({
  types: {},
  actions: {
    forwardToParent: sendParent(({ event: event2 }) => {
      return event2;
    }),
    forwardToSpawned: ({ context, event: event2 }) => {
      Object.values(context.spawned).forEach((actor) => {
        actor.send(event2);
      });
    },
    resetCameraPose: (_0) => __async(void 0, [_0], function* ({ context: { image: image2, resolution: dims }, self: self2 }) {
      const { camera } = self2.getSnapshot().children;
      if (!image2 || !camera)
        return;
      const aspect = (() => {
        return dims[1] && dims[0] ? dims[0] / dims[1] : 1;
      })();
      const bounds = yield image2.getWorldBounds(image2.coarsestScale);
      const { pose: currentPose, verticalFieldOfView } = camera.getSnapshot().context;
      const pose = reset3d(currentPose, verticalFieldOfView, bounds, aspect);
      camera.send({
        type: "setPose",
        pose
      });
    })
  }
}).createMachine({
  id: "viewport",
  context: ({ spawn }) => ({
    resolution: [0, 0],
    spawned: {},
    camera: spawn(cameraMachine, { id: "camera" })
  }),
  initial: "active",
  states: {
    active: {
      on: {
        createChild: {
          actions: [
            assign({
              spawned: ({ spawn, context: { spawned }, event: { logic, onActor }, self: self2 }) => {
                const child = spawn(logic);
                child.send({ type: "setViewport", viewport: self2 });
                const { camera } = self2.getSnapshot().children;
                child.send({ type: "setCamera", camera });
                const id = Object.keys(spawned).length.toString();
                onActor(child);
                return __spreadProps(__spreadValues({}, spawned), {
                  [id]: child
                });
              }
            })
          ]
        },
        setImage: {
          actions: [
            assign({
              image: ({ event: { image: image2 } }) => image2
            }),
            "resetCameraPose",
            "forwardToSpawned"
          ]
        },
        setCamera: {
          actions: [
            assign({
              camera: ({ event: { camera } }) => camera
            }),
            "resetCameraPose",
            "forwardToSpawned"
          ]
        },
        setResolution: {
          actions: [
            assign({
              resolution: ({ event: { resolution } }) => resolution
            }),
            "forwardToParent"
          ]
        }
      }
    }
  }
});

// node_modules/@itk-viewer/element/dist/itk-viewport.js
var __decorate2 = function(decorators, target, key, desc) {
  var c6 = arguments.length, r9 = c6 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
  else for (var i6 = decorators.length - 1; i6 >= 0; i6--) if (d3 = decorators[i6]) r9 = (c6 < 3 ? d3(r9) : c6 > 3 ? d3(target, key, r9) : d3(target, key)) || r9;
  return c6 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
};
var ItkViewport = class ItkViewport2 extends s3 {
  constructor() {
    super(...arguments);
    this.dispatched = false;
  }
  getActor() {
    return this.actor;
  }
  setActor(actor) {
    this.actor = actor;
  }
  render() {
    if (!this.dispatched) {
      dispatchSpawn(this, "viewport", viewportMachine, (actor) => this.setActor(actor));
      this.dispatched = true;
    }
    return x`<slot @view=${handleLogic(this.actor)}></slot>`;
  }
};
ItkViewport = __decorate2([
  t3("itk-viewport")
], ItkViewport);

// node_modules/@itk-viewer/viewer/dist/view-2d.js
var AXIS = {
  X: "x",
  Y: "y",
  Z: "z"
};
var axisToIndex = {
  x: 0,
  y: 1,
  z: 2
};
var viewContext = {
  slice: 0.5,
  axis: AXIS.Z,
  scale: 0,
  image: void 0,
  spawned: {},
  viewport: void 0,
  camera: void 0
};
var toRotation = (axis2) => {
  let vec = vec3_exports.fromValues(1, 0, 0);
  let angle2 = Math.PI;
  if (axis2 == "x") {
    vec = vec3_exports.fromValues(0, 1, 0);
    angle2 = Math.PI / 2;
  } else if (axis2 == "y") {
    angle2 = Math.PI / 2;
  }
  const rotation = quat_exports.create();
  quat_exports.setAxisAngle(rotation, vec, angle2);
  return rotation;
};
var computeMinSizeAxis = (bounds) => {
  const xSize = Math.abs(bounds[1] - bounds[0]);
  const ySize = Math.abs(bounds[3] - bounds[2]);
  const zSize = Math.abs(bounds[5] - bounds[4]);
  if (xSize < ySize && xSize < zSize) {
    return AXIS.X;
  }
  if (ySize < xSize && ySize < zSize) {
    return AXIS.Y;
  }
  return AXIS.Z;
};
var view2d = setup({
  types: {},
  actors: {
    imageBuilder: fromPromise((_0) => __async(void 0, [_0], function* ({ input: { image: image2, scale: scale7, slice, axis: axis2 } }) {
      const worldBounds = yield image2.getWorldBounds(scale7);
      let sliceWorldPos = 0;
      if (axis2 === "x") {
        const xWidth = worldBounds[1] - worldBounds[0];
        sliceWorldPos = worldBounds[0] + xWidth * slice;
        worldBounds[0] = sliceWorldPos;
        worldBounds[1] = sliceWorldPos;
      } else if (axis2 === "y") {
        const yWidth = worldBounds[3] - worldBounds[2];
        sliceWorldPos = worldBounds[2] + yWidth * slice;
        worldBounds[2] = sliceWorldPos;
        worldBounds[3] = sliceWorldPos;
      } else if (axis2 === "z") {
        const zWidth = worldBounds[5] - worldBounds[4];
        sliceWorldPos = worldBounds[4] + zWidth * slice;
        worldBounds[4] = sliceWorldPos;
        worldBounds[5] = sliceWorldPos;
      }
      const builtImage = yield image2.getImage(scale7, worldBounds);
      if (builtImage.imageType.dimension === 2) {
        return { builtImage, sliceIndex: 0 };
      }
      const axisIndex = axisToIndex[axis2];
      const builtWidthWorld = builtImage.spacing[axisIndex] * builtImage.size[axisIndex];
      const sliceInBuildImageWorld = sliceWorldPos - builtImage.origin[axisIndex];
      const sliceIndexFloat = Math.round(builtImage.size[axisIndex] * (sliceInBuildImageWorld / builtWidthWorld));
      const sliceIndex = Math.max(0, Math.min(sliceIndexFloat, builtImage.size[axisIndex] - 1));
      return { builtImage, sliceIndex };
    })),
    findDefaultAxis: fromPromise((_0) => __async(void 0, [_0], function* ({ input: { image: image2 } }) {
      const worldBounds = yield image2.getWorldBounds(image2.coarsestScale);
      return computeMinSizeAxis(worldBounds);
    }))
  },
  actions: {
    forwardToSpawned: ({ context, event: event2 }) => {
      Object.values(context.spawned).forEach((actor) => {
        actor.send(event2);
      });
    },
    resetCameraPose: (_0) => __async(void 0, [_0], function* ({ context: { image: image2, camera, viewport, axis: axis2 } }) {
      if (!image2 || !camera)
        return;
      const aspect = (() => {
        if (!viewport)
          return 1;
        const { resolution: dims } = viewport.getSnapshot().context;
        return dims[1] && dims[0] ? dims[0] / dims[1] : 1;
      })();
      const bounds = yield image2.getWorldBounds(image2.coarsestScale);
      const { pose: currentPose, verticalFieldOfView } = camera.getSnapshot().context;
      const withAxis = __spreadValues({}, currentPose);
      withAxis.rotation = toRotation(axis2);
      const pose = reset2d(withAxis, verticalFieldOfView, bounds, aspect);
      camera.send({
        type: "setPose",
        pose
      });
      camera.send({
        type: "setEnableRotation",
        enable: false
      });
    })
  }
}).createMachine({
  context: () => {
    return JSON.parse(JSON.stringify(viewContext));
  },
  id: "view2d",
  initial: "view2d",
  states: {
    view2d: {
      on: {
        createChild: {
          actions: [
            assign({
              spawned: ({ spawn, context: { spawned, camera, axis: axis2 }, event: { logic, onActor }, self: self2 }) => {
                const child = spawn(logic, { input: { parent: self2 } });
                if (camera)
                  child.send({ type: "setCamera", camera });
                child.send({ type: "axis", axis: axis2 });
                const id = Object.keys(spawned).length.toString();
                onActor(child);
                return __spreadProps(__spreadValues({}, spawned), {
                  [id]: child
                });
              }
            })
          ]
        },
        setImage: {
          actions: [
            assign({
              image: ({ event: event2 }) => event2.image,
              scale: ({ event: event2 }) => event2.image.coarsestScale,
              slice: 0.5
            }),
            enqueueActions(({ context, enqueue }) => {
              Object.values(context.spawned).forEach((actor) => {
                enqueue.sendTo(actor, {
                  type: "setImage",
                  image: context.image
                });
              });
            })
          ],
          target: ".findingNewImageDefaults"
        },
        setSlice: {
          actions: [assign({ slice: ({ event: event2 }) => event2.slice })],
          target: ".buildingImage"
        },
        setScale: {
          actions: [assign({ scale: ({ event: event2 }) => event2.scale })],
          target: ".buildingImage"
        },
        setViewport: {
          actions: [
            assign({
              viewport: ({ event: { viewport } }) => viewport
            })
          ]
        },
        setResolution: {
          actions: [
            ({ context: { viewport }, event: { resolution } }) => {
              if (!viewport)
                return;
              viewport.send({ type: "setResolution", resolution });
            }
          ]
        },
        setCamera: {
          actions: [
            assign({
              camera: ({ event: { camera } }) => camera
            }),
            "resetCameraPose",
            "forwardToSpawned"
          ]
        }
      },
      initial: "idle",
      states: {
        idle: {},
        findingNewImageDefaults: {
          invoke: {
            input: ({ context }) => {
              const { image: image2 } = context;
              if (!image2)
                throw new Error("No image available");
              return {
                image: image2
              };
            },
            src: "findDefaultAxis",
            onDone: {
              actions: [
                assign({
                  axis: ({ event: event2 }) => event2.output
                }),
                enqueueActions(({ context, enqueue }) => {
                  Object.values(context.spawned).forEach((actor) => {
                    enqueue.sendTo(actor, {
                      type: "axis",
                      axis: context.axis
                    });
                  });
                }),
                "resetCameraPose"
              ],
              target: "buildingImage"
            }
          }
        },
        buildingImage: {
          invoke: {
            input: ({ context }) => {
              const { image: image2, scale: scale7, slice, axis: axis2 } = context;
              if (!image2)
                throw new Error("No image available");
              return {
                image: image2,
                scale: scale7,
                slice,
                axis: axis2
              };
            },
            src: "imageBuilder",
            onDone: {
              actions: [
                enqueueActions(({ context, enqueue, event: { output } }) => {
                  Object.values(context.spawned).forEach((actor) => {
                    enqueue.sendTo(actor, {
                      type: "imageBuilt",
                      image: output.builtImage,
                      sliceIndex: output.sliceIndex
                    });
                  });
                })
              ]
            }
          }
        }
      }
    }
  }
});

// node_modules/@itk-viewer/element/dist/itk-view-2d.js
var __decorate3 = function(decorators, target, key, desc) {
  var c6 = arguments.length, r9 = c6 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
  else for (var i6 = decorators.length - 1; i6 >= 0; i6--) if (d3 = decorators[i6]) r9 = (c6 < 3 ? d3(r9) : c6 > 3 ? d3(target, key, r9) : d3(target, key)) || r9;
  return c6 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
};
var _a6;
var ItkView2d = (_a6 = class extends s3 {
  constructor() {
    super(...arguments);
    this.dispatched = false;
  }
  setActor(actor) {
    this.actor = actor;
  }
  getActor() {
    return this.actor;
  }
  onSlice(event2) {
    const target = event2.target;
    this.actor.send({
      type: "setSlice",
      slice: target.valueAsNumber
    });
  }
  onScale(event2) {
    const target = event2.target;
    const scale7 = Number(target.value);
    this.actor.send({ type: "setScale", scale: scale7 });
  }
  render() {
    if (!this.dispatched) {
      dispatchSpawn(this, "view", view2d, (actor) => this.setActor(actor));
      this.dispatched = true;
    }
    return x`
      <slot class="container" @renderer=${handleLogic(this.actor)}></slot>
    `;
  }
}, _a6.styles = i`
    .container {
      flex: 1;
      min-height: 0;
      display: flex;
    }
  `, _a6);
ItkView2d = __decorate3([
  t3("itk-view-2d")
], ItkView2d);

// node_modules/xstate-lit/dist/selector-controller.js
var defaultCompare = (a4, b3) => a4 === b3;
var SelectorController = class {
  constructor(host, actorRef, selector, compare = defaultCompare) {
    __publicField(this, "host");
    __publicField(this, "subscription");
    __publicField(this, "selected");
    this.host = host;
    this.host.addController(this);
    this.selected = selector(actorRef.getSnapshot());
    this.subscription = actorRef.subscribe((emitted) => {
      const nextSelected = selector(emitted);
      if (!compare(this.selected, nextSelected)) {
        this.selected = nextSelected;
        this.host.requestUpdate();
      }
    });
  }
  get value() {
    return this.selected;
  }
  hostDisconnected() {
    this.subscription.unsubscribe();
  }
};

// node_modules/@kitware/vtk.js/macros2.js
var import_fast_deep_equal = __toESM(require_fast_deep_equal());

// node_modules/@kitware/vtk.js/vtk.js
var import_globalthis = __toESM(require_globalthis());
var vtkGlobal = (0, import_globalthis.default)();
var factoryMapping = {
  vtkObject: () => null
};
function vtk(obj2) {
  if (obj2 === null || obj2 === void 0) {
    return obj2;
  }
  if (obj2.isA) {
    return obj2;
  }
  if (!obj2.vtkClass) {
    if (vtkGlobal.console && vtkGlobal.console.error) {
      vtkGlobal.console.error("Invalid VTK object");
    }
    return null;
  }
  const constructor = factoryMapping[obj2.vtkClass];
  if (!constructor) {
    if (vtkGlobal.console && vtkGlobal.console.error) {
      vtkGlobal.console.error(`No vtk class found for Object of type ${obj2.vtkClass}`);
    }
    return null;
  }
  const model = __spreadValues({}, obj2);
  Object.keys(model).forEach((keyName) => {
    if (model[keyName] && typeof model[keyName] === "object" && model[keyName].vtkClass) {
      model[keyName] = vtk(model[keyName]);
    }
  });
  const newInst = constructor(model);
  if (newInst && newInst.modified) {
    newInst.modified();
  }
  return newInst;
}
function register(vtkClassName, constructor) {
  factoryMapping[vtkClassName] = constructor;
}
vtk.register = register;

// node_modules/@kitware/vtk.js/Common/Core/ClassHierarchy.js
var ClassHierarchy = class extends Array {
  push() {
    for (let i6 = 0; i6 < arguments.length; i6++) {
      if (!this.includes(arguments[i6])) {
        super.push(arguments[i6]);
      }
    }
    return this.length;
  }
};

// node_modules/@kitware/vtk.js/macros2.js
var globalMTime = 0;
var VOID = Symbol("void");
function getCurrentGlobalMTime() {
  return globalMTime;
}
var fakeConsole = {};
function noOp() {
}
var consoleMethods = ["log", "debug", "info", "warn", "error", "time", "timeEnd", "group", "groupEnd"];
consoleMethods.forEach((methodName) => {
  fakeConsole[methodName] = noOp;
});
vtkGlobal.console = console.hasOwnProperty("log") ? console : fakeConsole;
var loggerFunctions = {
  debug: noOp,
  // Don't print debug by default
  error: vtkGlobal.console.error || noOp,
  info: vtkGlobal.console.info || noOp,
  log: vtkGlobal.console.log || noOp,
  warn: vtkGlobal.console.warn || noOp
};
function setLoggerFunction(name, fn) {
  if (loggerFunctions[name]) {
    loggerFunctions[name] = fn || noOp;
  }
}
function vtkLogMacro() {
  loggerFunctions.log(...arguments);
}
function vtkInfoMacro() {
  loggerFunctions.info(...arguments);
}
function vtkDebugMacro() {
  loggerFunctions.debug(...arguments);
}
function vtkErrorMacro2() {
  loggerFunctions.error(...arguments);
}
function vtkWarningMacro() {
  loggerFunctions.warn(...arguments);
}
var ERROR_ONCE_MAP = {};
function vtkOnceErrorMacro(str6) {
  if (!ERROR_ONCE_MAP[str6]) {
    loggerFunctions.error(str6);
    ERROR_ONCE_MAP[str6] = true;
  }
}
var TYPED_ARRAYS = /* @__PURE__ */ Object.create(null);
TYPED_ARRAYS.Float32Array = Float32Array;
TYPED_ARRAYS.Float64Array = Float64Array;
TYPED_ARRAYS.Uint8Array = Uint8Array;
TYPED_ARRAYS.Int8Array = Int8Array;
TYPED_ARRAYS.Uint16Array = Uint16Array;
TYPED_ARRAYS.Int16Array = Int16Array;
TYPED_ARRAYS.Uint32Array = Uint32Array;
TYPED_ARRAYS.Int32Array = Int32Array;
TYPED_ARRAYS.Uint8ClampedArray = Uint8ClampedArray;
try {
  TYPED_ARRAYS.BigInt64Array = BigInt64Array;
  TYPED_ARRAYS.BigUint64Array = BigUint64Array;
} catch (e13) {
}
function newTypedArray(type) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  return new (TYPED_ARRAYS[type] || Float64Array)(...args);
}
function newTypedArrayFrom(type) {
  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }
  return (TYPED_ARRAYS[type] || Float64Array).from(...args);
}
function capitalize(str6) {
  return str6.charAt(0).toUpperCase() + str6.slice(1);
}
function _capitalize(str6) {
  return capitalize(str6[0] === "_" ? str6.slice(1) : str6);
}
function uncapitalize(str6) {
  return str6.charAt(0).toLowerCase() + str6.slice(1);
}
function formatBytesToProperUnit(size3) {
  let precision = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
  let chunkSize = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1e3;
  const units = ["TB", "GB", "MB", "KB"];
  let value = Number(size3);
  let currentUnit = "B";
  while (value > chunkSize) {
    value /= chunkSize;
    currentUnit = units.pop();
  }
  return `${value.toFixed(precision)} ${currentUnit}`;
}
function formatNumbersWithThousandSeparator(n9) {
  let separator = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : " ";
  const sections = [];
  let size3 = n9;
  while (size3 > 1e3) {
    sections.push(`000${size3 % 1e3}`.slice(-3));
    size3 = Math.floor(size3 / 1e3);
  }
  if (size3 > 0) {
    sections.push(size3);
  }
  sections.reverse();
  return sections.join(separator);
}
function safeArrays(model) {
  Object.keys(model).forEach((key) => {
    if (Array.isArray(model[key])) {
      model[key] = [].concat(model[key]);
    }
  });
}
function isTypedArray(value) {
  return Object.values(TYPED_ARRAYS).some((ctor) => value instanceof ctor);
}
function shallowEquals(a4, b3) {
  if (a4 === b3) {
    return true;
  }
  if (Array.isArray(a4) && Array.isArray(b3)) {
    if (a4.length !== b3.length) {
      return false;
    }
    for (let i6 = 0; i6 < a4.length; i6++) {
      if (a4[i6] !== b3[i6]) {
        return false;
      }
    }
    return true;
  }
  return false;
}
function enumToString(e13, value) {
  return Object.keys(e13).find((key) => e13[key] === value);
}
function getStateArrayMapFunc(item) {
  if (item && item.isA) {
    return item.getState();
  }
  return item;
}
function setImmediateVTK(fn) {
  setTimeout(fn, 0);
}
function measurePromiseExecution(promise, callback) {
  const start = performance.now();
  promise.finally(() => {
    const delta = performance.now() - start;
    callback(delta);
  });
}
function obj() {
  let publicAPI = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  let model = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  safeArrays(model);
  const callbacks = [];
  if (!Number.isInteger(model.mtime)) {
    model.mtime = ++globalMTime;
  }
  if (!("classHierarchy" in model)) {
    model.classHierarchy = new ClassHierarchy("vtkObject");
  } else if (!(model.classHierarchy instanceof ClassHierarchy)) {
    const hierarchy = new ClassHierarchy();
    for (let i6 = 0; i6 < model.classHierarchy.length; i6++) {
      hierarchy.push(model.classHierarchy[i6]);
    }
    model.classHierarchy = hierarchy;
  }
  function off(index2) {
    callbacks[index2] = null;
  }
  function on(index2) {
    function unsubscribe() {
      off(index2);
    }
    return Object.freeze({
      unsubscribe
    });
  }
  publicAPI.isDeleted = () => !!model.deleted;
  publicAPI.modified = (otherMTime) => {
    if (model.deleted) {
      vtkErrorMacro2("instance deleted - cannot call any method");
      return;
    }
    if (otherMTime && otherMTime < publicAPI.getMTime()) {
      return;
    }
    model.mtime = ++globalMTime;
    callbacks.forEach((callback) => callback && callback(publicAPI));
  };
  publicAPI.onModified = (callback) => {
    if (model.deleted) {
      vtkErrorMacro2("instance deleted - cannot call any method");
      return null;
    }
    const index2 = callbacks.length;
    callbacks.push(callback);
    return on(index2);
  };
  publicAPI.getMTime = () => model.mtime;
  publicAPI.isA = (className) => {
    let count = model.classHierarchy.length;
    while (count--) {
      if (model.classHierarchy[count] === className) {
        return true;
      }
    }
    return false;
  };
  publicAPI.getClassName = function() {
    let depth = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    return model.classHierarchy[model.classHierarchy.length - 1 - depth];
  };
  publicAPI.set = function() {
    let map = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let noWarning = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    let noFunction = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    let ret = false;
    Object.keys(map).forEach((name) => {
      const fn = noFunction ? null : publicAPI[`set${capitalize(name)}`];
      if (fn && Array.isArray(map[name]) && fn.length > 1) {
        ret = fn(...map[name]) || ret;
      } else if (fn) {
        ret = fn(map[name]) || ret;
      } else {
        if (["mtime"].indexOf(name) === -1 && !noWarning) {
          vtkWarningMacro(`Warning: Set value to model directly ${name}, ${map[name]}`);
        }
        ret = model[name] !== map[name] || ret;
        model[name] = map[name];
      }
    });
    return ret;
  };
  publicAPI.get = function() {
    for (var _len3 = arguments.length, list = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      list[_key3] = arguments[_key3];
    }
    if (!list.length) {
      return model;
    }
    const subset = {};
    list.forEach((name) => {
      subset[name] = model[name];
    });
    return subset;
  };
  publicAPI.getReferenceByName = (val) => model[val];
  publicAPI.delete = () => {
    Object.keys(model).forEach((field) => delete model[field]);
    callbacks.forEach((el, index2) => off(index2));
    model.deleted = true;
  };
  publicAPI.getState = () => {
    if (model.deleted) {
      return null;
    }
    const jsonArchive = __spreadProps(__spreadValues({}, model), {
      vtkClass: publicAPI.getClassName()
    });
    Object.keys(jsonArchive).forEach((keyName) => {
      if (jsonArchive[keyName] === null || jsonArchive[keyName] === void 0 || keyName[0] === "_") {
        delete jsonArchive[keyName];
      } else if (jsonArchive[keyName].isA) {
        jsonArchive[keyName] = jsonArchive[keyName].getState();
      } else if (Array.isArray(jsonArchive[keyName])) {
        jsonArchive[keyName] = jsonArchive[keyName].map(getStateArrayMapFunc);
      } else if (isTypedArray(jsonArchive[keyName])) {
        jsonArchive[keyName] = Array.from(jsonArchive[keyName]);
      }
    });
    const sortedObj = {};
    Object.keys(jsonArchive).sort().forEach((name) => {
      sortedObj[name] = jsonArchive[name];
    });
    if (sortedObj.mtime) {
      delete sortedObj.mtime;
    }
    return sortedObj;
  };
  publicAPI.shallowCopy = function(other) {
    let debug = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    if (other.getClassName() !== publicAPI.getClassName()) {
      throw new Error(`Cannot ShallowCopy ${other.getClassName()} into ${publicAPI.getClassName()}`);
    }
    const otherModel = other.get();
    const keyList = Object.keys(model).sort();
    const otherKeyList = Object.keys(otherModel).sort();
    otherKeyList.forEach((key) => {
      const keyIdx = keyList.indexOf(key);
      if (keyIdx === -1) {
        if (debug) {
          vtkDebugMacro(`add ${key} in shallowCopy`);
        }
      } else {
        keyList.splice(keyIdx, 1);
      }
      model[key] = otherModel[key];
    });
    if (keyList.length && debug) {
      vtkDebugMacro(`Untouched keys: ${keyList.join(", ")}`);
    }
    publicAPI.modified();
  };
  publicAPI.toJSON = function vtkObjToJSON() {
    return publicAPI.getState();
  };
  return publicAPI;
}
var objectGetterMap = {
  object(publicAPI, model, field) {
    return function getter() {
      return __spreadValues({}, model[field.name]);
    };
  }
};
function get(publicAPI, model, fieldNames) {
  fieldNames.forEach((field) => {
    if (typeof field === "object") {
      const getter = objectGetterMap[field.type];
      if (getter) {
        publicAPI[`get${_capitalize(field.name)}`] = getter(publicAPI, model, field);
      } else {
        publicAPI[`get${_capitalize(field.name)}`] = () => model[field.name];
      }
    } else {
      publicAPI[`get${_capitalize(field)}`] = () => model[field];
    }
  });
}
var objectSetterMap = {
  enum(publicAPI, model, field) {
    const onChanged = `_on${_capitalize(field.name)}Changed`;
    return (value) => {
      var _a9;
      if (typeof value === "string") {
        if (field.enum[value] !== void 0) {
          if (model[field.name] !== field.enum[value]) {
            model[field.name] = field.enum[value];
            publicAPI.modified();
            return true;
          }
          return false;
        }
        vtkErrorMacro2(`Set Enum with invalid argument ${field}, ${value}`);
        throw new RangeError("Set Enum with invalid string argument");
      }
      if (typeof value === "number") {
        if (model[field.name] !== value) {
          if (Object.keys(field.enum).map((key) => field.enum[key]).indexOf(value) !== -1) {
            const previousValue = model[field.name];
            model[field.name] = value;
            (_a9 = model[onChanged]) == null ? void 0 : _a9.call(model, publicAPI, model, value, previousValue);
            publicAPI.modified();
            return true;
          }
          vtkErrorMacro2(`Set Enum outside numeric range ${field}, ${value}`);
          throw new RangeError("Set Enum outside numeric range");
        }
        return false;
      }
      vtkErrorMacro2(`Set Enum with invalid argument (String/Number) ${field}, ${value}`);
      throw new TypeError("Set Enum with invalid argument (String/Number)");
    };
  },
  object(publicAPI, model, field) {
    const onChanged = `_on${_capitalize(field.name)}Changed`;
    return (value) => {
      var _a9;
      if (!(0, import_fast_deep_equal.default)(model[field.name], value)) {
        const previousValue = model[field.name];
        model[field.name] = value;
        (_a9 = model[onChanged]) == null ? void 0 : _a9.call(model, publicAPI, model, value, previousValue);
        publicAPI.modified();
        return true;
      }
      return false;
    };
  }
};
function findSetter(field) {
  if (typeof field === "object") {
    const fn = objectSetterMap[field.type];
    if (fn) {
      return (publicAPI, model) => fn(publicAPI, model, field);
    }
    vtkErrorMacro2(`No setter for field ${field}`);
    throw new TypeError("No setter for field");
  }
  return function getSetter(publicAPI, model) {
    const onChanged = `_on${_capitalize(field)}Changed`;
    return function setter(value) {
      var _a9;
      if (model.deleted) {
        vtkErrorMacro2("instance deleted - cannot call any method");
        return false;
      }
      if (model[field] !== value) {
        const previousValue = model[field.name];
        model[field] = value;
        (_a9 = model[onChanged]) == null ? void 0 : _a9.call(model, publicAPI, model, value, previousValue);
        publicAPI.modified();
        return true;
      }
      return false;
    };
  };
}
function set6(publicAPI, model, fields) {
  fields.forEach((field) => {
    if (typeof field === "object") {
      publicAPI[`set${_capitalize(field.name)}`] = findSetter(field)(publicAPI, model);
    } else {
      publicAPI[`set${_capitalize(field)}`] = findSetter(field)(publicAPI, model);
    }
  });
}
function setGet(publicAPI, model, fieldNames) {
  get(publicAPI, model, fieldNames);
  set6(publicAPI, model, fieldNames);
}
function getArray(publicAPI, model, fieldNames) {
  fieldNames.forEach((field) => {
    publicAPI[`get${_capitalize(field)}`] = () => model[field] ? Array.from(model[field]) : model[field];
    publicAPI[`get${_capitalize(field)}ByReference`] = () => model[field];
  });
}
function setArray(publicAPI, model, fieldNames, size3) {
  let defaultVal = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : void 0;
  fieldNames.forEach((field) => {
    if (model[field] && size3 && model[field].length !== size3) {
      throw new RangeError(`Invalid initial number of values for array (${field})`);
    }
    const onChanged = `_on${_capitalize(field)}Changed`;
    publicAPI[`set${_capitalize(field)}`] = function() {
      var _a9;
      if (model.deleted) {
        vtkErrorMacro2("instance deleted - cannot call any method");
        return false;
      }
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      let array = args;
      let changeDetected;
      let needCopy = false;
      if (array.length === 1 && (array[0] == null || array[0].length >= 0)) {
        array = array[0];
        needCopy = true;
      }
      if (array == null) {
        changeDetected = model[field] !== array;
      } else {
        if (size3 && array.length !== size3) {
          if (array.length < size3 && defaultVal !== void 0) {
            array = Array.from(array);
            needCopy = false;
            while (array.length < size3) array.push(defaultVal);
          } else {
            throw new RangeError(`Invalid number of values for array setter (${field})`);
          }
        }
        changeDetected = model[field] == null || model[field].length !== array.length;
        for (let i6 = 0; !changeDetected && i6 < array.length; ++i6) {
          changeDetected = model[field][i6] !== array[i6];
        }
        if (changeDetected && needCopy) {
          array = Array.from(array);
        }
      }
      if (changeDetected) {
        const previousValue = model[field.name];
        model[field] = array;
        (_a9 = model[onChanged]) == null ? void 0 : _a9.call(model, publicAPI, model, array, previousValue);
        publicAPI.modified();
      }
      return changeDetected;
    };
    publicAPI[`set${_capitalize(field)}From`] = (otherArray) => {
      const target = model[field];
      otherArray.forEach((v2, i6) => {
        target[i6] = v2;
      });
    };
  });
}
function setGetArray(publicAPI, model, fieldNames, size3) {
  let defaultVal = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : void 0;
  getArray(publicAPI, model, fieldNames);
  setArray(publicAPI, model, fieldNames, size3, defaultVal);
}
function moveToProtected(publicAPI, model, fieldNames) {
  for (let i6 = 0; i6 < fieldNames.length; i6++) {
    const fieldName = fieldNames[i6];
    if (model[fieldName] !== void 0) {
      model[`_${fieldName}`] = model[fieldName];
      delete model[fieldName];
    }
  }
}
function algo(publicAPI, model, numberOfInputs, numberOfOutputs) {
  if (model.inputData) {
    model.inputData = model.inputData.map(vtk);
  } else {
    model.inputData = [];
  }
  if (model.inputConnection) {
    model.inputConnection = model.inputConnection.map(vtk);
  } else {
    model.inputConnection = [];
  }
  if (model.output) {
    model.output = model.output.map(vtk);
  } else {
    model.output = [];
  }
  if (model.inputArrayToProcess) {
    model.inputArrayToProcess = model.inputArrayToProcess.map(vtk);
  } else {
    model.inputArrayToProcess = [];
  }
  model.numberOfInputs = numberOfInputs;
  function setInputData(dataset) {
    let port = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    if (model.deleted) {
      vtkErrorMacro2("instance deleted - cannot call any method");
      return;
    }
    if (port >= model.numberOfInputs) {
      vtkErrorMacro2(`algorithm ${publicAPI.getClassName()} only has ${model.numberOfInputs} input ports. To add more input ports, use addInputData()`);
      return;
    }
    if (model.inputData[port] !== dataset || model.inputConnection[port]) {
      model.inputData[port] = dataset;
      model.inputConnection[port] = null;
      if (publicAPI.modified) {
        publicAPI.modified();
      }
    }
  }
  function getInputData() {
    let port = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    if (model.inputConnection[port]) {
      model.inputData[port] = model.inputConnection[port]();
    }
    return model.inputData[port];
  }
  function setInputConnection(outputPort) {
    let port = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    if (model.deleted) {
      vtkErrorMacro2("instance deleted - cannot call any method");
      return;
    }
    if (port >= model.numberOfInputs) {
      let msg = `algorithm ${publicAPI.getClassName()} only has `;
      msg += `${model.numberOfInputs}`;
      msg += " input ports. To add more input ports, use addInputConnection()";
      vtkErrorMacro2(msg);
      return;
    }
    model.inputData[port] = null;
    model.inputConnection[port] = outputPort;
  }
  function getInputConnection() {
    let port = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    return model.inputConnection[port];
  }
  function getPortToFill() {
    let portToFill = model.numberOfInputs;
    while (portToFill && !model.inputData[portToFill - 1] && !model.inputConnection[portToFill - 1]) {
      portToFill--;
    }
    if (portToFill === model.numberOfInputs) {
      model.numberOfInputs++;
    }
    return portToFill;
  }
  function addInputConnection(outputPort) {
    if (model.deleted) {
      vtkErrorMacro2("instance deleted - cannot call any method");
      return;
    }
    setInputConnection(outputPort, getPortToFill());
  }
  function addInputData(dataset) {
    if (model.deleted) {
      vtkErrorMacro2("instance deleted - cannot call any method");
      return;
    }
    setInputData(dataset, getPortToFill());
  }
  function getOutputData() {
    let port = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    if (model.deleted) {
      vtkErrorMacro2("instance deleted - cannot call any method");
      return null;
    }
    if (publicAPI.shouldUpdate()) {
      publicAPI.update();
    }
    return model.output[port];
  }
  publicAPI.shouldUpdate = () => {
    var _a9, _b2;
    const localMTime = publicAPI.getMTime();
    let minOutputMTime = Infinity;
    let count = numberOfOutputs;
    while (count--) {
      if (!model.output[count] || model.output[count].isDeleted()) {
        return true;
      }
      const mt = model.output[count].getMTime();
      if (mt < localMTime) {
        return true;
      }
      if (mt < minOutputMTime) {
        minOutputMTime = mt;
      }
    }
    count = model.numberOfInputs;
    while (count--) {
      if (((_a9 = model.inputConnection[count]) == null ? void 0 : _a9.filter.shouldUpdate()) || ((_b2 = publicAPI.getInputData(count)) == null ? void 0 : _b2.getMTime()) > minOutputMTime) {
        return true;
      }
    }
    return false;
  };
  function getOutputPort() {
    let port = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    const outputPortAccess = () => getOutputData(port);
    outputPortAccess.filter = publicAPI;
    return outputPortAccess;
  }
  if (model.numberOfInputs) {
    let count = model.numberOfInputs;
    while (count--) {
      model.inputData.push(null);
      model.inputConnection.push(null);
    }
    publicAPI.setInputData = setInputData;
    publicAPI.setInputConnection = setInputConnection;
    publicAPI.addInputData = addInputData;
    publicAPI.addInputConnection = addInputConnection;
    publicAPI.getInputData = getInputData;
    publicAPI.getInputConnection = getInputConnection;
  }
  if (numberOfOutputs) {
    publicAPI.getOutputData = getOutputData;
    publicAPI.getOutputPort = getOutputPort;
  }
  publicAPI.update = () => {
    const ins = [];
    if (model.numberOfInputs) {
      let count = 0;
      while (count < model.numberOfInputs) {
        ins[count] = publicAPI.getInputData(count);
        count++;
      }
    }
    if (publicAPI.shouldUpdate() && publicAPI.requestData) {
      publicAPI.requestData(ins, model.output);
    }
  };
  publicAPI.getNumberOfInputPorts = () => model.numberOfInputs;
  publicAPI.getNumberOfOutputPorts = () => numberOfOutputs || model.output.length;
  publicAPI.getInputArrayToProcess = (inputPort) => {
    const arrayDesc = model.inputArrayToProcess[inputPort];
    const ds = model.inputData[inputPort];
    if (arrayDesc && ds) {
      return ds[`get${arrayDesc.fieldAssociation}`]().getArray(arrayDesc.arrayName);
    }
    return null;
  };
  publicAPI.setInputArrayToProcess = function(inputPort, arrayName, fieldAssociation) {
    let attributeType = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "Scalars";
    while (model.inputArrayToProcess.length < inputPort) {
      model.inputArrayToProcess.push(null);
    }
    model.inputArrayToProcess[inputPort] = {
      arrayName,
      fieldAssociation,
      attributeType
    };
  };
}
var EVENT_ABORT = Symbol("Event abort");
function event(publicAPI, model, eventName) {
  const callbacks = [];
  const previousDelete = publicAPI.delete;
  let curCallbackID = 1;
  function off(callbackID) {
    for (let i6 = 0; i6 < callbacks.length; ++i6) {
      const [cbID] = callbacks[i6];
      if (cbID === callbackID) {
        callbacks.splice(i6, 1);
        return;
      }
    }
  }
  function on(callbackID) {
    function unsubscribe() {
      off(callbackID);
    }
    return Object.freeze({
      unsubscribe
    });
  }
  function invoke() {
    if (model.deleted) {
      vtkErrorMacro2("instance deleted - cannot call any method");
      return;
    }
    const currentCallbacks = callbacks.slice();
    for (let index2 = 0; index2 < currentCallbacks.length; ++index2) {
      const [, cb, priority] = currentCallbacks[index2];
      if (!cb) {
        continue;
      }
      if (priority < 0) {
        setTimeout(() => cb.apply(publicAPI, arguments), 1 - priority);
      } else {
        const continueNext = cb.apply(publicAPI, arguments);
        if (continueNext === EVENT_ABORT) {
          break;
        }
      }
    }
  }
  publicAPI[`invoke${_capitalize(eventName)}`] = invoke;
  publicAPI[`on${_capitalize(eventName)}`] = function(callback) {
    let priority = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    if (!callback.apply) {
      console.error(`Invalid callback for event ${eventName}`);
      return null;
    }
    if (model.deleted) {
      vtkErrorMacro2("instance deleted - cannot call any method");
      return null;
    }
    const callbackID = curCallbackID++;
    callbacks.push([callbackID, callback, priority]);
    callbacks.sort((cb1, cb2) => cb2[2] - cb1[2]);
    return on(callbackID);
  };
  publicAPI.delete = () => {
    previousDelete();
    callbacks.forEach((_ref) => {
      let [cbID] = _ref;
      return off(cbID);
    });
  };
}
function newInstance(extend110, className) {
  const constructor = function() {
    let initialValues = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const model = {};
    const publicAPI = {};
    extend110(publicAPI, model, initialValues);
    return Object.freeze(publicAPI);
  };
  if (className) {
    vtk.register(className, constructor);
  }
  return constructor;
}
function chain() {
  for (var _len5 = arguments.length, fn = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
    fn[_key5] = arguments[_key5];
  }
  return function() {
    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
      args[_key6] = arguments[_key6];
    }
    return fn.filter((i6) => !!i6).map((i6) => i6(...args));
  };
}
function isVtkObject(instance) {
  return instance && instance.isA && instance.isA("vtkObject");
}
function traverseInstanceTree(instance, extractFunction) {
  let accumulator = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
  let visitedInstances = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [];
  if (isVtkObject(instance)) {
    if (visitedInstances.indexOf(instance) >= 0) {
      return accumulator;
    }
    visitedInstances.push(instance);
    const result = extractFunction(instance);
    if (result !== void 0) {
      accumulator.push(result);
    }
    const model = instance.get();
    Object.keys(model).forEach((key) => {
      const modelObj = model[key];
      if (Array.isArray(modelObj)) {
        modelObj.forEach((subObj) => {
          traverseInstanceTree(subObj, extractFunction, accumulator, visitedInstances);
        });
      } else {
        traverseInstanceTree(modelObj, extractFunction, accumulator, visitedInstances);
      }
    });
  }
  return accumulator;
}
function debounce(func, wait, immediate) {
  var _this = this;
  let timeout;
  const debounced = function() {
    for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
      args[_key7] = arguments[_key7];
    }
    const context = _this;
    const later = () => {
      timeout = null;
      if (!immediate) {
        func.apply(context, args);
      }
    };
    const callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (callNow) {
      func.apply(context, args);
    }
  };
  debounced.cancel = () => clearTimeout(timeout);
  return debounced;
}
function throttle(callback, delay) {
  let isThrottled = false;
  let argsToUse = null;
  function next() {
    isThrottled = false;
    if (argsToUse !== null) {
      wrapper(...argsToUse);
      argsToUse = null;
    }
  }
  function wrapper() {
    for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
      args[_key8] = arguments[_key8];
    }
    if (isThrottled) {
      argsToUse = args;
      return;
    }
    isThrottled = true;
    callback(...args);
    setTimeout(next, delay);
  }
  return wrapper;
}
function keystore(publicAPI, model) {
  let initialKeystore = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  model.keystore = Object.assign(model.keystore || {}, initialKeystore);
  publicAPI.setKey = (key, value) => {
    model.keystore[key] = value;
  };
  publicAPI.getKey = (key) => model.keystore[key];
  publicAPI.getAllKeys = () => Object.keys(model.keystore);
  publicAPI.deleteKey = (key) => delete model.keystore[key];
  publicAPI.clearKeystore = () => publicAPI.getAllKeys().forEach((key) => delete model.keystore[key]);
}
var nextProxyId = 1;
var ROOT_GROUP_NAME = "__root__";
function proxy(publicAPI, model) {
  keystore(publicAPI, model);
  const parentDelete = publicAPI.delete;
  model.proxyId = `${nextProxyId++}`;
  model.ui = JSON.parse(JSON.stringify(model.ui || []));
  get(publicAPI, model, ["proxyId", "proxyGroup", "proxyName"]);
  setGet(publicAPI, model, ["proxyManager"]);
  const propertyMap = {};
  const groupChildrenNames = {};
  function registerProperties(descriptionList, currentGroupName) {
    if (!groupChildrenNames[currentGroupName]) {
      groupChildrenNames[currentGroupName] = [];
    }
    const childrenNames = groupChildrenNames[currentGroupName];
    for (let i6 = 0; i6 < descriptionList.length; i6++) {
      childrenNames.push(descriptionList[i6].name);
      propertyMap[descriptionList[i6].name] = descriptionList[i6];
      if (descriptionList[i6].children && descriptionList[i6].children.length) {
        registerProperties(descriptionList[i6].children, descriptionList[i6].name);
      }
    }
  }
  registerProperties(model.ui, ROOT_GROUP_NAME);
  publicAPI.updateUI = (ui) => {
    model.ui = JSON.parse(JSON.stringify(ui || []));
    Object.keys(propertyMap).forEach((k2) => delete propertyMap[k2]);
    Object.keys(groupChildrenNames).forEach((k2) => delete groupChildrenNames[k2]);
    registerProperties(model.ui, ROOT_GROUP_NAME);
    publicAPI.modified();
  };
  function listProxyProperties() {
    let gName = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ROOT_GROUP_NAME;
    return groupChildrenNames[gName];
  }
  publicAPI.updateProxyProperty = (propertyName, propUI) => {
    const prop = propertyMap[propertyName];
    if (prop) {
      Object.assign(prop, propUI);
    } else {
      propertyMap[propertyName] = __spreadValues({}, propUI);
    }
  };
  publicAPI.activate = () => {
    if (model.proxyManager) {
      const setActiveMethod = `setActive${_capitalize(publicAPI.getProxyGroup().slice(0, -1))}`;
      if (model.proxyManager[setActiveMethod]) {
        model.proxyManager[setActiveMethod](publicAPI);
      }
    }
  };
  model.propertyLinkSubscribers = {};
  publicAPI.registerPropertyLinkForGC = (otherLink, type) => {
    if (!(type in model.propertyLinkSubscribers)) {
      model.propertyLinkSubscribers[type] = [];
    }
    model.propertyLinkSubscribers[type].push(otherLink);
  };
  publicAPI.gcPropertyLinks = (type) => {
    const subscribers = model.propertyLinkSubscribers[type] || [];
    while (subscribers.length) {
      subscribers.pop().unbind(publicAPI);
    }
  };
  model.propertyLinkMap = {};
  publicAPI.getPropertyLink = function(id) {
    let persistent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    if (model.propertyLinkMap[id]) {
      return model.propertyLinkMap[id];
    }
    let value = null;
    const links = [];
    let count = 0;
    let updateInProgress = false;
    function update2(source) {
      let force = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (updateInProgress) {
        return null;
      }
      const needUpdate = [];
      let sourceLink = null;
      count = links.length;
      while (count--) {
        const link = links[count];
        if (link.instance === source) {
          sourceLink = link;
        } else {
          needUpdate.push(link);
        }
      }
      if (!sourceLink) {
        return null;
      }
      const newValue = sourceLink.instance[`get${_capitalize(sourceLink.propertyName)}`]();
      if (!shallowEquals(newValue, value) || force) {
        value = newValue;
        updateInProgress = true;
        while (needUpdate.length) {
          const linkToUpdate = needUpdate.pop();
          linkToUpdate.instance.set({
            [linkToUpdate.propertyName]: value
          });
        }
        updateInProgress = false;
      }
      if (model.propertyLinkMap[id].persistent) {
        model.propertyLinkMap[id].value = newValue;
      }
      return newValue;
    }
    function unbind(instance, propertyName) {
      const indexToDelete = [];
      count = links.length;
      while (count--) {
        const link = links[count];
        if (link.instance === instance && (link.propertyName === propertyName || propertyName === void 0)) {
          link.subscription.unsubscribe();
          indexToDelete.push(count);
        }
      }
      while (indexToDelete.length) {
        links.splice(indexToDelete.pop(), 1);
      }
    }
    function bind2(instance, propertyName) {
      let updateMe = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      const subscription = instance.onModified(update2);
      const other = links[0];
      links.push({
        instance,
        propertyName,
        subscription
      });
      if (updateMe) {
        if (model.propertyLinkMap[id].persistent && model.propertyLinkMap[id].value !== void 0) {
          instance.set({
            [propertyName]: model.propertyLinkMap[id].value
          });
        } else if (other) {
          update2(other.instance, true);
        }
      }
      return {
        unsubscribe: () => unbind(instance, propertyName)
      };
    }
    function unsubscribe() {
      while (links.length) {
        links.pop().subscription.unsubscribe();
      }
    }
    const linkHandler = {
      bind: bind2,
      unbind,
      unsubscribe,
      persistent
    };
    model.propertyLinkMap[id] = linkHandler;
    return linkHandler;
  };
  function getProperties() {
    let groupName = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ROOT_GROUP_NAME;
    const values = [];
    const id = model.proxyId;
    const propertyNames = listProxyProperties(groupName) || [];
    for (let i6 = 0; i6 < propertyNames.length; i6++) {
      const name = propertyNames[i6];
      const method = publicAPI[`get${_capitalize(name)}`];
      const value = method ? method() : void 0;
      const prop = {
        id,
        name,
        value
      };
      const children = getProperties(name);
      if (children.length) {
        prop.children = children;
      }
      values.push(prop);
    }
    return values;
  }
  publicAPI.listPropertyNames = () => getProperties().map((p3) => p3.name);
  publicAPI.getPropertyByName = (name) => getProperties().find((p3) => p3.name === name);
  publicAPI.getPropertyDomainByName = (name) => (propertyMap[name] || {}).domain;
  publicAPI.getProxySection = () => ({
    id: model.proxyId,
    name: model.proxyGroup,
    ui: model.ui,
    properties: getProperties()
  });
  publicAPI.delete = () => {
    const list = Object.keys(model.propertyLinkMap);
    let count = list.length;
    while (count--) {
      model.propertyLinkMap[list[count]].unsubscribe();
    }
    Object.keys(model.propertyLinkSubscribers).forEach(publicAPI.gcPropertyLinks);
    parentDelete();
  };
  publicAPI.getState = () => null;
  function registerLinks() {
    if (model.links) {
      for (let i6 = 0; i6 < model.links.length; i6++) {
        const {
          link,
          property,
          persistent,
          updateOnBind,
          type
        } = model.links[i6];
        if (type === "application") {
          const sLink = model.proxyManager.getPropertyLink(link, persistent);
          publicAPI.registerPropertyLinkForGC(sLink, "application");
          sLink.bind(publicAPI, property, updateOnBind);
        }
      }
    }
  }
  setImmediateVTK(registerLinks);
}
function proxyPropertyMapping(publicAPI, model, map) {
  const parentDelete = publicAPI.delete;
  const subscriptions = [];
  const propertyNames = Object.keys(map);
  let count = propertyNames.length;
  while (count--) {
    const propertyName = propertyNames[count];
    const {
      modelKey,
      property,
      modified = true
    } = map[propertyName];
    const methodSrc = _capitalize(property);
    const methodDst = _capitalize(propertyName);
    publicAPI[`get${methodDst}`] = model[modelKey][`get${methodSrc}`];
    publicAPI[`set${methodDst}`] = model[modelKey][`set${methodSrc}`];
    if (modified) {
      subscriptions.push(model[modelKey].onModified(publicAPI.modified));
    }
  }
  publicAPI.delete = () => {
    while (subscriptions.length) {
      subscriptions.pop().unsubscribe();
    }
    parentDelete();
  };
}
function proxyPropertyState(publicAPI, model) {
  let state = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  let defaults2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  model.this = publicAPI;
  function applyState(map) {
    const modelKeys2 = Object.keys(map);
    let count2 = modelKeys2.length;
    while (count2--) {
      const modelKey = modelKeys2[count2];
      model[modelKey].set(map[modelKey]);
    }
  }
  const modelKeys = Object.keys(defaults2);
  let count = modelKeys.length;
  while (count--) {
    const key = modelKeys[count];
    model[key] = defaults2[key];
    const mapping = state[key];
    publicAPI[`set${_capitalize(key)}`] = (value) => {
      if (value !== model[key]) {
        model[key] = value;
        const propValues = mapping[value];
        applyState(propValues);
        publicAPI.modified();
      }
    };
  }
  if (modelKeys.length) {
    get(publicAPI, model, modelKeys);
  }
}
var PIXEL_STEP = 10;
var LINE_HEIGHT = 40;
var PAGE_HEIGHT = 800;
function normalizeWheel(wheelEvent) {
  let sX = 0;
  let sY = 0;
  let pX = 0;
  let pY = 0;
  if ("detail" in wheelEvent) {
    sY = wheelEvent.detail;
  }
  if ("wheelDelta" in wheelEvent) {
    sY = -wheelEvent.wheelDelta / 120;
  }
  if ("wheelDeltaY" in wheelEvent) {
    sY = -wheelEvent.wheelDeltaY / 120;
  }
  if ("wheelDeltaX" in wheelEvent) {
    sX = -wheelEvent.wheelDeltaX / 120;
  }
  if ("axis" in wheelEvent && wheelEvent.axis === wheelEvent.HORIZONTAL_AXIS) {
    sX = sY;
    sY = 0;
  }
  pX = sX * PIXEL_STEP;
  pY = sY * PIXEL_STEP;
  if ("deltaY" in wheelEvent) {
    pY = wheelEvent.deltaY;
  }
  if ("deltaX" in wheelEvent) {
    pX = wheelEvent.deltaX;
  }
  if ((pX || pY) && wheelEvent.deltaMode) {
    if (wheelEvent.deltaMode === 1) {
      pX *= LINE_HEIGHT;
      pY *= LINE_HEIGHT;
    } else {
      pX *= PAGE_HEIGHT;
      pY *= PAGE_HEIGHT;
    }
  }
  if (pX && !sX) {
    sX = pX < 1 ? -1 : 1;
  }
  if (pY && !sY) {
    sY = pY < 1 ? -1 : 1;
  }
  return {
    spinX: sX,
    spinY: sY || sX,
    pixelX: pX,
    pixelY: pY || pX
  };
}
var macro = {
  algo,
  capitalize,
  chain,
  debounce,
  enumToString,
  event,
  EVENT_ABORT,
  formatBytesToProperUnit,
  formatNumbersWithThousandSeparator,
  get,
  getArray,
  getCurrentGlobalMTime,
  getStateArrayMapFunc,
  isVtkObject,
  keystore,
  measurePromiseExecution,
  moveToProtected,
  newInstance,
  newTypedArray,
  newTypedArrayFrom,
  normalizeWheel,
  obj,
  proxy,
  proxyPropertyMapping,
  proxyPropertyState,
  safeArrays,
  set: set6,
  setArray,
  setGet,
  setGetArray,
  setImmediate: setImmediateVTK,
  setLoggerFunction,
  throttle,
  traverseInstanceTree,
  TYPED_ARRAYS,
  // deprecated todo remove on breaking API revision
  uncapitalize,
  VOID,
  vtkDebugMacro,
  vtkErrorMacro: vtkErrorMacro2,
  vtkInfoMacro,
  vtkLogMacro,
  vtkOnceErrorMacro,
  vtkWarningMacro
};
var macro$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  VOID,
  setLoggerFunction,
  vtkLogMacro,
  vtkInfoMacro,
  vtkDebugMacro,
  vtkErrorMacro: vtkErrorMacro2,
  vtkWarningMacro,
  vtkOnceErrorMacro,
  TYPED_ARRAYS,
  newTypedArray,
  newTypedArrayFrom,
  capitalize,
  _capitalize,
  uncapitalize,
  formatBytesToProperUnit,
  formatNumbersWithThousandSeparator,
  setImmediateVTK,
  measurePromiseExecution,
  obj,
  get,
  set: set6,
  setGet,
  getArray,
  setArray,
  setGetArray,
  moveToProtected,
  algo,
  EVENT_ABORT,
  event,
  newInstance,
  chain,
  isVtkObject,
  traverseInstanceTree,
  debounce,
  throttle,
  keystore,
  proxy,
  proxyPropertyMapping,
  proxyPropertyState,
  normalizeWheel,
  "default": macro
});

// node_modules/@kitware/vtk.js/Rendering/SceneGraph/ViewNode.js
var {
  vtkErrorMacro: vtkErrorMacro3
} = macro;
var PASS_TYPES = ["Build", "Render"];
function vtkViewNode(publicAPI, model) {
  model.classHierarchy.push("vtkViewNode");
  publicAPI.build = (prepass) => {
  };
  publicAPI.render = (prepass) => {
  };
  publicAPI.traverse = (renderPass) => {
    const passTraversal = renderPass.getTraverseOperation();
    const fn = publicAPI[passTraversal];
    if (fn) {
      fn(renderPass);
      return;
    }
    publicAPI.apply(renderPass, true);
    for (let index2 = 0; index2 < model.children.length; index2++) {
      model.children[index2].traverse(renderPass);
    }
    publicAPI.apply(renderPass, false);
  };
  publicAPI.apply = (renderPass, prepass) => {
    const customRenderPass = publicAPI[renderPass.getOperation()];
    if (customRenderPass) {
      customRenderPass(prepass, renderPass);
    }
  };
  publicAPI.getViewNodeFor = (dataObject) => {
    if (model.renderable === dataObject) {
      return publicAPI;
    }
    for (let index2 = 0; index2 < model.children.length; ++index2) {
      const child = model.children[index2];
      const vn = child.getViewNodeFor(dataObject);
      if (vn) {
        return vn;
      }
    }
    return void 0;
  };
  publicAPI.getFirstAncestorOfType = (type) => {
    if (!model._parent) {
      return null;
    }
    if (model._parent.isA(type)) {
      return model._parent;
    }
    return model._parent.getFirstAncestorOfType(type);
  };
  publicAPI.getLastAncestorOfType = (type) => {
    if (!model._parent) {
      return null;
    }
    const lastAncestor = model._parent.getLastAncestorOfType(type);
    if (lastAncestor) {
      return lastAncestor;
    }
    if (model._parent.isA(type)) {
      return model._parent;
    }
    return null;
  };
  publicAPI.addMissingNode = (dobj) => {
    if (!dobj) {
      return void 0;
    }
    const result = model._renderableChildMap.get(dobj);
    if (result !== void 0) {
      result.setVisited(true);
      return result;
    }
    const newNode = publicAPI.createViewNode(dobj);
    if (newNode) {
      newNode.setParent(publicAPI);
      newNode.setVisited(true);
      model._renderableChildMap.set(dobj, newNode);
      model.children.push(newNode);
      return newNode;
    }
    return void 0;
  };
  publicAPI.addMissingNodes = (dataObjs) => {
    if (!dataObjs || !dataObjs.length) {
      return;
    }
    for (let index2 = 0; index2 < dataObjs.length; ++index2) {
      const dobj = dataObjs[index2];
      publicAPI.addMissingNode(dobj);
    }
  };
  publicAPI.addMissingChildren = (children) => {
    if (!children || !children.length) {
      return;
    }
    for (let index2 = 0; index2 < children.length; ++index2) {
      const child = children[index2];
      const cindex = model.children.indexOf(child);
      if (cindex === -1) {
        child.setParent(publicAPI);
        model.children.push(child);
        const childRenderable = child.getRenderable();
        if (childRenderable) {
          model._renderableChildMap.set(childRenderable, child);
        }
      }
      child.setVisited(true);
    }
  };
  publicAPI.prepareNodes = () => {
    for (let index2 = 0; index2 < model.children.length; ++index2) {
      model.children[index2].setVisited(false);
    }
  };
  publicAPI.setVisited = (val) => {
    model.visited = val;
  };
  publicAPI.removeUnusedNodes = () => {
    let visitedCount = 0;
    for (let index2 = 0; index2 < model.children.length; ++index2) {
      const child = model.children[index2];
      const visited = child.getVisited();
      if (visited) {
        model.children[visitedCount++] = child;
        child.setVisited(false);
      } else {
        const renderable = child.getRenderable();
        if (renderable) {
          model._renderableChildMap.delete(renderable);
        }
        child.delete();
      }
    }
    model.children.length = visitedCount;
  };
  publicAPI.createViewNode = (dataObj) => {
    if (!model.myFactory) {
      vtkErrorMacro3("Cannot create view nodes without my own factory");
      return null;
    }
    const ret = model.myFactory.createNode(dataObj);
    if (ret) {
      ret.setRenderable(dataObj);
    }
    return ret;
  };
  const parentDelete = publicAPI.delete;
  publicAPI.delete = () => {
    for (let i6 = 0; i6 < model.children.length; i6++) {
      model.children[i6].delete();
    }
    parentDelete();
  };
}
var DEFAULT_VALUES = {
  // _parent: null,
  renderable: null,
  myFactory: null,
  children: [],
  visited: false
};
function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);
  macro.obj(publicAPI, model);
  macro.event(publicAPI, model, "event");
  model._renderableChildMap = /* @__PURE__ */ new Map();
  macro.get(publicAPI, model, ["visited"]);
  macro.setGet(publicAPI, model, ["_parent", "renderable", "myFactory"]);
  macro.getArray(publicAPI, model, ["children"]);
  macro.moveToProtected(publicAPI, model, ["parent"]);
  vtkViewNode(publicAPI, model);
}
var newInstance2 = macro.newInstance(extend, "vtkViewNode");
var vtkViewNode$1 = {
  newInstance: newInstance2,
  extend,
  PASS_TYPES
};

// node_modules/@kitware/vtk.js/Rendering/SceneGraph/ViewNodeFactory.js
function vtkViewNodeFactory(publicAPI, model) {
  if (!model.overrides) {
    model.overrides = {};
  }
  model.classHierarchy.push("vtkViewNodeFactory");
  publicAPI.createNode = (dataObject) => {
    if (dataObject.isDeleted()) {
      return null;
    }
    let cpt = 0;
    let className = dataObject.getClassName(cpt++);
    let isObject3 = false;
    const keys = Object.keys(model.overrides);
    while (className && !isObject3) {
      if (keys.indexOf(className) !== -1) {
        isObject3 = true;
      } else {
        className = dataObject.getClassName(cpt++);
      }
    }
    if (!isObject3) {
      return null;
    }
    const vn = model.overrides[className]();
    vn.setMyFactory(publicAPI);
    return vn;
  };
}
var DEFAULT_VALUES2 = {
  // overrides: {},
};
function extend2(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES2, initialValues);
  macro.obj(publicAPI, model);
  vtkViewNodeFactory(publicAPI, model);
}
var newInstance3 = macro.newInstance(extend2, "vtkViewNodeFactory");
var vtkViewNodeFactory$1 = {
  newInstance: newInstance3,
  extend: extend2
};

// node_modules/@kitware/vtk.js/Rendering/OpenGL/ViewNodeFactory.js
var CLASS_MAPPING = /* @__PURE__ */ Object.create(null);
function registerOverride(className, fn) {
  CLASS_MAPPING[className] = fn;
}
function vtkOpenGLViewNodeFactory(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLViewNodeFactory");
}
var DEFAULT_VALUES3 = {};
function extend3(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES3, initialValues);
  model.overrides = CLASS_MAPPING;
  vtkViewNodeFactory$1.extend(publicAPI, model, initialValues);
  vtkOpenGLViewNodeFactory(publicAPI, model);
}
var newInstance4 = macro.newInstance(extend3, "vtkOpenGLViewNodeFactory");
var vtkViewNodeFactory2 = {
  newInstance: newInstance4,
  extend: extend3
};

// node_modules/@kitware/vtk.js/Rendering/OpenGL/Camera.js
function vtkOpenGLCamera(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLCamera");
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      model._openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
      model._openGLRenderWindow = model._openGLRenderer.getParent();
      model.context = model._openGLRenderWindow.getContext();
    }
  };
  publicAPI.opaquePass = (prepass) => {
    if (prepass) {
      const tsize = model._openGLRenderer.getTiledSizeAndOrigin();
      model.context.viewport(tsize.lowerLeftU, tsize.lowerLeftV, tsize.usize, tsize.vsize);
      model.context.scissor(tsize.lowerLeftU, tsize.lowerLeftV, tsize.usize, tsize.vsize);
    }
  };
  publicAPI.translucentPass = publicAPI.opaquePass;
  publicAPI.zBufferPass = publicAPI.opaquePass;
  publicAPI.opaqueZBufferPass = publicAPI.opaquePass;
  publicAPI.volumePass = publicAPI.opaquePass;
  publicAPI.getKeyMatrices = (ren) => {
    if (ren !== model.lastRenderer || model._openGLRenderWindow.getMTime() > model.keyMatrixTime.getMTime() || publicAPI.getMTime() > model.keyMatrixTime.getMTime() || ren.getMTime() > model.keyMatrixTime.getMTime() || model.renderable.getMTime() > model.keyMatrixTime.getMTime()) {
      mat4_exports.copy(model.keyMatrices.wcvc, model.renderable.getViewMatrix());
      mat3_exports.fromMat4(model.keyMatrices.normalMatrix, model.keyMatrices.wcvc);
      mat3_exports.invert(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);
      mat4_exports.transpose(model.keyMatrices.wcvc, model.keyMatrices.wcvc);
      const aspectRatio = model._openGLRenderer.getAspectRatio();
      mat4_exports.copy(model.keyMatrices.vcpc, model.renderable.getProjectionMatrix(aspectRatio, -1, 1));
      mat4_exports.transpose(model.keyMatrices.vcpc, model.keyMatrices.vcpc);
      mat4_exports.multiply(model.keyMatrices.wcpc, model.keyMatrices.vcpc, model.keyMatrices.wcvc);
      model.keyMatrixTime.modified();
      model.lastRenderer = ren;
    }
    return model.keyMatrices;
  };
}
var DEFAULT_VALUES4 = {
  context: null,
  lastRenderer: null,
  keyMatrixTime: null,
  keyMatrices: null
};
function extend4(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES4, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.keyMatrixTime = {};
  obj(model.keyMatrixTime);
  model.keyMatrices = {
    normalMatrix: new Float64Array(9),
    vcpc: new Float64Array(16),
    wcvc: new Float64Array(16),
    wcpc: new Float64Array(16)
  };
  setGet(publicAPI, model, ["context", "keyMatrixTime"]);
  vtkOpenGLCamera(publicAPI, model);
}
var newInstance5 = newInstance(extend4);
registerOverride("vtkCamera", newInstance5);

// node_modules/@kitware/vtk.js/Rendering/OpenGL/Renderer.js
var {
  vtkDebugMacro: vtkDebugMacro2
} = macro$1;
function vtkOpenGLRenderer(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLRenderer");
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      if (!model.renderable) {
        return;
      }
      publicAPI.updateLights();
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.renderable.getActiveCamera());
      publicAPI.addMissingNodes(model.renderable.getViewPropsWithNestedProps());
      publicAPI.removeUnusedNodes();
    }
  };
  publicAPI.updateLights = () => {
    let count = 0;
    const lights = model.renderable.getLightsByReference();
    for (let index2 = 0; index2 < lights.length; ++index2) {
      if (lights[index2].getSwitch() > 0) {
        count++;
      }
    }
    if (!count) {
      vtkDebugMacro2("No lights are on, creating one.");
      model.renderable.createLight();
    }
    return count;
  };
  publicAPI.zBufferPass = (prepass) => {
    if (prepass) {
      let clearMask = 0;
      const gl = model.context;
      if (!model.renderable.getTransparent()) {
        model.context.clearColor(1, 0, 0, 1);
        clearMask |= gl.COLOR_BUFFER_BIT;
      }
      if (!model.renderable.getPreserveDepthBuffer()) {
        gl.clearDepth(1);
        clearMask |= gl.DEPTH_BUFFER_BIT;
        model.context.depthMask(true);
      }
      const ts = publicAPI.getTiledSizeAndOrigin();
      gl.enable(gl.SCISSOR_TEST);
      gl.scissor(ts.lowerLeftU, ts.lowerLeftV, ts.usize, ts.vsize);
      gl.viewport(ts.lowerLeftU, ts.lowerLeftV, ts.usize, ts.vsize);
      gl.colorMask(true, true, true, true);
      if (clearMask) {
        gl.clear(clearMask);
      }
      gl.enable(gl.DEPTH_TEST);
    }
  };
  publicAPI.opaqueZBufferPass = (prepass) => publicAPI.zBufferPass(prepass);
  publicAPI.cameraPass = (prepass) => {
    if (prepass) {
      publicAPI.clear();
    }
  };
  publicAPI.getAspectRatio = () => {
    const size3 = model._parent.getSizeByReference();
    const viewport = model.renderable.getViewportByReference();
    return size3[0] * (viewport[2] - viewport[0]) / ((viewport[3] - viewport[1]) * size3[1]);
  };
  publicAPI.getTiledSizeAndOrigin = () => {
    const vport = model.renderable.getViewportByReference();
    const tileViewPort = [0, 0, 1, 1];
    const vpu = vport[0] - tileViewPort[0];
    const vpv = vport[1] - tileViewPort[1];
    const ndvp = model._parent.normalizedDisplayToDisplay(vpu, vpv);
    const lowerLeftU = Math.round(ndvp[0]);
    const lowerLeftV = Math.round(ndvp[1]);
    const vpu2 = vport[2] - tileViewPort[0];
    const vpv2 = vport[3] - tileViewPort[1];
    const ndvp2 = model._parent.normalizedDisplayToDisplay(vpu2, vpv2);
    let usize = Math.round(ndvp2[0]) - lowerLeftU;
    let vsize = Math.round(ndvp2[1]) - lowerLeftV;
    if (usize < 0) {
      usize = 0;
    }
    if (vsize < 0) {
      vsize = 0;
    }
    return {
      usize,
      vsize,
      lowerLeftU,
      lowerLeftV
    };
  };
  publicAPI.clear = () => {
    let clearMask = 0;
    const gl = model.context;
    if (!model.renderable.getTransparent()) {
      const background = model.renderable.getBackgroundByReference();
      gl.clearColor(background[0], background[1], background[2], background[3]);
      clearMask |= gl.COLOR_BUFFER_BIT;
    }
    if (!model.renderable.getPreserveDepthBuffer()) {
      gl.clearDepth(1);
      clearMask |= gl.DEPTH_BUFFER_BIT;
      gl.depthMask(true);
    }
    gl.colorMask(true, true, true, true);
    const ts = publicAPI.getTiledSizeAndOrigin();
    gl.enable(gl.SCISSOR_TEST);
    gl.scissor(ts.lowerLeftU, ts.lowerLeftV, ts.usize, ts.vsize);
    gl.viewport(ts.lowerLeftU, ts.lowerLeftV, ts.usize, ts.vsize);
    if (clearMask) {
      gl.clear(clearMask);
    }
    gl.enable(gl.DEPTH_TEST);
  };
  publicAPI.releaseGraphicsResources = () => {
    if (model.selector !== null) {
      model.selector.releaseGraphicsResources();
    }
    if (model.renderable) {
      model.renderable.getViewProps().forEach((prop) => {
        prop.modified();
      });
    }
  };
  publicAPI.setOpenGLRenderWindow = (rw) => {
    if (model._openGLRenderWindow === rw) {
      return;
    }
    publicAPI.releaseGraphicsResources();
    model._openGLRenderWindow = rw;
    model.context = null;
    if (rw) {
      model.context = model._openGLRenderWindow.getContext();
    }
  };
}
var DEFAULT_VALUES5 = {
  context: null,
  _openGLRenderWindow: null,
  selector: null
};
function extend5(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES5, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  get(publicAPI, model, ["shaderCache"]);
  setGet(publicAPI, model, ["selector"]);
  moveToProtected(publicAPI, model, ["openGLRenderWindow"]);
  vtkOpenGLRenderer(publicAPI, model);
}
var newInstance6 = newInstance(extend5, "vtkOpenGLRenderer");
registerOverride("vtkRenderer", newInstance6);

// node_modules/@kitware/vtk.js/Common/Core/DataArray/Constants.js
var DataTypeByteSize = {
  Int8Array: 1,
  Uint8Array: 1,
  Uint8ClampedArray: 1,
  Int16Array: 2,
  Uint16Array: 2,
  Int32Array: 4,
  Uint32Array: 4,
  Float32Array: 4,
  Float64Array: 8
};
var VtkDataTypes = {
  VOID: "",
  // not sure to know what that should be
  CHAR: "Int8Array",
  SIGNED_CHAR: "Int8Array",
  UNSIGNED_CHAR: "Uint8Array",
  UNSIGNED_CHAR_CLAMPED: "Uint8ClampedArray",
  // should be used for VTK.js internal purpose only
  SHORT: "Int16Array",
  UNSIGNED_SHORT: "Uint16Array",
  INT: "Int32Array",
  UNSIGNED_INT: "Uint32Array",
  FLOAT: "Float32Array",
  DOUBLE: "Float64Array"
};
var DefaultDataType = VtkDataTypes.FLOAT;
var Constants = {
  DefaultDataType,
  DataTypeByteSize,
  VtkDataTypes
};

// node_modules/@kitware/vtk.js/Common/Core/Math/index.js
var import_seedrandom = __toESM(require_seedrandom2());

// node_modules/@kitware/vtk.js/Common/Core/Math/Constants.js
var IDENTITY = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
var IDENTITY_3X3 = [1, 0, 0, 0, 1, 0, 0, 0, 1];
var EPSILON2 = 1e-6;
var VTK_SMALL_NUMBER = 1e-12;

// node_modules/@kitware/vtk.js/Common/Core/Math/index.js
var {
  vtkErrorMacro: vtkErrorMacro4,
  vtkWarningMacro: vtkWarningMacro2
} = macro;
var randomSeedValue = 0;
var VTK_MAX_ROTATIONS = 20;
function notImplemented(method) {
  return () => vtkErrorMacro4(`vtkMath::${method} - NOT IMPLEMENTED`);
}
function swapRowsMatrix_nxn(matrix, n9, row1, row2) {
  let tmp;
  for (let i6 = 0; i6 < n9; i6++) {
    tmp = matrix[row1 * n9 + i6];
    matrix[row1 * n9 + i6] = matrix[row2 * n9 + i6];
    matrix[row2 * n9 + i6] = tmp;
  }
}
function swapColumnsMatrix_nxn(matrix, n9, column1, column2) {
  let tmp;
  for (let i6 = 0; i6 < n9; i6++) {
    tmp = matrix[i6 * n9 + column1];
    matrix[i6 * n9 + column1] = matrix[i6 * n9 + column2];
    matrix[i6 * n9 + column2] = tmp;
  }
}
function createArray() {
  let size3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 3;
  const res = Array(size3);
  for (let i6 = 0; i6 < size3; ++i6) {
    res[i6] = 0;
  }
  return res;
}
var Pi = () => Math.PI;
function radiansFromDegrees(deg) {
  return deg / 180 * Math.PI;
}
function degreesFromRadians(rad) {
  return rad * 180 / Math.PI;
}
var {
  round: round4,
  floor: floor4,
  ceil: ceil3,
  min: min4,
  max: max4
} = Math;
function arrayMin(arr) {
  let offset3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  let stride = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
  let minValue = Infinity;
  for (let i6 = offset3, len4 = arr.length; i6 < len4; i6 += stride) {
    if (arr[i6] < minValue) {
      minValue = arr[i6];
    }
  }
  return minValue;
}
function arrayMax(arr) {
  let offset3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  let stride = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
  let maxValue = -Infinity;
  for (let i6 = offset3, len4 = arr.length; i6 < len4; i6 += stride) {
    if (maxValue < arr[i6]) {
      maxValue = arr[i6];
    }
  }
  return maxValue;
}
function arrayRange(arr) {
  let offset3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  let stride = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
  let minValue = Infinity;
  let maxValue = -Infinity;
  for (let i6 = offset3, len4 = arr.length; i6 < len4; i6 += stride) {
    if (arr[i6] < minValue) {
      minValue = arr[i6];
    }
    if (maxValue < arr[i6]) {
      maxValue = arr[i6];
    }
  }
  return [minValue, maxValue];
}
var ceilLog2 = notImplemented("ceilLog2");
var factorial = notImplemented("factorial");
function nearestPowerOfTwo(xi) {
  let v2 = 1;
  while (v2 < xi) {
    v2 *= 2;
  }
  return v2;
}
function isPowerOfTwo(x2) {
  return x2 === nearestPowerOfTwo(x2);
}
function binomial(m3, n9) {
  let r9 = 1;
  for (let i6 = 1; i6 <= n9; ++i6) {
    r9 *= (m3 - i6 + 1) / i6;
  }
  return Math.floor(r9);
}
function beginCombination(m3, n9) {
  if (m3 < n9) {
    return 0;
  }
  const r9 = createArray(n9);
  for (let i6 = 0; i6 < n9; ++i6) {
    r9[i6] = i6;
  }
  return r9;
}
function nextCombination(m3, n9, r9) {
  let status = 0;
  for (let i6 = n9 - 1; i6 >= 0; --i6) {
    if (r9[i6] < m3 - n9 + i6) {
      let j2 = r9[i6] + 1;
      while (i6 < n9) {
        r9[i6++] = j2++;
      }
      status = 1;
      break;
    }
  }
  return status;
}
function randomSeed(seed) {
  (0, import_seedrandom.default)(`${seed}`, {
    global: true
  });
  randomSeedValue = seed;
}
function getSeed() {
  return randomSeedValue;
}
function random4() {
  let minValue = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
  let maxValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  const delta = maxValue - minValue;
  return minValue + delta * Math.random();
}
var gaussian = notImplemented("gaussian");
function add6(a4, b3, out) {
  out[0] = a4[0] + b3[0];
  out[1] = a4[1] + b3[1];
  out[2] = a4[2] + b3[2];
  return out;
}
function subtract5(a4, b3, out) {
  out[0] = a4[0] - b3[0];
  out[1] = a4[1] - b3[1];
  out[2] = a4[2] - b3[2];
  return out;
}
function multiplyScalar3(vec, scalar) {
  vec[0] *= scalar;
  vec[1] *= scalar;
  vec[2] *= scalar;
  return vec;
}
function multiplyScalar2D(vec, scalar) {
  vec[0] *= scalar;
  vec[1] *= scalar;
  return vec;
}
function multiplyAccumulate(a4, b3, scalar, out) {
  out[0] = a4[0] + b3[0] * scalar;
  out[1] = a4[1] + b3[1] * scalar;
  out[2] = a4[2] + b3[2] * scalar;
  return out;
}
function multiplyAccumulate2D(a4, b3, scalar, out) {
  out[0] = a4[0] + b3[0] * scalar;
  out[1] = a4[1] + b3[1] * scalar;
  return out;
}
function dot4(x2, y3) {
  return x2[0] * y3[0] + x2[1] * y3[1] + x2[2] * y3[2];
}
function outer(x2, y3, out_3x3) {
  out_3x3[0] = x2[0] * y3[0];
  out_3x3[1] = x2[0] * y3[1];
  out_3x3[2] = x2[0] * y3[2];
  out_3x3[3] = x2[1] * y3[0];
  out_3x3[4] = x2[1] * y3[1];
  out_3x3[5] = x2[1] * y3[2];
  out_3x3[6] = x2[2] * y3[0];
  out_3x3[7] = x2[2] * y3[1];
  out_3x3[8] = x2[2] * y3[2];
}
function cross3(x2, y3, out) {
  const Zx = x2[1] * y3[2] - x2[2] * y3[1];
  const Zy = x2[2] * y3[0] - x2[0] * y3[2];
  const Zz = x2[0] * y3[1] - x2[1] * y3[0];
  out[0] = Zx;
  out[1] = Zy;
  out[2] = Zz;
  return out;
}
function norm(x2) {
  let n9 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 3;
  switch (n9) {
    case 1:
      return Math.abs(x2);
    case 2:
      return Math.sqrt(x2[0] * x2[0] + x2[1] * x2[1]);
    case 3:
      return Math.sqrt(x2[0] * x2[0] + x2[1] * x2[1] + x2[2] * x2[2]);
    default: {
      let sum = 0;
      for (let i6 = 0; i6 < n9; i6++) {
        sum += x2[i6] * x2[i6];
      }
      return Math.sqrt(sum);
    }
  }
}
function normalize4(x2) {
  const den = norm(x2);
  if (den !== 0) {
    x2[0] /= den;
    x2[1] /= den;
    x2[2] /= den;
  }
  return den;
}
function perpendiculars(x2, y3, z3, theta) {
  const x22 = x2[0] * x2[0];
  const y22 = x2[1] * x2[1];
  const z22 = x2[2] * x2[2];
  const r9 = Math.sqrt(x22 + y22 + z22);
  let dx;
  let dy;
  let dz;
  if (x22 > y22 && x22 > z22) {
    dx = 0;
    dy = 1;
    dz = 2;
  } else if (y22 > z22) {
    dx = 1;
    dy = 2;
    dz = 0;
  } else {
    dx = 2;
    dy = 0;
    dz = 1;
  }
  const a4 = x2[dx] / r9;
  const b3 = x2[dy] / r9;
  const c6 = x2[dz] / r9;
  const tmp = Math.sqrt(a4 * a4 + c6 * c6);
  if (theta !== 0) {
    const sintheta = Math.sin(theta);
    const costheta = Math.cos(theta);
    if (y3) {
      y3[dx] = (c6 * costheta - a4 * b3 * sintheta) / tmp;
      y3[dy] = sintheta * tmp;
      y3[dz] = (-(a4 * costheta) - b3 * c6 * sintheta) / tmp;
    }
    if (z3) {
      z3[dx] = (-(c6 * sintheta) - a4 * b3 * costheta) / tmp;
      z3[dy] = costheta * tmp;
      z3[dz] = (a4 * sintheta - b3 * c6 * costheta) / tmp;
    }
  } else {
    if (y3) {
      y3[dx] = c6 / tmp;
      y3[dy] = 0;
      y3[dz] = -a4 / tmp;
    }
    if (z3) {
      z3[dx] = -a4 * b3 / tmp;
      z3[dy] = tmp;
      z3[dz] = -b3 * c6 / tmp;
    }
  }
}
function projectVector(a4, b3, projection2) {
  const bSquared = dot4(b3, b3);
  if (bSquared === 0) {
    projection2[0] = 0;
    projection2[1] = 0;
    projection2[2] = 0;
    return false;
  }
  const scale7 = dot4(a4, b3) / bSquared;
  for (let i6 = 0; i6 < 3; i6++) {
    projection2[i6] = b3[i6];
  }
  multiplyScalar3(projection2, scale7);
  return true;
}
function dot2D(x2, y3) {
  return x2[0] * y3[0] + x2[1] * y3[1];
}
function projectVector2D(a4, b3, projection2) {
  const bSquared = dot2D(b3, b3);
  if (bSquared === 0) {
    projection2[0] = 0;
    projection2[1] = 0;
    return false;
  }
  const scale7 = dot2D(a4, b3) / bSquared;
  for (let i6 = 0; i6 < 2; i6++) {
    projection2[i6] = b3[i6];
  }
  multiplyScalar2D(projection2, scale7);
  return true;
}
function distance2BetweenPoints(x2, y3) {
  return (x2[0] - y3[0]) * (x2[0] - y3[0]) + (x2[1] - y3[1]) * (x2[1] - y3[1]) + (x2[2] - y3[2]) * (x2[2] - y3[2]);
}
function angleBetweenVectors(v1, v2) {
  const crossVect = [0, 0, 0];
  cross3(v1, v2, crossVect);
  return Math.atan2(norm(crossVect), dot4(v1, v2));
}
function gaussianAmplitude(mean, variance, position) {
  const distanceFromMean = Math.abs(mean - position);
  return 1 / Math.sqrt(2 * Math.PI * variance) * Math.exp(-__pow(distanceFromMean, 2) / (2 * variance));
}
function gaussianWeight(mean, variance, position) {
  const distanceFromMean = Math.abs(mean - position);
  return Math.exp(-__pow(distanceFromMean, 2) / (2 * variance));
}
function outer2D(x2, y3, out_2x2) {
  out_2x2[0] = x2[0] * y3[0];
  out_2x2[1] = x2[0] * y3[1];
  out_2x2[2] = x2[1] * y3[0];
  out_2x2[3] = x2[1] * y3[1];
}
function norm2D(x2D) {
  return Math.sqrt(x2D[0] * x2D[0] + x2D[1] * x2D[1]);
}
function normalize2D(x2) {
  const den = norm2D(x2);
  if (den !== 0) {
    x2[0] /= den;
    x2[1] /= den;
  }
  return den;
}
function determinant2x2() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  if (args.length === 2) {
    return args[0][0] * args[1][1] - args[1][0] * args[0][1];
  }
  if (args.length === 4) {
    return args[0] * args[3] - args[1] * args[2];
  }
  return Number.NaN;
}
function LUFactor3x3(mat_3x3, index_3) {
  let maxI;
  let tmp;
  let largest;
  const scale7 = [0, 0, 0];
  for (let i6 = 0; i6 < 3; i6++) {
    largest = Math.abs(mat_3x3[i6 * 3]);
    if ((tmp = Math.abs(mat_3x3[i6 * 3 + 1])) > largest) {
      largest = tmp;
    }
    if ((tmp = Math.abs(mat_3x3[i6 * 3 + 2])) > largest) {
      largest = tmp;
    }
    scale7[i6] = 1 / largest;
  }
  largest = scale7[0] * Math.abs(mat_3x3[0]);
  maxI = 0;
  if ((tmp = scale7[1] * Math.abs(mat_3x3[3])) >= largest) {
    largest = tmp;
    maxI = 1;
  }
  if ((tmp = scale7[2] * Math.abs(mat_3x3[6])) >= largest) {
    maxI = 2;
  }
  if (maxI !== 0) {
    swapRowsMatrix_nxn(mat_3x3, 3, maxI, 0);
    scale7[maxI] = scale7[0];
  }
  index_3[0] = maxI;
  mat_3x3[3] /= mat_3x3[0];
  mat_3x3[6] /= mat_3x3[0];
  mat_3x3[4] -= mat_3x3[3] * mat_3x3[1];
  mat_3x3[7] -= mat_3x3[6] * mat_3x3[1];
  largest = scale7[1] * Math.abs(mat_3x3[4]);
  maxI = 1;
  if ((tmp = scale7[2] * Math.abs(mat_3x3[7])) >= largest) {
    maxI = 2;
    swapRowsMatrix_nxn(mat_3x3, 3, 1, 2);
    scale7[2] = scale7[1];
  }
  index_3[1] = maxI;
  mat_3x3[7] /= mat_3x3[4];
  mat_3x3[5] -= mat_3x3[3] * mat_3x3[2];
  mat_3x3[8] -= mat_3x3[6] * mat_3x3[2] + mat_3x3[7] * mat_3x3[5];
  index_3[2] = 2;
}
function LUSolve3x3(mat_3x3, index_3, x_3) {
  let sum = x_3[index_3[0]];
  x_3[index_3[0]] = x_3[0];
  x_3[0] = sum;
  sum = x_3[index_3[1]];
  x_3[index_3[1]] = x_3[1];
  x_3[1] = sum - mat_3x3[3] * x_3[0];
  sum = x_3[index_3[2]];
  x_3[index_3[2]] = x_3[2];
  x_3[2] = sum - mat_3x3[6] * x_3[0] - mat_3x3[7] * x_3[1];
  x_3[2] /= mat_3x3[8];
  x_3[1] = (x_3[1] - mat_3x3[5] * x_3[2]) / mat_3x3[4];
  x_3[0] = (x_3[0] - mat_3x3[1] * x_3[1] - mat_3x3[2] * x_3[2]) / mat_3x3[0];
}
function linearSolve3x3(mat_3x3, x_3, y_3) {
  const a1 = mat_3x3[0];
  const b1 = mat_3x3[1];
  const c1 = mat_3x3[2];
  const a22 = mat_3x3[3];
  const b22 = mat_3x3[4];
  const c22 = mat_3x3[5];
  const a32 = mat_3x3[6];
  const b3 = mat_3x3[7];
  const c32 = mat_3x3[8];
  const d1 = +determinant2x2(b22, b3, c22, c32);
  const d22 = -determinant2x2(a22, a32, c22, c32);
  const d3 = +determinant2x2(a22, a32, b22, b3);
  const e1 = -determinant2x2(b1, b3, c1, c32);
  const e22 = +determinant2x2(a1, a32, c1, c32);
  const e32 = -determinant2x2(a1, a32, b1, b3);
  const f1 = +determinant2x2(b1, b22, c1, c22);
  const f22 = -determinant2x2(a1, a22, c1, c22);
  const f32 = +determinant2x2(a1, a22, b1, b22);
  const det = a1 * d1 + b1 * d22 + c1 * d3;
  const v1 = d1 * x_3[0] + e1 * x_3[1] + f1 * x_3[2];
  const v2 = d22 * x_3[0] + e22 * x_3[1] + f22 * x_3[2];
  const v3 = d3 * x_3[0] + e32 * x_3[1] + f32 * x_3[2];
  y_3[0] = v1 / det;
  y_3[1] = v2 / det;
  y_3[2] = v3 / det;
}
function multiply3x3_vect3(mat_3x3, in_3, out_3) {
  const x2 = mat_3x3[0] * in_3[0] + mat_3x3[1] * in_3[1] + mat_3x3[2] * in_3[2];
  const y3 = mat_3x3[3] * in_3[0] + mat_3x3[4] * in_3[1] + mat_3x3[5] * in_3[2];
  const z3 = mat_3x3[6] * in_3[0] + mat_3x3[7] * in_3[1] + mat_3x3[8] * in_3[2];
  out_3[0] = x2;
  out_3[1] = y3;
  out_3[2] = z3;
}
function multiply3x3_mat3(a_3x3, b_3x3, out_3x3) {
  const copyA = [...a_3x3];
  const copyB = [...b_3x3];
  for (let i6 = 0; i6 < 3; i6++) {
    out_3x3[i6] = copyA[0] * copyB[i6] + copyA[1] * copyB[i6 + 3] + copyA[2] * copyB[i6 + 6];
    out_3x3[i6 + 3] = copyA[3] * copyB[i6] + copyA[4] * copyB[i6 + 3] + copyA[5] * copyB[i6 + 6];
    out_3x3[i6 + 6] = copyA[6] * copyB[i6] + copyA[7] * copyB[i6 + 3] + copyA[8] * copyB[i6 + 6];
  }
}
function multiplyMatrix(a4, b3, rowA, colA, rowB, colB, outRowAColB) {
  if (colA !== rowB) {
    vtkErrorMacro4("Number of columns of A must match number of rows of B.");
  }
  const copyA = [...a4];
  const copyB = [...b3];
  for (let i6 = 0; i6 < rowA; i6++) {
    for (let j2 = 0; j2 < colB; j2++) {
      outRowAColB[i6 * colB + j2] = 0;
      for (let k2 = 0; k2 < colA; k2++) {
        outRowAColB[i6 * colB + j2] += copyA[i6 * colA + k2] * copyB[j2 + colB * k2];
      }
    }
  }
}
function transpose3x3(in_3x3, outT_3x3) {
  let tmp;
  tmp = in_3x3[3];
  outT_3x3[3] = in_3x3[1];
  outT_3x3[1] = tmp;
  tmp = in_3x3[6];
  outT_3x3[6] = in_3x3[2];
  outT_3x3[2] = tmp;
  tmp = in_3x3[7];
  outT_3x3[7] = in_3x3[5];
  outT_3x3[5] = tmp;
  outT_3x3[0] = in_3x3[0];
  outT_3x3[4] = in_3x3[4];
  outT_3x3[8] = in_3x3[8];
}
function invert3x3(in_3x3, outI_3x3) {
  const a1 = in_3x3[0];
  const b1 = in_3x3[1];
  const c1 = in_3x3[2];
  const a22 = in_3x3[3];
  const b22 = in_3x3[4];
  const c22 = in_3x3[5];
  const a32 = in_3x3[6];
  const b3 = in_3x3[7];
  const c32 = in_3x3[8];
  const d1 = +determinant2x2(b22, b3, c22, c32);
  const d22 = -determinant2x2(a22, a32, c22, c32);
  const d3 = +determinant2x2(a22, a32, b22, b3);
  const e1 = -determinant2x2(b1, b3, c1, c32);
  const e22 = +determinant2x2(a1, a32, c1, c32);
  const e32 = -determinant2x2(a1, a32, b1, b3);
  const f1 = +determinant2x2(b1, b22, c1, c22);
  const f22 = -determinant2x2(a1, a22, c1, c22);
  const f32 = +determinant2x2(a1, a22, b1, b22);
  const det = a1 * d1 + b1 * d22 + c1 * d3;
  if (det === 0) {
    vtkWarningMacro2("Matrix has 0 determinant");
  }
  outI_3x3[0] = d1 / det;
  outI_3x3[3] = d22 / det;
  outI_3x3[6] = d3 / det;
  outI_3x3[1] = e1 / det;
  outI_3x3[4] = e22 / det;
  outI_3x3[7] = e32 / det;
  outI_3x3[2] = f1 / det;
  outI_3x3[5] = f22 / det;
  outI_3x3[8] = f32 / det;
}
function determinant3x3(mat_3x3) {
  return mat_3x3[0] * mat_3x3[4] * mat_3x3[8] + mat_3x3[3] * mat_3x3[7] * mat_3x3[2] + mat_3x3[6] * mat_3x3[1] * mat_3x3[5] - mat_3x3[0] * mat_3x3[7] * mat_3x3[5] - mat_3x3[3] * mat_3x3[1] * mat_3x3[8] - mat_3x3[6] * mat_3x3[4] * mat_3x3[2];
}
function areEquals(a4, b3) {
  let eps = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : EPSILON2;
  if (a4.length !== b3.length) {
    return false;
  }
  function isEqual(element, index2) {
    return Math.abs(element - b3[index2]) <= eps;
  }
  return a4.every(isEqual);
}
var areMatricesEqual = areEquals;
function identity3x3(mat_3x3) {
  for (let i6 = 0; i6 < 3; i6++) {
    mat_3x3[i6 * 3] = mat_3x3[i6 * 3 + 1] = mat_3x3[i6 * 3 + 2] = 0;
    mat_3x3[i6 * 3 + i6] = 1;
  }
}
function identity4(n9, mat) {
  for (let i6 = 0; i6 < n9; i6++) {
    for (let j2 = 0; j2 < n9; j2++) {
      mat[i6 * n9 + j2] = 0;
    }
    mat[i6 * n9 + i6] = 1;
  }
  return mat;
}
function isIdentity(mat) {
  let eps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : EPSILON2;
  return areMatricesEqual(mat, IDENTITY, eps);
}
function isIdentity3x3(mat) {
  let eps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : EPSILON2;
  return areMatricesEqual(mat, IDENTITY_3X3, eps);
}
function quaternionToMatrix3x3(quat_4, mat_3x3) {
  const ww = quat_4[0] * quat_4[0];
  const wx = quat_4[0] * quat_4[1];
  const wy = quat_4[0] * quat_4[2];
  const wz = quat_4[0] * quat_4[3];
  const xx = quat_4[1] * quat_4[1];
  const yy = quat_4[2] * quat_4[2];
  const zz = quat_4[3] * quat_4[3];
  const xy = quat_4[1] * quat_4[2];
  const xz = quat_4[1] * quat_4[3];
  const yz = quat_4[2] * quat_4[3];
  const rr = xx + yy + zz;
  let f5 = 1 / (ww + rr);
  const s9 = (ww - rr) * f5;
  f5 *= 2;
  mat_3x3[0] = xx * f5 + s9;
  mat_3x3[3] = (xy + wz) * f5;
  mat_3x3[6] = (xz - wy) * f5;
  mat_3x3[1] = (xy - wz) * f5;
  mat_3x3[4] = yy * f5 + s9;
  mat_3x3[7] = (yz + wx) * f5;
  mat_3x3[2] = (xz + wy) * f5;
  mat_3x3[5] = (yz - wx) * f5;
  mat_3x3[8] = zz * f5 + s9;
}
function roundNumber(num) {
  let digits = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  if (!`${num}`.includes("e")) {
    return +`${Math.round(`${num}e+${digits}`)}e-${digits}`;
  }
  const arr = `${num}`.split("e");
  let sig = "";
  if (+arr[1] + digits > 0) {
    sig = "+";
  }
  return +`${Math.round(`${+arr[0]}e${sig}${+arr[1] + digits}`)}e-${digits}`;
}
function roundVector(vector) {
  let out = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];
  let digits = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  out[0] = roundNumber(vector[0], digits);
  out[1] = roundNumber(vector[1], digits);
  out[2] = roundNumber(vector[2], digits);
  return out;
}
function jacobiN(a4, n9, w2, v2) {
  let i6;
  let j2;
  let k2;
  let iq;
  let ip;
  let numPos;
  let tresh;
  let theta;
  let t9;
  let tau;
  let sm;
  let s9;
  let h5;
  let g2;
  let c6;
  let tmp;
  const b3 = createArray(n9);
  const z3 = createArray(n9);
  const vtkROTATE = (aa, ii, jj) => {
    g2 = aa[ii];
    h5 = aa[jj];
    aa[ii] = g2 - s9 * (h5 + g2 * tau);
    aa[jj] = h5 + s9 * (g2 - h5 * tau);
  };
  identity4(n9, v2);
  for (ip = 0; ip < n9; ip++) {
    b3[ip] = w2[ip] = a4[ip + ip * n9];
    z3[ip] = 0;
  }
  for (i6 = 0; i6 < VTK_MAX_ROTATIONS; i6++) {
    sm = 0;
    for (ip = 0; ip < n9 - 1; ip++) {
      for (iq = ip + 1; iq < n9; iq++) {
        sm += Math.abs(a4[ip * n9 + iq]);
      }
    }
    if (sm === 0) {
      break;
    }
    if (i6 < 3) {
      tresh = 0.2 * sm / (n9 * n9);
    } else {
      tresh = 0;
    }
    for (ip = 0; ip < n9 - 1; ip++) {
      for (iq = ip + 1; iq < n9; iq++) {
        g2 = 100 * Math.abs(a4[ip * n9 + iq]);
        if (i6 > 3 && Math.abs(w2[ip]) + g2 === Math.abs(w2[ip]) && Math.abs(w2[iq]) + g2 === Math.abs(w2[iq])) {
          a4[ip * n9 + iq] = 0;
        } else if (Math.abs(a4[ip * n9 + iq]) > tresh) {
          h5 = w2[iq] - w2[ip];
          if (Math.abs(h5) + g2 === Math.abs(h5)) {
            t9 = a4[ip * n9 + iq] / h5;
          } else {
            theta = 0.5 * h5 / a4[ip * n9 + iq];
            t9 = 1 / (Math.abs(theta) + Math.sqrt(1 + theta * theta));
            if (theta < 0) {
              t9 = -t9;
            }
          }
          c6 = 1 / Math.sqrt(1 + t9 * t9);
          s9 = t9 * c6;
          tau = s9 / (1 + c6);
          h5 = t9 * a4[ip * n9 + iq];
          z3[ip] -= h5;
          z3[iq] += h5;
          w2[ip] -= h5;
          w2[iq] += h5;
          a4[ip * n9 + iq] = 0;
          for (j2 = 0; j2 <= ip - 1; j2++) {
            vtkROTATE(a4, j2 * n9 + ip, j2 * n9 + iq);
          }
          for (j2 = ip + 1; j2 <= iq - 1; j2++) {
            vtkROTATE(a4, ip * n9 + j2, j2 * n9 + iq);
          }
          for (j2 = iq + 1; j2 < n9; j2++) {
            vtkROTATE(a4, ip * n9 + j2, iq * n9 + j2);
          }
          for (j2 = 0; j2 < n9; j2++) {
            vtkROTATE(v2, j2 * n9 + ip, j2 * n9 + iq);
          }
        }
      }
    }
    for (ip = 0; ip < n9; ip++) {
      b3[ip] += z3[ip];
      w2[ip] = b3[ip];
      z3[ip] = 0;
    }
  }
  if (i6 >= VTK_MAX_ROTATIONS) {
    vtkWarningMacro2("vtkMath::Jacobi: Error extracting eigenfunctions");
    return 0;
  }
  for (j2 = 0; j2 < n9 - 1; j2++) {
    k2 = j2;
    tmp = w2[k2];
    for (i6 = j2 + 1; i6 < n9; i6++) {
      if (w2[i6] >= tmp || Math.abs(w2[i6] - tmp) < VTK_SMALL_NUMBER) {
        k2 = i6;
        tmp = w2[k2];
      }
    }
    if (k2 !== j2) {
      w2[k2] = w2[j2];
      w2[j2] = tmp;
      swapColumnsMatrix_nxn(v2, n9, j2, k2);
    }
  }
  const ceil_half_n = (n9 >> 1) + (n9 & 1);
  for (numPos = 0, i6 = 0; i6 < n9 * n9; i6++) {
    if (v2[i6] >= 0) {
      numPos++;
    }
  }
  if (numPos < ceil_half_n) {
    for (i6 = 0; i6 < n9; i6++) {
      v2[i6 * n9 + j2] *= -1;
    }
  }
  return 1;
}
function matrix3x3ToQuaternion(mat_3x3, quat_4) {
  const tmp = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  tmp[0] = mat_3x3[0] + mat_3x3[4] + mat_3x3[8];
  tmp[5] = mat_3x3[0] - mat_3x3[4] - mat_3x3[8];
  tmp[10] = -mat_3x3[0] + mat_3x3[4] - mat_3x3[8];
  tmp[15] = -mat_3x3[0] - mat_3x3[4] + mat_3x3[8];
  tmp[1] = tmp[4] = mat_3x3[7] - mat_3x3[5];
  tmp[2] = tmp[8] = mat_3x3[2] - mat_3x3[6];
  tmp[3] = tmp[12] = mat_3x3[3] - mat_3x3[1];
  tmp[6] = tmp[9] = mat_3x3[3] + mat_3x3[1];
  tmp[7] = tmp[13] = mat_3x3[2] + mat_3x3[6];
  tmp[11] = tmp[14] = mat_3x3[7] + mat_3x3[5];
  const eigenvectors = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  const eigenvalues = [0, 0, 0, 0];
  const NTemp = [...tmp];
  jacobiN(NTemp, 4, eigenvalues, eigenvectors);
  quat_4[0] = eigenvectors[0];
  quat_4[1] = eigenvectors[4];
  quat_4[2] = eigenvectors[8];
  quat_4[3] = eigenvectors[12];
}
function multiplyQuaternion(quat_1, quat_2, quat_out) {
  const ww = quat_1[0] * quat_2[0];
  const wx = quat_1[0] * quat_2[1];
  const wy = quat_1[0] * quat_2[2];
  const wz = quat_1[0] * quat_2[3];
  const xw = quat_1[1] * quat_2[0];
  const xx = quat_1[1] * quat_2[1];
  const xy = quat_1[1] * quat_2[2];
  const xz = quat_1[1] * quat_2[3];
  const yw = quat_1[2] * quat_2[0];
  const yx = quat_1[2] * quat_2[1];
  const yy = quat_1[2] * quat_2[2];
  const yz = quat_1[2] * quat_2[3];
  const zw = quat_1[3] * quat_2[0];
  const zx = quat_1[3] * quat_2[1];
  const zy = quat_1[3] * quat_2[2];
  const zz = quat_1[3] * quat_2[3];
  quat_out[0] = ww - xx - yy - zz;
  quat_out[1] = wx + xw + yz - zy;
  quat_out[2] = wy - xz + yw + zx;
  quat_out[3] = wz + xy - yx + zw;
}
function orthogonalize3x3(a_3x3, out_3x3) {
  for (let i6 = 0; i6 < 9; i6++) {
    out_3x3[i6] = a_3x3[i6];
  }
  const scale7 = createArray(3);
  const index2 = createArray(3);
  let largest;
  for (let i6 = 0; i6 < 3; i6++) {
    const x12 = Math.abs(out_3x3[i6 * 3]);
    const x22 = Math.abs(out_3x3[i6 * 3 + 1]);
    const x32 = Math.abs(out_3x3[i6 * 3 + 2]);
    largest = x22 > x12 ? x22 : x12;
    largest = x32 > largest ? x32 : largest;
    scale7[i6] = 1;
    if (largest !== 0) {
      scale7[i6] /= largest;
    }
  }
  const x1 = Math.abs(out_3x3[0]) * scale7[0];
  const x2 = Math.abs(out_3x3[3]) * scale7[1];
  const x3 = Math.abs(out_3x3[6]) * scale7[2];
  index2[0] = 0;
  largest = x1;
  if (x2 >= largest) {
    largest = x2;
    index2[0] = 1;
  }
  if (x3 >= largest) {
    index2[0] = 2;
  }
  if (index2[0] !== 0) {
    swapColumnsMatrix_nxn(out_3x3, 3, index2[0], 0);
    scale7[index2[0]] = scale7[0];
  }
  const y22 = Math.abs(out_3x3[4]) * scale7[1];
  const y3 = Math.abs(out_3x3[7]) * scale7[2];
  index2[1] = 1;
  largest = y22;
  if (y3 >= largest) {
    index2[1] = 2;
    swapColumnsMatrix_nxn(out_3x3, 3, 1, 2);
  }
  index2[2] = 2;
  let flip3 = 0;
  if (determinant3x3(out_3x3) < 0) {
    flip3 = 1;
    for (let i6 = 0; i6 < 9; i6++) {
      out_3x3[i6] = -out_3x3[i6];
    }
  }
  const quat2 = createArray(4);
  matrix3x3ToQuaternion(out_3x3, quat2);
  quaternionToMatrix3x3(quat2, out_3x3);
  if (flip3) {
    for (let i6 = 0; i6 < 9; i6++) {
      out_3x3[i6] = -out_3x3[i6];
    }
  }
  if (index2[1] !== 1) {
    swapColumnsMatrix_nxn(out_3x3, 3, index2[1], 1);
  }
  if (index2[0] !== 0) {
    swapColumnsMatrix_nxn(out_3x3, 3, index2[0], 0);
  }
}
function diagonalize3x3(a_3x3, w_3, v_3x3) {
  let i6;
  let j2;
  let k2;
  let maxI;
  let tmp;
  let maxVal;
  const copyA = [...a_3x3];
  jacobiN(copyA, 3, w_3, v_3x3);
  if (w_3[0] === w_3[1] && w_3[0] === w_3[2]) {
    identity3x3(v_3x3);
    return;
  }
  transpose3x3(v_3x3, v_3x3);
  for (i6 = 0; i6 < 3; i6++) {
    if (w_3[(i6 + 1) % 3] === w_3[(i6 + 2) % 3]) {
      maxVal = Math.abs(v_3x3[i6 * 3]);
      maxI = 0;
      for (j2 = 1; j2 < 3; j2++) {
        if (maxVal < (tmp = Math.abs(v_3x3[i6 * 3 + j2]))) {
          maxVal = tmp;
          maxI = j2;
        }
      }
      if (maxI !== i6) {
        tmp = w_3[maxI];
        w_3[maxI] = w_3[i6];
        w_3[i6] = tmp;
        swapRowsMatrix_nxn(v_3x3, 3, i6, maxI);
      }
      if (v_3x3[maxI * 3 + maxI] < 0) {
        v_3x3[maxI * 3] = -v_3x3[maxI * 3];
        v_3x3[maxI * 3 + 1] = -v_3x3[maxI * 3 + 1];
        v_3x3[maxI * 3 + 2] = -v_3x3[maxI * 3 + 2];
      }
      j2 = (maxI + 1) % 3;
      k2 = (maxI + 2) % 3;
      v_3x3[j2 * 3] = 0;
      v_3x3[j2 * 3 + 1] = 0;
      v_3x3[j2 * 3 + 2] = 0;
      v_3x3[j2 * 3 + j2] = 1;
      const vectTmp1 = cross3([v_3x3[maxI * 3], v_3x3[maxI * 3 + 1], v_3x3[maxI * 3 + 2]], [v_3x3[j2 * 3], v_3x3[j2 * 3 + 1], v_3x3[j2 * 3 + 2]], []);
      normalize4(vectTmp1);
      const vectTmp2 = cross3(vectTmp1, [v_3x3[maxI * 3], v_3x3[maxI * 3 + 1], v_3x3[maxI * 3 + 2]], []);
      for (let t9 = 0; t9 < 3; t9++) {
        v_3x3[k2 * 3 + t9] = vectTmp1[t9];
        v_3x3[j2 * 3 + t9] = vectTmp2[t9];
      }
      transpose3x3(v_3x3, v_3x3);
      return;
    }
  }
  maxVal = Math.abs(v_3x3[0]);
  maxI = 0;
  for (i6 = 1; i6 < 3; i6++) {
    if (maxVal < (tmp = Math.abs(v_3x3[i6 * 3]))) {
      maxVal = tmp;
      maxI = i6;
    }
  }
  if (maxI !== 0) {
    const eigenValTmp = w_3[maxI];
    w_3[maxI] = w_3[0];
    w_3[0] = eigenValTmp;
    swapRowsMatrix_nxn(v_3x3, 3, maxI, 0);
  }
  if (Math.abs(v_3x3[4]) < Math.abs(v_3x3[7])) {
    const eigenValTmp = w_3[2];
    w_3[2] = w_3[1];
    w_3[1] = eigenValTmp;
    swapRowsMatrix_nxn(v_3x3, 3, 1, 2);
  }
  for (i6 = 0; i6 < 2; i6++) {
    if (v_3x3[i6 * 3 + i6] < 0) {
      v_3x3[i6 * 3] = -v_3x3[i6 * 3];
      v_3x3[i6 * 3 + 1] = -v_3x3[i6 * 3 + 1];
      v_3x3[i6 * 3 + 2] = -v_3x3[i6 * 3 + 2];
    }
  }
  if (determinant3x3(v_3x3) < 0) {
    v_3x3[6] = -v_3x3[6];
    v_3x3[7] = -v_3x3[7];
    v_3x3[8] = -v_3x3[8];
  }
  transpose3x3(v_3x3, v_3x3);
}
function singularValueDecomposition3x3(a_3x3, u_3x3, w_3, vT_3x3) {
  let i6;
  const B = [...a_3x3];
  const d3 = determinant3x3(B);
  if (d3 < 0) {
    for (i6 = 0; i6 < 9; i6++) {
      B[i6] = -B[i6];
    }
  }
  orthogonalize3x3(B, u_3x3);
  transpose3x3(B, B);
  multiply3x3_mat3(B, u_3x3, vT_3x3);
  diagonalize3x3(vT_3x3, w_3, vT_3x3);
  multiply3x3_mat3(u_3x3, vT_3x3, u_3x3);
  transpose3x3(vT_3x3, vT_3x3);
  if (d3 < 0) {
    w_3[0] = -w_3[0];
    w_3[1] = -w_3[1];
    w_3[2] = -w_3[2];
  }
}
function luFactorLinearSystem(A2, index2, size3) {
  let i6;
  let j2;
  let k2;
  let largest;
  let maxI = 0;
  let sum;
  let temp1;
  let temp2;
  const scale7 = createArray(size3);
  for (i6 = 0; i6 < size3; i6++) {
    for (largest = 0, j2 = 0; j2 < size3; j2++) {
      if ((temp2 = Math.abs(A2[i6 * size3 + j2])) > largest) {
        largest = temp2;
      }
    }
    if (largest === 0) {
      vtkWarningMacro2("Unable to factor linear system");
      return 0;
    }
    scale7[i6] = 1 / largest;
  }
  for (j2 = 0; j2 < size3; j2++) {
    for (i6 = 0; i6 < j2; i6++) {
      sum = A2[i6 * size3 + j2];
      for (k2 = 0; k2 < i6; k2++) {
        sum -= A2[i6 * size3 + k2] * A2[k2 * size3 + j2];
      }
      A2[i6 * size3 + j2] = sum;
    }
    for (largest = 0, i6 = j2; i6 < size3; i6++) {
      sum = A2[i6 * size3 + j2];
      for (k2 = 0; k2 < j2; k2++) {
        sum -= A2[i6 * size3 + k2] * A2[k2 * size3 + j2];
      }
      A2[i6 * size3 + j2] = sum;
      if ((temp1 = scale7[i6] * Math.abs(sum)) >= largest) {
        largest = temp1;
        maxI = i6;
      }
    }
    if (j2 !== maxI) {
      for (k2 = 0; k2 < size3; k2++) {
        temp1 = A2[maxI * size3 + k2];
        A2[maxI * size3 + k2] = A2[j2 * size3 + k2];
        A2[j2 * size3 + k2] = temp1;
      }
      scale7[maxI] = scale7[j2];
    }
    index2[j2] = maxI;
    if (Math.abs(A2[j2 * size3 + j2]) <= VTK_SMALL_NUMBER) {
      vtkWarningMacro2("Unable to factor linear system");
      return 0;
    }
    if (j2 !== size3 - 1) {
      temp1 = 1 / A2[j2 * size3 + j2];
      for (i6 = j2 + 1; i6 < size3; i6++) {
        A2[i6 * size3 + j2] *= temp1;
      }
    }
  }
  return 1;
}
function luSolveLinearSystem(A2, index2, x2, size3) {
  let i6;
  let j2;
  let ii;
  let idx;
  let sum;
  for (ii = -1, i6 = 0; i6 < size3; i6++) {
    idx = index2[i6];
    sum = x2[idx];
    x2[idx] = x2[i6];
    if (ii >= 0) {
      for (j2 = ii; j2 <= i6 - 1; j2++) {
        sum -= A2[i6 * size3 + j2] * x2[j2];
      }
    } else if (sum !== 0) {
      ii = i6;
    }
    x2[i6] = sum;
  }
  for (i6 = size3 - 1; i6 >= 0; i6--) {
    sum = x2[i6];
    for (j2 = i6 + 1; j2 < size3; j2++) {
      sum -= A2[i6 * size3 + j2] * x2[j2];
    }
    x2[i6] = sum / A2[i6 * size3 + i6];
  }
}
function solveLinearSystem(A2, x2, size3) {
  if (size3 === 2) {
    const y3 = createArray(2);
    const det = determinant2x2(A2[0], A2[1], A2[2], A2[3]);
    if (det === 0) {
      return 0;
    }
    y3[0] = (A2[3] * x2[0] - A2[1] * x2[1]) / det;
    y3[1] = (-(A2[2] * x2[0]) + A2[0] * x2[1]) / det;
    x2[0] = y3[0];
    x2[1] = y3[1];
    return 1;
  }
  if (size3 === 1) {
    if (A2[0] === 0) {
      return 0;
    }
    x2[0] /= A2[0];
    return 1;
  }
  const index2 = createArray(size3);
  if (luFactorLinearSystem(A2, index2, size3) === 0) {
    return 0;
  }
  luSolveLinearSystem(A2, index2, x2, size3);
  return 1;
}
function invertMatrix(A2, AI, size3) {
  let index2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  let column = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;
  const tmp1Size = index2 || createArray(size3);
  const tmp2Size = column || createArray(size3);
  if (luFactorLinearSystem(A2, tmp1Size, size3) === 0) {
    return null;
  }
  for (let j2 = 0; j2 < size3; j2++) {
    for (let i6 = 0; i6 < size3; i6++) {
      tmp2Size[i6] = 0;
    }
    tmp2Size[j2] = 1;
    luSolveLinearSystem(A2, tmp1Size, tmp2Size, size3);
    for (let i6 = 0; i6 < size3; i6++) {
      AI[i6 * size3 + j2] = tmp2Size[i6];
    }
  }
  return AI;
}
function estimateMatrixCondition(A2, size3) {
  let minValue = +Number.MAX_VALUE;
  let maxValue = -Number.MAX_VALUE;
  for (let i6 = 0; i6 < size3; i6++) {
    for (let j2 = i6; j2 < size3; j2++) {
      if (Math.abs(A2[i6 * size3 + j2]) > maxValue) {
        maxValue = Math.abs(A2[i6 * size3 + j2]);
      }
    }
  }
  for (let i6 = 0; i6 < size3; i6++) {
    if (Math.abs(A2[i6 * size3 + i6]) < minValue) {
      minValue = Math.abs(A2[i6 * size3 + i6]);
    }
  }
  if (minValue === 0) {
    return Number.MAX_VALUE;
  }
  return maxValue / minValue;
}
function jacobi(a_3x3, w2, v2) {
  return jacobiN(a_3x3, 3, w2, v2);
}
function solveHomogeneousLeastSquares(numberOfSamples, xt, xOrder, mt) {
  if (numberOfSamples < xOrder) {
    vtkWarningMacro2("Insufficient number of samples. Underdetermined.");
    return 0;
  }
  let i6;
  let j2;
  let k2;
  const XXt = createArray(xOrder * xOrder);
  const eigenvals = createArray(xOrder);
  const eigenvecs = createArray(xOrder * xOrder);
  for (k2 = 0; k2 < numberOfSamples; k2++) {
    for (i6 = 0; i6 < xOrder; i6++) {
      for (j2 = i6; j2 < xOrder; j2++) {
        XXt[i6 * xOrder + j2] += xt[k2 * xOrder + i6] * xt[k2 * xOrder + j2];
      }
    }
  }
  for (i6 = 0; i6 < xOrder; i6++) {
    for (j2 = 0; j2 < i6; j2++) {
      XXt[i6 * xOrder + j2] = XXt[j2 * xOrder + i6];
    }
  }
  jacobiN(XXt, xOrder, eigenvals, eigenvecs);
  for (i6 = 0; i6 < xOrder; i6++) {
    mt[i6] = eigenvecs[i6 * xOrder + xOrder - 1];
  }
  return 1;
}
function solveLeastSquares(numberOfSamples, xt, xOrder, yt, yOrder, mt) {
  let checkHomogeneous = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : true;
  if (numberOfSamples < xOrder || numberOfSamples < yOrder) {
    vtkWarningMacro2("Insufficient number of samples. Underdetermined.");
    return 0;
  }
  const homogenFlags = createArray(yOrder);
  let allHomogeneous = 1;
  let hmt;
  let homogRC = 0;
  let i6;
  let j2;
  let k2;
  let someHomogeneous = 0;
  if (checkHomogeneous) {
    for (j2 = 0; j2 < yOrder; j2++) {
      homogenFlags[j2] = 1;
    }
    for (i6 = 0; i6 < numberOfSamples; i6++) {
      for (j2 = 0; j2 < yOrder; j2++) {
        if (Math.abs(yt[i6 * yOrder + j2]) > VTK_SMALL_NUMBER) {
          allHomogeneous = 0;
          homogenFlags[j2] = 0;
        }
      }
    }
    if (allHomogeneous && yOrder === 1) {
      vtkWarningMacro2("Detected homogeneous system (Y=0), calling SolveHomogeneousLeastSquares()");
      return solveHomogeneousLeastSquares(numberOfSamples, xt, xOrder, mt);
    }
    if (allHomogeneous) {
      someHomogeneous = 1;
    } else {
      for (j2 = 0; j2 < yOrder; j2++) {
        if (homogenFlags[j2]) {
          someHomogeneous = 1;
        }
      }
    }
  }
  if (someHomogeneous) {
    hmt = createArray(xOrder);
    homogRC = solveHomogeneousLeastSquares(numberOfSamples, xt, xOrder, hmt);
  }
  const XXt = createArray(xOrder * xOrder);
  const XXtI = createArray(xOrder * xOrder);
  const XYt = createArray(xOrder * yOrder);
  for (k2 = 0; k2 < numberOfSamples; k2++) {
    for (i6 = 0; i6 < xOrder; i6++) {
      for (j2 = i6; j2 < xOrder; j2++) {
        XXt[i6 * xOrder + j2] += xt[k2 * xOrder + i6] * xt[k2 * xOrder + j2];
      }
      for (j2 = 0; j2 < yOrder; j2++) {
        XYt[i6 * yOrder + j2] += xt[k2 * xOrder + i6] * yt[k2 * yOrder + j2];
      }
    }
  }
  for (i6 = 0; i6 < xOrder; i6++) {
    for (j2 = 0; j2 < i6; j2++) {
      XXt[i6 * xOrder + j2] = XXt[j2 * xOrder + i6];
    }
  }
  const successFlag = invertMatrix(XXt, XXtI, xOrder);
  if (successFlag) {
    for (i6 = 0; i6 < xOrder; i6++) {
      for (j2 = 0; j2 < yOrder; j2++) {
        mt[i6 * yOrder + j2] = 0;
        for (k2 = 0; k2 < xOrder; k2++) {
          mt[i6 * yOrder + j2] += XXtI[i6 * xOrder + k2] * XYt[k2 * yOrder + j2];
        }
      }
    }
  }
  if (someHomogeneous) {
    for (j2 = 0; j2 < yOrder; j2++) {
      if (homogenFlags[j2]) {
        for (i6 = 0; i6 < xOrder; i6++) {
          mt[i6 * yOrder + j2] = hmt[i6 * yOrder];
        }
      }
    }
  }
  if (someHomogeneous) {
    return homogRC && successFlag;
  }
  return successFlag;
}
function hex2float(hexStr) {
  let outFloatArray = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0.5, 1];
  switch (hexStr.length) {
    case 3:
      outFloatArray[0] = parseInt(hexStr[0], 16) * 17 / 255;
      outFloatArray[1] = parseInt(hexStr[1], 16) * 17 / 255;
      outFloatArray[2] = parseInt(hexStr[2], 16) * 17 / 255;
      return outFloatArray;
    case 4:
      outFloatArray[0] = parseInt(hexStr[1], 16) * 17 / 255;
      outFloatArray[1] = parseInt(hexStr[2], 16) * 17 / 255;
      outFloatArray[2] = parseInt(hexStr[3], 16) * 17 / 255;
      return outFloatArray;
    case 6:
      outFloatArray[0] = parseInt(hexStr.substr(0, 2), 16) / 255;
      outFloatArray[1] = parseInt(hexStr.substr(2, 2), 16) / 255;
      outFloatArray[2] = parseInt(hexStr.substr(4, 2), 16) / 255;
      return outFloatArray;
    case 7:
      outFloatArray[0] = parseInt(hexStr.substr(1, 2), 16) / 255;
      outFloatArray[1] = parseInt(hexStr.substr(3, 2), 16) / 255;
      outFloatArray[2] = parseInt(hexStr.substr(5, 2), 16) / 255;
      return outFloatArray;
    case 9:
      outFloatArray[0] = parseInt(hexStr.substr(1, 2), 16) / 255;
      outFloatArray[1] = parseInt(hexStr.substr(3, 2), 16) / 255;
      outFloatArray[2] = parseInt(hexStr.substr(5, 2), 16) / 255;
      outFloatArray[3] = parseInt(hexStr.substr(7, 2), 16) / 255;
      return outFloatArray;
    default:
      return outFloatArray;
  }
}
function rgb2hsv(rgb, hsv) {
  let h5;
  let s9;
  const [r9, g2, b3] = rgb;
  const onethird = 1 / 3;
  const onesixth = 1 / 6;
  const twothird = 2 / 3;
  let cmax = r9;
  let cmin = r9;
  if (g2 > cmax) {
    cmax = g2;
  } else if (g2 < cmin) {
    cmin = g2;
  }
  if (b3 > cmax) {
    cmax = b3;
  } else if (b3 < cmin) {
    cmin = b3;
  }
  const v2 = cmax;
  if (v2 > 0) {
    s9 = (cmax - cmin) / cmax;
  } else {
    s9 = 0;
  }
  if (s9 > 0) {
    if (r9 === cmax) {
      h5 = onesixth * (g2 - b3) / (cmax - cmin);
    } else if (g2 === cmax) {
      h5 = onethird + onesixth * (b3 - r9) / (cmax - cmin);
    } else {
      h5 = twothird + onesixth * (r9 - g2) / (cmax - cmin);
    }
    if (h5 < 0) {
      h5 += 1;
    }
  } else {
    h5 = 0;
  }
  hsv[0] = h5;
  hsv[1] = s9;
  hsv[2] = v2;
}
function hsv2rgb(hsv, rgb) {
  const [h5, s9, v2] = hsv;
  const onethird = 1 / 3;
  const onesixth = 1 / 6;
  const twothird = 2 / 3;
  const fivesixth = 5 / 6;
  let r9;
  let g2;
  let b3;
  if (h5 > onesixth && h5 <= onethird) {
    g2 = 1;
    r9 = (onethird - h5) / onesixth;
    b3 = 0;
  } else if (h5 > onethird && h5 <= 0.5) {
    g2 = 1;
    b3 = (h5 - onethird) / onesixth;
    r9 = 0;
  } else if (h5 > 0.5 && h5 <= twothird) {
    b3 = 1;
    g2 = (twothird - h5) / onesixth;
    r9 = 0;
  } else if (h5 > twothird && h5 <= fivesixth) {
    b3 = 1;
    r9 = (h5 - twothird) / onesixth;
    g2 = 0;
  } else if (h5 > fivesixth && h5 <= 1) {
    r9 = 1;
    b3 = (1 - h5) / onesixth;
    g2 = 0;
  } else {
    r9 = 1;
    g2 = h5 / onesixth;
    b3 = 0;
  }
  r9 = s9 * r9 + (1 - s9);
  g2 = s9 * g2 + (1 - s9);
  b3 = s9 * b3 + (1 - s9);
  r9 *= v2;
  g2 *= v2;
  b3 *= v2;
  rgb[0] = r9;
  rgb[1] = g2;
  rgb[2] = b3;
}
function lab2xyz(lab, xyz) {
  const [L2, a4, b3] = lab;
  let var_Y = (L2 + 16) / 116;
  let var_X = a4 / 500 + var_Y;
  let var_Z = var_Y - b3 / 200;
  if (__pow(var_Y, 3) > 8856e-6) {
    var_Y = __pow(var_Y, 3);
  } else {
    var_Y = (var_Y - 16 / 116) / 7.787;
  }
  if (__pow(var_X, 3) > 8856e-6) {
    var_X = __pow(var_X, 3);
  } else {
    var_X = (var_X - 16 / 116) / 7.787;
  }
  if (__pow(var_Z, 3) > 8856e-6) {
    var_Z = __pow(var_Z, 3);
  } else {
    var_Z = (var_Z - 16 / 116) / 7.787;
  }
  const ref_X = 0.9505;
  const ref_Y = 1;
  const ref_Z = 1.089;
  xyz[0] = ref_X * var_X;
  xyz[1] = ref_Y * var_Y;
  xyz[2] = ref_Z * var_Z;
}
function xyz2lab(xyz, lab) {
  const [x2, y3, z3] = xyz;
  const ref_X = 0.9505;
  const ref_Y = 1;
  const ref_Z = 1.089;
  let var_X = x2 / ref_X;
  let var_Y = y3 / ref_Y;
  let var_Z = z3 / ref_Z;
  if (var_X > 8856e-6) var_X = __pow(var_X, 1 / 3);
  else var_X = 7.787 * var_X + 16 / 116;
  if (var_Y > 8856e-6) var_Y = __pow(var_Y, 1 / 3);
  else var_Y = 7.787 * var_Y + 16 / 116;
  if (var_Z > 8856e-6) var_Z = __pow(var_Z, 1 / 3);
  else var_Z = 7.787 * var_Z + 16 / 116;
  lab[0] = 116 * var_Y - 16;
  lab[1] = 500 * (var_X - var_Y);
  lab[2] = 200 * (var_Y - var_Z);
}
function xyz2rgb(xyz, rgb) {
  const [x2, y3, z3] = xyz;
  let r9 = x2 * 3.2406 + y3 * -1.5372 + z3 * -0.4986;
  let g2 = x2 * -0.9689 + y3 * 1.8758 + z3 * 0.0415;
  let b3 = x2 * 0.0557 + y3 * -0.204 + z3 * 1.057;
  if (r9 > 31308e-7) r9 = 1.055 * __pow(r9, 1 / 2.4) - 0.055;
  else r9 *= 12.92;
  if (g2 > 31308e-7) g2 = 1.055 * __pow(g2, 1 / 2.4) - 0.055;
  else g2 *= 12.92;
  if (b3 > 31308e-7) b3 = 1.055 * __pow(b3, 1 / 2.4) - 0.055;
  else b3 *= 12.92;
  let maxVal = r9;
  if (maxVal < g2) maxVal = g2;
  if (maxVal < b3) maxVal = b3;
  if (maxVal > 1) {
    r9 /= maxVal;
    g2 /= maxVal;
    b3 /= maxVal;
  }
  if (r9 < 0) r9 = 0;
  if (g2 < 0) g2 = 0;
  if (b3 < 0) b3 = 0;
  rgb[0] = r9;
  rgb[1] = g2;
  rgb[2] = b3;
}
function rgb2xyz(rgb, xyz) {
  let [r9, g2, b3] = rgb;
  if (r9 > 0.04045) r9 = __pow((r9 + 0.055) / 1.055, 2.4);
  else r9 /= 12.92;
  if (g2 > 0.04045) g2 = __pow((g2 + 0.055) / 1.055, 2.4);
  else g2 /= 12.92;
  if (b3 > 0.04045) b3 = __pow((b3 + 0.055) / 1.055, 2.4);
  else b3 /= 12.92;
  xyz[0] = r9 * 0.4124 + g2 * 0.3576 + b3 * 0.1805;
  xyz[1] = r9 * 0.2126 + g2 * 0.7152 + b3 * 0.0722;
  xyz[2] = r9 * 0.0193 + g2 * 0.1192 + b3 * 0.9505;
}
function rgb2lab(rgb, lab) {
  const xyz = [0, 0, 0];
  rgb2xyz(rgb, xyz);
  xyz2lab(xyz, lab);
}
function lab2rgb(lab, rgb) {
  const xyz = [0, 0, 0];
  lab2xyz(lab, xyz);
  xyz2rgb(xyz, rgb);
}
function uninitializeBounds(bounds) {
  bounds[0] = 1;
  bounds[1] = -1;
  bounds[2] = 1;
  bounds[3] = -1;
  bounds[4] = 1;
  bounds[5] = -1;
  return bounds;
}
function areBoundsInitialized(bounds) {
  return !(bounds[1] - bounds[0] < 0);
}
function computeBoundsFromPoints(point1, point2, bounds) {
  bounds[0] = Math.min(point1[0], point2[0]);
  bounds[1] = Math.max(point1[0], point2[0]);
  bounds[2] = Math.min(point1[1], point2[1]);
  bounds[3] = Math.max(point1[1], point2[1]);
  bounds[4] = Math.min(point1[2], point2[2]);
  bounds[5] = Math.max(point1[2], point2[2]);
  return bounds;
}
function clampValue(value, minValue, maxValue) {
  if (value < minValue) {
    return minValue;
  }
  if (value > maxValue) {
    return maxValue;
  }
  return value;
}
function clampVector(vector, minVector, maxVector) {
  let out = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [0, 0, 0];
  out[0] = clampValue(vector[0], minVector[0], maxVector[0]);
  out[1] = clampValue(vector[1], minVector[1], maxVector[1]);
  out[2] = clampValue(vector[2], minVector[2], maxVector[2]);
  return out;
}
function clampAndNormalizeValue(value, range) {
  let result = 0;
  if (range[0] !== range[1]) {
    if (value < range[0]) {
      result = range[0];
    } else if (value > range[1]) {
      result = range[1];
    } else {
      result = value;
    }
    result = (result - range[0]) / (range[1] - range[0]);
  }
  return result;
}
var getScalarTypeFittingRange = notImplemented("GetScalarTypeFittingRange");
var getAdjustedScalarRange = notImplemented("GetAdjustedScalarRange");
function extentIsWithinOtherExtent(extent1, extent2) {
  if (!extent1 || !extent2) {
    return 0;
  }
  for (let i6 = 0; i6 < 6; i6 += 2) {
    if (extent1[i6] < extent2[i6] || extent1[i6] > extent2[i6 + 1] || extent1[i6 + 1] < extent2[i6] || extent1[i6 + 1] > extent2[i6 + 1]) {
      return 0;
    }
  }
  return 1;
}
function boundsIsWithinOtherBounds(bounds1_6, bounds2_6, delta_3) {
  if (!bounds1_6 || !bounds2_6) {
    return 0;
  }
  for (let i6 = 0; i6 < 6; i6 += 2) {
    if (bounds1_6[i6] + delta_3[i6 / 2] < bounds2_6[i6] || bounds1_6[i6] - delta_3[i6 / 2] > bounds2_6[i6 + 1] || bounds1_6[i6 + 1] + delta_3[i6 / 2] < bounds2_6[i6] || bounds1_6[i6 + 1] - delta_3[i6 / 2] > bounds2_6[i6 + 1]) {
      return 0;
    }
  }
  return 1;
}
function pointIsWithinBounds(point_3, bounds_6, delta_3) {
  if (!point_3 || !bounds_6 || !delta_3) {
    return 0;
  }
  for (let i6 = 0; i6 < 3; i6++) {
    if (point_3[i6] + delta_3[i6] < bounds_6[2 * i6] || point_3[i6] - delta_3[i6] > bounds_6[2 * i6 + 1]) {
      return 0;
    }
  }
  return 1;
}
function solve3PointCircle(p1, p22, p3, center) {
  const v21 = createArray(3);
  const v32 = createArray(3);
  const v13 = createArray(3);
  const v12 = createArray(3);
  const v23 = createArray(3);
  const v31 = createArray(3);
  for (let i6 = 0; i6 < 3; ++i6) {
    v21[i6] = p1[i6] - p22[i6];
    v32[i6] = p22[i6] - p3[i6];
    v13[i6] = p3[i6] - p1[i6];
    v12[i6] = -v21[i6];
    v23[i6] = -v32[i6];
    v31[i6] = -v13[i6];
  }
  const norm12 = norm(v12);
  const norm23 = norm(v23);
  const norm13 = norm(v13);
  const crossv21v32 = createArray(3);
  cross3(v21, v32, crossv21v32);
  const normCross = norm(crossv21v32);
  const radius = norm12 * norm23 * norm13 / (2 * normCross);
  const normCross22 = 2 * normCross * normCross;
  const alpha = norm23 * norm23 * dot4(v21, v31) / normCross22;
  const beta = norm13 * norm13 * dot4(v12, v32) / normCross22;
  const gamma = norm12 * norm12 * dot4(v13, v23) / normCross22;
  for (let i6 = 0; i6 < 3; ++i6) {
    center[i6] = alpha * p1[i6] + beta * p22[i6] + gamma * p3[i6];
  }
  return radius;
}
var inf = Infinity;
var negInf = -Infinity;
var isInf = (value) => !Number.isFinite(value);
var {
  isFinite: isFinite2,
  isNaN: isNaN2
} = Number;
var isNan = isNaN2;
function createUninitializedBounds() {
  return [].concat([
    Number.MAX_VALUE,
    -Number.MAX_VALUE,
    // X
    Number.MAX_VALUE,
    -Number.MAX_VALUE,
    // Y
    Number.MAX_VALUE,
    -Number.MAX_VALUE
    // Z
  ]);
}
function getMajorAxisIndex(vector) {
  let maxValue = -1;
  let axisIndex = -1;
  for (let i6 = 0; i6 < vector.length; i6++) {
    const value = Math.abs(vector[i6]);
    if (value > maxValue) {
      axisIndex = i6;
      maxValue = value;
    }
  }
  return axisIndex;
}
function getSparseOrthogonalMatrix(matrix) {
  let n9 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 3;
  const rows = new Array(n9);
  const cols = new Array(n9);
  for (let i6 = 0; i6 < n9; ++i6) {
    rows[i6] = i6;
    cols[i6] = i6;
  }
  for (let i6 = n9 - 1; i6 > 0; i6--) {
    let bestValue = -Infinity;
    let bestRowI = 0;
    let bestColI = 0;
    for (let rowI = 0; rowI <= i6; ++rowI) {
      const row = rows[rowI];
      for (let colI = 0; colI <= i6; ++colI) {
        const col = cols[colI];
        const absVal = Math.abs(matrix[row + n9 * col]);
        if (absVal > bestValue) {
          bestValue = absVal;
          bestRowI = rowI;
          bestColI = colI;
        }
      }
    }
    [rows[i6], rows[bestRowI]] = [rows[bestRowI], rows[i6]];
    [cols[i6], cols[bestColI]] = [cols[bestColI], cols[i6]];
  }
  const output = new Array(n9 * n9).fill(0);
  for (let i6 = 0; i6 < n9; ++i6) {
    const matIdx = rows[i6] + n9 * cols[i6];
    output[matIdx] = matrix[matIdx] < 0 ? -1 : 1;
  }
  return output;
}
function floatToHex2(value) {
  const integer = Math.floor(value * 255);
  if (integer > 15) {
    return integer.toString(16);
  }
  return `0${integer.toString(16)}`;
}
function floatRGB2HexCode(rgbArray) {
  let prefix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "#";
  return `${prefix}${rgbArray.map(floatToHex2).join("")}`;
}
function floatToChar(f5) {
  return Math.round(f5 * 255);
}
function float2CssRGBA(rgbArray) {
  if (rgbArray.length === 3) {
    return `rgb(${rgbArray.map(floatToChar).join(", ")})`;
  }
  return `rgba(${floatToChar(rgbArray[0] || 0)}, ${floatToChar(rgbArray[1] || 0)}, ${floatToChar(rgbArray[2] || 0)}, ${rgbArray[3] || 0})`;
}
var vtkMath = {
  Pi,
  radiansFromDegrees,
  degreesFromRadians,
  round: round4,
  floor: floor4,
  ceil: ceil3,
  ceilLog2,
  min: min4,
  max: max4,
  arrayMin,
  arrayMax,
  arrayRange,
  isPowerOfTwo,
  nearestPowerOfTwo,
  factorial,
  binomial,
  beginCombination,
  nextCombination,
  randomSeed,
  getSeed,
  random: random4,
  gaussian,
  add: add6,
  subtract: subtract5,
  multiplyScalar: multiplyScalar3,
  multiplyScalar2D,
  multiplyAccumulate,
  multiplyAccumulate2D,
  dot: dot4,
  outer,
  cross: cross3,
  norm,
  normalize: normalize4,
  perpendiculars,
  projectVector,
  projectVector2D,
  distance2BetweenPoints,
  angleBetweenVectors,
  gaussianAmplitude,
  gaussianWeight,
  dot2D,
  outer2D,
  norm2D,
  normalize2D,
  determinant2x2,
  LUFactor3x3,
  LUSolve3x3,
  linearSolve3x3,
  multiply3x3_vect3,
  multiply3x3_mat3,
  multiplyMatrix,
  transpose3x3,
  invert3x3,
  identity3x3,
  identity: identity4,
  isIdentity,
  isIdentity3x3,
  determinant3x3,
  quaternionToMatrix3x3,
  areEquals,
  areMatricesEqual,
  roundNumber,
  roundVector,
  matrix3x3ToQuaternion,
  multiplyQuaternion,
  orthogonalize3x3,
  diagonalize3x3,
  singularValueDecomposition3x3,
  solveLinearSystem,
  invertMatrix,
  luFactorLinearSystem,
  luSolveLinearSystem,
  estimateMatrixCondition,
  jacobi,
  jacobiN,
  solveHomogeneousLeastSquares,
  solveLeastSquares,
  hex2float,
  rgb2hsv,
  hsv2rgb,
  lab2xyz,
  xyz2lab,
  xyz2rgb,
  rgb2xyz,
  rgb2lab,
  lab2rgb,
  uninitializeBounds,
  areBoundsInitialized,
  computeBoundsFromPoints,
  clampValue,
  clampVector,
  clampAndNormalizeValue,
  getScalarTypeFittingRange,
  getAdjustedScalarRange,
  extentIsWithinOtherExtent,
  boundsIsWithinOtherBounds,
  pointIsWithinBounds,
  solve3PointCircle,
  inf,
  negInf,
  isInf,
  isNan: isNaN2,
  isNaN: isNaN2,
  isFinite: isFinite2,
  // JS add-on
  createUninitializedBounds,
  getMajorAxisIndex,
  getSparseOrthogonalMatrix,
  floatToHex2,
  floatRGB2HexCode,
  float2CssRGBA
};

// node_modules/@kitware/vtk.js/Common/Core/DataArray.js
var {
  vtkErrorMacro: vtkErrorMacro5
} = macro$1;
var {
  DefaultDataType: DefaultDataType2
} = Constants;
var EPSILON3 = 1e-6;
function fastComputeRange(arr, offset3, numberOfComponents) {
  const len4 = arr.length;
  let min5 = Number.MAX_VALUE;
  let max5 = -Number.MAX_VALUE;
  let x2;
  let i6;
  for (i6 = offset3; i6 < len4; i6 += numberOfComponents) {
    if (!Number.isNaN(arr[i6])) {
      min5 = arr[i6];
      max5 = min5;
      break;
    }
  }
  for (; i6 < len4; i6 += numberOfComponents) {
    x2 = arr[i6];
    if (x2 < min5) {
      min5 = x2;
    } else if (x2 > max5) {
      max5 = x2;
    }
  }
  return {
    min: min5,
    max: max5
  };
}
function createRangeHelper() {
  let min5 = Number.MAX_VALUE;
  let max5 = -Number.MAX_VALUE;
  let count = 0;
  let sum = 0;
  return {
    add(value) {
      if (min5 > value) {
        min5 = value;
      }
      if (max5 < value) {
        max5 = value;
      }
      count++;
      sum += value;
    },
    get() {
      return {
        min: min5,
        max: max5,
        count,
        sum,
        mean: sum / count
      };
    },
    getRange() {
      return {
        min: min5,
        max: max5
      };
    }
  };
}
function computeRange(values) {
  let component = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  let numberOfComponents = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
  if (component < 0 && numberOfComponents > 1) {
    const size3 = values.length;
    const numberOfValues = size3 / numberOfComponents;
    const data = new Float64Array(numberOfValues);
    for (let i6 = 0, j2 = 0; i6 < numberOfValues; ++i6) {
      for (let nextJ = j2 + numberOfComponents; j2 < nextJ; ++j2) {
        data[i6] += values[j2] * values[j2];
      }
      data[i6] = __pow(data[i6], 0.5);
    }
    return fastComputeRange(data, 0, 1);
  }
  return fastComputeRange(values, component < 0 ? 0 : component, numberOfComponents);
}
function ensureRangeSize(rangeArray) {
  let size3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  const ranges2 = rangeArray || [];
  while (ranges2.length <= size3) {
    ranges2.push(null);
  }
  return ranges2;
}
function getDataType(typedArray) {
  return Object.prototype.toString.call(typedArray).slice(8, -1);
}
function getMaxNorm(normArray) {
  const numComps = normArray.getNumberOfComponents();
  let maxNorm = 0;
  const tuple = new Array(numComps);
  for (let i6 = 0; i6 < normArray.getNumberOfTuples(); ++i6) {
    normArray.getTuple(i6, tuple);
    const norm$1 = norm(tuple, numComps);
    if (norm$1 > maxNorm) {
      maxNorm = norm$1;
    }
  }
  return maxNorm;
}
var STATIC = {
  computeRange,
  createRangeHelper,
  fastComputeRange,
  getDataType,
  getMaxNorm
};
function vtkDataArray(publicAPI, model) {
  model.classHierarchy.push("vtkDataArray");
  function resize2(requestedNumTuples) {
    if (requestedNumTuples < 0) {
      return false;
    }
    const numComps = publicAPI.getNumberOfComponents();
    const curNumTuples = model.values.length / (numComps > 0 ? numComps : 1);
    if (requestedNumTuples === curNumTuples) {
      return true;
    }
    if (requestedNumTuples > curNumTuples) {
      const oldValues = model.values;
      model.values = newTypedArray(model.dataType, (requestedNumTuples + curNumTuples) * numComps);
      model.values.set(oldValues);
      return true;
    }
    if (model.size > requestedNumTuples * numComps) {
      model.size = requestedNumTuples * numComps;
      publicAPI.dataChange();
    }
    return true;
  }
  publicAPI.dataChange = () => {
    model.ranges = null;
    publicAPI.modified();
  };
  publicAPI.resize = (requestedNumTuples) => {
    resize2(requestedNumTuples);
    const newSize = requestedNumTuples * publicAPI.getNumberOfComponents();
    if (model.size !== newSize) {
      model.size = newSize;
      publicAPI.dataChange();
      return true;
    }
    return false;
  };
  publicAPI.initialize = () => {
    publicAPI.resize(0);
  };
  publicAPI.getElementComponentSize = () => model.values.BYTES_PER_ELEMENT;
  publicAPI.getComponent = function(tupleIdx) {
    let compIdx = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    return model.values[tupleIdx * model.numberOfComponents + compIdx];
  };
  publicAPI.setComponent = (tupleIdx, compIdx, value) => {
    if (value !== model.values[tupleIdx * model.numberOfComponents + compIdx]) {
      model.values[tupleIdx * model.numberOfComponents + compIdx] = value;
      publicAPI.dataChange();
    }
  };
  publicAPI.getValue = (valueIdx) => {
    const idx = valueIdx / model.numberOfComponents;
    const comp = valueIdx % model.numberOfComponents;
    return publicAPI.getComponent(idx, comp);
  };
  publicAPI.setValue = (valueIdx, value) => {
    const idx = valueIdx / model.numberOfComponents;
    const comp = valueIdx % model.numberOfComponents;
    publicAPI.setComponent(idx, comp, value);
  };
  publicAPI.getData = () => model.size === model.values.length ? model.values : model.values.subarray(0, model.size);
  publicAPI.getRange = function() {
    let componentIndex = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : -1;
    let rangeIdx = componentIndex;
    if (rangeIdx < 0) {
      rangeIdx = model.numberOfComponents === 1 ? 0 : model.numberOfComponents;
    }
    let range = null;
    if (!model.ranges) {
      model.ranges = ensureRangeSize(model.ranges, model.numberOfComponents);
    }
    range = model.ranges[rangeIdx];
    if (range) {
      model.rangeTuple[0] = range.min;
      model.rangeTuple[1] = range.max;
      return model.rangeTuple;
    }
    range = computeRange(publicAPI.getData(), componentIndex, model.numberOfComponents);
    model.ranges[rangeIdx] = range;
    model.rangeTuple[0] = range.min;
    model.rangeTuple[1] = range.max;
    return model.rangeTuple;
  };
  publicAPI.setRange = (rangeValue, componentIndex) => {
    if (!model.ranges) {
      model.ranges = ensureRangeSize(model.ranges, model.numberOfComponents);
    }
    const range = {
      min: rangeValue.min,
      max: rangeValue.max
    };
    model.ranges[componentIndex] = range;
    model.rangeTuple[0] = range.min;
    model.rangeTuple[1] = range.max;
    return model.rangeTuple;
  };
  publicAPI.setTuple = (idx, tuple) => {
    const offset3 = idx * model.numberOfComponents;
    for (let i6 = 0; i6 < model.numberOfComponents; i6++) {
      model.values[offset3 + i6] = tuple[i6];
    }
  };
  publicAPI.setTuples = (idx, tuples) => {
    let i6 = idx * model.numberOfComponents;
    const last = Math.min(tuples.length, model.size - i6);
    for (let j2 = 0; j2 < last; ) {
      model.values[i6++] = tuples[j2++];
    }
  };
  publicAPI.insertTuple = (idx, tuple) => {
    if (model.size <= idx * model.numberOfComponents) {
      model.size = (idx + 1) * model.numberOfComponents;
      resize2(idx + 1);
    }
    publicAPI.setTuple(idx, tuple);
    return idx;
  };
  publicAPI.insertTuples = (idx, tuples) => {
    const end = idx + tuples.length / model.numberOfComponents;
    if (model.size < end * model.numberOfComponents) {
      model.size = end * model.numberOfComponents;
      resize2(end);
    }
    publicAPI.setTuples(idx, tuples);
    return end;
  };
  publicAPI.insertNextTuple = (tuple) => {
    const idx = model.size / model.numberOfComponents;
    return publicAPI.insertTuple(idx, tuple);
  };
  publicAPI.insertNextTuples = (tuples) => {
    const idx = model.size / model.numberOfComponents;
    return publicAPI.insertTuples(idx, tuples);
  };
  publicAPI.findTuple = function(tuple) {
    let precision = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : EPSILON3;
    for (let i6 = 0; i6 < model.size; i6 += model.numberOfComponents) {
      if (Math.abs(tuple[0] - model.values[i6]) <= precision) {
        let match = true;
        for (let j2 = 1; j2 < model.numberOfComponents; ++j2) {
          if (Math.abs(tuple[j2] - model.values[i6 + j2]) > precision) {
            match = false;
            break;
          }
        }
        if (match) {
          return i6 / model.numberOfComponents;
        }
      }
    }
    return -1;
  };
  publicAPI.getTuple = function(idx) {
    let tupleToFill = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    const numberOfComponents = model.numberOfComponents || 1;
    const offset3 = idx * numberOfComponents;
    switch (numberOfComponents) {
      case 4:
        tupleToFill[3] = model.values[offset3 + 3];
      case 3:
        tupleToFill[2] = model.values[offset3 + 2];
      case 2:
        tupleToFill[1] = model.values[offset3 + 1];
      case 1:
        tupleToFill[0] = model.values[offset3];
        break;
      default:
        for (let i6 = numberOfComponents - 1; i6 >= 0; --i6) {
          tupleToFill[i6] = model.values[offset3 + i6];
        }
    }
    return tupleToFill;
  };
  publicAPI.getTuples = (fromId, toId) => {
    const from = (fromId != null ? fromId : 0) * model.numberOfComponents;
    const to = (toId != null ? toId : publicAPI.getNumberOfTuples()) * model.numberOfComponents;
    const arr = publicAPI.getData().subarray(from, to);
    return arr.length > 0 ? arr : null;
  };
  publicAPI.getTupleLocation = function() {
    let idx = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
    return idx * model.numberOfComponents;
  };
  publicAPI.getNumberOfComponents = () => model.numberOfComponents;
  publicAPI.getNumberOfValues = () => model.size;
  publicAPI.getNumberOfTuples = () => model.size / model.numberOfComponents;
  publicAPI.getDataType = () => model.dataType;
  publicAPI.newClone = () => newInstance7({
    empty: true,
    name: model.name,
    dataType: model.dataType,
    numberOfComponents: model.numberOfComponents
  });
  publicAPI.getName = () => {
    if (!model.name) {
      publicAPI.modified();
      model.name = `vtkDataArray${publicAPI.getMTime()}`;
    }
    return model.name;
  };
  publicAPI.setData = (typedArray, numberOfComponents) => {
    model.values = typedArray;
    model.size = typedArray.length;
    model.dataType = getDataType(typedArray);
    if (numberOfComponents) {
      model.numberOfComponents = numberOfComponents;
    }
    if (model.size % model.numberOfComponents !== 0) {
      model.numberOfComponents = 1;
    }
    publicAPI.dataChange();
  };
  publicAPI.getState = () => {
    if (model.deleted) {
      return null;
    }
    const jsonArchive = __spreadProps(__spreadValues({}, model), {
      vtkClass: publicAPI.getClassName()
    });
    jsonArchive.values = Array.from(jsonArchive.values);
    delete jsonArchive.buffer;
    Object.keys(jsonArchive).forEach((keyName) => {
      if (!jsonArchive[keyName]) {
        delete jsonArchive[keyName];
      }
    });
    const sortedObj = {};
    Object.keys(jsonArchive).sort().forEach((name) => {
      sortedObj[name] = jsonArchive[name];
    });
    if (sortedObj.mtime) {
      delete sortedObj.mtime;
    }
    return sortedObj;
  };
  publicAPI.deepCopy = (other) => {
    const currentType = publicAPI.getDataType();
    const currentArray = model.values;
    publicAPI.shallowCopy(other);
    if ((currentArray == null ? void 0 : currentArray.length) >= other.getNumberOfValues() && currentType === other.getDataType()) {
      currentArray.set(other.getData());
      model.values = currentArray;
      publicAPI.dataChange();
    } else {
      publicAPI.setData(other.getData().slice());
    }
  };
  publicAPI.interpolateTuple = (idx, source1, source1Idx, source2, source2Idx, t9) => {
    const numberOfComponents = model.numberOfComponents || 1;
    if (numberOfComponents !== source1.getNumberOfComponents() || numberOfComponents !== source2.getNumberOfComponents()) {
      vtkErrorMacro5("numberOfComponents must match");
    }
    const tuple1 = source1.getTuple(source1Idx);
    const tuple2 = source2.getTuple(source2Idx);
    const out = [];
    out.length = numberOfComponents;
    switch (numberOfComponents) {
      case 4:
        out[3] = tuple1[3] + (tuple2[3] - tuple1[3]) * t9;
      case 3:
        out[2] = tuple1[2] + (tuple2[2] - tuple1[2]) * t9;
      case 2:
        out[1] = tuple1[1] + (tuple2[1] - tuple1[1]) * t9;
      case 1:
        out[0] = tuple1[0] + (tuple2[0] - tuple1[0]) * t9;
        break;
      default:
        for (let i6 = 0; i6 < numberOfComponents; i6++) {
          out[i6] = tuple1[i6] + (tuple2[i6] - tuple1[i6]) * t9;
        }
    }
    return publicAPI.insertTuple(idx, out);
  };
}
var DEFAULT_VALUES6 = {
  name: "",
  numberOfComponents: 1,
  dataType: DefaultDataType2,
  rangeTuple: [0, 0]
  // size: undefined,
  // values: null,
  // ranges: null,
};
function extend6(publicAPI, model) {
  var _a9;
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES6, initialValues);
  if (!model.empty && !model.values && !model.size) {
    throw new TypeError("Cannot create vtkDataArray object without: size > 0, values");
  }
  if (!model.values) {
    model.values = newTypedArray(model.dataType, model.size);
  } else if (Array.isArray(model.values)) {
    model.values = newTypedArrayFrom(model.dataType, model.values);
  }
  if (model.values) {
    model.size = (_a9 = model.size) != null ? _a9 : model.values.length;
    model.dataType = getDataType(model.values);
  }
  obj(publicAPI, model);
  set6(publicAPI, model, ["name", "numberOfComponents"]);
  if (model.size % model.numberOfComponents !== 0) {
    throw new RangeError("model.size is not a multiple of model.numberOfComponents");
  }
  vtkDataArray(publicAPI, model);
}
var newInstance7 = newInstance(extend6, "vtkDataArray");
var vtkDataArray$1 = __spreadValues(__spreadValues({
  newInstance: newInstance7,
  extend: extend6
}, STATIC), Constants);

// node_modules/@kitware/vtk.js/Common/Core/CellArray.js
function extractCellSizes(cellArray) {
  let currentIdx = 0;
  return cellArray.filter((value, index2) => {
    if (index2 === currentIdx) {
      currentIdx += value + 1;
      return true;
    }
    return false;
  });
}
function getNumberOfCells(cellArray) {
  let cellId = 0;
  for (let cellArrayIndex = 0; cellArrayIndex < cellArray.length; ) {
    cellArrayIndex += cellArray[cellArrayIndex] + 1;
    cellId++;
  }
  return cellId;
}
var STATIC2 = {
  extractCellSizes,
  getNumberOfCells
};
function vtkCellArray(publicAPI, model) {
  model.classHierarchy.push("vtkCellArray");
  const superClass = __spreadValues({}, publicAPI);
  publicAPI.getNumberOfCells = (recompute) => {
    if (model.numberOfCells !== void 0 && !recompute) {
      return model.numberOfCells;
    }
    if (model.cellSizes) {
      model.numberOfCells = model.cellSizes.length;
    } else {
      model.numberOfCells = getNumberOfCells(publicAPI.getData());
    }
    return model.numberOfCells;
  };
  publicAPI.getCellSizes = (recompute) => {
    if (model.cellSizes !== void 0 && !recompute) {
      return model.cellSizes;
    }
    model.cellSizes = extractCellSizes(publicAPI.getData());
    return model.cellSizes;
  };
  publicAPI.resize = (requestedNumTuples) => {
    const oldNumTuples = publicAPI.getNumberOfTuples();
    superClass.resize(requestedNumTuples);
    const newNumTuples = publicAPI.getNumberOfTuples();
    if (newNumTuples < oldNumTuples) {
      if (newNumTuples === 0) {
        model.numberOfCells = 0;
        model.cellSizes = [];
      } else {
        model.numberOfCells = void 0;
        model.cellSizes = void 0;
      }
    }
  };
  publicAPI.setData = (typedArray) => {
    superClass.setData(typedArray, 1);
    model.numberOfCells = void 0;
    model.cellSizes = void 0;
  };
  publicAPI.getCell = (loc) => {
    let cellLoc = loc;
    const numberOfPoints = model.values[cellLoc++];
    return model.values.subarray(cellLoc, cellLoc + numberOfPoints);
  };
  publicAPI.insertNextCell = (cellPointIds) => {
    const cellId = publicAPI.getNumberOfCells();
    publicAPI.insertNextTuples([cellPointIds.length, ...cellPointIds]);
    ++model.numberOfCells;
    if (model.cellSizes != null) {
      model.cellSizes.push(cellPointIds.length);
    }
    return cellId;
  };
}
function defaultValues(initialValues) {
  return __spreadValues({
    empty: true,
    numberOfComponents: 1,
    dataType: VtkDataTypes.UNSIGNED_INT
  }, initialValues);
}
function extend7(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  vtkDataArray$1.extend(publicAPI, model, defaultValues(initialValues));
  vtkCellArray(publicAPI, model);
}
var newInstance8 = macro.newInstance(extend7, "vtkCellArray");
var vtkCellArray$1 = __spreadValues({
  newInstance: newInstance8,
  extend: extend7
}, STATIC2);

// node_modules/@kitware/vtk.js/Common/Core/Points.js
var {
  vtkErrorMacro: vtkErrorMacro6
} = macro;
var INVALID_BOUNDS = [1, -1, 1, -1, 1, -1];
function vtkPoints(publicAPI, model) {
  model.classHierarchy.push("vtkPoints");
  publicAPI.getNumberOfPoints = publicAPI.getNumberOfTuples;
  publicAPI.setNumberOfPoints = function(nbPoints) {
    let dimension2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 3;
    if (publicAPI.getNumberOfPoints() !== nbPoints) {
      model.size = nbPoints * dimension2;
      model.values = macro.newTypedArray(model.dataType, model.size);
      publicAPI.setNumberOfComponents(dimension2);
      publicAPI.modified();
    }
  };
  publicAPI.setPoint = function(idx) {
    for (var _len = arguments.length, xyz = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      xyz[_key - 1] = arguments[_key];
    }
    publicAPI.setTuple(idx, xyz);
  };
  publicAPI.getPoint = publicAPI.getTuple;
  publicAPI.findPoint = publicAPI.findTuple;
  publicAPI.insertNextPoint = (x2, y3, z3) => publicAPI.insertNextTuple([x2, y3, z3]);
  publicAPI.getBounds = () => {
    if (publicAPI.getNumberOfComponents() === 3) {
      const xRange2 = publicAPI.getRange(0);
      model.bounds[0] = xRange2[0];
      model.bounds[1] = xRange2[1];
      const yRange2 = publicAPI.getRange(1);
      model.bounds[2] = yRange2[0];
      model.bounds[3] = yRange2[1];
      const zRange = publicAPI.getRange(2);
      model.bounds[4] = zRange[0];
      model.bounds[5] = zRange[1];
      return model.bounds;
    }
    if (publicAPI.getNumberOfComponents() !== 2) {
      vtkErrorMacro6(`getBounds called on an array with components of
        ${publicAPI.getNumberOfComponents()}`);
      return INVALID_BOUNDS;
    }
    const xRange = publicAPI.getRange(0);
    model.bounds[0] = xRange[0];
    model.bounds[1] = xRange[1];
    const yRange = publicAPI.getRange(1);
    model.bounds[2] = yRange[0];
    model.bounds[3] = yRange[1];
    model.bounds[4] = 0;
    model.bounds[5] = 0;
    return model.bounds;
  };
  publicAPI.computeBounds = publicAPI.getBounds;
  publicAPI.setNumberOfComponents(model.numberOfComponents < 2 ? 3 : model.numberOfComponents);
}
var DEFAULT_VALUES7 = {
  empty: true,
  numberOfComponents: 3,
  dataType: VtkDataTypes.FLOAT,
  bounds: [1, -1, 1, -1, 1, -1]
};
function extend8(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES7, initialValues);
  vtkDataArray$1.extend(publicAPI, model, initialValues);
  vtkPoints(publicAPI, model);
}
var newInstance9 = macro.newInstance(extend8, "vtkPoints");
var vtkPoints$1 = {
  newInstance: newInstance9,
  extend: extend8
};

// node_modules/@kitware/vtk.js/Common/DataModel/Cell.js
function vtkCell(publicAPI, model) {
  model.classHierarchy.push("vtkCell");
  publicAPI.initialize = function(points) {
    let pointIdsList = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    if (!pointIdsList) {
      model.points = points;
      model.pointsIds = new Array(points.getNumberOfPoints());
      for (let i6 = points.getNumberOfPoints() - 1; i6 >= 0; --i6) {
        model.pointsIds[i6] = i6;
      }
    } else {
      model.pointsIds = pointIdsList;
      let triangleData = model.points.getData();
      if (triangleData.length !== 3 * model.pointsIds.length) {
        triangleData = macro.newTypedArray(points.getDataType(), 3 * model.pointsIds.length);
      }
      const pointsData = points.getData();
      model.pointsIds.forEach((pointId, index2) => {
        let pointOffset = 3 * pointId;
        let trianglePointOffset = 3 * index2;
        triangleData[trianglePointOffset] = pointsData[pointOffset];
        triangleData[++trianglePointOffset] = pointsData[++pointOffset];
        triangleData[++trianglePointOffset] = pointsData[++pointOffset];
      });
      model.points.setData(triangleData);
    }
  };
  publicAPI.getBounds = () => {
    const nbPoints = model.points.getNumberOfPoints();
    const x2 = [];
    if (nbPoints) {
      model.points.getPoint(0, x2);
      model.bounds[0] = x2[0];
      model.bounds[1] = x2[0];
      model.bounds[2] = x2[1];
      model.bounds[3] = x2[1];
      model.bounds[4] = x2[2];
      model.bounds[5] = x2[2];
      for (let i6 = 1; i6 < nbPoints; i6++) {
        model.points.getPoint(i6, x2);
        model.bounds[0] = x2[0] < model.bounds[0] ? x2[0] : model.bounds[0];
        model.bounds[1] = x2[0] > model.bounds[1] ? x2[0] : model.bounds[1];
        model.bounds[2] = x2[1] < model.bounds[2] ? x2[1] : model.bounds[2];
        model.bounds[3] = x2[1] > model.bounds[3] ? x2[1] : model.bounds[3];
        model.bounds[4] = x2[2] < model.bounds[4] ? x2[2] : model.bounds[4];
        model.bounds[5] = x2[2] > model.bounds[5] ? x2[2] : model.bounds[5];
      }
    } else {
      uninitializeBounds(model.bounds);
    }
    return model.bounds;
  };
  publicAPI.getLength2 = () => {
    publicAPI.getBounds();
    let length4 = 0;
    let diff = 0;
    for (let i6 = 0; i6 < 3; i6++) {
      diff = model.bounds[2 * i6 + 1] - model.bounds[2 * i6];
      length4 += diff * diff;
    }
    return length4;
  };
  publicAPI.getParametricDistance = (pcoords) => {
    let pDist;
    let pDistMax = 0;
    for (let i6 = 0; i6 < 3; i6++) {
      if (pcoords[i6] < 0) {
        pDist = -pcoords[i6];
      } else if (pcoords[i6] > 1) {
        pDist = pcoords[i6] - 1;
      } else {
        pDist = 0;
      }
      if (pDist > pDistMax) {
        pDistMax = pDist;
      }
    }
    return pDistMax;
  };
  publicAPI.getNumberOfPoints = () => model.points.getNumberOfPoints();
  publicAPI.deepCopy = (cell) => {
    cell.initialize(model.points, model.pointsIds);
  };
  publicAPI.getCellDimension = () => {
  };
  publicAPI.intersectWithLine = (p1, p22, tol, t9, x2, pcoords, subId) => {
  };
  publicAPI.evaluatePosition = (x2, closestPoint, subId, pcoords, dist22, weights) => {
    macro.vtkErrorMacro("vtkCell.evaluatePosition is not implemented.");
  };
}
var DEFAULT_VALUES8 = {
  bounds: [-1, -1, -1, -1, -1, -1],
  pointsIds: []
};
function extend9(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES8, initialValues);
  macro.obj(publicAPI, model);
  if (!model.points) {
    model.points = vtkPoints$1.newInstance();
  }
  macro.get(publicAPI, model, ["points", "pointsIds"]);
  vtkCell(publicAPI, model);
}
var newInstance10 = macro.newInstance(extend9, "vtkCell");
var vtkCell$1 = {
  newInstance: newInstance10,
  extend: extend9
};

// node_modules/@kitware/vtk.js/Common/DataModel/CellLinks.js
function resize(model, sz) {
  let newSize = sz;
  if (sz >= model.array.length) {
    newSize += model.array.length;
  }
  while (newSize > model.array.length) model.array.push({
    ncells: 0,
    cells: null
  });
  model.array.length = newSize;
}
function vtkCellLinks(publicAPI, model) {
  model.classHierarchy.push("vtkCellLinks");
  publicAPI.buildLinks = (data) => {
    const numPts = data.getPoints().getNumberOfPoints();
    const numCells = data.getNumberOfCells();
    const linkLoc = new Uint32Array(numPts);
    if (data.isA("vtkPolyData")) {
      for (let cellId = 0; cellId < numCells; ++cellId) {
        const {
          cellPointIds
        } = data.getCellPoints(cellId);
        cellPointIds.forEach((cellPointId) => {
          publicAPI.incrementLinkCount(cellPointId);
        });
      }
      publicAPI.allocateLinks(numPts);
      model.maxId = numPts - 1;
      for (let cellId = 0; cellId < numCells; ++cellId) {
        const {
          cellPointIds
        } = data.getCellPoints(cellId);
        cellPointIds.forEach((cellPointId) => {
          publicAPI.insertCellReference(cellPointId, linkLoc[cellPointId]++, cellId);
        });
      }
    } else {
      for (let cellId = 0; cellId < numCells; cellId++) {
        const cell = vtkCell$1.newInstance();
        cell.getPointsIds().forEach((cellPointId) => {
          publicAPI.incrementLinkCount(cellPointId);
        });
      }
      publicAPI.allocateLinks(numPts);
      model.maxId = numPts - 1;
      for (let cellId = 0; cellId < numCells; ++cellId) {
        const cell = vtkCell$1.newInstance();
        cell.getPointsIds().forEach((cellPointId) => {
          publicAPI.insertCellReference(cellPointId, linkLoc[cellPointId]++, cellId);
        });
      }
    }
  };
  publicAPI.allocate = function(numLinks) {
    let ext = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1e3;
    model.array = Array(numLinks).fill().map(() => ({
      ncells: 0,
      cells: null
    }));
    model.extend = ext;
    model.maxId = -1;
  };
  publicAPI.initialize = () => {
    model.array = null;
  };
  publicAPI.getLink = (ptId) => model.array[ptId];
  publicAPI.getNcells = (ptId) => model.array[ptId].ncells;
  publicAPI.getCells = (ptId) => model.array[ptId].cells;
  publicAPI.insertNextPoint = (numLinks) => {
    model.array.push({
      ncells: numLinks,
      cells: Array(numLinks)
    });
    ++model.maxId;
  };
  publicAPI.insertNextCellReference = (ptId, cellId) => {
    model.array[ptId].cells[model.array[ptId].ncells++] = cellId;
  };
  publicAPI.deletePoint = (ptId) => {
    model.array[ptId].ncells = 0;
    model.array[ptId].cells = null;
  };
  publicAPI.removeCellReference = (cellId, ptId) => {
    model.array[ptId].cells = model.array[ptId].cells.filter((cell) => cell !== cellId);
    model.array[ptId].ncells = model.array[ptId].cells.length;
  };
  publicAPI.addCellReference = (cellId, ptId) => {
    model.array[ptId].cells[model.array[ptId].ncells++] = cellId;
  };
  publicAPI.resizeCellList = (ptId, size3) => {
    model.array[ptId].cells.length = size3;
  };
  publicAPI.squeeze = () => {
    resize(model, model.maxId + 1);
  };
  publicAPI.reset = () => {
    model.maxId = -1;
  };
  publicAPI.deepCopy = (src) => {
    model.array = [...src.array];
    model.extend = src.extend;
    model.maxId = src.maxId;
  };
  publicAPI.incrementLinkCount = (ptId) => {
    ++model.array[ptId].ncells;
  };
  publicAPI.allocateLinks = (n9) => {
    for (let i6 = 0; i6 < n9; ++i6) {
      model.array[i6].cells = new Array(model.array[i6].ncells);
    }
  };
  publicAPI.insertCellReference = (ptId, pos, cellId) => {
    model.array[ptId].cells[pos] = cellId;
  };
}
var DEFAULT_VALUES9 = {
  array: null,
  // pointer to data
  maxId: 0,
  // maximum index inserted thus far
  extend: 0
  // grow array by this point
};
function extend10(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES9, initialValues);
  macro.obj(publicAPI, model);
  vtkCellLinks(publicAPI, model);
}
var newInstance11 = macro.newInstance(extend10, "vtkCellLinks");
var vtkCellLinks$1 = {
  newInstance: newInstance11,
  extend: extend10
};

// node_modules/@kitware/vtk.js/Common/DataModel/CellTypes/Constants.js
var CellType = {
  // Linear cells
  VTK_EMPTY_CELL: 0,
  VTK_VERTEX: 1,
  VTK_POLY_VERTEX: 2,
  VTK_LINE: 3,
  VTK_POLY_LINE: 4,
  VTK_TRIANGLE: 5,
  VTK_TRIANGLE_STRIP: 6,
  VTK_POLYGON: 7,
  VTK_PIXEL: 8,
  VTK_QUAD: 9,
  VTK_TETRA: 10,
  VTK_VOXEL: 11,
  VTK_HEXAHEDRON: 12,
  VTK_WEDGE: 13,
  VTK_PYRAMID: 14,
  VTK_PENTAGONAL_PRISM: 15,
  VTK_HEXAGONAL_PRISM: 16,
  // Quadratic, isoparametric cells
  VTK_QUADRATIC_EDGE: 21,
  VTK_QUADRATIC_TRIANGLE: 22,
  VTK_QUADRATIC_QUAD: 23,
  VTK_QUADRATIC_POLYGON: 36,
  VTK_QUADRATIC_TETRA: 24,
  VTK_QUADRATIC_HEXAHEDRON: 25,
  VTK_QUADRATIC_WEDGE: 26,
  VTK_QUADRATIC_PYRAMID: 27,
  VTK_BIQUADRATIC_QUAD: 28,
  VTK_TRIQUADRATIC_HEXAHEDRON: 29,
  VTK_QUADRATIC_LINEAR_QUAD: 30,
  VTK_QUADRATIC_LINEAR_WEDGE: 31,
  VTK_BIQUADRATIC_QUADRATIC_WEDGE: 32,
  VTK_BIQUADRATIC_QUADRATIC_HEXAHEDRON: 33,
  VTK_BIQUADRATIC_TRIANGLE: 34,
  // Cubic, isoparametric cell
  VTK_CUBIC_LINE: 35,
  // Special class of cells formed by convex group of points
  VTK_CONVEX_POINT_SET: 41,
  // Polyhedron cell (consisting of polygonal faces)
  VTK_POLYHEDRON: 42,
  // Higher order cells in parametric form
  VTK_PARAMETRIC_CURVE: 51,
  VTK_PARAMETRIC_SURFACE: 52,
  VTK_PARAMETRIC_TRI_SURFACE: 53,
  VTK_PARAMETRIC_QUAD_SURFACE: 54,
  VTK_PARAMETRIC_TETRA_REGION: 55,
  VTK_PARAMETRIC_HEX_REGION: 56,
  // Higher order cells
  VTK_HIGHER_ORDER_EDGE: 60,
  VTK_HIGHER_ORDER_TRIANGLE: 61,
  VTK_HIGHER_ORDER_QUAD: 62,
  VTK_HIGHER_ORDER_POLYGON: 63,
  VTK_HIGHER_ORDER_TETRAHEDRON: 64,
  VTK_HIGHER_ORDER_WEDGE: 65,
  VTK_HIGHER_ORDER_PYRAMID: 66,
  VTK_HIGHER_ORDER_HEXAHEDRON: 67,
  // Arbitrary order Lagrange elements (formulated separated from generic higher order cells)
  VTK_LAGRANGE_CURVE: 68,
  VTK_LAGRANGE_TRIANGLE: 69,
  VTK_LAGRANGE_QUADRILATERAL: 70,
  VTK_LAGRANGE_TETRAHEDRON: 71,
  VTK_LAGRANGE_HEXAHEDRON: 72,
  VTK_LAGRANGE_WEDGE: 73,
  VTK_LAGRANGE_PYRAMID: 74,
  VTK_NUMBER_OF_CELL_TYPES: 75
};
var CellTypesStrings = ["vtkEmptyCell", "vtkVertex", "vtkPolyVertex", "vtkLine", "vtkPolyLine", "vtkTriangle", "vtkTriangleStrip", "vtkPolygon", "vtkPixel", "vtkQuad", "vtkTetra", "vtkVoxel", "vtkHexahedron", "vtkWedge", "vtkPyramid", "vtkPentagonalPrism", "vtkHexagonalPrism", "UnknownClass", "UnknownClass", "UnknownClass", "UnknownClass", "vtkQuadraticEdge", "vtkQuadraticTriangle", "vtkQuadraticQuad", "vtkQuadraticTetra", "vtkQuadraticHexahedron", "vtkQuadraticWedge", "vtkQuadraticPyramid", "vtkBiQuadraticQuad", "vtkTriQuadraticHexahedron", "vtkQuadraticLinearQuad", "vtkQuadraticLinearWedge", "vtkBiQuadraticQuadraticWedge", "vtkBiQuadraticQuadraticHexahedron", "vtkBiQuadraticTriangle", "vtkCubicLine", "vtkQuadraticPolygon", "UnknownClass", "UnknownClass", "UnknownClass", "UnknownClass", "vtkConvexPointSet", "UnknownClass", "UnknownClass", "UnknownClass", "UnknownClass", "UnknownClass", "UnknownClass", "UnknownClass", "UnknownClass", "UnknownClass", "vtkParametricCurve", "vtkParametricSurface", "vtkParametricTriSurface", "vtkParametricQuadSurface", "vtkParametricTetraRegion", "vtkParametricHexRegion", "UnknownClass", "UnknownClass", "UnknownClass", "vtkHigherOrderEdge", "vtkHigherOrderTriangle", "vtkHigherOrderQuad", "vtkHigherOrderPolygon", "vtkHigherOrderTetrahedron", "vtkHigherOrderWedge", "vtkHigherOrderPyramid", "vtkHigherOrderHexahedron"];

// node_modules/@kitware/vtk.js/Common/DataModel/CellTypes.js
function getClassNameFromTypeId(typeId) {
  return typeId < CellTypesStrings.length ? CellTypesStrings[typeId] : "UnknownClass";
}
function getTypeIdFromClassName(cellTypeString) {
  return CellTypesStrings.findIndex(cellTypeString);
}
function isLinear(type) {
  return type < CellType.VTK_QUADRATIC_EDGE || type === CellType.VTK_CONVEX_POINT_SET || type === CellType.VTK_POLYHEDRON;
}
function hasSubCells(cellType) {
  return cellType === CellType.VTK_TRIANGLE_STRIP || cellType === CellType.VTK_POLY_LINE || cellType === CellType.VTK_POLY_VERTEX;
}
var STATIC3 = {
  getClassNameFromTypeId,
  getTypeIdFromClassName,
  isLinear,
  hasSubCells
};
function vtkCellTypes(publicAPI, model) {
  model.classHierarchy.push("vtkCellTypes");
  publicAPI.allocate = function() {
    let sz = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 512;
    let ext = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1e3;
    model.size = sz > 0 ? sz : 1;
    model.extend = ext > 0 ? ext : 1;
    model.maxId = -1;
    model.typeArray = new Uint8Array(sz);
    model.locationArray = new Uint32Array(sz);
  };
  publicAPI.insertCell = (cellId, type, loc) => {
    model.typeArray[cellId] = type;
    model.locationArray[cellId] = loc;
    if (cellId > model.maxId) {
      model.maxId = cellId;
    }
  };
  publicAPI.insertNextCell = (type, loc) => {
    publicAPI.insertCell(++model.maxId, type, loc);
    return model.maxId;
  };
  publicAPI.setCellTypes = (ncells, cellTypes, cellLocations) => {
    model.size = ncells;
    model.typeArray = cellTypes;
    model.locationArray = cellLocations;
    model.maxId = ncells - 1;
  };
  publicAPI.getCellLocation = (cellId) => model.locationArray[cellId];
  publicAPI.deleteCell = (cellId) => {
    model.typeArray[cellId] = CellType.VTK_EMPTY_CELL;
  };
  publicAPI.getNumberOfTypes = () => model.maxId + 1;
  publicAPI.isType = (type) => {
    const numTypes = publicAPI.getNumberOfTypes();
    for (let i6 = 0; i6 < numTypes; ++i6) {
      if (type === publicAPI.getCellType(i6)) {
        return true;
      }
    }
    return false;
  };
  publicAPI.insertNextType = (type) => publicAPI.insertNextCell(type, -1);
  publicAPI.getCellType = (cellId) => model.typeArray[cellId];
  publicAPI.reset = () => {
    model.maxId = -1;
  };
  publicAPI.deepCopy = (src) => {
    publicAPI.allocate(src.getSize(), src.getExtend());
    model.typeArray.set(src.getTypeArray());
    model.locationArray.set(src.getLocationArray());
    model.maxId = src.getMaxId();
  };
}
var DEFAULT_VALUES10 = {
  // typeArray: null, // pointer to types array
  // locationArray: null;   // pointer to array of offsets
  size: 0,
  // allocated size of data
  maxId: -1,
  // maximum index inserted thus far
  extend: 1e3
  // grow array by this point
};
function extend11(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES10, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["size", "maxId", "extend"]);
  macro.getArray(publicAPI, model, ["typeArray", "locationArray"]);
  vtkCellTypes(publicAPI, model);
}
var newInstance12 = macro.newInstance(extend11, "vtkCellTypes");
var vtkCellTypes$1 = __spreadValues({
  newInstance: newInstance12,
  extend: extend11
}, STATIC3);

// node_modules/@kitware/vtk.js/Common/DataModel/Line/Constants.js
var IntersectionState = {
  NO_INTERSECTION: 0,
  YES_INTERSECTION: 1,
  ON_LINE: 2
};
var Constants2 = {
  IntersectionState
};

// node_modules/@kitware/vtk.js/Common/DataModel/Line.js
var {
  IntersectionState: IntersectionState2
} = Constants2;
function distanceToLine(x2, p1, p22) {
  let closestPoint = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  const outObj = {
    t: Number.MIN_VALUE,
    distance: 0
  };
  const p21 = [];
  let closest;
  p21[0] = p22[0] - p1[0];
  p21[1] = p22[1] - p1[1];
  p21[2] = p22[2] - p1[2];
  const num = p21[0] * (x2[0] - p1[0]) + p21[1] * (x2[1] - p1[1]) + p21[2] * (x2[2] - p1[2]);
  const denom = dot4(p21, p21);
  let tolerance = 1e-5 * num;
  if (denom !== 0) {
    outObj.t = num / denom;
  }
  if (tolerance < 0) {
    tolerance = -tolerance;
  }
  if (-tolerance < denom && denom < tolerance) {
    closest = p1;
  } else if (denom <= 0 || outObj.t < 0) {
    closest = p1;
  } else if (outObj.t > 1) {
    closest = p22;
  } else {
    closest = p21;
    p21[0] = p1[0] + outObj.t * p21[0];
    p21[1] = p1[1] + outObj.t * p21[1];
    p21[2] = p1[2] + outObj.t * p21[2];
  }
  if (closestPoint) {
    closestPoint[0] = closest[0];
    closestPoint[1] = closest[1];
    closestPoint[2] = closest[2];
  }
  outObj.distance = distance2BetweenPoints(closest, x2);
  return outObj;
}
function intersection(a1, a22, b1, b22, u5, v2) {
  const a21 = [];
  const b21 = [];
  const b1a1 = [];
  u5[0] = 0;
  v2[0] = 0;
  subtract5(a22, a1, a21);
  subtract5(b22, b1, b21);
  subtract5(b1, a1, b1a1);
  const A2 = [dot4(a21, a21), -dot4(a21, b21), -dot4(a21, b21), dot4(b21, b21)];
  const c6 = [];
  c6[0] = dot4(a21, b1a1);
  c6[1] = -dot4(b21, b1a1);
  if (solveLinearSystem(A2, c6, 2) === 0) {
    let minDist = Number.MAX_VALUE;
    const p3 = [a1, a22, b1, b22];
    const l1 = [b1, b1, a1, a1];
    const l22 = [b22, b22, a22, a22];
    [v2[0], v2[0], u5[0], u5[0]];
    [u5[0], u5[0], v2[0], v2[0]];
    let obj2;
    for (let i6 = 0; i6 < 4; i6++) {
      obj2 = distanceToLine(p3[i6], l1[i6], l22[i6]);
      if (obj2.distance < minDist) {
        minDist = obj2.distance;
      }
    }
    return IntersectionState2.ON_LINE;
  }
  u5[0] = c6[0];
  v2[0] = c6[1];
  if (u5[0] >= 0 && u5[0] <= 1 && v2[0] >= 0 && v2[0] <= 1) {
    return IntersectionState2.YES_INTERSECTION;
  }
  return IntersectionState2.NO_INTERSECTION;
}
var STATIC4 = {
  distanceToLine,
  intersection
};
function vtkLine(publicAPI, model) {
  model.classHierarchy.push("vtkLine");
  function isBetweenPoints(t9) {
    return t9 >= 0 && t9 <= 1;
  }
  publicAPI.getCellDimension = () => 1;
  publicAPI.intersectWithLine = (p1, p22, tol, x2, pcoords) => {
    const outObj = {
      intersect: 0,
      t: Number.MAX_VALUE,
      subId: 0,
      betweenPoints: null
    };
    pcoords[1] = 0;
    pcoords[2] = 0;
    const projXYZ = [];
    const a1 = [];
    const a22 = [];
    model.points.getPoint(0, a1);
    model.points.getPoint(1, a22);
    const u5 = [];
    const v2 = [];
    const intersect2 = intersection(p1, p22, a1, a22, u5, v2);
    outObj.t = u5[0];
    outObj.betweenPoints = isBetweenPoints(outObj.t);
    pcoords[0] = v2[0];
    if (intersect2 === IntersectionState2.YES_INTERSECTION) {
      for (let i6 = 0; i6 < 3; i6++) {
        x2[i6] = a1[i6] + pcoords[0] * (a22[i6] - a1[i6]);
        projXYZ[i6] = p1[i6] + outObj.t * (p22[i6] - p1[i6]);
      }
      if (distance2BetweenPoints(x2, projXYZ) <= tol * tol) {
        outObj.intersect = 1;
        return outObj;
      }
    } else {
      let outDistance;
      if (outObj.t < 0) {
        outDistance = distanceToLine(p1, a1, a22, x2);
        if (outDistance.distance <= tol * tol) {
          outObj.t = 0;
          outObj.intersect = 1;
          outObj.betweenPoints = true;
          return outObj;
        }
        return outObj;
      }
      if (outObj.t > 1) {
        outDistance = distanceToLine(p22, a1, a22, x2);
        if (outDistance.distance <= tol * tol) {
          outObj.t = 1;
          outObj.intersect = 1;
          outObj.betweenPoints = true;
          return outObj;
        }
        return outObj;
      }
      if (pcoords[0] < 0) {
        pcoords[0] = 0;
        outDistance = distanceToLine(a1, p1, p22, x2);
        outObj.t = outDistance.t;
        if (outDistance.distance <= tol * tol) {
          outObj.intersect = 1;
          return outObj;
        }
        return outObj;
      }
      if (pcoords[0] > 1) {
        pcoords[0] = 1;
        outDistance = distanceToLine(a22, p1, p22, x2);
        outObj.t = outDistance.t;
        if (outDistance.distance <= tol * tol) {
          outObj.intersect = 1;
          return outObj;
        }
        return outObj;
      }
    }
    return outObj;
  };
  publicAPI.evaluateLocation = (pcoords, x2, weights) => {
    const a1 = [];
    const a22 = [];
    model.points.getPoint(0, a1);
    model.points.getPoint(1, a22);
    for (let i6 = 0; i6 < 3; i6++) {
      x2[i6] = a1[i6] + pcoords[0] * (a22[i6] - a1[i6]);
    }
    weights[0] = 1 - pcoords[0];
    weights[1] = pcoords[0];
  };
  publicAPI.evaluateOrientation = (pcoords, q, weights) => {
    if (model.orientations) {
      quat_exports.slerp(q, model.orientations[0], model.orientations[1], pcoords[0]);
      weights[0] = 1 - pcoords[0];
      weights[1] = pcoords[0];
      return true;
    }
    return false;
  };
}
var DEFAULT_VALUES11 = {
  orientations: null
  // an array of two quat or null
};
function extend12(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES11, initialValues);
  vtkCell$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["orientations"]);
  vtkLine(publicAPI, model);
}
var newInstance13 = macro.newInstance(extend12, "vtkLine");
var vtkLine$1 = __spreadValues(__spreadValues({
  newInstance: newInstance13,
  extend: extend12
}, STATIC4), Constants2);

// node_modules/@kitware/vtk.js/Common/DataModel/DataSetAttributes/FieldData.js
var {
  vtkErrorMacro: vtkErrorMacro7,
  vtkWarningMacro: vtkWarningMacro3
} = macro;
function vtkFieldData(publicAPI, model) {
  model.classHierarchy.push("vtkFieldData");
  const superGetState = publicAPI.getState;
  if (model.arrays) {
    model.arrays = model.arrays.map((item) => ({
      data: vtk(item.data)
    }));
  }
  publicAPI.initialize = () => {
    publicAPI.initializeFields();
    publicAPI.copyAllOn();
    publicAPI.clearFieldFlags();
  };
  publicAPI.initializeFields = () => {
    model.arrays = [];
    model.copyFieldFlags = {};
    publicAPI.modified();
  };
  publicAPI.copyStructure = (other) => {
    publicAPI.initializeFields();
    model.copyFieldFlags = other.getCopyFieldFlags().map((x2) => x2);
    model.arrays = other.arrays().map((x2) => ({
      array: x2
    }));
  };
  publicAPI.getNumberOfArrays = () => model.arrays.length;
  publicAPI.getNumberOfActiveArrays = () => model.arrays.length;
  publicAPI.addArray = (arr) => {
    const name = arr.getName();
    const {
      array,
      index: index2
    } = publicAPI.getArrayWithIndex(name);
    if (array != null) {
      model.arrays[index2] = {
        data: arr
      };
      return index2;
    }
    model.arrays = [].concat(model.arrays, {
      data: arr
    });
    return model.arrays.length - 1;
  };
  publicAPI.removeAllArrays = () => {
    model.arrays = [];
  };
  publicAPI.removeArray = (arrayName) => {
    const index2 = model.arrays.findIndex((array) => array.data.getName() === arrayName);
    return publicAPI.removeArrayByIndex(index2);
  };
  publicAPI.removeArrayByIndex = (arrayIdx) => {
    if (arrayIdx !== -1 && arrayIdx < model.arrays.length) {
      model.arrays.splice(arrayIdx, 1);
      return true;
    }
    return false;
  };
  publicAPI.getArrays = () => model.arrays.map((entry) => entry.data);
  publicAPI.getArray = (arraySpec) => typeof arraySpec === "number" ? publicAPI.getArrayByIndex(arraySpec) : publicAPI.getArrayByName(arraySpec);
  publicAPI.getArrayByName = (arrayName) => model.arrays.reduce((a4, b3, i6) => b3.data.getName() === arrayName ? b3.data : a4, null);
  publicAPI.getArrayWithIndex = (arrayName) => {
    const index2 = model.arrays.findIndex((array) => array.data.getName() === arrayName);
    return {
      array: index2 !== -1 ? model.arrays[index2].data : null,
      index: index2
    };
  };
  publicAPI.getArrayByIndex = (idx) => idx >= 0 && idx < model.arrays.length ? model.arrays[idx].data : null;
  publicAPI.hasArray = (arrayName) => publicAPI.getArrayWithIndex(arrayName).index >= 0;
  publicAPI.getArrayName = (idx) => {
    const arr = model.arrays[idx];
    return arr ? arr.data.getName() : "";
  };
  publicAPI.getCopyFieldFlags = () => model.copyFieldFlags;
  publicAPI.getFlag = (arrayName) => model.copyFieldFlags[arrayName];
  publicAPI.passData = function(other) {
    let fromId = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1;
    let toId = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -1;
    other.getArrays().forEach((arr) => {
      const copyFlag = publicAPI.getFlag(arr.getName());
      if (copyFlag !== false && !(model.doCopyAllOff && copyFlag !== true) && arr) {
        let destArr = publicAPI.getArrayByName(arr.getName());
        if (!destArr) {
          if (fromId < 0 || fromId > arr.getNumberOfTuples()) {
            publicAPI.addArray(arr);
            other.getAttributes(arr).forEach((attrType) => {
              publicAPI.setAttribute(arr, attrType);
            });
          } else {
            const ncomps = arr.getNumberOfComponents();
            let newSize = arr.getNumberOfValues();
            const tId = toId > -1 ? toId : fromId;
            if (newSize <= tId * ncomps) {
              newSize = (tId + 1) * ncomps;
            }
            destArr = vtkDataArray$1.newInstance({
              name: arr.getName(),
              dataType: arr.getDataType(),
              numberOfComponents: ncomps,
              values: macro.newTypedArray(arr.getDataType(), newSize),
              size: 0
            });
            destArr.insertTuple(tId, arr.getTuple(fromId));
            publicAPI.addArray(destArr);
            other.getAttributes(arr).forEach((attrType) => {
              publicAPI.setAttribute(destArr, attrType);
            });
          }
        } else if (arr.getNumberOfComponents() === destArr.getNumberOfComponents()) {
          if (fromId > -1 && fromId < arr.getNumberOfTuples()) {
            const tId = toId > -1 ? toId : fromId;
            destArr.insertTuple(tId, arr.getTuple(fromId));
          } else {
            destArr.insertTuples(0, arr.getTuples());
          }
        } else {
          vtkErrorMacro7("Unhandled case in passData");
        }
      }
    });
  };
  publicAPI.interpolateData = function(other) {
    let fromId1 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1;
    let fromId2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -1;
    let toId = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : -1;
    let t9 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0.5;
    other.getArrays().forEach((arr) => {
      const copyFlag = publicAPI.getFlag(arr.getName());
      if (copyFlag !== false && !(model.doCopyAllOff && copyFlag !== true) && arr) {
        let destArr = publicAPI.getArrayByName(arr.getName());
        if (!destArr) {
          if (fromId1 < 0 || fromId2 < 0 || fromId1 > arr.getNumberOfTuples()) {
            publicAPI.addArray(arr);
            other.getAttributes(arr).forEach((attrType) => {
              publicAPI.setAttribute(arr, attrType);
            });
          } else {
            const ncomps = arr.getNumberOfComponents();
            let newSize = arr.getNumberOfValues();
            const tId = toId > -1 ? toId : fromId1;
            if (newSize <= tId * ncomps) {
              newSize = (tId + 1) * ncomps;
            }
            destArr = vtkDataArray$1.newInstance({
              name: arr.getName(),
              dataType: arr.getDataType(),
              numberOfComponents: ncomps,
              values: macro.newTypedArray(arr.getDataType(), newSize),
              size: 0
            });
            destArr.interpolateTuple(tId, arr, fromId1, arr, fromId2, t9);
            publicAPI.addArray(destArr);
            other.getAttributes(arr).forEach((attrType) => {
              publicAPI.setAttribute(destArr, attrType);
            });
          }
        } else if (arr.getNumberOfComponents() === destArr.getNumberOfComponents()) {
          if (fromId1 > -1 && fromId1 < arr.getNumberOfTuples()) {
            const tId = toId > -1 ? toId : fromId1;
            destArr.interpolateTuple(tId, arr, fromId1, arr, fromId2, t9);
            vtkWarningMacro3("Unexpected case in interpolateData");
          } else {
            destArr.insertTuples(arr.getTuples());
          }
        } else {
          vtkErrorMacro7("Unhandled case in interpolateData");
        }
      }
    });
  };
  publicAPI.copyFieldOn = (arrayName) => {
    model.copyFieldFlags[arrayName] = true;
  };
  publicAPI.copyFieldOff = (arrayName) => {
    model.copyFieldFlags[arrayName] = false;
  };
  publicAPI.copyAllOn = () => {
    if (!model.doCopyAllOn || model.doCopyAllOff) {
      model.doCopyAllOn = true;
      model.doCopyAllOff = false;
      publicAPI.modified();
    }
  };
  publicAPI.copyAllOff = () => {
    if (model.doCopyAllOn || !model.doCopyAllOff) {
      model.doCopyAllOn = false;
      model.doCopyAllOff = true;
      publicAPI.modified();
    }
  };
  publicAPI.clearFieldFlags = () => {
    model.copyFieldFlags = {};
  };
  publicAPI.deepCopy = (other) => {
    model.arrays = other.getArrays().map((arr) => {
      const arrNew = arr.newClone();
      arrNew.deepCopy(arr);
      return {
        data: arrNew
      };
    });
  };
  publicAPI.copyFlags = (other) => other.getCopyFieldFlags().map((x2) => x2);
  publicAPI.reset = () => model.arrays.forEach((entry) => entry.data.reset());
  publicAPI.getMTime = () => model.arrays.reduce((a4, b3) => b3.data.getMTime() > a4 ? b3.data.getMTime() : a4, model.mtime);
  publicAPI.getNumberOfComponents = () => model.arrays.reduce((a4, b3) => a4 + b3.data.getNumberOfComponents(), 0);
  publicAPI.getNumberOfTuples = () => model.arrays.length > 0 ? model.arrays[0].getNumberOfTuples() : 0;
  publicAPI.getState = () => {
    const result = superGetState();
    if (result) {
      result.arrays = model.arrays.map((item) => ({
        data: item.data.getState()
      }));
    }
    return result;
  };
}
var DEFAULT_VALUES12 = {
  arrays: [],
  copyFieldFlags: [],
  // fields not to copy
  doCopyAllOn: true,
  doCopyAllOff: false
};
function extend13(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES12, initialValues);
  macro.obj(publicAPI, model);
  vtkFieldData(publicAPI, model);
}
var newInstance14 = macro.newInstance(extend13, "vtkFieldData");
var vtkFieldData$1 = {
  newInstance: newInstance14,
  extend: extend13
};

// node_modules/@kitware/vtk.js/Common/DataModel/DataSetAttributes/Constants.js
var AttributeTypes = {
  SCALARS: 0,
  VECTORS: 1,
  NORMALS: 2,
  TCOORDS: 3,
  TENSORS: 4,
  GLOBALIDS: 5,
  PEDIGREEIDS: 6,
  EDGEFLAG: 7,
  NUM_ATTRIBUTES: 8
};
var AttributeLimitTypes = {
  MAX: 0,
  EXACT: 1,
  NOLIMIT: 2
};
var CellGhostTypes = {
  DUPLICATECELL: 1,
  // the cell is present on multiple processors
  HIGHCONNECTIVITYCELL: 2,
  // the cell has more neighbors than in a regular mesh
  LOWCONNECTIVITYCELL: 4,
  // the cell has less neighbors than in a regular mesh
  REFINEDCELL: 8,
  // other cells are present that refines it.
  EXTERIORCELL: 16,
  // the cell is on the exterior of the data set
  HIDDENCELL: 32
  // the cell is needed to maintain connectivity, but the data values should be ignored.
};
var PointGhostTypes = {
  DUPLICATEPOINT: 1,
  // the cell is present on multiple processors
  HIDDENPOINT: 2
  // the point is needed to maintain connectivity, but the data values should be ignored.
};
var AttributeCopyOperations = {
  COPYTUPLE: 0,
  INTERPOLATE: 1,
  PASSDATA: 2,
  ALLCOPY: 3
  // all of the above
};
var ghostArrayName = "vtkGhostType";
var DesiredOutputPrecision = {
  DEFAULT: 0,
  // use the point type that does not truncate any data
  SINGLE: 1,
  // use Float32Array
  DOUBLE: 2
  // use Float64Array
};
var Constants3 = {
  AttributeCopyOperations,
  AttributeLimitTypes,
  AttributeTypes,
  CellGhostTypes,
  DesiredOutputPrecision,
  PointGhostTypes,
  ghostArrayName
};

// node_modules/@kitware/vtk.js/Common/DataModel/DataSetAttributes.js
var {
  AttributeTypes: AttributeTypes2,
  AttributeCopyOperations: AttributeCopyOperations2
} = Constants3;
var {
  vtkWarningMacro: vtkWarningMacro4
} = macro;
function vtkDataSetAttributes(publicAPI, model) {
  const attrTypes = ["Scalars", "Vectors", "Normals", "TCoords", "Tensors", "GlobalIds", "PedigreeIds"];
  function cleanAttributeType(attType) {
    let cleanAttType = attrTypes.find((ee) => AttributeTypes2[ee.toUpperCase()] === attType || typeof attType !== "number" && ee.toLowerCase() === attType.toLowerCase());
    if (typeof cleanAttType === "undefined") {
      cleanAttType = null;
    }
    return cleanAttType;
  }
  model.classHierarchy.push("vtkDataSetAttributes");
  const superClass = __spreadValues({}, publicAPI);
  publicAPI.checkNumberOfComponents = (x2) => true;
  publicAPI.setAttribute = (arr, uncleanAttType) => {
    const attType = cleanAttributeType(uncleanAttType);
    if (arr && attType.toUpperCase() === "PEDIGREEIDS" && !arr.isA("vtkDataArray")) {
      vtkWarningMacro4(`Cannot set attribute ${attType}. The attribute must be a vtkDataArray.`);
      return -1;
    }
    if (arr && !publicAPI.checkNumberOfComponents(arr, attType)) {
      vtkWarningMacro4(`Cannot set attribute ${attType}. Incorrect number of components.`);
      return -1;
    }
    let currentAttribute = model[`active${attType}`];
    if (currentAttribute >= 0 && currentAttribute < model.arrays.length) {
      if (model.arrays[currentAttribute] === arr) {
        return currentAttribute;
      }
      publicAPI.removeArrayByIndex(currentAttribute);
    }
    if (arr) {
      currentAttribute = publicAPI.addArray(arr);
      model[`active${attType}`] = currentAttribute;
    } else {
      model[`active${attType}`] = -1;
    }
    publicAPI.modified();
    return model[`active${attType}`];
  };
  publicAPI.getAttributes = (arr) => attrTypes.filter((attrType) => publicAPI[`get${attrType}`]() === arr);
  publicAPI.setActiveAttributeByName = (arrayName, attType) => publicAPI.setActiveAttributeByIndex(publicAPI.getArrayWithIndex(arrayName).index, attType);
  publicAPI.setActiveAttributeByIndex = (arrayIdx, uncleanAttType) => {
    const attType = cleanAttributeType(uncleanAttType);
    if (arrayIdx >= 0 && arrayIdx < model.arrays.length) {
      if (attType.toUpperCase() !== "PEDIGREEIDS") {
        const arr = publicAPI.getArrayByIndex(arrayIdx);
        if (!arr.isA("vtkDataArray")) {
          vtkWarningMacro4(`Cannot set attribute ${attType}. Only vtkDataArray subclasses can be set as active attributes.`);
          return -1;
        }
        if (!publicAPI.checkNumberOfComponents(arr, attType)) {
          vtkWarningMacro4(`Cannot set attribute ${attType}. Incorrect number of components.`);
          return -1;
        }
      }
      model[`active${attType}`] = arrayIdx;
      publicAPI.modified();
      return arrayIdx;
    }
    if (arrayIdx === -1) {
      model[`active${attType}`] = arrayIdx;
      publicAPI.modified();
    }
    return -1;
  };
  publicAPI.getActiveAttribute = (attType) => {
    const cleanAttType = cleanAttributeType(attType);
    return publicAPI[`get${cleanAttType}`]();
  };
  publicAPI.removeAllArrays = () => {
    attrTypes.forEach((attType) => {
      model[`active${attType}`] = -1;
    });
    superClass.removeAllArrays();
  };
  publicAPI.removeArrayByIndex = (arrayIdx) => {
    if (arrayIdx !== -1) {
      attrTypes.forEach((attType) => {
        if (arrayIdx === model[`active${attType}`]) {
          model[`active${attType}`] = -1;
        } else if (arrayIdx < model[`active${attType}`]) {
          model[`active${attType}`] -= 1;
        }
      });
    }
    return superClass.removeArrayByIndex(arrayIdx);
  };
  attrTypes.forEach((value) => {
    const activeVal = `active${value}`;
    publicAPI[`get${value}`] = () => publicAPI.getArrayByIndex(model[activeVal]);
    publicAPI[`set${value}`] = (da) => publicAPI.setAttribute(da, value);
    publicAPI[`setActive${value}`] = (arrayName) => publicAPI.setActiveAttributeByIndex(publicAPI.getArrayWithIndex(arrayName).index, value);
    publicAPI[`copy${value}Off`] = () => {
      const attType = value.toUpperCase();
      model.copyAttributeFlags[AttributeCopyOperations2.PASSDATA][AttributeTypes2[attType]] = false;
    };
    publicAPI[`copy${value}On`] = () => {
      const attType = value.toUpperCase();
      model.copyAttributeFlags[AttributeCopyOperations2.PASSDATA][AttributeTypes2[attType]] = true;
    };
  });
  publicAPI.initializeAttributeCopyFlags = () => {
    model.copyAttributeFlags = [];
    Object.keys(AttributeCopyOperations2).filter((op) => op !== "ALLCOPY").forEach((attCopyOp) => {
      model.copyAttributeFlags[AttributeCopyOperations2[attCopyOp]] = Object.keys(AttributeTypes2).filter((ty) => ty !== "NUM_ATTRIBUTES").reduce((a4, b3) => {
        a4[AttributeTypes2[b3]] = true;
        return a4;
      }, []);
    });
    model.copyAttributeFlags[AttributeCopyOperations2.COPYTUPLE][AttributeTypes2.GLOBALIDS] = false;
    model.copyAttributeFlags[AttributeCopyOperations2.INTERPOLATE][AttributeTypes2.GLOBALIDS] = false;
    model.copyAttributeFlags[AttributeCopyOperations2.COPYTUPLE][AttributeTypes2.PEDIGREEIDS] = false;
  };
  publicAPI.initialize = macro.chain(publicAPI.initialize, publicAPI.initializeAttributeCopyFlags);
  if (model.dataArrays && Object.keys(model.dataArrays).length) {
    Object.keys(model.dataArrays).forEach((name) => {
      if (!model.dataArrays[name].ref && model.dataArrays[name].type === "vtkDataArray") {
        publicAPI.addArray(vtkDataArray$1.newInstance(model.dataArrays[name]));
      }
    });
  }
  const superShallowCopy = publicAPI.shallowCopy;
  publicAPI.shallowCopy = (other, debug) => {
    superShallowCopy(other, debug);
    model.arrays = other.getArrays().map((arr) => {
      const arrNew = arr.newClone();
      arrNew.shallowCopy(arr, debug);
      return {
        data: arrNew
      };
    });
  };
  publicAPI.initializeAttributeCopyFlags();
}
var DEFAULT_VALUES13 = {
  activeScalars: -1,
  activeVectors: -1,
  activeTensors: -1,
  activeNormals: -1,
  activeTCoords: -1,
  activeGlobalIds: -1,
  activePedigreeIds: -1
};
function extend14(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES13, initialValues);
  vtkFieldData$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["activeScalars", "activeNormals", "activeTCoords", "activeVectors", "activeTensors", "activeGlobalIds", "activePedigreeIds"]);
  if (!model.arrays) {
    model.arrays = {};
  }
  vtkDataSetAttributes(publicAPI, model);
}
var newInstance15 = macro.newInstance(extend14, "vtkDataSetAttributes");
var vtkDataSetAttributes$1 = __spreadValues({
  newInstance: newInstance15,
  extend: extend14
}, Constants3);

// node_modules/@kitware/vtk.js/Common/DataModel/DataSet/Constants.js
var FieldDataTypes = {
  UNIFORM: 0,
  // data that does not vary over points/cells/etc.
  DATA_OBJECT_FIELD: 0,
  // to match VTK
  COORDINATE: 1,
  // data that specifies the location of each point
  POINT_DATA: 1,
  // to match VTK
  POINT: 2,
  // data defined at each point, but that does not specify the point location
  POINT_FIELD_DATA: 2,
  // to match VTK
  CELL: 3,
  // data defined at each cell, but that does not specify the cell
  CELL_FIELD_DATA: 3,
  // to match VTK
  VERTEX: 4,
  // data defined at each graph vertex, but that does not specify the graph vertex
  VERTEX_FIELD_DATA: 4,
  // to match VTK
  EDGE: 5,
  // data defined at each graph edge, but that does not specify the graph edge
  EDGE_FIELD_DATA: 5,
  // to match VTK
  ROW: 6,
  // data specifying a table row
  ROW_DATA: 6
  // to match VTK
};
var FieldAssociations = {
  FIELD_ASSOCIATION_POINTS: 0,
  FIELD_ASSOCIATION_CELLS: 1,
  FIELD_ASSOCIATION_NONE: 2,
  FIELD_ASSOCIATION_POINTS_THEN_CELLS: 3,
  FIELD_ASSOCIATION_VERTICES: 4,
  FIELD_ASSOCIATION_EDGES: 5,
  FIELD_ASSOCIATION_ROWS: 6,
  NUMBER_OF_ASSOCIATIONS: 7
};
var Constants4 = {
  FieldDataTypes,
  FieldAssociations
};

// node_modules/@kitware/vtk.js/Common/DataModel/DataSet.js
var DATASET_FIELDS = ["pointData", "cellData", "fieldData"];
function vtkDataSet(publicAPI, model) {
  model.classHierarchy.push("vtkDataSet");
  DATASET_FIELDS.forEach((fieldName) => {
    if (!model[fieldName]) {
      model[fieldName] = vtkDataSetAttributes$1.newInstance();
    } else {
      model[fieldName] = vtk(model[fieldName]);
    }
  });
  const superShallowCopy = publicAPI.shallowCopy;
  publicAPI.shallowCopy = function(other) {
    let debug = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    superShallowCopy(other, debug);
    DATASET_FIELDS.forEach((fieldName) => {
      model[fieldName] = vtkDataSetAttributes$1.newInstance();
      model[fieldName].shallowCopy(other.getReferenceByName(fieldName));
    });
  };
}
var DEFAULT_VALUES14 = {
  // pointData: null,
  // cellData: null,
  // fieldData: null,
};
function extend15(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES14, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, DATASET_FIELDS);
  vtkDataSet(publicAPI, model);
}
var newInstance16 = macro.newInstance(extend15, "vtkDataSet");
var vtkDataSet$1 = __spreadValues({
  newInstance: newInstance16,
  extend: extend15
}, Constants4);

// node_modules/@kitware/vtk.js/Common/DataModel/PointSet.js
function vtkPointSet(publicAPI, model) {
  model.classHierarchy.push("vtkPointSet");
  if (!model.points) {
    model.points = vtkPoints$1.newInstance();
  } else {
    model.points = vtk(model.points);
  }
  publicAPI.getNumberOfPoints = () => model.points.getNumberOfPoints();
  publicAPI.getBounds = () => model.points.getBounds();
  publicAPI.computeBounds = () => {
    publicAPI.getBounds();
  };
  const superShallowCopy = publicAPI.shallowCopy;
  publicAPI.shallowCopy = function(other) {
    let debug = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    superShallowCopy(other, debug);
    model.points = vtkPoints$1.newInstance();
    model.points.shallowCopy(other.getPoints());
  };
}
var DEFAULT_VALUES15 = {
  // points: null,
};
function extend16(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES15, initialValues);
  vtkDataSet$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["points"]);
  vtkPointSet(publicAPI, model);
}
var newInstance17 = macro.newInstance(extend16, "vtkPointSet");
var vtkPointSet$1 = {
  newInstance: newInstance17,
  extend: extend16
};

// node_modules/@kitware/vtk.js/Common/DataModel/Plane.js
var PLANE_TOLERANCE = 1e-6;
var COINCIDE = "coincide";
var DISJOINT = "disjoint";
function evaluate2(normal, origin2, x2) {
  return normal[0] * (x2[0] - origin2[0]) + normal[1] * (x2[1] - origin2[1]) + normal[2] * (x2[2] - origin2[2]);
}
function distanceToPlane(x2, origin2, normal) {
  const distance3 = normal[0] * (x2[0] - origin2[0]) + normal[1] * (x2[1] - origin2[1]) + normal[2] * (x2[2] - origin2[2]);
  return Math.abs(distance3);
}
function projectPoint(x2, origin2, normal, xproj) {
  const xo = [];
  subtract5(x2, origin2, xo);
  const t9 = dot4(normal, xo);
  xproj[0] = x2[0] - t9 * normal[0];
  xproj[1] = x2[1] - t9 * normal[1];
  xproj[2] = x2[2] - t9 * normal[2];
}
function projectVector2(v2, normal, vproj) {
  const t9 = dot4(v2, normal);
  let n22 = dot4(normal, normal);
  if (n22 === 0) {
    n22 = 1;
  }
  vproj[0] = v2[0] - t9 * normal[0] / n22;
  vproj[1] = v2[1] - t9 * normal[1] / n22;
  vproj[2] = v2[2] - t9 * normal[2] / n22;
  return vproj;
}
function generalizedProjectPoint(x2, origin2, normal, xproj) {
  const xo = [];
  subtract5(x2, origin2, xo);
  const t9 = dot4(normal, xo);
  const n22 = dot4(normal, normal);
  if (n22 !== 0) {
    xproj[0] = x2[0] - t9 * normal[0] / n22;
    xproj[1] = x2[1] - t9 * normal[1] / n22;
    xproj[2] = x2[2] - t9 * normal[2] / n22;
  } else {
    xproj[0] = x2[0];
    xproj[1] = x2[1];
    xproj[2] = x2[2];
  }
}
function intersectWithLine(p1, p22, origin2, normal) {
  const outObj = {
    intersection: false,
    betweenPoints: false,
    t: Number.MAX_VALUE,
    x: []
  };
  const p21 = [];
  const p1Origin = [];
  subtract5(p22, p1, p21);
  subtract5(origin2, p1, p1Origin);
  const num = dot4(normal, p1Origin);
  const den = dot4(normal, p21);
  let fabsden;
  let fabstolerance;
  if (den < 0) {
    fabsden = -den;
  } else {
    fabsden = den;
  }
  if (num < 0) {
    fabstolerance = -num * PLANE_TOLERANCE;
  } else {
    fabstolerance = num * PLANE_TOLERANCE;
  }
  if (fabsden <= fabstolerance) {
    return outObj;
  }
  outObj.t = num / den;
  outObj.x[0] = p1[0] + outObj.t * p21[0];
  outObj.x[1] = p1[1] + outObj.t * p21[1];
  outObj.x[2] = p1[2] + outObj.t * p21[2];
  outObj.intersection = true;
  outObj.betweenPoints = outObj.t >= 0 && outObj.t <= 1;
  return outObj;
}
function intersectWithPlane(plane1Origin, plane1Normal, plane2Origin, plane2Normal) {
  const outObj = {
    intersection: false,
    l0: [],
    l1: [],
    error: null
  };
  const cross$1 = [];
  cross3(plane1Normal, plane2Normal, cross$1);
  const absCross = cross$1.map((n9) => Math.abs(n9));
  if (absCross[0] + absCross[1] + absCross[2] < PLANE_TOLERANCE) {
    const v2 = [];
    subtract5(plane1Origin, plane2Origin, v2);
    if (dot4(plane1Normal, v2) === 0) {
      outObj.error = COINCIDE;
    } else {
      outObj.error = DISJOINT;
    }
    return outObj;
  }
  let maxc;
  if (absCross[0] > absCross[1] && absCross[0] > absCross[2]) {
    maxc = "x";
  } else if (absCross[1] > absCross[2]) {
    maxc = "y";
  } else {
    maxc = "z";
  }
  const iP = [];
  const d1 = -dot4(plane1Normal, plane1Origin);
  const d22 = -dot4(plane2Normal, plane2Origin);
  switch (maxc) {
    case "x":
      iP[0] = 0;
      iP[1] = (d22 * plane1Normal[2] - d1 * plane2Normal[2]) / cross$1[0];
      iP[2] = (d1 * plane2Normal[1] - d22 * plane1Normal[1]) / cross$1[0];
      break;
    case "y":
      iP[0] = (d1 * plane2Normal[2] - d22 * plane1Normal[2]) / cross$1[1];
      iP[1] = 0;
      iP[2] = (d22 * plane1Normal[0] - d1 * plane2Normal[0]) / cross$1[1];
      break;
    case "z":
      iP[0] = (d22 * plane1Normal[1] - d1 * plane2Normal[1]) / cross$1[2];
      iP[1] = (d1 * plane2Normal[0] - d22 * plane1Normal[0]) / cross$1[2];
      iP[2] = 0;
      break;
  }
  outObj.l0 = iP;
  add6(iP, cross$1, outObj.l1);
  outObj.intersection = true;
  return outObj;
}
var STATIC5 = {
  evaluate: evaluate2,
  distanceToPlane,
  projectPoint,
  projectVector: projectVector2,
  generalizedProjectPoint,
  intersectWithLine,
  intersectWithPlane,
  DISJOINT,
  COINCIDE
};
function vtkPlane(publicAPI, model) {
  model.classHierarchy.push("vtkPlane");
  publicAPI.distanceToPlane = (x2) => distanceToPlane(x2, model.origin, model.normal);
  publicAPI.projectPoint = (x2, xproj) => {
    projectPoint(x2, model.origin, model.normal, xproj);
  };
  publicAPI.projectVector = (v2, vproj) => projectVector2(v2, model.normal, vproj);
  publicAPI.push = (distance3) => {
    if (distance3 === 0) {
      return;
    }
    for (let i6 = 0; i6 < 3; i6++) {
      model.origin[i6] += distance3 * model.normal[i6];
    }
  };
  publicAPI.generalizedProjectPoint = (x2, xproj) => {
    generalizedProjectPoint(x2, model.origin, model.normal, xproj);
  };
  publicAPI.evaluateFunction = (x2, y3, z3) => {
    if (!Array.isArray(x2)) {
      return model.normal[0] * (x2 - model.origin[0]) + model.normal[1] * (y3 - model.origin[1]) + model.normal[2] * (z3 - model.origin[2]);
    }
    return model.normal[0] * (x2[0] - model.origin[0]) + model.normal[1] * (x2[1] - model.origin[1]) + model.normal[2] * (x2[2] - model.origin[2]);
  };
  publicAPI.evaluateGradient = (xyz) => {
    const retVal = [model.normal[0], model.normal[1], model.normal[2]];
    return retVal;
  };
  publicAPI.intersectWithLine = (p1, p22) => intersectWithLine(p1, p22, model.origin, model.normal);
  publicAPI.intersectWithPlane = (planeOrigin, planeNormal) => intersectWithPlane(planeOrigin, planeNormal, model.origin, model.normal);
}
var DEFAULT_VALUES16 = {
  normal: [0, 0, 1],
  origin: [0, 0, 0]
};
function extend17(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES16, initialValues);
  macro.obj(publicAPI, model);
  macro.setGetArray(publicAPI, model, ["normal", "origin"], 3);
  vtkPlane(publicAPI, model);
}
var newInstance18 = macro.newInstance(extend17, "vtkPlane");
var vtkPlane$1 = __spreadValues({
  newInstance: newInstance18,
  extend: extend17
}, STATIC5);

// node_modules/@kitware/vtk.js/Common/DataModel/Triangle.js
function computeNormalDirection(v1, v2, v3, n9) {
  const ax = v3[0] - v2[0];
  const ay = v3[1] - v2[1];
  const az = v3[2] - v2[2];
  const bx = v1[0] - v2[0];
  const by = v1[1] - v2[1];
  const bz = v1[2] - v2[2];
  n9[0] = ay * bz - az * by;
  n9[1] = az * bx - ax * bz;
  n9[2] = ax * by - ay * bx;
}
function computeNormal(v1, v2, v3, n9) {
  computeNormalDirection(v1, v2, v3, n9);
  const length4 = Math.sqrt(n9[0] * n9[0] + n9[1] * n9[1] + n9[2] * n9[2]);
  if (length4 !== 0) {
    n9[0] /= length4;
    n9[1] /= length4;
    n9[2] /= length4;
  }
}
function intersectWithTriangle(p1, q1, r1, p22, q2, r22) {
  let tolerance = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : 1e-6;
  let coplanar = false;
  const pt1 = [];
  const pt2 = [];
  const surfaceId = [];
  const n1 = [];
  const n22 = [];
  computeNormal(p1, q1, r1, n1);
  computeNormal(p22, q2, r22, n22);
  const s1 = -dot4(n1, p1);
  const s22 = -dot4(n22, p22);
  const dist1 = [dot4(n22, p1) + s22, dot4(n22, q1) + s22, dot4(n22, r1) + s22];
  if (dist1[0] * dist1[1] > tolerance && dist1[0] * dist1[2] > tolerance) {
    return {
      intersect: false,
      coplanar,
      pt1,
      pt2,
      surfaceId
    };
  }
  const dist22 = [dot4(n1, p22) + s1, dot4(n1, q2) + s1, dot4(n1, r22) + s1];
  if (dist22[0] * dist22[1] > tolerance && dist22[0] * dist22[2] > tolerance) {
    return {
      intersect: false,
      coplanar,
      pt1,
      pt2,
      surfaceId
    };
  }
  if (Math.abs(n1[0] - n22[0]) < 1e-9 && Math.abs(n1[1] - n22[1]) < 1e-9 && Math.abs(n1[2] - n22[2]) < 1e-9 && Math.abs(s1 - s22) < 1e-9) {
    coplanar = true;
    return {
      intersect: false,
      coplanar,
      pt1,
      pt2,
      surfaceId
    };
  }
  const pts1 = [p1, q1, r1];
  const pts2 = [p22, q2, r22];
  const n1n2 = dot4(n1, n22);
  const a4 = (s1 - s22 * n1n2) / (n1n2 * n1n2 - 1);
  const b3 = (s22 - s1 * n1n2) / (n1n2 * n1n2 - 1);
  const p3 = [a4 * n1[0] + b3 * n22[0], a4 * n1[1] + b3 * n22[1], a4 * n1[2] + b3 * n22[2]];
  const v2 = cross3(n1, n22, []);
  normalize4(v2);
  let index1 = 0;
  let index2 = 0;
  const t1 = [];
  const t22 = [];
  let ts1 = 50;
  let ts2 = 50;
  for (let i6 = 0; i6 < 3; i6++) {
    const id1 = i6;
    const id2 = (i6 + 1) % 3;
    const val1 = vtkPlane$1.intersectWithLine(pts1[id1], pts1[id2], p22, n22);
    if (val1.intersection && val1.t > 0 - tolerance && val1.t < 1 + tolerance) {
      if (val1.t < 1 + tolerance && val1.t > 1 - tolerance) {
        ts1 = index1;
      }
      t1[index1++] = dot4(val1.x, v2) - dot4(p3, v2);
    }
    const val2 = vtkPlane$1.intersectWithLine(pts2[id1], pts2[id2], p1, n1);
    if (val2.intersection && val2.t > 0 - tolerance && val2.t < 1 + tolerance) {
      if (val2.t < 1 + tolerance && val2.t > 1 - tolerance) {
        ts2 = index2;
      }
      t22[index2++] = dot4(val2.x, v2) - dot4(p3, v2);
    }
  }
  if (index1 > 2) {
    index1--;
    const t12 = t1[2];
    t1[2] = t1[ts1];
    t1[ts1] = t12;
  }
  if (index2 > 2) {
    index2--;
    const t222 = t22[2];
    t22[2] = t22[ts2];
    t22[ts2] = t222;
  }
  if (index1 !== 2 || index2 !== 2) {
    return {
      intersect: false,
      coplanar,
      pt1,
      pt2,
      surfaceId
    };
  }
  if (Number.isNaN(t1[0]) || Number.isNaN(t1[1]) || Number.isNaN(t22[0]) || Number.isNaN(t22[1])) {
    return {
      intersect: false,
      coplanar,
      pt1,
      pt2,
      surfaceId
    };
  }
  if (t1[0] > t1[1]) {
    const t11 = t1[1];
    t1[1] = t1[0];
    t1[0] = t11;
  }
  if (t22[0] > t22[1]) {
    const t21 = t22[1];
    t22[1] = t22[0];
    t22[0] = t21;
  }
  let tt1;
  let tt2;
  if (t1[1] < t22[0] || t22[1] < t1[0]) {
    return {
      intersect: false,
      coplanar,
      pt1,
      pt2,
      surfaceId
    };
  }
  if (t1[0] < t22[0]) {
    if (t1[1] < t22[1]) {
      surfaceId[0] = 2;
      surfaceId[1] = 1;
      tt1 = t22[0];
      tt2 = t1[1];
    } else {
      surfaceId[0] = 2;
      surfaceId[1] = 2;
      tt1 = t22[0];
      tt2 = t22[1];
    }
  } else if (t1[1] < t22[1]) {
    surfaceId[0] = 1;
    surfaceId[1] = 1;
    tt1 = t1[0];
    tt2 = t1[1];
  } else {
    surfaceId[0] = 1;
    surfaceId[1] = 2;
    tt1 = t1[0];
    tt2 = t22[1];
  }
  multiplyAccumulate(p3, v2, tt1, pt1);
  multiplyAccumulate(p3, v2, tt2, pt2);
  return {
    intersect: true,
    coplanar,
    pt1,
    pt2,
    surfaceId
  };
}
var STATIC6 = {
  computeNormalDirection,
  computeNormal,
  intersectWithTriangle
};
function vtkTriangle(publicAPI, model) {
  model.classHierarchy.push("vtkTriangle");
  publicAPI.getCellDimension = () => 2;
  publicAPI.intersectWithLine = (p1, p22, tol, x2, pcoords) => {
    const outObj = {
      subId: 0,
      t: Number.MAX_VALUE,
      intersect: 0,
      betweenPoints: false
    };
    pcoords[2] = 0;
    const closestPoint = [];
    const tol2 = tol * tol;
    const pt1 = [];
    const pt2 = [];
    const pt3 = [];
    model.points.getPoint(0, pt1);
    model.points.getPoint(1, pt2);
    model.points.getPoint(2, pt3);
    const n9 = [];
    const weights = [];
    computeNormal(pt1, pt2, pt3, n9);
    if (n9[0] !== 0 || n9[1] !== 0 || n9[2] !== 0) {
      const plane = vtkPlane$1.intersectWithLine(p1, p22, pt1, n9);
      outObj.betweenPoints = plane.betweenPoints;
      outObj.t = plane.t;
      x2[0] = plane.x[0];
      x2[1] = plane.x[1];
      x2[2] = plane.x[2];
      if (!plane.intersection) {
        pcoords[0] = 0;
        pcoords[1] = 0;
        outObj.intersect = 0;
        return outObj;
      }
      const inside = publicAPI.evaluatePosition(x2, closestPoint, pcoords, weights);
      if (inside.evaluation >= 0) {
        if (inside.dist2 <= tol2) {
          outObj.intersect = 1;
          return outObj;
        }
        outObj.intersect = inside.evaluation;
        return outObj;
      }
    }
    const dist2Pt1Pt2 = distance2BetweenPoints(pt1, pt2);
    const dist2Pt2Pt3 = distance2BetweenPoints(pt2, pt3);
    const dist2Pt3Pt1 = distance2BetweenPoints(pt3, pt1);
    if (!model.line) {
      model.line = vtkLine$1.newInstance();
    }
    if (dist2Pt1Pt2 > dist2Pt2Pt3 && dist2Pt1Pt2 > dist2Pt3Pt1) {
      model.line.getPoints().setPoint(0, pt1);
      model.line.getPoints().setPoint(1, pt2);
    } else if (dist2Pt2Pt3 > dist2Pt3Pt1 && dist2Pt2Pt3 > dist2Pt1Pt2) {
      model.line.getPoints().setPoint(0, pt2);
      model.line.getPoints().setPoint(1, pt3);
    } else {
      model.line.getPoints().setPoint(0, pt3);
      model.line.getPoints().setPoint(1, pt1);
    }
    const intersectLine = model.line.intersectWithLine(p1, p22, tol, x2, pcoords);
    outObj.betweenPoints = intersectLine.betweenPoints;
    outObj.t = intersectLine.t;
    if (intersectLine.intersect) {
      const pt3Pt1 = [];
      const pt3Pt2 = [];
      const pt3X = [];
      for (let i6 = 0; i6 < 3; i6++) {
        pt3Pt1[i6] = pt1[i6] - pt3[i6];
        pt3Pt2[i6] = pt2[i6] - pt3[i6];
        pt3X[i6] = x2[i6] - pt3[i6];
      }
      pcoords[0] = dot4(pt3X, pt3Pt1) / dist2Pt3Pt1;
      pcoords[1] = dot4(pt3X, pt3Pt2) / dist2Pt2Pt3;
      outObj.intersect = 1;
      return outObj;
    }
    pcoords[0] = 0;
    pcoords[1] = 0;
    outObj.intersect = 0;
    return outObj;
  };
  publicAPI.evaluatePosition = (x2, closestPoint, pcoords, weights) => {
    const outObj = {
      subId: 0,
      dist2: 0,
      evaluation: -1
    };
    let i6;
    let j2;
    const pt1 = [];
    const pt2 = [];
    const pt3 = [];
    const n9 = [];
    let fabsn;
    const rhs = [];
    const c1 = [];
    const c22 = [];
    let det = 0;
    let idx = 0;
    const indices = [];
    let dist2Point;
    let dist2Line1;
    let dist2Line2;
    let closest = [];
    const closestPoint1 = [];
    const closestPoint2 = [];
    const cp = [];
    outObj.subId = 0;
    pcoords[2] = 0;
    model.points.getPoint(1, pt1);
    model.points.getPoint(2, pt2);
    model.points.getPoint(0, pt3);
    computeNormalDirection(pt1, pt2, pt3, n9);
    vtkPlane$1.generalizedProjectPoint(x2, pt1, n9, cp);
    let maxComponent = 0;
    for (i6 = 0; i6 < 3; i6++) {
      if (n9[i6] < 0) {
        fabsn = -n9[i6];
      } else {
        fabsn = n9[i6];
      }
      if (fabsn > maxComponent) {
        maxComponent = fabsn;
        idx = i6;
      }
    }
    for (j2 = 0, i6 = 0; i6 < 3; i6++) {
      if (i6 !== idx) {
        indices[j2++] = i6;
      }
    }
    for (i6 = 0; i6 < 2; i6++) {
      rhs[i6] = cp[indices[i6]] - pt3[indices[i6]];
      c1[i6] = pt1[indices[i6]] - pt3[indices[i6]];
      c22[i6] = pt2[indices[i6]] - pt3[indices[i6]];
    }
    det = determinant2x2(c1, c22);
    if (det === 0) {
      pcoords[0] = 0;
      pcoords[1] = 0;
      outObj.evaluation = -1;
      return outObj;
    }
    pcoords[0] = determinant2x2(rhs, c22) / det;
    pcoords[1] = determinant2x2(c1, rhs) / det;
    weights[0] = 1 - (pcoords[0] + pcoords[1]);
    weights[1] = pcoords[0];
    weights[2] = pcoords[1];
    if (weights[0] >= 0 && weights[0] <= 1 && weights[1] >= 0 && weights[1] <= 1 && weights[2] >= 0 && weights[2] <= 1) {
      if (closestPoint) {
        outObj.dist2 = distance2BetweenPoints(cp, x2);
        closestPoint[0] = cp[0];
        closestPoint[1] = cp[1];
        closestPoint[2] = cp[2];
      }
      outObj.evaluation = 1;
    } else {
      let t9;
      if (closestPoint) {
        if (weights[1] < 0 && weights[2] < 0) {
          dist2Point = distance2BetweenPoints(x2, pt3);
          dist2Line1 = vtkLine$1.distanceToLine(x2, pt1, pt3, t9, closestPoint1);
          dist2Line2 = vtkLine$1.distanceToLine(x2, pt3, pt2, t9, closestPoint2);
          if (dist2Point < dist2Line1) {
            outObj.dist2 = dist2Point;
            closest = pt3;
          } else {
            outObj.dist2 = dist2Line1;
            closest = closestPoint1;
          }
          if (dist2Line2 < outObj.dist2) {
            outObj.dist2 = dist2Line2;
            closest = closestPoint2;
          }
          for (i6 = 0; i6 < 3; i6++) {
            closestPoint[i6] = closest[i6];
          }
        } else if (weights[2] < 0 && weights[0] < 0) {
          dist2Point = distance2BetweenPoints(x2, pt1);
          dist2Line1 = vtkLine$1.distanceToLine(x2, pt1, pt3, t9, closestPoint1);
          dist2Line2 = vtkLine$1.distanceToLine(x2, pt1, pt2, t9, closestPoint2);
          if (dist2Point < dist2Line1) {
            outObj.dist2 = dist2Point;
            closest = pt1;
          } else {
            outObj.dist2 = dist2Line1;
            closest = closestPoint1;
          }
          if (dist2Line2 < outObj.dist2) {
            outObj.dist2 = dist2Line2;
            closest = closestPoint2;
          }
          for (i6 = 0; i6 < 3; i6++) {
            closestPoint[i6] = closest[i6];
          }
        } else if (weights[1] < 0 && weights[0] < 0) {
          dist2Point = distance2BetweenPoints(x2, pt2);
          dist2Line1 = vtkLine$1.distanceToLine(x2, pt2, pt3, t9, closestPoint1);
          dist2Line2 = vtkLine$1.distanceToLine(x2, pt1, pt2, t9, closestPoint2);
          if (dist2Point < dist2Line1) {
            outObj.dist2 = dist2Point;
            closest = pt2;
          } else {
            outObj.dist2 = dist2Line1;
            closest = closestPoint1;
          }
          if (dist2Line2 < outObj.dist2) {
            outObj.dist2 = dist2Line2;
            closest = closestPoint2;
          }
          for (i6 = 0; i6 < 3; i6++) {
            closestPoint[i6] = closest[i6];
          }
        } else if (weights[0] < 0) {
          const lineDistance = vtkLine$1.distanceToLine(x2, pt1, pt2, closestPoint);
          outObj.dist2 = lineDistance.distance;
        } else if (weights[1] < 0) {
          const lineDistance = vtkLine$1.distanceToLine(x2, pt2, pt3, closestPoint);
          outObj.dist2 = lineDistance.distance;
        } else if (weights[2] < 0) {
          const lineDistance = vtkLine$1.distanceToLine(x2, pt1, pt3, closestPoint);
          outObj.dist2 = lineDistance.distance;
        }
      }
      outObj.evaluation = 0;
    }
    return outObj;
  };
  publicAPI.evaluateLocation = (pcoords, x2, weights) => {
    const p0 = [];
    const p1 = [];
    const p22 = [];
    model.points.getPoint(0, p0);
    model.points.getPoint(1, p1);
    model.points.getPoint(2, p22);
    const u32 = 1 - pcoords[0] - pcoords[1];
    for (let i6 = 0; i6 < 3; i6++) {
      x2[i6] = p0[i6] * u32 + p1[i6] * pcoords[0] + p22[i6] * pcoords[1];
    }
    weights[0] = u32;
    weights[1] = pcoords[0];
    weights[2] = pcoords[1];
  };
  publicAPI.getParametricDistance = (pcoords) => {
    let pDist;
    let pDistMax = 0;
    const pc = [];
    pc[0] = pcoords[0];
    pc[1] = pcoords[1];
    pc[2] = 1 - pcoords[0] - pcoords[1];
    for (let i6 = 0; i6 < 3; i6++) {
      if (pc[i6] < 0) {
        pDist = -pc[i6];
      } else if (pc[i6] > 1) {
        pDist = pc[i6] - 1;
      } else {
        pDist = 0;
      }
      if (pDist > pDistMax) {
        pDistMax = pDist;
      }
    }
    return pDistMax;
  };
}
var DEFAULT_VALUES17 = {};
function extend18(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES17, initialValues);
  vtkCell$1.extend(publicAPI, model, initialValues);
  vtkTriangle(publicAPI, model);
}
var newInstance19 = macro.newInstance(extend18, "vtkTriangle");
var vtkTriangle$1 = __spreadValues({
  newInstance: newInstance19,
  extend: extend18
}, STATIC6);

// node_modules/@kitware/vtk.js/Common/DataModel/PolyData/Constants.js
var POLYDATA_FIELDS = ["verts", "lines", "polys", "strips"];

// node_modules/@kitware/vtk.js/Common/DataModel/PolyData.js
var {
  vtkWarningMacro: vtkWarningMacro5
} = macro;
var CELL_FACTORY = {
  [CellType.VTK_LINE]: vtkLine$1,
  [CellType.VTK_POLY_LINE]: vtkLine$1,
  [CellType.VTK_TRIANGLE]: vtkTriangle$1
};
function vtkPolyData(publicAPI, model) {
  model.classHierarchy.push("vtkPolyData");
  function camelize(str6) {
    return str6.replace(/(?:^\w|[A-Z]|\b\w)/g, (letter) => letter.toUpperCase()).replace(/\s+/g, "");
  }
  POLYDATA_FIELDS.forEach((type) => {
    publicAPI[`getNumberOf${camelize(type)}`] = () => model[type].getNumberOfCells();
    if (!model[type]) {
      model[type] = vtkCellArray$1.newInstance();
    } else {
      model[type] = vtk(model[type]);
    }
  });
  publicAPI.getNumberOfCells = () => POLYDATA_FIELDS.reduce((num, cellType) => num + model[cellType].getNumberOfCells(), 0);
  const superShallowCopy = publicAPI.shallowCopy;
  publicAPI.shallowCopy = function(other) {
    let debug = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    superShallowCopy(other, debug);
    POLYDATA_FIELDS.forEach((type) => {
      model[type] = vtkCellArray$1.newInstance();
      model[type].shallowCopy(other.getReferenceByName(type));
    });
  };
  publicAPI.buildCells = () => {
    const nVerts = publicAPI.getNumberOfVerts();
    const nLines = publicAPI.getNumberOfLines();
    const nPolys = publicAPI.getNumberOfPolys();
    const nStrips = publicAPI.getNumberOfStrips();
    const nCells = nVerts + nLines + nPolys + nStrips;
    const types = new Uint8Array(nCells);
    let pTypes = types;
    const locs = new Uint32Array(nCells);
    let pLocs = locs;
    if (nVerts) {
      let nextCellPts = 0;
      model.verts.getCellSizes().forEach((numCellPts, index2) => {
        pLocs[index2] = nextCellPts;
        pTypes[index2] = numCellPts > 1 ? CellType.VTK_POLY_VERTEX : CellType.VTK_VERTEX;
        nextCellPts += numCellPts + 1;
      });
      pLocs = pLocs.subarray(nVerts);
      pTypes = pTypes.subarray(nVerts);
    }
    if (nLines) {
      let nextCellPts = 0;
      model.lines.getCellSizes().forEach((numCellPts, index2) => {
        pLocs[index2] = nextCellPts;
        pTypes[index2] = numCellPts > 2 ? CellType.VTK_POLY_LINE : CellType.VTK_LINE;
        if (numCellPts === 1) {
          vtkWarningMacro5("Building VTK_LINE ", index2, " with only one point, but VTK_LINE needs at least two points. Check the input.");
        }
        nextCellPts += numCellPts + 1;
      });
      pLocs = pLocs.subarray(nLines);
      pTypes = pTypes.subarray(nLines);
    }
    if (nPolys) {
      let nextCellPts = 0;
      model.polys.getCellSizes().forEach((numCellPts, index2) => {
        pLocs[index2] = nextCellPts;
        switch (numCellPts) {
          case 3:
            pTypes[index2] = CellType.VTK_TRIANGLE;
            break;
          case 4:
            pTypes[index2] = CellType.VTK_QUAD;
            break;
          default:
            pTypes[index2] = CellType.VTK_POLYGON;
            break;
        }
        if (numCellPts < 3) {
          vtkWarningMacro5("Building VTK_TRIANGLE ", index2, " with less than three points, but VTK_TRIANGLE needs at least three points. Check the input.");
        }
        nextCellPts += numCellPts + 1;
      });
      pLocs += pLocs.subarray(nPolys);
      pTypes += pTypes.subarray(nPolys);
    }
    if (nStrips) {
      let nextCellPts = 0;
      pTypes.fill(CellType.VTK_TRIANGLE_STRIP, 0, nStrips);
      model.strips.getCellSizes().forEach((numCellPts, index2) => {
        pLocs[index2] = nextCellPts;
        nextCellPts += numCellPts + 1;
      });
    }
    model.cells = vtkCellTypes$1.newInstance();
    model.cells.setCellTypes(nCells, types, locs);
  };
  publicAPI.buildLinks = function() {
    let initialSize = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    if (model.cells === void 0) {
      publicAPI.buildCells();
    }
    model.links = vtkCellLinks$1.newInstance();
    if (initialSize > 0) {
      model.links.allocate(initialSize);
    } else {
      model.links.allocate(publicAPI.getPoints().getNumberOfPoints());
    }
    model.links.buildLinks(publicAPI);
  };
  publicAPI.getCellType = (cellId) => model.cells.getCellType(cellId);
  publicAPI.getCellPoints = (cellId) => {
    const cellType = publicAPI.getCellType(cellId);
    let cells = null;
    switch (cellType) {
      case CellType.VTK_VERTEX:
      case CellType.VTK_POLY_VERTEX:
        cells = model.verts;
        break;
      case CellType.VTK_LINE:
      case CellType.VTK_POLY_LINE:
        cells = model.lines;
        break;
      case CellType.VTK_TRIANGLE:
      case CellType.VTK_QUAD:
      case CellType.VTK_POLYGON:
        cells = model.polys;
        break;
      case CellType.VTK_TRIANGLE_STRIP:
        cells = model.strips;
        break;
      default:
        cells = null;
        return {
          type: 0,
          cellPointIds: null
        };
    }
    const loc = model.cells.getCellLocation(cellId);
    const cellPointIds = cells.getCell(loc);
    return {
      cellType,
      cellPointIds
    };
  };
  publicAPI.getPointCells = (ptId) => model.links.getCells(ptId);
  publicAPI.getCellEdgeNeighbors = (cellId, point1, point2) => {
    const link1 = model.links.getLink(point1);
    const link2 = model.links.getLink(point2);
    return link1.cells.filter((cell) => cell !== cellId && link2.cells.indexOf(cell) !== -1);
  };
  publicAPI.getCell = function(cellId) {
    let cellHint = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    const cellInfo = publicAPI.getCellPoints(cellId);
    const cell = cellHint || CELL_FACTORY[cellInfo.cellType].newInstance();
    cell.initialize(publicAPI.getPoints(), cellInfo.cellPointIds);
    return cell;
  };
}
var DEFAULT_VALUES18 = {
  // verts: null,
  // lines: null,
  // polys: null,
  // strips: null,
  // cells: null,
  // links: null,
};
function extend19(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES18, initialValues);
  vtkPointSet$1.extend(publicAPI, model, initialValues);
  macro.get(publicAPI, model, ["cells", "links"]);
  macro.setGet(publicAPI, model, ["verts", "lines", "polys", "strips"]);
  vtkPolyData(publicAPI, model);
}
var newInstance20 = macro.newInstance(extend19, "vtkPolyData");
var vtkPolyData$1 = {
  newInstance: newInstance20,
  extend: extend19
};

// node_modules/@kitware/vtk.js/Filters/General/ClosedPolyLineToSurfaceFilter.js
var {
  vtkErrorMacro: vtkErrorMacro8
} = macro;
var SegmentAgregator = class {
  constructor() {
    this.segmentMapping = {};
    this.segments = [null];
    this.faces = [];
  }
  addSegment(segment) {
    const first = segment[0];
    const last = segment[segment.length - 1];
    if (first === last || segment.length < 2) {
      return;
    }
    const mappingFirst = this.segmentMapping[first];
    const mappingLast = this.segmentMapping[last];
    if (mappingFirst !== void 0 && mappingLast !== void 0) {
      if (Math.abs(mappingFirst) === Math.abs(mappingLast)) {
        const idx = mappingFirst < mappingLast ? mappingLast : mappingFirst;
        const seg = this.segments[idx];
        if (mappingFirst > 0) {
          for (let i6 = 1; i6 < segment.length - 1; i6++) {
            seg.push(segment[i6]);
          }
        } else {
          for (let i6 = 1; i6 < segment.length - 1; i6++) {
            seg.unshift(segment[segment.length - 1 - i6]);
          }
        }
        this.faces.push(seg);
        this.segments[idx] = null;
        this.segmentMapping[first] = void 0;
        this.segmentMapping[last] = void 0;
      } else {
        const idxHead = Math.abs(mappingFirst);
        const idxTail = Math.abs(mappingLast);
        const segHead = this.segments[idxHead];
        const segTail = this.segments[idxTail];
        this.segments[idxHead] = null;
        this.segments[idxTail] = null;
        this.segmentMapping[segHead[0]] = void 0;
        this.segmentMapping[segTail[0]] = void 0;
        this.segmentMapping[segHead[segHead.length - 1]] = void 0;
        this.segmentMapping[segTail[segTail.length - 1]] = void 0;
        this.addSegment(segment);
        this.addSegment(segHead);
        this.addSegment(segTail);
      }
    } else if (mappingFirst !== void 0) {
      if (mappingFirst > 0) {
        const seg = this.segments[mappingFirst];
        for (let i6 = 1; i6 < segment.length; i6++) {
          seg.push(segment[i6]);
        }
        this.segmentMapping[last] = mappingFirst;
      } else {
        const seg = this.segments[-mappingFirst];
        this.segmentMapping[last] = mappingFirst;
        for (let i6 = 1; i6 < segment.length; i6++) {
          seg.unshift(segment[i6]);
        }
      }
      this.segmentMapping[first] = void 0;
    } else if (mappingLast !== void 0) {
      if (mappingLast > 0) {
        const seg = this.segments[mappingLast];
        for (let i6 = 1; i6 < segment.length; i6++) {
          seg.push(segment[segment.length - 1 - i6]);
        }
        this.segmentMapping[first] = mappingLast;
      } else {
        const seg = this.segments[-mappingLast];
        this.segmentMapping[first] = mappingLast;
        for (let i6 = 1; i6 < segment.length; i6++) {
          seg.unshift(segment[segment.length - i6 - 1]);
        }
      }
      this.segmentMapping[last] = void 0;
    } else {
      const id = this.segments.length;
      this.segments.push(segment);
      this.segmentMapping[first] = -id;
      this.segmentMapping[last] = id;
    }
  }
};
function vtkClosedPolyLineToSurfaceFilter(publicAPI, model) {
  model.classHierarchy.push("vtkClosedPolyLineToSurfaceFilter");
  publicAPI.requestData = (inData, outData) => {
    const input = inData[0];
    if (!input) {
      vtkErrorMacro8("Invalid or missing input");
      return;
    }
    const output = vtkPolyData$1.newInstance();
    output.shallowCopy(input);
    const agregator = new SegmentAgregator();
    const lines = input.getLines().getData();
    let offset3 = 0;
    while (offset3 < lines.length) {
      const lineSize = lines[offset3++];
      const lineSegment = [];
      for (let i6 = 0; i6 < lineSize; i6++) {
        lineSegment.push(lines[offset3 + i6]);
      }
      agregator.addSegment(lineSegment);
      offset3 += lineSize;
    }
    const {
      faces
    } = agregator;
    let cellArraySize = faces.length;
    for (let i6 = 0; i6 < faces.length; i6++) {
      cellArraySize += faces[i6].length;
    }
    const cellArray = new Uint16Array(cellArraySize);
    offset3 = 0;
    for (let i6 = 0; i6 < faces.length; i6++) {
      const face = faces[i6];
      cellArray[offset3++] = face.length;
      for (let j2 = 0; j2 < face.length; j2++) {
        cellArray[offset3++] = face[j2];
      }
    }
    output.setPolys(vtkCellArray$1.newInstance({
      values: cellArray,
      name: "faces"
    }));
    outData[0] = output;
  };
}
var DEFAULT_VALUES19 = {};
function extend20(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES19, initialValues);
  macro.obj(publicAPI, model);
  macro.algo(publicAPI, model, 1, 1);
  vtkClosedPolyLineToSurfaceFilter(publicAPI, model);
}
var newInstance21 = macro.newInstance(extend20, "vtkClosedPolyLineToSurfaceFilter");
var vtkClosedPolyLineToSurfaceFilter$1 = {
  newInstance: newInstance21,
  extend: extend20
};

// node_modules/@kitware/vtk.js/Filters/Core/Cutter.js
var {
  vtkErrorMacro: vtkErrorMacro9
} = macro$1;
function initPolyIterator(pd) {
  const polys = pd.getPolys().getData();
  const strips = pd.getStrips().getData();
  const it = {
    cellSize: 0,
    cell: [],
    done: false,
    polyIdx: 0,
    stripIdx: 0,
    remainingStripLength: 0,
    // returns a single poly cell
    next() {
      if (it.polyIdx < polys.length) {
        it.cellSize = polys[it.polyIdx];
        const start = it.polyIdx + 1;
        const end = start + it.cellSize;
        it.polyIdx = end;
        let p3 = 0;
        for (let i6 = start; i6 < end; ++i6) {
          it.cell[p3++] = polys[i6];
        }
      } else if (it.stripIdx < strips.length) {
        it.cellSize = 3;
        if (it.remainingStripLength === 0) {
          it.remainingStripLength = strips[it.stripIdx] - 2;
          it.stripIdx += 3;
        }
        const start = it.stripIdx - 2;
        const end = it.stripIdx + 1;
        it.stripIdx++;
        it.remainingStripLength--;
        let p3 = 0;
        for (let i6 = start; i6 < end; ++i6) {
          it.cell[p3++] = strips[i6];
        }
      } else if (!it.done) {
        it.done = true;
      } else {
        throw new Error("Iterator is done");
      }
    }
  };
  it.next();
  return it;
}
function vtkCutter(publicAPI, model) {
  model.classHierarchy.push("vtkCutter");
  const superClass = __spreadValues({}, publicAPI);
  publicAPI.getMTime = () => {
    let mTime = superClass.getMTime();
    if (!model.cutFunction) {
      return mTime;
    }
    mTime = Math.max(mTime, model.cutFunction.getMTime());
    return mTime;
  };
  function dataSetCutter(input, output) {
    const points = input.getPoints();
    const pointsData = points.getData();
    const numPts = points.getNumberOfPoints();
    const newPointsData = [];
    const newLinesData = [];
    const newPolysData = [];
    if (!model.cutScalars || model.cutScalars.length < numPts) {
      model.cutScalars = new Float32Array(numPts);
    }
    let inOffset = 0;
    let outOffset = 0;
    while (inOffset < pointsData.length) {
      model.cutScalars[outOffset++] = model.cutFunction.evaluateFunction(pointsData[inOffset++], pointsData[inOffset++], pointsData[inOffset++]);
    }
    const crossedEdges = [];
    const x1 = new Array(3);
    const x2 = new Array(3);
    const cellPointsScalars = [];
    for (const it = initPolyIterator(input); !it.done; it.next()) {
      if (it.cellSize <= 2) {
        continue;
      }
      for (let i6 = 0; i6 < it.cellSize; ) {
        cellPointsScalars[i6] = model.cutScalars[it.cell[i6++]];
      }
      const sideFirstPoint = cellPointsScalars[0] > 0;
      let allPointsSameSide = true;
      for (let i6 = 1; i6 < it.cell.length; i6++) {
        const sideCurrentPoint = cellPointsScalars[i6] > 0;
        if (sideCurrentPoint !== sideFirstPoint) {
          allPointsSameSide = false;
          break;
        }
      }
      if (allPointsSameSide) {
        continue;
      }
      const intersectedEdgesList = [];
      for (let i6 = 0; i6 < it.cellSize; i6++) {
        const idNext = i6 + 1 === it.cellSize ? 0 : i6 + 1;
        const signPoint0 = cellPointsScalars[i6] > 0;
        const signPoint1 = cellPointsScalars[idNext] > 0;
        if (signPoint1 === signPoint0) {
          continue;
        }
        let e1 = i6;
        let e22 = idNext;
        let deltaScalar = cellPointsScalars[e22] - cellPointsScalars[e1];
        if (deltaScalar <= 0) {
          e1 = idNext;
          e22 = i6;
          deltaScalar *= -1;
        }
        let t9 = 0;
        if (deltaScalar !== 0) {
          t9 = (model.cutValue - cellPointsScalars[e1]) / deltaScalar;
        }
        const pointID1 = it.cell[e1];
        const pointID2 = it.cell[e22];
        x1[0] = pointsData[pointID1 * 3];
        x1[1] = pointsData[pointID1 * 3 + 1];
        x1[2] = pointsData[pointID1 * 3 + 2];
        x2[0] = pointsData[pointID2 * 3];
        x2[1] = pointsData[pointID2 * 3 + 1];
        x2[2] = pointsData[pointID2 * 3 + 2];
        const computedIntersectedPoint = [x1[0] + t9 * (x2[0] - x1[0]), x1[1] + t9 * (x2[1] - x1[1]), x1[2] + t9 * (x2[2] - x1[2])];
        intersectedEdgesList.push({
          pointEdge1: pointID1,
          // id of one point of the edge
          pointEdge2: pointID2,
          // id of one point of the edge
          intersectedPoint: computedIntersectedPoint,
          // 3D coordinate of points that intersected edge
          newPointID: -1
          // id of the intersected point when it will be added into vtkPoints
        });
      }
      for (let i6 = 0; i6 < intersectedEdgesList.length; i6++) {
        const intersectedEdge = intersectedEdgesList[i6];
        let alreadyAdded = false;
        for (let j2 = 0; j2 < crossedEdges.length; j2++) {
          const crossedEdge = crossedEdges[j2];
          const sameEdge = intersectedEdge.pointEdge1 === crossedEdge.pointEdge1 && intersectedEdge.pointEdge2 === crossedEdge.pointEdge2;
          const samePoint = intersectedEdge.intersectedPoint[0] === crossedEdge.intersectedPoint[0] && intersectedEdge.intersectedPoint[1] === crossedEdge.intersectedPoint[1] && intersectedEdge.intersectedPoint[2] === crossedEdge.intersectedPoint[2];
          if (sameEdge || samePoint) {
            alreadyAdded = true;
            intersectedEdgesList[i6].newPointID = crossedEdges[j2].newPointID;
            break;
          }
        }
        if (!alreadyAdded) {
          newPointsData.push(intersectedEdge.intersectedPoint[0]);
          newPointsData.push(intersectedEdge.intersectedPoint[1]);
          newPointsData.push(intersectedEdge.intersectedPoint[2]);
          intersectedEdgesList[i6].newPointID = newPointsData.length / 3 - 1;
          crossedEdges.push(intersectedEdgesList[i6]);
        }
      }
      const cellSize = intersectedEdgesList.length;
      if (cellSize === 2) {
        newLinesData.push(cellSize, intersectedEdgesList[0].newPointID, intersectedEdgesList[1].newPointID);
      } else if (cellSize > 2) {
        newPolysData.push(cellSize);
        intersectedEdgesList.forEach((edge) => {
          newPolysData.push(edge.newPointID);
        });
      }
    }
    const outputPoints = output.getPoints();
    outputPoints.setData(newTypedArrayFrom(points.getDataType(), newPointsData), 3);
    if (newLinesData.length !== 0) {
      output.getLines().setData(Uint16Array.from(newLinesData));
    }
    if (newPolysData.length !== 0) {
      output.getPolys().setData(Uint16Array.from(newPolysData));
    }
  }
  publicAPI.requestData = (inData, outData) => {
    const input = inData[0];
    if (!input) {
      vtkErrorMacro9("Invalid or missing input");
      return;
    }
    if (!model.cutFunction) {
      vtkErrorMacro9("Missing cut function");
      return;
    }
    const output = vtkPolyData$1.newInstance();
    dataSetCutter(input, output);
    outData[0] = output;
  };
}
var DEFAULT_VALUES20 = {
  cutFunction: null,
  // support method with evaluateFunction method
  cutScalars: null,
  cutValue: 0
};
function extend21(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES20, initialValues);
  obj(publicAPI, model);
  algo(publicAPI, model, 1, 1);
  setGet(publicAPI, model, ["cutFunction", "cutValue"]);
  vtkCutter(publicAPI, model);
}
var newInstance22 = newInstance(extend21, "vtkCutter");
var vtkCutter$1 = {
  newInstance: newInstance22,
  extend: extend21
};

// node_modules/@kitware/vtk.js/Rendering/OpenGL/BufferObject/Constants.js
var ObjectType = {
  ARRAY_BUFFER: 0,
  ELEMENT_ARRAY_BUFFER: 1,
  TEXTURE_BUFFER: 2
};
var Constants5 = {
  ObjectType
};

// node_modules/@kitware/vtk.js/Rendering/OpenGL/BufferObject.js
var {
  ObjectType: ObjectType2
} = Constants5;
var STATIC7 = {};
function vtkOpenGLBufferObject(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLBufferObject");
  function convertType(type) {
    switch (type) {
      case ObjectType2.ELEMENT_ARRAY_BUFFER:
        return model.context.ELEMENT_ARRAY_BUFFER;
      case ObjectType2.TEXTURE_BUFFER:
        if ("TEXTURE_BUFFER" in model.context) {
          return model.context.TEXTURE_BUFFER;
        }
      case ObjectType2.ARRAY_BUFFER:
      default:
        return model.context.ARRAY_BUFFER;
    }
  }
  let internalType = null;
  let internalHandle = null;
  let dirty = true;
  let error = "";
  publicAPI.getType = () => internalType;
  publicAPI.setType = (value) => {
    internalType = value;
  };
  publicAPI.getHandle = () => internalHandle;
  publicAPI.isReady = () => dirty === false;
  publicAPI.generateBuffer = (type) => {
    const objectTypeGL = convertType(type);
    if (internalHandle === null) {
      internalHandle = model.context.createBuffer();
      internalType = type;
    }
    return convertType(internalType) === objectTypeGL;
  };
  publicAPI.upload = (data, type) => {
    const alreadyGenerated = publicAPI.generateBuffer(type);
    if (!alreadyGenerated) {
      error = "Trying to upload array buffer to incompatible buffer.";
      return false;
    }
    model.context.bindBuffer(convertType(internalType), internalHandle);
    model.context.bufferData(convertType(internalType), data, model.context.STATIC_DRAW);
    model.allocatedGPUMemoryInBytes = data.length * data.BYTES_PER_ELEMENT;
    dirty = false;
    return true;
  };
  publicAPI.bind = () => {
    if (!internalHandle) {
      return false;
    }
    model.context.bindBuffer(convertType(internalType), internalHandle);
    return true;
  };
  publicAPI.release = () => {
    if (!internalHandle) {
      return false;
    }
    model.context.bindBuffer(convertType(internalType), null);
    return true;
  };
  publicAPI.releaseGraphicsResources = () => {
    if (internalHandle !== null) {
      model.context.bindBuffer(convertType(internalType), null);
      model.context.deleteBuffer(internalHandle);
      internalHandle = null;
      model.allocatedGPUMemoryInBytes = 0;
    }
  };
  publicAPI.setOpenGLRenderWindow = (rw) => {
    if (model._openGLRenderWindow === rw) {
      return;
    }
    publicAPI.releaseGraphicsResources();
    model._openGLRenderWindow = rw;
    model.context = null;
    if (rw) {
      model.context = model._openGLRenderWindow.getContext();
    }
  };
  publicAPI.getError = () => error;
}
var DEFAULT_VALUES21 = {
  objectType: ObjectType2.ARRAY_BUFFER,
  // _openGLRenderWindow: null,
  context: null,
  allocatedGPUMemoryInBytes: 0
};
function extend22(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES21, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["_openGLRenderWindow", "allocatedGPUMemoryInBytes"]);
  macro.moveToProtected(publicAPI, model, ["openGLRenderWindow"]);
  vtkOpenGLBufferObject(publicAPI, model);
}
var newInstance23 = macro.newInstance(extend22);
var vtkBufferObject = __spreadValues(__spreadValues({
  newInstance: newInstance23,
  extend: extend22
}, STATIC7), Constants5);

// node_modules/@kitware/vtk.js/Rendering/Core/Property/Constants.js
var Shading = {
  FLAT: 0,
  GOURAUD: 1,
  PHONG: 2
};
var Representation = {
  POINTS: 0,
  WIREFRAME: 1,
  SURFACE: 2
};
var Interpolation = Shading;
var PropertyConst = {
  Shading,
  Representation,
  Interpolation
};

// node_modules/@kitware/vtk.js/Rendering/OpenGL/CellArrayBufferObject.js
var {
  vtkErrorMacro: vtkErrorMacro10
} = macro;
function computeInverseShiftAndScaleMatrix(coordShift, coordScale) {
  const inverseScale = new Float64Array(3);
  vec3_exports.inverse(inverseScale, coordScale);
  const matrix = new Float64Array(16);
  mat4_exports.fromRotationTranslationScale(matrix, quat_exports.create(), coordShift, inverseScale);
  return matrix;
}
function shouldApplyCoordShiftAndScale(coordShift, coordScale) {
  if (coordShift === null || coordScale === null) {
    return false;
  }
  return !(vec3_exports.exactEquals(coordShift, [0, 0, 0]) && vec3_exports.exactEquals(coordScale, [1, 1, 1]));
}
function vtkOpenGLCellArrayBufferObject(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLCellArrayBufferObject");
  publicAPI.setType(ObjectType.ARRAY_BUFFER);
  publicAPI.createVBO = function(cellArray, inRep, outRep, options) {
    let selectionMaps = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;
    if (!cellArray.getData() || !cellArray.getData().length) {
      model.elementCount = 0;
      return 0;
    }
    model.blockSize = 3;
    model.vertexOffset = 0;
    model.normalOffset = 0;
    model.tCoordOffset = 0;
    model.tCoordComponents = 0;
    model.colorComponents = 0;
    model.colorOffset = 0;
    model.customData = [];
    const pointData = options.points.getData();
    let normalData = null;
    let tcoordData = null;
    let colorData = null;
    const colorComponents = options.colors ? options.colors.getNumberOfComponents() : 0;
    const textureComponents = options.tcoords ? options.tcoords.getNumberOfComponents() : 0;
    if (options.normals) {
      model.normalOffset = 4 * model.blockSize;
      model.blockSize += 3;
      normalData = options.normals.getData();
    }
    if (options.customAttributes) {
      options.customAttributes.forEach((a4) => {
        if (a4) {
          model.customData.push({
            data: a4.getData(),
            offset: 4 * model.blockSize,
            components: a4.getNumberOfComponents(),
            name: a4.getName()
          });
          model.blockSize += a4.getNumberOfComponents();
        }
      });
    }
    if (options.tcoords) {
      model.tCoordOffset = 4 * model.blockSize;
      model.tCoordComponents = textureComponents;
      model.blockSize += textureComponents;
      tcoordData = options.tcoords.getData();
    }
    if (options.colors) {
      model.colorComponents = options.colors.getNumberOfComponents();
      model.colorOffset = 0;
      colorData = options.colors.getData();
      if (!model.colorBO) {
        model.colorBO = vtkBufferObject.newInstance();
      }
      model.colorBO.setOpenGLRenderWindow(model._openGLRenderWindow);
    } else {
      model.colorBO = null;
    }
    model.stride = 4 * model.blockSize;
    let pointIdx = 0;
    let normalIdx = 0;
    let tcoordIdx = 0;
    let colorIdx = 0;
    let custIdx = 0;
    let cellCount = 0;
    let addAPoint;
    const cellBuilders = {
      // easy, every input point becomes an output point
      anythingToPoints(numPoints, cellPts, offset3) {
        for (let i6 = 0; i6 < numPoints; ++i6) {
          addAPoint(cellPts[offset3 + i6]);
        }
      },
      linesToWireframe(numPoints, cellPts, offset3) {
        for (let i6 = 0; i6 < numPoints - 1; ++i6) {
          addAPoint(cellPts[offset3 + i6]);
          addAPoint(cellPts[offset3 + i6 + 1]);
        }
      },
      polysToWireframe(numPoints, cellPts, offset3) {
        if (numPoints > 2) {
          for (let i6 = 0; i6 < numPoints; ++i6) {
            addAPoint(cellPts[offset3 + i6]);
            addAPoint(cellPts[offset3 + (i6 + 1) % numPoints]);
          }
        }
      },
      stripsToWireframe(numPoints, cellPts, offset3) {
        if (numPoints > 2) {
          for (let i6 = 0; i6 < numPoints - 1; ++i6) {
            addAPoint(cellPts[offset3 + i6]);
            addAPoint(cellPts[offset3 + i6 + 1]);
          }
          for (let i6 = 0; i6 < numPoints - 2; i6++) {
            addAPoint(cellPts[offset3 + i6]);
            addAPoint(cellPts[offset3 + i6 + 2]);
          }
        }
      },
      polysToSurface(npts, cellPts, offset3) {
        for (let i6 = 0; i6 < npts - 2; i6++) {
          addAPoint(cellPts[offset3 + 0]);
          addAPoint(cellPts[offset3 + i6 + 1]);
          addAPoint(cellPts[offset3 + i6 + 2]);
        }
      },
      stripsToSurface(npts, cellPts, offset3) {
        for (let i6 = 0; i6 < npts - 2; i6++) {
          addAPoint(cellPts[offset3 + i6]);
          addAPoint(cellPts[offset3 + i6 + 1 + i6 % 2]);
          addAPoint(cellPts[offset3 + i6 + 1 + (i6 + 1) % 2]);
        }
      }
    };
    const cellCounters = {
      // easy, every input point becomes an output point
      anythingToPoints(numPoints, cellPts) {
        return numPoints;
      },
      linesToWireframe(numPoints, cellPts) {
        if (numPoints > 1) {
          return (numPoints - 1) * 2;
        }
        return 0;
      },
      polysToWireframe(numPoints, cellPts) {
        if (numPoints > 2) {
          return numPoints * 2;
        }
        return 0;
      },
      stripsToWireframe(numPoints, cellPts) {
        if (numPoints > 2) {
          return numPoints * 4 - 6;
        }
        return 0;
      },
      polysToSurface(npts, cellPts) {
        if (npts > 2) {
          return (npts - 2) * 3;
        }
        return 0;
      },
      stripsToSurface(npts, cellPts, offset3) {
        if (npts > 2) {
          return (npts - 2) * 3;
        }
        return 0;
      }
    };
    let func = null;
    let countFunc = null;
    if (outRep === Representation.POINTS || inRep === "verts") {
      func = cellBuilders.anythingToPoints;
      countFunc = cellCounters.anythingToPoints;
    } else if (outRep === Representation.WIREFRAME || inRep === "lines") {
      func = cellBuilders[`${inRep}ToWireframe`];
      countFunc = cellCounters[`${inRep}ToWireframe`];
    } else {
      func = cellBuilders[`${inRep}ToSurface`];
      countFunc = cellCounters[`${inRep}ToSurface`];
    }
    const array = cellArray.getData();
    const size3 = array.length;
    let caboCount = 0;
    for (let index2 = 0; index2 < size3; ) {
      caboCount += countFunc(array[index2], array);
      index2 += array[index2] + 1;
    }
    let packedUCVBO = null;
    const packedVBO = new Float32Array(caboCount * model.blockSize);
    if (colorData) {
      packedUCVBO = new Uint8Array(caboCount * 4);
    }
    let vboidx = 0;
    let ucidx = 0;
    let diagSq = 0;
    let distSq = 0;
    for (let i6 = 0; i6 < 3; ++i6) {
      const range = options.points.getRange(i6);
      const delta = range[1] - range[0];
      diagSq += delta * delta;
      const distShift = 0.5 * (range[1] + range[0]);
      distSq += distShift * distShift;
    }
    const useShiftAndScale = diagSq > 0 && (Math.abs(distSq) / diagSq > 1e6 || // If data is far from the origin relative to its size
    Math.abs(Math.log10(diagSq)) > 3 || // If the size is huge when not far from the origin
    diagSq === 0 && distSq > 1e6);
    if (useShiftAndScale) {
      const coordShift = new Float64Array(3);
      const coordScale = new Float64Array(3);
      for (let i6 = 0; i6 < 3; ++i6) {
        const range = options.points.getRange(i6);
        const delta = range[1] - range[0];
        coordShift[i6] = 0.5 * (range[1] + range[0]);
        coordScale[i6] = delta > 0 ? 1 / delta : 1;
      }
      publicAPI.setCoordShiftAndScale(coordShift, coordScale);
    } else if (model.coordShiftAndScaleEnabled === true) {
      publicAPI.setCoordShiftAndScale(null, null);
    }
    if (selectionMaps) {
      if (!selectionMaps.points && !selectionMaps.cells) {
        selectionMaps.points = new Int32Array(caboCount);
        selectionMaps.cells = new Int32Array(caboCount);
      } else {
        const newPoints = new Int32Array(caboCount + selectionMaps.points.length);
        newPoints.set(selectionMaps.points);
        selectionMaps.points = newPoints;
        const newCells = new Int32Array(caboCount + selectionMaps.cells.length);
        newCells.set(selectionMaps.cells);
        selectionMaps.cells = newCells;
      }
    }
    let pointCount = options.vertexOffset;
    addAPoint = function addAPointFunc(i6) {
      if (selectionMaps) {
        selectionMaps.points[pointCount] = i6;
        selectionMaps.cells[pointCount] = cellCount + options.cellOffset;
      }
      ++pointCount;
      pointIdx = i6 * 3;
      if (!model.coordShiftAndScaleEnabled) {
        packedVBO[vboidx++] = pointData[pointIdx++];
        packedVBO[vboidx++] = pointData[pointIdx++];
        packedVBO[vboidx++] = pointData[pointIdx++];
      } else {
        packedVBO[vboidx++] = (pointData[pointIdx++] - model.coordShift[0]) * model.coordScale[0];
        packedVBO[vboidx++] = (pointData[pointIdx++] - model.coordShift[1]) * model.coordScale[1];
        packedVBO[vboidx++] = (pointData[pointIdx++] - model.coordShift[2]) * model.coordScale[2];
      }
      if (normalData !== null) {
        if (options.haveCellNormals) {
          normalIdx = (cellCount + options.cellOffset) * 3;
        } else {
          normalIdx = i6 * 3;
        }
        packedVBO[vboidx++] = normalData[normalIdx++];
        packedVBO[vboidx++] = normalData[normalIdx++];
        packedVBO[vboidx++] = normalData[normalIdx++];
      }
      model.customData.forEach((attr) => {
        custIdx = i6 * attr.components;
        for (let j2 = 0; j2 < attr.components; ++j2) {
          packedVBO[vboidx++] = attr.data[custIdx++];
        }
      });
      if (tcoordData !== null) {
        tcoordIdx = i6 * textureComponents;
        for (let j2 = 0; j2 < textureComponents; ++j2) {
          packedVBO[vboidx++] = tcoordData[tcoordIdx++];
        }
      }
      if (colorData !== null) {
        if (options.haveCellScalars) {
          colorIdx = (cellCount + options.cellOffset) * colorComponents;
        } else {
          colorIdx = i6 * colorComponents;
        }
        packedUCVBO[ucidx++] = colorData[colorIdx++];
        packedUCVBO[ucidx++] = colorData[colorIdx++];
        packedUCVBO[ucidx++] = colorData[colorIdx++];
        packedUCVBO[ucidx++] = colorComponents === 4 ? colorData[colorIdx++] : 255;
      }
    };
    for (let index2 = 0; index2 < size3; ) {
      func(array[index2], array, index2 + 1);
      index2 += array[index2] + 1;
      cellCount++;
    }
    model.elementCount = caboCount;
    publicAPI.upload(packedVBO, ObjectType.ARRAY_BUFFER);
    if (model.colorBO) {
      model.colorBOStride = 4;
      model.colorBO.upload(packedUCVBO, ObjectType.ARRAY_BUFFER);
    }
    return cellCount;
  };
  publicAPI.setCoordShiftAndScale = (coordShift, coordScale) => {
    if (coordShift !== null && (coordShift.constructor !== Float64Array || coordShift.length !== 3)) {
      vtkErrorMacro10("Wrong type for coordShift, expected vec3 or null");
      return;
    }
    if (coordScale !== null && (coordScale.constructor !== Float64Array || coordScale.length !== 3)) {
      vtkErrorMacro10("Wrong type for coordScale, expected vec3 or null");
      return;
    }
    if (model.coordShift === null || coordShift === null || !vec3_exports.equals(coordShift, model.coordShift)) {
      model.coordShift = coordShift;
    }
    if (model.coordScale === null || coordScale === null || !vec3_exports.equals(coordScale, model.coordScale)) {
      model.coordScale = coordScale;
    }
    model.coordShiftAndScaleEnabled = shouldApplyCoordShiftAndScale(model.coordShift, model.coordScale);
    if (model.coordShiftAndScaleEnabled) {
      model.inverseShiftAndScaleMatrix = computeInverseShiftAndScaleMatrix(model.coordShift, model.coordScale);
    } else {
      model.inverseShiftAndScaleMatrix = null;
    }
  };
}
var DEFAULT_VALUES22 = {
  elementCount: 0,
  stride: 0,
  colorBOStride: 0,
  vertexOffset: 0,
  normalOffset: 0,
  tCoordOffset: 0,
  tCoordComponents: 0,
  colorOffset: 0,
  colorComponents: 0,
  tcoordBO: null,
  customData: [],
  coordShift: null,
  coordScale: null,
  coordShiftAndScaleEnabled: false,
  inverseShiftAndScaleMatrix: null
};
function extend23(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES22, initialValues);
  vtkBufferObject.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["colorBO", "elementCount", "stride", "colorBOStride", "vertexOffset", "normalOffset", "tCoordOffset", "tCoordComponents", "colorOffset", "colorComponents", "customData"]);
  macro.get(publicAPI, model, ["coordShift", "coordScale", "coordShiftAndScaleEnabled", "inverseShiftAndScaleMatrix"]);
  vtkOpenGLCellArrayBufferObject(publicAPI, model);
}
var newInstance24 = macro.newInstance(extend23);
var vtkCellArrayBufferObject = {
  newInstance: newInstance24,
  extend: extend23
};

// node_modules/@kitware/vtk.js/Rendering/OpenGL/Shader.js
var {
  vtkErrorMacro: vtkErrorMacro11
} = macro;
function vtkShader(publicAPI, model) {
  model.classHierarchy.push("vtkShader");
  publicAPI.compile = () => {
    let stype = model.context.VERTEX_SHADER;
    if (!model.source || !model.source.length || model.shaderType === "Unknown") {
      return false;
    }
    if (model.handle !== 0) {
      model.context.deleteShader(model.handle);
      model.handle = 0;
    }
    switch (model.shaderType) {
      case "Fragment":
        stype = model.context.FRAGMENT_SHADER;
        break;
      case "Vertex":
      default:
        stype = model.context.VERTEX_SHADER;
        break;
    }
    model.handle = model.context.createShader(stype);
    model.context.shaderSource(model.handle, model.source);
    model.context.compileShader(model.handle);
    const isCompiled = model.context.getShaderParameter(model.handle, model.context.COMPILE_STATUS);
    if (!isCompiled) {
      const lastError = model.context.getShaderInfoLog(model.handle);
      vtkErrorMacro11(`Error compiling shader '${model.source}': ${lastError}`);
      model.context.deleteShader(model.handle);
      model.handle = 0;
      return false;
    }
    return true;
  };
  publicAPI.cleanup = () => {
    if (model.shaderType === "Unknown" || model.handle === 0) {
      return;
    }
    model.context.deleteShader(model.handle);
    model.handle = 0;
    model.dirty = true;
  };
}
var DEFAULT_VALUES23 = {
  shaderType: "Unknown",
  source: "",
  error: "",
  handle: 0,
  dirty: false,
  context: null
};
function extend24(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES23, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["shaderType", "source", "error", "handle", "context"]);
  vtkShader(publicAPI, model);
}
var newInstance25 = macro.newInstance(extend24, "vtkShader");
var vtkShader$1 = {
  newInstance: newInstance25,
  extend: extend24
};

// node_modules/@kitware/vtk.js/Rendering/OpenGL/ShaderProgram.js
var {
  vtkErrorMacro: vtkErrorMacro12
} = macro;
function substitute(source, search, replace, all3) {
  const replaceStr = typeof replace === "string" ? replace : replace.join("\n");
  const replaceSearch = all3 === false ? search : new RegExp(search, "g");
  const resultstr = source.replace(replaceSearch, replaceStr);
  return {
    // If the result is different than the input, we did perform a replacement
    replace: resultstr !== replaceStr,
    result: resultstr
  };
}
function vtkShaderProgram(publicAPI, model) {
  model.classHierarchy.push("vtkShaderProgram");
  publicAPI.compileShader = () => {
    if (!model.vertexShader.compile()) {
      vtkErrorMacro12(model.vertexShader.getSource().split("\n").map((line, index2) => `${index2}: ${line}`).join("\n"));
      vtkErrorMacro12(model.vertexShader.getError());
      return 0;
    }
    if (!model.fragmentShader.compile()) {
      vtkErrorMacro12(model.fragmentShader.getSource().split("\n").map((line, index2) => `${index2}: ${line}`).join("\n"));
      vtkErrorMacro12(model.fragmentShader.getError());
      return 0;
    }
    if (!publicAPI.attachShader(model.vertexShader)) {
      vtkErrorMacro12(model.error);
      return 0;
    }
    if (!publicAPI.attachShader(model.fragmentShader)) {
      vtkErrorMacro12(model.error);
      return 0;
    }
    if (!publicAPI.link()) {
      vtkErrorMacro12(`Links failed: ${model.error}`);
      return 0;
    }
    publicAPI.setCompiled(true);
    return 1;
  };
  publicAPI.cleanup = () => {
    if (model.shaderType === "Unknown" || model.handle === 0) {
      return;
    }
    publicAPI.release();
    if (model.vertexShaderHandle !== 0) {
      model.context.detachShader(model.handle, model.vertexShaderHandle);
      model.vertexShaderHandle = 0;
    }
    if (model.fragmentShaderHandle !== 0) {
      model.context.detachShader(model.handle, model.fragmentShaderHandle);
      model.fragmentShaderHandle = 0;
    }
    model.context.deleteProgram(model.handle);
    model.handle = 0;
    publicAPI.setCompiled(false);
  };
  publicAPI.bind = () => {
    if (!model.linked && !publicAPI.link()) {
      return false;
    }
    model.context.useProgram(model.handle);
    publicAPI.setBound(true);
    return true;
  };
  publicAPI.isBound = () => !!model.bound;
  publicAPI.release = () => {
    model.context.useProgram(null);
    publicAPI.setBound(false);
  };
  publicAPI.setContext = (ctx) => {
    model.vertexShader.setContext(ctx);
    model.fragmentShader.setContext(ctx);
    model.geometryShader.setContext(ctx);
  };
  publicAPI.link = () => {
    if (model.linked) {
      return true;
    }
    if (model.handle === 0) {
      model.error = "Program has not been initialized, and/or does not have shaders.";
      return false;
    }
    model.uniformLocs = {};
    model.context.linkProgram(model.handle);
    const isCompiled = model.context.getProgramParameter(model.handle, model.context.LINK_STATUS);
    if (!isCompiled) {
      const lastError = model.context.getProgramInfoLog(model.handle);
      vtkErrorMacro12(`Error linking shader ${lastError}`);
      model.handle = 0;
      return false;
    }
    publicAPI.setLinked(true);
    model.attributeLocs = {};
    return true;
  };
  publicAPI.setUniformMatrix = (name, v2) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    const f32 = new Float32Array(v2);
    model.context.uniformMatrix4fv(location, false, f32);
    return true;
  };
  publicAPI.setUniformMatrix3x3 = (name, v2) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    const f32 = new Float32Array(v2);
    model.context.uniformMatrix3fv(location, false, f32);
    return true;
  };
  publicAPI.setUniformf = (name, v2) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    model.context.uniform1f(location, v2);
    return true;
  };
  publicAPI.setUniformfv = (name, v2) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    model.context.uniform1fv(location, v2);
    return true;
  };
  publicAPI.setUniformi = (name, v2) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    model.context.uniform1i(location, v2);
    return true;
  };
  publicAPI.setUniformiv = (name, v2) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    model.context.uniform1iv(location, v2);
    return true;
  };
  publicAPI.setUniform2f = (name, v1, v2) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    if (v2 === void 0) {
      throw new RangeError("Invalid number of values for array");
    }
    model.context.uniform2f(location, v1, v2);
    return true;
  };
  publicAPI.setUniform2fv = (name, v2) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    model.context.uniform2fv(location, v2);
    return true;
  };
  publicAPI.setUniform2i = (name, v1, v2) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    if (v2 === void 0) {
      throw new RangeError("Invalid number of values for array");
    }
    model.context.uniform2i(location, v1, v2);
    return true;
  };
  publicAPI.setUniform2iv = (name, v2) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    model.context.uniform2iv(location, v2);
    return true;
  };
  publicAPI.setUniform3f = (name, a1, a22, a32) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    if (a32 === void 0) {
      throw new RangeError("Invalid number of values for array");
    }
    model.context.uniform3f(location, a1, a22, a32);
    return true;
  };
  publicAPI.setUniform3fArray = (name, a4) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    if (!Array.isArray(a4) || a4.length !== 3) {
      throw new RangeError("Invalid number of values for array");
    }
    model.context.uniform3f(location, a4[0], a4[1], a4[2]);
    return true;
  };
  publicAPI.setUniform3fv = (name, v2) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    model.context.uniform3fv(location, v2);
    return true;
  };
  publicAPI.setUniform3i = function(name) {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    let array = args;
    if (array.length === 1 && Array.isArray(array[0])) {
      array = array[0];
    }
    if (array.length !== 3) {
      throw new RangeError("Invalid number of values for array");
    }
    model.context.uniform3i(location, array[0], array[1], array[2]);
    return true;
  };
  publicAPI.setUniform3iv = (name, v2) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    model.context.uniform3iv(location, v2);
    return true;
  };
  publicAPI.setUniform4f = function(name) {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }
    let array = args;
    if (array.length === 1 && Array.isArray(array[0])) {
      array = array[0];
    }
    if (array.length !== 4) {
      throw new RangeError("Invalid number of values for array");
    }
    model.context.uniform4f(location, array[0], array[1], array[2], array[3]);
    return true;
  };
  publicAPI.setUniform4fv = (name, v2) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    model.context.uniform4fv(location, v2);
    return true;
  };
  publicAPI.setUniform4i = function(name) {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      args[_key3 - 1] = arguments[_key3];
    }
    let array = args;
    if (array.length === 1 && Array.isArray(array[0])) {
      array = array[0];
    }
    if (array.length !== 4) {
      throw new RangeError("Invalid number of values for array");
    }
    model.context.uniform4i(location, array[0], array[1], array[2], array[3]);
    return true;
  };
  publicAPI.setUniform4iv = (name, v2) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    model.context.uniform4iv(location, v2);
    return true;
  };
  publicAPI.findUniform = (name) => {
    if (!name || !model.linked) {
      return -1;
    }
    let loc = model.uniformLocs[name];
    if (loc !== void 0) {
      return loc;
    }
    loc = model.context.getUniformLocation(model.handle, name);
    if (loc === null) {
      model.error = `Uniform ${name} not found in current shader program.`;
      model.uniformLocs[name] = -1;
      return -1;
    }
    model.uniformLocs[name] = loc;
    return loc;
  };
  publicAPI.isUniformUsed = (name) => {
    if (!name) {
      return false;
    }
    let loc = model.uniformLocs[name];
    if (loc !== void 0) {
      return loc !== null;
    }
    if (!model.linked) {
      vtkErrorMacro12("attempt to find uniform when the shader program is not linked");
      return false;
    }
    loc = model.context.getUniformLocation(model.handle, name);
    model.uniformLocs[name] = loc;
    if (loc === null) {
      return false;
    }
    return true;
  };
  publicAPI.isAttributeUsed = (name) => {
    if (!name) {
      return false;
    }
    if (name in model.attributeLocs) {
      return true;
    }
    if (!model.linked) {
      vtkErrorMacro12("attempt to find uniform when the shader program is not linked");
      return false;
    }
    const loc = model.context.getAttribLocation(model.handle, name);
    if (loc === -1) {
      return false;
    }
    model.attributeLocs[name] = loc;
    return true;
  };
  publicAPI.attachShader = (shader) => {
    if (shader.getHandle() === 0) {
      model.error = "Shader object was not initialized, cannot attach it.";
      return false;
    }
    if (shader.getShaderType() === "Unknown") {
      model.error = "Shader object is of type Unknown and cannot be used.";
      return false;
    }
    if (model.handle === 0) {
      const thandle = model.context.createProgram();
      if (thandle === 0) {
        model.error = "Could not create shader program.";
        return false;
      }
      model.handle = thandle;
      model.linked = false;
    }
    if (shader.getShaderType() === "Vertex") {
      if (model.vertexShaderHandle !== 0) {
        model.context.detachShader(model.handle, model.vertexShaderHandle);
      }
      model.vertexShaderHandle = shader.getHandle();
    }
    if (shader.getShaderType() === "Fragment") {
      if (model.fragmentShaderHandle !== 0) {
        model.context.detachShader(model.handle, model.fragmentShaderHandle);
      }
      model.fragmentShaderHandle = shader.getHandle();
    }
    model.context.attachShader(model.handle, shader.getHandle());
    publicAPI.setLinked(false);
    return true;
  };
  publicAPI.detachShader = (shader) => {
    if (shader.getHandle() === 0) {
      model.error = "shader object was not initialized, cannot attach it.";
      return false;
    }
    if (shader.getShaderType() === "Unknown") {
      model.error = "Shader object is of type Unknown and cannot be used.";
      return false;
    }
    if (model.handle === 0) {
      model.error = "This shader program has not been initialized yet.";
    }
    switch (shader.getShaderType()) {
      case "Vertex":
        if (model.vertexShaderHandle !== shader.getHandle()) {
          model.error = "The supplied shader was not attached to this program.";
          return false;
        }
        model.context.detachShader(model.handle, shader.getHandle());
        model.vertexShaderHandle = 0;
        model.linked = false;
        return true;
      case "Fragment":
        if (model.fragmentShaderHandle !== shader.getHandle()) {
          model.error = "The supplied shader was not attached to this program.";
          return false;
        }
        model.context.detachShader(model.handle, shader.getHandle());
        model.fragmentShaderHandle = 0;
        model.linked = false;
        return true;
      default:
        return false;
    }
  };
  publicAPI.setContext = (ctx) => {
    model.context = ctx;
    model.vertexShader.setContext(ctx);
    model.fragmentShader.setContext(ctx);
    model.geometryShader.setContext(ctx);
  };
  publicAPI.setLastCameraMTime = (mtime) => {
    model.lastCameraMTime = mtime;
  };
}
var DEFAULT_VALUES24 = {
  vertexShaderHandle: 0,
  fragmentShaderHandle: 0,
  geometryShaderHandle: 0,
  vertexShader: null,
  fragmentShader: null,
  geometryShader: null,
  linked: false,
  bound: false,
  compiled: false,
  error: "",
  handle: 0,
  numberOfOutputs: 0,
  attributesLocs: null,
  uniformLocs: null,
  md5Hash: 0,
  context: null,
  lastCameraMTime: null
};
function extend25(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES24, initialValues);
  model.attributesLocs = {};
  model.uniformLocs = {};
  model.vertexShader = vtkShader$1.newInstance();
  model.vertexShader.setShaderType("Vertex");
  model.fragmentShader = vtkShader$1.newInstance();
  model.fragmentShader.setShaderType("Fragment");
  model.geometryShader = vtkShader$1.newInstance();
  model.geometryShader.setShaderType("Geometry");
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["lastCameraMTime"]);
  macro.setGet(publicAPI, model, ["error", "handle", "compiled", "bound", "md5Hash", "vertexShader", "fragmentShader", "geometryShader", "linked"]);
  vtkShaderProgram(publicAPI, model);
}
var newInstance26 = macro.newInstance(extend25, "vtkShaderProgram");
var vtkShaderProgram$1 = {
  newInstance: newInstance26,
  extend: extend25,
  substitute
};

// node_modules/@kitware/vtk.js/Rendering/OpenGL/VertexArrayObject.js
function vtkOpenGLVertexArrayObject(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLVertexArrayObject");
  publicAPI.exposedMethod = () => {
  };
  publicAPI.initialize = () => {
    model.instancingExtension = null;
    if (!model._openGLRenderWindow.getWebgl2()) {
      model.instancingExtension = model.context.getExtension("ANGLE_instanced_arrays");
    }
    if (!model.forceEmulation && model._openGLRenderWindow && model._openGLRenderWindow.getWebgl2()) {
      model.extension = null;
      model.supported = true;
      model.handleVAO = model.context.createVertexArray();
    } else {
      model.extension = model.context.getExtension("OES_vertex_array_object");
      if (!model.forceEmulation && model.extension) {
        model.supported = true;
        model.handleVAO = model.extension.createVertexArrayOES();
      } else {
        model.supported = false;
      }
    }
  };
  publicAPI.isReady = () => (
    // We either probed and allocated a VAO, or are falling back as the current
    // hardware does not support VAOs.
    model.handleVAO !== 0 || model.supported === false
  );
  publicAPI.bind = () => {
    if (!publicAPI.isReady()) {
      publicAPI.initialize();
    }
    if (publicAPI.isReady() && model.supported) {
      if (model.extension) {
        model.extension.bindVertexArrayOES(model.handleVAO);
      } else {
        model.context.bindVertexArray(model.handleVAO);
      }
    } else if (publicAPI.isReady()) {
      const gl = model.context;
      for (let ibuff = 0; ibuff < model.buffers.length; ++ibuff) {
        const buff = model.buffers[ibuff];
        model.context.bindBuffer(gl.ARRAY_BUFFER, buff.buffer);
        for (let iatt = 0; iatt < buff.attributes.length; ++iatt) {
          const attrIt = buff.attributes[iatt];
          const matrixCount = attrIt.isMatrix ? attrIt.size : 1;
          for (let i6 = 0; i6 < matrixCount; ++i6) {
            gl.enableVertexAttribArray(attrIt.index + i6);
            gl.vertexAttribPointer(attrIt.index + i6, attrIt.size, attrIt.type, attrIt.normalize, attrIt.stride, attrIt.offset + attrIt.stride * i6 / attrIt.size);
            if (attrIt.divisor > 0) {
              if (model.instancingExtension) {
                model.instancingExtension.vertexAttribDivisorANGLE(attrIt.index + i6, 1);
              } else {
                gl.vertexAttribDivisor(attrIt.index + i6, 1);
              }
            }
          }
        }
      }
    }
  };
  publicAPI.release = () => {
    if (publicAPI.isReady() && model.supported) {
      if (model.extension) {
        model.extension.bindVertexArrayOES(null);
      } else {
        model.context.bindVertexArray(null);
      }
    } else if (publicAPI.isReady()) {
      const gl = model.context;
      for (let ibuff = 0; ibuff < model.buffers.length; ++ibuff) {
        const buff = model.buffers[ibuff];
        model.context.bindBuffer(gl.ARRAY_BUFFER, buff.buffer);
        for (let iatt = 0; iatt < buff.attributes.length; ++iatt) {
          const attrIt = buff.attributes[iatt];
          const matrixCount = attrIt.isMatrix ? attrIt.size : 1;
          for (let i6 = 0; i6 < matrixCount; ++i6) {
            gl.enableVertexAttribArray(attrIt.index + i6);
            gl.vertexAttribPointer(attrIt.index + i6, attrIt.size, attrIt.type, attrIt.normalize, attrIt.stride, attrIt.offset + attrIt.stride * i6 / attrIt.size);
            if (attrIt.divisor > 0) {
              if (model.instancingExtension) {
                model.instancingExtension.vertexAttribDivisorANGLE(attrIt.index + i6, 0);
              } else {
                gl.vertexAttribDivisor(attrIt.index + i6, 0);
              }
            }
            gl.disableVertexAttribArray(attrIt.index + i6);
          }
        }
      }
    }
  };
  publicAPI.shaderProgramChanged = () => {
    publicAPI.release();
    if (model.handleVAO) {
      if (model.extension) {
        model.extension.deleteVertexArrayOES(model.handleVAO);
      } else {
        model.context.deleteVertexArray(model.handleVAO);
      }
    }
    model.handleVAO = 0;
    model.handleProgram = 0;
  };
  publicAPI.releaseGraphicsResources = () => {
    publicAPI.shaderProgramChanged();
    if (model.handleVAO) {
      if (model.extension) {
        model.extension.deleteVertexArrayOES(model.handleVAO);
      } else {
        model.context.deleteVertexArray(model.handleVAO);
      }
    }
    model.handleVAO = 0;
    model.supported = true;
    model.handleProgram = 0;
  };
  publicAPI.addAttributeArray = (program, buffer, name, offset3, stride, elementType, elementTupleSize, normalize5) => publicAPI.addAttributeArrayWithDivisor(program, buffer, name, offset3, stride, elementType, elementTupleSize, normalize5, 0, false);
  publicAPI.addAttributeArrayWithDivisor = (program, buffer, name, offset3, stride, elementType, elementTupleSize, normalize5, divisor, isMatrix) => {
    if (!program) {
      return false;
    }
    if (!program.isBound() || buffer.getHandle() === 0 || buffer.getType() !== ObjectType.ARRAY_BUFFER) {
      return false;
    }
    if (model.handleProgram === 0) {
      model.handleProgram = program.getHandle();
    }
    if (!publicAPI.isReady()) {
      publicAPI.initialize();
    }
    if (!publicAPI.isReady() || model.handleProgram !== program.getHandle()) {
      return false;
    }
    const gl = model.context;
    const attribs = {};
    attribs.name = name;
    attribs.index = gl.getAttribLocation(model.handleProgram, name);
    attribs.offset = offset3;
    attribs.stride = stride;
    attribs.type = elementType;
    attribs.size = elementTupleSize;
    attribs.normalize = normalize5;
    attribs.isMatrix = isMatrix;
    attribs.divisor = divisor;
    if (attribs.Index === -1) {
      return false;
    }
    buffer.bind();
    gl.enableVertexAttribArray(attribs.index);
    gl.vertexAttribPointer(attribs.index, attribs.size, attribs.type, attribs.normalize, attribs.stride, attribs.offset);
    if (divisor > 0) {
      if (model.instancingExtension) {
        model.instancingExtension.vertexAttribDivisorANGLE(attribs.index, 1);
      } else {
        gl.vertexAttribDivisor(attribs.index, 1);
      }
    }
    attribs.buffer = buffer.getHandle();
    if (!model.supported) {
      let buffFound = false;
      for (let ibuff = 0; ibuff < model.buffers.length; ++ibuff) {
        const buff = model.buffers[ibuff];
        if (buff.buffer === attribs.buffer) {
          buffFound = true;
          let found = false;
          for (let iatt = 0; iatt < buff.attributes.length; ++iatt) {
            const attrIt = buff.attributes[iatt];
            if (attrIt.name === name) {
              found = true;
              buff.attributes[iatt] = attribs;
            }
          }
          if (!found) {
            buff.attributes.push(attribs);
          }
        }
      }
      if (!buffFound) {
        model.buffers.push({
          buffer: attribs.buffer,
          attributes: [attribs]
        });
      }
    }
    return true;
  };
  publicAPI.addAttributeMatrixWithDivisor = (program, buffer, name, offset3, stride, elementType, elementTupleSize, normalize5, divisor) => {
    const result = publicAPI.addAttributeArrayWithDivisor(program, buffer, name, offset3, stride, elementType, elementTupleSize, normalize5, divisor, true);
    if (!result) {
      return result;
    }
    const gl = model.context;
    const index2 = gl.getAttribLocation(model.handleProgram, name);
    for (let i6 = 1; i6 < elementTupleSize; i6++) {
      gl.enableVertexAttribArray(index2 + i6);
      gl.vertexAttribPointer(index2 + i6, elementTupleSize, elementType, normalize5, stride, offset3 + stride * i6 / elementTupleSize);
      if (divisor > 0) {
        if (model.instancingExtension) {
          model.instancingExtension.vertexAttribDivisorANGLE(index2 + i6, 1);
        } else {
          gl.vertexAttribDivisor(index2 + i6, 1);
        }
      }
    }
    return true;
  };
  publicAPI.removeAttributeArray = (name) => {
    if (!publicAPI.isReady() || model.handleProgram === 0) {
      return false;
    }
    if (!model.supported) {
      for (let ibuff = 0; ibuff < model.buffers.length; ++ibuff) {
        const buff = model.buffers[ibuff];
        for (let iatt = 0; iatt < buff.attributes.length; ++iatt) {
          const attrIt = buff.attributes[iatt];
          if (attrIt.name === name) {
            buff.attributes.splice(iatt, 1);
            if (!buff.attributes.length) {
              model.buffers.splice(ibuff, 1);
            }
            return true;
          }
        }
      }
    }
    return true;
  };
  publicAPI.setOpenGLRenderWindow = (rw) => {
    if (model._openGLRenderWindow === rw) {
      return;
    }
    publicAPI.releaseGraphicsResources();
    model._openGLRenderWindow = rw;
    model.context = null;
    if (rw) {
      model.context = model._openGLRenderWindow.getContext();
    }
  };
}
var DEFAULT_VALUES25 = {
  forceEmulation: false,
  handleVAO: 0,
  handleProgram: 0,
  supported: true,
  buffers: null,
  context: null
  // _openGLRenderWindow: null,
};
function extend26(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES25, initialValues);
  model.buffers = [];
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["supported"]);
  macro.setGet(publicAPI, model, ["forceEmulation"]);
  vtkOpenGLVertexArrayObject(publicAPI, model);
}
var newInstance27 = macro.newInstance(extend26, "vtkOpenGLVertexArrayObject");
var vtkVertexArrayObject = {
  newInstance: newInstance27,
  extend: extend26
};

// node_modules/@kitware/vtk.js/Rendering/OpenGL/Helper.js
var primTypes = {
  Start: 0,
  Points: 0,
  Lines: 1,
  Tris: 2,
  TriStrips: 3,
  TrisEdges: 4,
  TriStripsEdges: 5,
  End: 6
};
function vtkOpenGLHelper(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLHelper");
  publicAPI.setOpenGLRenderWindow = (win) => {
    model.context = win.getContext();
    model.program.setContext(model.context);
    model.VAO.setOpenGLRenderWindow(win);
    model.CABO.setOpenGLRenderWindow(win);
  };
  publicAPI.releaseGraphicsResources = (oglwin) => {
    model.VAO.releaseGraphicsResources();
    model.CABO.releaseGraphicsResources();
    model.CABO.setElementCount(0);
  };
  publicAPI.drawArrays = (ren, actor, rep, oglMapper) => {
    if (model.CABO.getElementCount()) {
      const mode = publicAPI.getOpenGLMode(rep);
      const wideLines = publicAPI.haveWideLines(ren, actor);
      const gl = model.context;
      const depthMask = gl.getParameter(gl.DEPTH_WRITEMASK);
      if (model.pointPicking) {
        gl.depthMask(false);
      }
      const drawingLines = mode === gl.LINES;
      if (drawingLines && wideLines) {
        publicAPI.updateShaders(ren, actor, oglMapper);
        gl.drawArraysInstanced(mode, 0, model.CABO.getElementCount(), 2 * Math.ceil(actor.getProperty().getLineWidth()));
      } else {
        gl.lineWidth(actor.getProperty().getLineWidth());
        publicAPI.updateShaders(ren, actor, oglMapper);
        gl.drawArrays(mode, 0, model.CABO.getElementCount());
        gl.lineWidth(1);
      }
      const stride = (mode === gl.POINTS ? 1 : 0) || (mode === gl.LINES ? 2 : 3);
      if (model.pointPicking) {
        gl.depthMask(depthMask);
      }
      return model.CABO.getElementCount() / stride;
    }
    return 0;
  };
  publicAPI.getOpenGLMode = (rep) => {
    if (model.pointPicking) {
      return model.context.POINTS;
    }
    const type = model.primitiveType;
    if (rep === Representation.POINTS || type === primTypes.Points) {
      return model.context.POINTS;
    }
    if (rep === Representation.WIREFRAME || type === primTypes.Lines || type === primTypes.TrisEdges || type === primTypes.TriStripsEdges) {
      return model.context.LINES;
    }
    return model.context.TRIANGLES;
  };
  publicAPI.haveWideLines = (ren, actor) => {
    if (actor.getProperty().getLineWidth() > 1) {
      if (model.CABO.getOpenGLRenderWindow()) {
        if (model.CABO.getOpenGLRenderWindow().getHardwareMaximumLineWidth() >= actor.getProperty().getLineWidth()) {
          return false;
        }
      }
      return true;
    }
    return false;
  };
  publicAPI.getNeedToRebuildShaders = (ren, actor, oglMapper) => {
    if (oglMapper.getNeedToRebuildShaders(publicAPI, ren, actor) || publicAPI.getProgram() === 0 || publicAPI.getShaderSourceTime().getMTime() < oglMapper.getMTime() || publicAPI.getShaderSourceTime().getMTime() < actor.getMTime()) {
      return true;
    }
    return false;
  };
  publicAPI.updateShaders = (ren, actor, oglMapper) => {
    if (publicAPI.getNeedToRebuildShaders(ren, actor, oglMapper)) {
      const shaders = {
        Vertex: null,
        Fragment: null,
        Geometry: null
      };
      oglMapper.buildShaders(shaders, ren, actor);
      const newShader = model.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgramArray(shaders.Vertex, shaders.Fragment, shaders.Geometry);
      if (newShader !== publicAPI.getProgram()) {
        publicAPI.setProgram(newShader);
        publicAPI.getVAO().releaseGraphicsResources();
      }
      publicAPI.getShaderSourceTime().modified();
    } else {
      model.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgram(publicAPI.getProgram());
    }
    publicAPI.getVAO().bind();
    oglMapper.setMapperShaderParameters(publicAPI, ren, actor);
    oglMapper.setPropertyShaderParameters(publicAPI, ren, actor);
    oglMapper.setCameraShaderParameters(publicAPI, ren, actor);
    oglMapper.setLightingShaderParameters(publicAPI, ren, actor);
    oglMapper.invokeShaderCallbacks(publicAPI, ren, actor);
  };
  publicAPI.setMapperShaderParameters = (ren, actor, size3) => {
    if (publicAPI.haveWideLines(ren, actor)) {
      publicAPI.getProgram().setUniform2f("viewportSize", size3.usize, size3.vsize);
      const lineWidth = parseFloat(actor.getProperty().getLineWidth());
      const halfLineWidth = lineWidth / 2;
      publicAPI.getProgram().setUniformf("lineWidthStepSize", lineWidth / Math.ceil(lineWidth));
      publicAPI.getProgram().setUniformf("halfLineWidth", halfLineWidth);
    }
    if (model.primitiveType === primTypes.Points || actor.getProperty().getRepresentation() === Representation.POINTS) {
      publicAPI.getProgram().setUniformf("pointSize", actor.getProperty().getPointSize());
    } else if (model.pointPicking) {
      publicAPI.getProgram().setUniformf("pointSize", publicAPI.getPointPickingPrimitiveSize());
    }
  };
  publicAPI.replaceShaderPositionVC = (shaders, ren, actor) => {
    let VSSource = shaders.Vertex;
    VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::PositionVC::Dec", ["//VTK::PositionVC::Dec", "uniform float pointSize;"]).result;
    VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::PositionVC::Impl", ["//VTK::PositionVC::Impl", "  gl_PointSize = pointSize;"], false).result;
    if (publicAPI.getOpenGLMode(actor.getProperty().getRepresentation()) === model.context.LINES && publicAPI.haveWideLines(ren, actor)) {
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::PositionVC::Dec", ["//VTK::PositionVC::Dec", "uniform vec2 viewportSize;", "uniform float lineWidthStepSize;", "uniform float halfLineWidth;"]).result;
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::PositionVC::Impl", ["//VTK::PositionVC::Impl", " if (halfLineWidth > 0.0)", "   {", "   float offset = float(gl_InstanceID / 2) * lineWidthStepSize - halfLineWidth;", "   vec4 tmpPos = gl_Position;", "   vec3 tmpPos2 = tmpPos.xyz / tmpPos.w;", "   tmpPos2.x = tmpPos2.x + 2.0 * mod(float(gl_InstanceID), 2.0) * offset / viewportSize[0];", "   tmpPos2.y = tmpPos2.y + 2.0 * mod(float(gl_InstanceID + 1), 2.0) * offset / viewportSize[1];", "   gl_Position = vec4(tmpPos2.xyz * tmpPos.w, tmpPos.w);", "   }"]).result;
    }
    shaders.Vertex = VSSource;
  };
  publicAPI.getPointPickingPrimitiveSize = () => {
    if (model.primitiveType === primTypes.Points) {
      return 2;
    }
    if (model.primitiveType === primTypes.Lines) {
      return 4;
    }
    return 6;
  };
  publicAPI.getAllocatedGPUMemoryInBytes = () => publicAPI.getCABO().getAllocatedGPUMemoryInBytes();
}
var DEFAULT_VALUES26 = {
  context: null,
  program: null,
  shaderSourceTime: null,
  VAO: null,
  attributeUpdateTime: null,
  CABO: null,
  primitiveType: 0,
  pointPicking: false
};
function extend27(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES26, initialValues);
  macro.obj(publicAPI, model);
  model.shaderSourceTime = {};
  macro.obj(model.shaderSourceTime);
  model.attributeUpdateTime = {};
  macro.obj(model.attributeUpdateTime);
  macro.setGet(publicAPI, model, ["program", "shaderSourceTime", "VAO", "attributeUpdateTime", "CABO", "primitiveType", "pointPicking"]);
  model.program = vtkShaderProgram$1.newInstance();
  model.VAO = vtkVertexArrayObject.newInstance();
  model.CABO = vtkCellArrayBufferObject.newInstance();
  vtkOpenGLHelper(publicAPI, model);
}
var newInstance28 = macro.newInstance(extend27);
var vtkHelper = {
  newInstance: newInstance28,
  extend: extend27,
  primTypes
};

// node_modules/@kitware/vtk.js/Common/Core/MatrixBuilder.js
var NoOp = (v2) => v2;
var EPSILON4 = 1e-6;
var Transform = class {
  constructor() {
    let useDegree = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    this.matrix = mat4_exports.identity(new Float64Array(16));
    this.tmp = new Float64Array(3);
    this.angleConv = useDegree ? common_exports.toRadian : NoOp;
  }
  rotateFromDirections(originDirection, targetDirection) {
    const src = new Float64Array(3);
    const dst = new Float64Array(3);
    const transf = new Float64Array(16);
    vec3_exports.set(src, originDirection[0], originDirection[1], originDirection[2]);
    vec3_exports.set(dst, targetDirection[0], targetDirection[1], targetDirection[2]);
    vec3_exports.normalize(src, src);
    vec3_exports.normalize(dst, dst);
    const cosAlpha = vec3_exports.dot(src, dst);
    if (cosAlpha >= 1) {
      return this;
    }
    vec3_exports.cross(this.tmp, src, dst);
    if (vec3_exports.length(this.tmp) < EPSILON4) {
      vec3_exports.cross(this.tmp, [1, 0, 0], originDirection);
      if (vec3_exports.length(this.tmp) < EPSILON4) {
        vec3_exports.cross(this.tmp, [0, 1, 0], originDirection);
      }
    }
    mat4_exports.fromRotation(transf, Math.acos(cosAlpha), this.tmp);
    mat4_exports.multiply(this.matrix, this.matrix, transf);
    return this;
  }
  rotate(angle2, axis2) {
    vec3_exports.set(this.tmp, ...axis2);
    vec3_exports.normalize(this.tmp, this.tmp);
    mat4_exports.rotate(this.matrix, this.matrix, this.angleConv(angle2), this.tmp);
    return this;
  }
  rotateX(angle2) {
    mat4_exports.rotateX(this.matrix, this.matrix, this.angleConv(angle2));
    return this;
  }
  rotateY(angle2) {
    mat4_exports.rotateY(this.matrix, this.matrix, this.angleConv(angle2));
    return this;
  }
  rotateZ(angle2) {
    mat4_exports.rotateZ(this.matrix, this.matrix, this.angleConv(angle2));
    return this;
  }
  translate(x2, y3, z3) {
    vec3_exports.set(this.tmp, x2, y3, z3);
    mat4_exports.translate(this.matrix, this.matrix, this.tmp);
    return this;
  }
  scale(sx, sy, sz) {
    vec3_exports.set(this.tmp, sx, sy, sz);
    mat4_exports.scale(this.matrix, this.matrix, this.tmp);
    return this;
  }
  multiply(mat4x4) {
    mat4_exports.multiply(this.matrix, this.matrix, mat4x4);
    return this;
  }
  multiply3x3(mat3x3) {
    mat4_exports.multiply(this.matrix, this.matrix, [mat3x3[0], mat3x3[1], mat3x3[2], 0, mat3x3[3], mat3x3[4], mat3x3[5], 0, mat3x3[6], mat3x3[7], mat3x3[8], 0, 0, 0, 0, 1]);
    return this;
  }
  invert() {
    mat4_exports.invert(this.matrix, this.matrix);
    return this;
  }
  identity() {
    mat4_exports.identity(this.matrix);
    return this;
  }
  //-----------
  apply(typedArray) {
    let offset3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    let nbIterations = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -1;
    if (areMatricesEqual(IDENTITY, this.matrix)) {
      return this;
    }
    const size3 = nbIterations === -1 ? typedArray.length : offset3 + nbIterations * 3;
    for (let i6 = offset3; i6 < size3; i6 += 3) {
      vec3_exports.set(this.tmp, typedArray[i6], typedArray[i6 + 1], typedArray[i6 + 2]);
      vec3_exports.transformMat4(this.tmp, this.tmp, this.matrix);
      typedArray[i6] = this.tmp[0];
      typedArray[i6 + 1] = this.tmp[1];
      typedArray[i6 + 2] = this.tmp[2];
    }
    return this;
  }
  getMatrix() {
    return this.matrix;
  }
  setMatrix(mat4x4) {
    if (!!mat4x4 && mat4x4.length === 16) {
      mat4_exports.copy(this.matrix, mat4x4);
    }
    return this;
  }
};
function buildFromDegree() {
  return new Transform(true);
}
function buildFromRadian() {
  return new Transform(false);
}
var vtkMatrixBuilder = {
  buildFromDegree,
  buildFromRadian
};

// node_modules/@kitware/vtk.js/Filters/Sources/CubeSource.js
var LINE_ARRAY = [2, 0, 1, 2, 2, 3, 2, 4, 5, 2, 6, 7, 2, 0, 2, 2, 1, 3, 2, 4, 6, 2, 5, 7, 2, 0, 4, 2, 1, 5, 2, 2, 6, 2, 3, 7];
var POLY_ARRAY = [4, 0, 1, 3, 2, 4, 4, 6, 7, 5, 4, 8, 10, 11, 9, 4, 12, 13, 15, 14, 4, 16, 18, 19, 17, 4, 20, 21, 23, 22];
function vtkCubeSource(publicAPI, model) {
  model.classHierarchy.push("vtkCubeSource");
  function requestData(inData, outData) {
    if (model.deleted) {
      return;
    }
    const polyData = vtkPolyData$1.newInstance();
    outData[0] = polyData;
    const numberOfPoints = 24;
    const points = macro.newTypedArray(model.pointType, numberOfPoints * 3);
    polyData.getPoints().setData(points, 3);
    const normals = macro.newTypedArray(model.pointType, numberOfPoints * 3);
    const normalArray = vtkDataArray$1.newInstance({
      name: "Normals",
      values: normals,
      numberOfComponents: 3
    });
    polyData.getPointData().setNormals(normalArray);
    let tcdim = 2;
    if (model.generate3DTextureCoordinates === true) {
      tcdim = 3;
    }
    const textureCoords = macro.newTypedArray(model.pointType, numberOfPoints * tcdim);
    const tcoords = vtkDataArray$1.newInstance({
      name: "TextureCoordinates",
      values: textureCoords,
      numberOfComponents: tcdim
    });
    polyData.getPointData().setTCoords(tcoords);
    const x2 = [0, 0, 0];
    const n9 = [0, 0, 0];
    const tc = [0, 0];
    let pointIndex = 0;
    x2[0] = -model.xLength / 2;
    n9[0] = -1;
    n9[1] = 0;
    n9[2] = 0;
    for (let i6 = 0; i6 < 2; i6++) {
      x2[1] = -model.yLength / 2;
      for (let j2 = 0; j2 < 2; j2++) {
        tc[1] = x2[1] + 0.5;
        x2[2] = -model.zLength / 2;
        for (let k2 = 0; k2 < 2; k2++) {
          tc[0] = (x2[2] + 0.5) * (1 - 2 * i6);
          points[pointIndex * 3] = x2[0];
          points[pointIndex * 3 + 1] = x2[1];
          points[pointIndex * 3 + 2] = x2[2];
          normals[pointIndex * 3] = n9[0];
          normals[pointIndex * 3 + 1] = n9[1];
          normals[pointIndex * 3 + 2] = n9[2];
          if (tcdim === 2) {
            textureCoords[pointIndex * tcdim] = tc[0];
            textureCoords[pointIndex * tcdim + 1] = tc[1];
          } else {
            textureCoords[pointIndex * tcdim] = 2 * i6 - 1;
            textureCoords[pointIndex * tcdim + 1] = 2 * j2 - 1;
            textureCoords[pointIndex * tcdim + 2] = 2 * k2 - 1;
          }
          pointIndex++;
          x2[2] += model.zLength;
        }
        x2[1] += model.yLength;
      }
      x2[0] += model.xLength;
      n9[0] += 2;
    }
    x2[1] = -model.yLength / 2;
    n9[1] = -1;
    n9[0] = 0;
    n9[2] = 0;
    for (let i6 = 0; i6 < 2; i6++) {
      x2[0] = -model.xLength / 2;
      for (let j2 = 0; j2 < 2; j2++) {
        tc[0] = (x2[0] + 0.5) * (2 * i6 - 1);
        x2[2] = -model.zLength / 2;
        for (let k2 = 0; k2 < 2; k2++) {
          tc[1] = (x2[2] + 0.5) * -1;
          points[pointIndex * 3] = x2[0];
          points[pointIndex * 3 + 1] = x2[1];
          points[pointIndex * 3 + 2] = x2[2];
          normals[pointIndex * 3] = n9[0];
          normals[pointIndex * 3 + 1] = n9[1];
          normals[pointIndex * 3 + 2] = n9[2];
          if (tcdim === 2) {
            textureCoords[pointIndex * tcdim] = tc[0];
            textureCoords[pointIndex * tcdim + 1] = tc[1];
          } else {
            textureCoords[pointIndex * tcdim] = 2 * j2 - 1;
            textureCoords[pointIndex * tcdim + 1] = 2 * i6 - 1;
            textureCoords[pointIndex * tcdim + 2] = 2 * k2 - 1;
          }
          pointIndex++;
          x2[2] += model.zLength;
        }
        x2[0] += model.xLength;
      }
      x2[1] += model.yLength;
      n9[1] += 2;
    }
    x2[2] = -model.zLength / 2;
    n9[2] = -1;
    n9[0] = 0;
    n9[1] = 0;
    for (let i6 = 0; i6 < 2; i6++) {
      x2[1] = -model.yLength / 2;
      for (let j2 = 0; j2 < 2; j2++) {
        tc[1] = x2[1] + 0.5;
        x2[0] = -model.xLength / 2;
        for (let k2 = 0; k2 < 2; k2++) {
          tc[0] = (x2[0] + 0.5) * (2 * i6 - 1);
          points[pointIndex * 3] = x2[0];
          points[pointIndex * 3 + 1] = x2[1];
          points[pointIndex * 3 + 2] = x2[2];
          normals[pointIndex * 3] = n9[0];
          normals[pointIndex * 3 + 1] = n9[1];
          normals[pointIndex * 3 + 2] = n9[2];
          if (tcdim === 2) {
            textureCoords[pointIndex * tcdim] = tc[0];
            textureCoords[pointIndex * tcdim + 1] = tc[1];
          } else {
            textureCoords[pointIndex * tcdim] = 2 * k2 - 1;
            textureCoords[pointIndex * tcdim + 1] = 2 * j2 - 1;
            textureCoords[pointIndex * tcdim + 2] = 2 * i6 - 1;
          }
          pointIndex++;
          x2[0] += model.xLength;
        }
        x2[1] += model.yLength;
      }
      x2[2] += model.zLength;
      n9[2] += 2;
    }
    if (model.rotations) {
      vtkMatrixBuilder.buildFromDegree().rotateX(model.rotations[0]).rotateY(model.rotations[1]).rotateZ(model.rotations[2]).apply(points).apply(normals);
    }
    if (model.center) {
      vtkMatrixBuilder.buildFromRadian().translate(...model.center).apply(points);
    }
    if (model.matrix) {
      vtkMatrixBuilder.buildFromRadian().setMatrix(model.matrix).apply(points);
      const rotMatrix = [model.matrix[0], model.matrix[1], model.matrix[2], 0, model.matrix[4], model.matrix[5], model.matrix[6], 0, model.matrix[8], model.matrix[9], model.matrix[10], 0, 0, 0, 0, 1];
      vtkMatrixBuilder.buildFromRadian().setMatrix(rotMatrix).apply(normals);
    }
    if (model.generateFaces) {
      polyData.getPolys().deepCopy(model._polys);
    } else {
      polyData.getPolys().initialize();
    }
    if (model.generateLines) {
      polyData.getLines().deepCopy(model._lineCells);
      polyData.getPointData().setNormals(null);
    } else {
      polyData.getLines().initialize();
    }
    polyData.modified();
  }
  publicAPI.setBounds = function() {
    let boundsArray = [];
    if (Array.isArray(arguments.length <= 0 ? void 0 : arguments[0])) {
      boundsArray = arguments.length <= 0 ? void 0 : arguments[0];
    } else {
      for (let i6 = 0; i6 < arguments.length; i6++) {
        boundsArray.push(i6 < 0 || arguments.length <= i6 ? void 0 : arguments[i6]);
      }
    }
    if (boundsArray.length !== 6) {
      return;
    }
    publicAPI.setXLength(boundsArray[1] - boundsArray[0]);
    publicAPI.setYLength(boundsArray[3] - boundsArray[2]);
    publicAPI.setZLength(boundsArray[5] - boundsArray[4]);
    publicAPI.setCenter([(boundsArray[0] + boundsArray[1]) / 2, (boundsArray[2] + boundsArray[3]) / 2, (boundsArray[4] + boundsArray[5]) / 2]);
  };
  publicAPI.requestData = requestData;
}
var DEFAULT_VALUES27 = {
  xLength: 1,
  yLength: 1,
  zLength: 1,
  pointType: "Float64Array",
  generate3DTextureCoordinates: false,
  generateFaces: true,
  generateLines: false
};
function extend28(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES27, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["xLength", "yLength", "zLength", "generate3DTextureCoordinates", "generateFaces", "generateLines"]);
  macro.setGetArray(publicAPI, model, ["center", "rotations"], 3);
  macro.setGetArray(publicAPI, model, ["matrix"], 16);
  model._polys = vtkCellArray$1.newInstance({
    values: Uint16Array.from(POLY_ARRAY)
  });
  model._lineCells = vtkCellArray$1.newInstance({
    values: Uint16Array.from(LINE_ARRAY)
  });
  macro.moveToProtected(publicAPI, model, ["polys", "lineCells"]);
  macro.algo(publicAPI, model, 0, 1);
  vtkCubeSource(publicAPI, model);
}
var newInstance29 = macro.newInstance(extend28, "vtkCubeSource");
var vtkCubeSource$1 = {
  newInstance: newInstance29,
  extend: extend28
};

// node_modules/@kitware/vtk.js/Filters/General/ImageDataOutlineFilter.js
var {
  vtkErrorMacro: vtkErrorMacro13
} = macro;
function vtkImageDataOutlineFilter(publicAPI, model) {
  model.classHierarchy.push("vtkImageDataOutlineFilter");
  const superClass = __spreadValues({}, publicAPI);
  publicAPI.requestData = (inData, outData) => {
    const input = inData[0];
    if (!input || !input.isA("vtkImageData")) {
      vtkErrorMacro13("Invalid or missing input");
      return;
    }
    const spatialExt = input.getSpatialExtent();
    if (!spatialExt) {
      vtkErrorMacro13("Unable to fetch spatial extents of input image.");
      return;
    }
    model._cubeSource.setBounds(spatialExt);
    model._cubeSource.setMatrix(input.getIndexToWorld());
    outData[0] = model._cubeSource.getOutputData();
  };
  publicAPI.getMTime = () => Math.max(superClass.getMTime(), model._cubeSource.getMTime());
  publicAPI.setGenerateFaces = model._cubeSource.setGenerateFaces;
  publicAPI.setGenerateLines = model._cubeSource.setGenerateLines;
  publicAPI.getGenerateFaces = model._cubeSource.getGenerateFaces;
  publicAPI.getGenerateLines = model._cubeSource.getGenerateLines;
}
var DEFAULT_VALUES28 = {};
function extend29(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES28, initialValues);
  macro.obj(publicAPI, model);
  macro.algo(publicAPI, model, 1, 1);
  model._cubeSource = vtkCubeSource$1.newInstance();
  macro.moveToProtected(publicAPI, model, ["cubeSource", "tmpOut"]);
  vtkImageDataOutlineFilter(publicAPI, model);
}
var newInstance30 = macro.newInstance(extend29, "vtkImageDataOutlineFilter");
var vtkImageDataOutlineFilter$1 = {
  newInstance: newInstance30,
  extend: extend29
};

// node_modules/@kitware/vtk.js/Rendering/OpenGL/Texture/Constants.js
var Wrap = {
  CLAMP_TO_EDGE: 0,
  REPEAT: 1,
  MIRRORED_REPEAT: 2
};
var Filter = {
  NEAREST: 0,
  LINEAR: 1,
  NEAREST_MIPMAP_NEAREST: 2,
  NEAREST_MIPMAP_LINEAR: 3,
  LINEAR_MIPMAP_NEAREST: 4,
  LINEAR_MIPMAP_LINEAR: 5
};
var Constants6 = {
  Wrap,
  Filter
};

// node_modules/@kitware/vtk.js/Common/Core/HalfFloat.js
var floatView = new Float32Array(1);
var int32View = new Int32Array(floatView.buffer);
function toHalf(val) {
  floatView[0] = val;
  const x2 = int32View[0];
  let bits = x2 >> 16 & 32768;
  let m3 = x2 >> 12 & 2047;
  const e13 = x2 >> 23 & 255;
  if (e13 < 103) {
    return bits;
  }
  if (e13 > 142) {
    bits |= 31744;
    bits |= (e13 === 255 ? 0 : 1) && x2 & 8388607;
    return bits;
  }
  if (e13 < 113) {
    m3 |= 2048;
    bits |= (m3 >> 114 - e13) + (m3 >> 113 - e13 & 1);
    return bits;
  }
  bits |= e13 - 112 << 10 | m3 >> 1;
  bits += m3 & 1;
  return bits;
}
function fromHalf(h5) {
  const s9 = (h5 & 32768) >> 15;
  const e13 = (h5 & 31744) >> 10;
  const f5 = h5 & 1023;
  if (e13 === 0) {
    return (s9 ? -1 : 1) * __pow(2, -14) * (f5 / __pow(2, 10));
  }
  if (e13 === 31) {
    return f5 ? NaN : (s9 ? -1 : 1) * Infinity;
  }
  return (s9 ? -1 : 1) * __pow(2, e13 - 15) * (1 + f5 / __pow(2, 10));
}
var HalfFloat = {
  fromHalf,
  toHalf
};

// node_modules/@kitware/vtk.js/Rendering/OpenGL/Texture.js
var {
  Wrap: Wrap2,
  Filter: Filter2
} = Constants6;
var {
  VtkDataTypes: VtkDataTypes2
} = vtkDataArray$1;
var {
  vtkDebugMacro: vtkDebugMacro3,
  vtkErrorMacro: vtkErrorMacro14,
  vtkWarningMacro: vtkWarningMacro6
} = macro$1;
var {
  toHalf: toHalf2
} = HalfFloat;
function vtkOpenGLTexture(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLTexture");
  publicAPI.render = function() {
    let renWin = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    if (renWin) {
      model._openGLRenderWindow = renWin;
    } else {
      model._openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
      model._openGLRenderWindow = model._openGLRenderer.getParent();
    }
    model.context = model._openGLRenderWindow.getContext();
    if (model.renderable.getInterpolate()) {
      if (model.generateMipmap) {
        publicAPI.setMinificationFilter(Filter2.LINEAR_MIPMAP_LINEAR);
      } else {
        publicAPI.setMinificationFilter(Filter2.LINEAR);
      }
      publicAPI.setMagnificationFilter(Filter2.LINEAR);
    } else {
      publicAPI.setMinificationFilter(Filter2.NEAREST);
      publicAPI.setMagnificationFilter(Filter2.NEAREST);
    }
    if (model.renderable.getRepeat()) {
      publicAPI.setWrapR(Wrap2.REPEAT);
      publicAPI.setWrapS(Wrap2.REPEAT);
      publicAPI.setWrapT(Wrap2.REPEAT);
    }
    if (model.renderable.getInputData()) {
      model.renderable.setImage(null);
    }
    if (!model.handle || model.renderable.getMTime() > model.textureBuildTime.getMTime()) {
      if (model.renderable.getImage() !== null) {
        if (model.renderable.getInterpolate()) {
          model.generateMipmap = true;
          publicAPI.setMinificationFilter(Filter2.LINEAR_MIPMAP_LINEAR);
        }
        if (model.renderable.getImage() && model.renderable.getImageLoaded()) {
          publicAPI.create2DFromImage(model.renderable.getImage());
          publicAPI.activate();
          publicAPI.sendParameters();
          model.textureBuildTime.modified();
        }
      }
      if (model.renderable.getCanvas() !== null) {
        if (model.renderable.getInterpolate()) {
          model.generateMipmap = true;
          publicAPI.setMinificationFilter(Filter2.LINEAR_MIPMAP_LINEAR);
        }
        const canvas = model.renderable.getCanvas();
        publicAPI.create2DFromRaw(canvas.width, canvas.height, 4, VtkDataTypes2.UNSIGNED_CHAR, canvas, true);
        publicAPI.activate();
        publicAPI.sendParameters();
        model.textureBuildTime.modified();
      }
      if (model.renderable.getJsImageData() !== null) {
        const jsid = model.renderable.getJsImageData();
        if (model.renderable.getInterpolate()) {
          model.generateMipmap = true;
          publicAPI.setMinificationFilter(Filter2.LINEAR_MIPMAP_LINEAR);
        }
        publicAPI.create2DFromRaw(jsid.width, jsid.height, 4, VtkDataTypes2.UNSIGNED_CHAR, jsid.data, true);
        publicAPI.activate();
        publicAPI.sendParameters();
        model.textureBuildTime.modified();
      }
      const input = model.renderable.getInputData(0);
      if (input && input.getPointData().getScalars()) {
        const ext = input.getExtent();
        const inScalars = input.getPointData().getScalars();
        const data = [];
        for (let i6 = 0; i6 < model.renderable.getNumberOfInputPorts(); ++i6) {
          const indata = model.renderable.getInputData(i6);
          const scalars = indata ? indata.getPointData().getScalars().getData() : null;
          if (scalars) {
            data.push(scalars);
          }
        }
        if (model.renderable.getInterpolate() && inScalars.getNumberOfComponents() === 4) {
          model.generateMipmap = true;
          publicAPI.setMinificationFilter(Filter2.LINEAR_MIPMAP_LINEAR);
        }
        if (data.length % 6 === 0) {
          publicAPI.createCubeFromRaw(ext[1] - ext[0] + 1, ext[3] - ext[2] + 1, inScalars.getNumberOfComponents(), inScalars.getDataType(), data);
        } else {
          publicAPI.create2DFromRaw(ext[1] - ext[0] + 1, ext[3] - ext[2] + 1, inScalars.getNumberOfComponents(), inScalars.getDataType(), inScalars.getData());
        }
        publicAPI.activate();
        publicAPI.sendParameters();
        model.textureBuildTime.modified();
      }
    }
    if (model.handle) {
      publicAPI.activate();
    }
  };
  publicAPI.destroyTexture = () => {
    publicAPI.deactivate();
    if (model.context && model.handle) {
      model.context.deleteTexture(model.handle);
    }
    model.handle = 0;
    model.numberOfDimensions = 0;
    model.target = 0;
    model.components = 0;
    model.width = 0;
    model.height = 0;
    model.depth = 0;
    publicAPI.resetFormatAndType();
  };
  publicAPI.createTexture = () => {
    if (!model.handle) {
      model.handle = model.context.createTexture();
      if (model.target) {
        model.context.bindTexture(model.target, model.handle);
        model.context.texParameteri(model.target, model.context.TEXTURE_MIN_FILTER, publicAPI.getOpenGLFilterMode(model.minificationFilter));
        model.context.texParameteri(model.target, model.context.TEXTURE_MAG_FILTER, publicAPI.getOpenGLFilterMode(model.magnificationFilter));
        model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_S, publicAPI.getOpenGLWrapMode(model.wrapS));
        model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_T, publicAPI.getOpenGLWrapMode(model.wrapT));
        if (model._openGLRenderWindow.getWebgl2()) {
          model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_R, publicAPI.getOpenGLWrapMode(model.wrapR));
        }
        model.context.bindTexture(model.target, null);
      }
    }
  };
  publicAPI.getTextureUnit = () => {
    if (model._openGLRenderWindow) {
      return model._openGLRenderWindow.getTextureUnitForTexture(publicAPI);
    }
    return -1;
  };
  publicAPI.activate = () => {
    model._openGLRenderWindow.activateTexture(publicAPI);
    publicAPI.bind();
  };
  publicAPI.deactivate = () => {
    if (model._openGLRenderWindow) {
      model._openGLRenderWindow.deactivateTexture(publicAPI);
    }
  };
  publicAPI.releaseGraphicsResources = (rwin) => {
    if (rwin && model.handle) {
      rwin.activateTexture(publicAPI);
      rwin.deactivateTexture(publicAPI);
      model.context.deleteTexture(model.handle);
      model.handle = 0;
      model.numberOfDimensions = 0;
      model.target = 0;
      model.internalFormat = 0;
      model.format = 0;
      model.openGLDataType = 0;
      model.components = 0;
      model.width = 0;
      model.height = 0;
      model.depth = 0;
      model.allocatedGPUMemoryInBytes = 0;
    }
    if (model.shaderProgram) {
      model.shaderProgram.releaseGraphicsResources(rwin);
      model.shaderProgram = null;
    }
  };
  publicAPI.bind = () => {
    model.context.bindTexture(model.target, model.handle);
    if (model.autoParameters && publicAPI.getMTime() > model.sendParametersTime.getMTime()) {
      publicAPI.sendParameters();
    }
  };
  publicAPI.isBound = () => {
    let result = false;
    if (model.context && model.handle) {
      let target = 0;
      switch (model.target) {
        case model.context.TEXTURE_2D:
          target = model.context.TEXTURE_BINDING_2D;
          break;
        default:
          vtkWarningMacro6("impossible case");
          break;
      }
      const oid = model.context.getIntegerv(target);
      result = oid === model.handle;
    }
    return result;
  };
  publicAPI.sendParameters = () => {
    model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_S, publicAPI.getOpenGLWrapMode(model.wrapS));
    model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_T, publicAPI.getOpenGLWrapMode(model.wrapT));
    if (model._openGLRenderWindow.getWebgl2()) {
      model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_R, publicAPI.getOpenGLWrapMode(model.wrapR));
    }
    model.context.texParameteri(model.target, model.context.TEXTURE_MIN_FILTER, publicAPI.getOpenGLFilterMode(model.minificationFilter));
    model.context.texParameteri(model.target, model.context.TEXTURE_MAG_FILTER, publicAPI.getOpenGLFilterMode(model.magnificationFilter));
    if (model._openGLRenderWindow.getWebgl2()) {
      model.context.texParameteri(model.target, model.context.TEXTURE_BASE_LEVEL, model.baseLevel);
      model.context.texParameteri(model.target, model.context.TEXTURE_MAX_LEVEL, model.maxLevel);
    }
    model.sendParametersTime.modified();
  };
  publicAPI.getInternalFormat = (vtktype, numComps) => {
    if (!model._forceInternalFormat) {
      model.internalFormat = publicAPI.getDefaultInternalFormat(vtktype, numComps);
    }
    if (!model.internalFormat) {
      vtkDebugMacro3(`Unable to find suitable internal format for T=${vtktype} NC= ${numComps}`);
    }
    if ([model.context.R32F, model.context.RG32F, model.context.RGB32F, model.context.RGBA32F].includes(model.internalFormat) && !model.context.getExtension("OES_texture_float_linear")) {
      vtkWarningMacro6("Failed to load OES_texture_float_linear. Texture filtering is not available for *32F internal formats.");
    }
    return model.internalFormat;
  };
  publicAPI.getDefaultInternalFormat = (vtktype, numComps) => {
    let result = 0;
    result = model._openGLRenderWindow.getDefaultTextureInternalFormat(vtktype, numComps, model.oglNorm16Ext, model.useHalfFloat);
    if (result) {
      return result;
    }
    if (!result) {
      vtkDebugMacro3("Unsupported internal texture type!");
      vtkDebugMacro3(`Unable to find suitable internal format for T=${vtktype} NC= ${numComps}`);
    }
    return result;
  };
  publicAPI.setInternalFormat = (iFormat) => {
    model._forceInternalFormat = true;
    if (iFormat !== model.internalFormat) {
      model.internalFormat = iFormat;
      publicAPI.modified();
    }
  };
  publicAPI.getFormat = (vtktype, numComps) => {
    model.format = publicAPI.getDefaultFormat(vtktype, numComps);
    return model.format;
  };
  publicAPI.getDefaultFormat = (vtktype, numComps) => {
    if (model._openGLRenderWindow.getWebgl2()) {
      switch (numComps) {
        case 1:
          return model.context.RED;
        case 2:
          return model.context.RG;
        case 3:
          return model.context.RGB;
        case 4:
          return model.context.RGBA;
        default:
          return model.context.RGB;
      }
    } else {
      switch (numComps) {
        case 1:
          return model.context.LUMINANCE;
        case 2:
          return model.context.LUMINANCE_ALPHA;
        case 3:
          return model.context.RGB;
        case 4:
          return model.context.RGBA;
        default:
          return model.context.RGB;
      }
    }
  };
  publicAPI.resetFormatAndType = () => {
    model.format = 0;
    model.internalFormat = 0;
    model._forceInternalFormat = false;
    model.openGLDataType = 0;
  };
  publicAPI.getDefaultDataType = (vtkScalarType) => {
    if (model._openGLRenderWindow.getWebgl2()) {
      switch (vtkScalarType) {
        case VtkDataTypes2.UNSIGNED_CHAR:
          return model.context.UNSIGNED_BYTE;
        case (model.oglNorm16Ext && !model.useHalfFloat && VtkDataTypes2.SHORT):
          return model.context.SHORT;
        case (model.oglNorm16Ext && !model.useHalfFloat && VtkDataTypes2.UNSIGNED_SHORT):
          return model.context.UNSIGNED_SHORT;
        case (model.useHalfFloat && VtkDataTypes2.SHORT):
          return model.context.HALF_FLOAT;
        case (model.useHalfFloat && VtkDataTypes2.UNSIGNED_SHORT):
          return model.context.HALF_FLOAT;
        case VtkDataTypes2.FLOAT:
        case VtkDataTypes2.VOID:
        default:
          return model.context.FLOAT;
      }
    }
    switch (vtkScalarType) {
      case VtkDataTypes2.UNSIGNED_CHAR:
        return model.context.UNSIGNED_BYTE;
      case VtkDataTypes2.FLOAT:
      case VtkDataTypes2.VOID:
      default:
        if (model.context.getExtension("OES_texture_float") && model.context.getExtension("OES_texture_float_linear")) {
          return model.context.FLOAT;
        }
        {
          const halfFloat = model.context.getExtension("OES_texture_half_float");
          if (halfFloat && model.context.getExtension("OES_texture_half_float_linear")) {
            return halfFloat.HALF_FLOAT_OES;
          }
        }
        return model.context.UNSIGNED_BYTE;
    }
  };
  publicAPI.getOpenGLDataType = function(vtkScalarType) {
    let forceUpdate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    if (!model.openGLDataType || forceUpdate) {
      model.openGLDataType = publicAPI.getDefaultDataType(vtkScalarType);
    }
    return model.openGLDataType;
  };
  publicAPI.getShiftAndScale = () => {
    let shift3 = 0;
    let scale7 = 1;
    switch (model.openGLDataType) {
      case model.context.BYTE:
        scale7 = 127.5;
        shift3 = scale7 - 128;
        break;
      case model.context.UNSIGNED_BYTE:
        scale7 = 255;
        shift3 = 0;
        break;
      case model.context.SHORT:
        scale7 = 32767.5;
        shift3 = scale7 - 32768;
        break;
      case model.context.UNSIGNED_SHORT:
        scale7 = 65536;
        shift3 = 0;
        break;
      case model.context.INT:
        scale7 = 21474836475e-1;
        shift3 = scale7 - 2147483648;
        break;
      case model.context.UNSIGNED_INT:
        scale7 = 4294967295;
        shift3 = 0;
        break;
      case model.context.FLOAT:
    }
    return {
      shift: shift3,
      scale: scale7
    };
  };
  publicAPI.getOpenGLFilterMode = (emode) => {
    switch (emode) {
      case Filter2.NEAREST:
        return model.context.NEAREST;
      case Filter2.LINEAR:
        return model.context.LINEAR;
      case Filter2.NEAREST_MIPMAP_NEAREST:
        return model.context.NEAREST_MIPMAP_NEAREST;
      case Filter2.NEAREST_MIPMAP_LINEAR:
        return model.context.NEAREST_MIPMAP_LINEAR;
      case Filter2.LINEAR_MIPMAP_NEAREST:
        return model.context.LINEAR_MIPMAP_NEAREST;
      case Filter2.LINEAR_MIPMAP_LINEAR:
        return model.context.LINEAR_MIPMAP_LINEAR;
      default:
        return model.context.NEAREST;
    }
  };
  publicAPI.getOpenGLWrapMode = (vtktype) => {
    switch (vtktype) {
      case Wrap2.CLAMP_TO_EDGE:
        return model.context.CLAMP_TO_EDGE;
      case Wrap2.REPEAT:
        return model.context.REPEAT;
      case Wrap2.MIRRORED_REPEAT:
        return model.context.MIRRORED_REPEAT;
      default:
        return model.context.CLAMP_TO_EDGE;
    }
  };
  function updateArrayDataType(dataType, data) {
    let depth = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    const pixData = [];
    let pixCount = model.width * model.height * model.components;
    if (depth) {
      pixCount *= model.depth;
    }
    if (dataType !== VtkDataTypes2.FLOAT && model.openGLDataType === model.context.FLOAT) {
      for (let idx = 0; idx < data.length; idx++) {
        if (data[idx]) {
          const dataArrayToCopy = data[idx].length > pixCount ? data[idx].subarray(0, pixCount) : data[idx];
          pixData.push(new Float32Array(dataArrayToCopy));
        } else {
          pixData.push(null);
        }
      }
    }
    if (dataType !== VtkDataTypes2.UNSIGNED_CHAR && model.openGLDataType === model.context.UNSIGNED_BYTE) {
      for (let idx = 0; idx < data.length; idx++) {
        if (data[idx]) {
          const dataArrayToCopy = data[idx].length > pixCount ? data[idx].subarray(0, pixCount) : data[idx];
          pixData.push(new Uint8Array(dataArrayToCopy));
        } else {
          pixData.push(null);
        }
      }
    }
    let halfFloat = false;
    if (model._openGLRenderWindow.getWebgl2()) {
      halfFloat = model.openGLDataType === model.context.HALF_FLOAT;
    } else {
      const halfFloatExt = model.context.getExtension("OES_texture_half_float");
      halfFloat = halfFloatExt && model.openGLDataType === halfFloatExt.HALF_FLOAT_OES;
    }
    if (halfFloat) {
      for (let idx = 0; idx < data.length; idx++) {
        if (data[idx]) {
          const newArray = new Uint16Array(pixCount);
          const src = data[idx];
          for (let i6 = 0; i6 < pixCount; i6++) {
            newArray[i6] = toHalf2(src[i6]);
          }
          pixData.push(newArray);
        } else {
          pixData.push(null);
        }
      }
    }
    if (pixData.length === 0) {
      for (let i6 = 0; i6 < data.length; i6++) {
        pixData.push(data[i6]);
      }
    }
    return pixData;
  }
  function scaleTextureToHighestPowerOfTwo(data) {
    if (model._openGLRenderWindow.getWebgl2()) {
      return data;
    }
    const pixData = [];
    const width = model.width;
    const height = model.height;
    const numComps = model.components;
    if (data && (!isPowerOfTwo(width) || !isPowerOfTwo(height))) {
      const halfFloat = model.context.getExtension("OES_texture_half_float");
      const newWidth = nearestPowerOfTwo(width);
      const newHeight = nearestPowerOfTwo(height);
      const pixCount = newWidth * newHeight * model.components;
      for (let idx = 0; idx < data.length; idx++) {
        if (data[idx] !== null) {
          let newArray = null;
          const jFactor = height / newHeight;
          const iFactor = width / newWidth;
          let usingHalf = false;
          if (model.openGLDataType === model.context.FLOAT) {
            newArray = new Float32Array(pixCount);
          } else if (halfFloat && model.openGLDataType === halfFloat.HALF_FLOAT_OES) {
            newArray = new Uint16Array(pixCount);
            usingHalf = true;
          } else {
            newArray = new Uint8Array(pixCount);
          }
          for (let j2 = 0; j2 < newHeight; j2++) {
            const joff = j2 * newWidth * numComps;
            const jidx = j2 * jFactor;
            let jlow = Math.floor(jidx);
            let jhi = Math.ceil(jidx);
            if (jhi >= height) {
              jhi = height - 1;
            }
            const jmix = jidx - jlow;
            const jmix1 = 1 - jmix;
            jlow = jlow * width * numComps;
            jhi = jhi * width * numComps;
            for (let i6 = 0; i6 < newWidth; i6++) {
              const ioff = i6 * numComps;
              const iidx = i6 * iFactor;
              let ilow = Math.floor(iidx);
              let ihi = Math.ceil(iidx);
              if (ihi >= width) {
                ihi = width - 1;
              }
              const imix = iidx - ilow;
              ilow *= numComps;
              ihi *= numComps;
              for (let c6 = 0; c6 < numComps; c6++) {
                if (usingHalf) {
                  newArray[joff + ioff + c6] = HalfFloat.toHalf(HalfFloat.fromHalf(data[idx][jlow + ilow + c6]) * jmix1 * (1 - imix) + HalfFloat.fromHalf(data[idx][jlow + ihi + c6]) * jmix1 * imix + HalfFloat.fromHalf(data[idx][jhi + ilow + c6]) * jmix * (1 - imix) + HalfFloat.fromHalf(data[idx][jhi + ihi + c6]) * jmix * imix);
                } else {
                  newArray[joff + ioff + c6] = data[idx][jlow + ilow + c6] * jmix1 * (1 - imix) + data[idx][jlow + ihi + c6] * jmix1 * imix + data[idx][jhi + ilow + c6] * jmix * (1 - imix) + data[idx][jhi + ihi + c6] * jmix * imix;
                }
              }
            }
          }
          pixData.push(newArray);
          model.width = newWidth;
          model.height = newHeight;
        } else {
          pixData.push(null);
        }
      }
    }
    if (pixData.length === 0) {
      for (let i6 = 0; i6 < data.length; i6++) {
        pixData.push(data[i6]);
      }
    }
    return pixData;
  }
  function useTexStorage(dataType) {
    var _a9;
    if (model._openGLRenderWindow) {
      if (model.resizable || ((_a9 = model.renderable) == null ? void 0 : _a9.getResizable())) {
        return false;
      }
      if (model._openGLRenderWindow.getWebgl2()) {
        const webGLInfo = model._openGLRenderWindow.getGLInformations();
        if (webGLInfo.RENDERER.value.match(/WebKit/gi) && navigator.platform.match(/Mac/gi) && model.oglNorm16Ext && (dataType === VtkDataTypes2.UNSIGNED_SHORT || dataType === VtkDataTypes2.SHORT)) {
          return false;
        }
        return true;
      }
      return false;
    }
    return false;
  }
  publicAPI.create2DFromRaw = function(width, height, numComps, dataType, data) {
    let flip3 = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : false;
    publicAPI.getOpenGLDataType(dataType, true);
    publicAPI.getInternalFormat(dataType, numComps);
    publicAPI.getFormat(dataType, numComps);
    if (!model.internalFormat || !model.format || !model.openGLDataType) {
      vtkErrorMacro14("Failed to determine texture parameters.");
      return false;
    }
    model.target = model.context.TEXTURE_2D;
    model.components = numComps;
    model.width = width;
    model.height = height;
    model.depth = 1;
    model.numberOfDimensions = 2;
    model._openGLRenderWindow.activateTexture(publicAPI);
    publicAPI.createTexture();
    publicAPI.bind();
    const dataArray = [data];
    const pixData = updateArrayDataType(dataType, dataArray);
    const scaledData = scaleTextureToHighestPowerOfTwo(pixData);
    model.context.pixelStorei(model.context.UNPACK_FLIP_Y_WEBGL, flip3);
    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);
    if (useTexStorage(dataType)) {
      model.context.texStorage2D(model.target, 1, model.internalFormat, model.width, model.height);
      if (scaledData[0] != null) {
        model.context.texSubImage2D(model.target, 0, 0, 0, model.width, model.height, model.format, model.openGLDataType, scaledData[0]);
      }
    } else {
      model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, scaledData[0]);
    }
    if (model.generateMipmap) {
      model.context.generateMipmap(model.target);
    }
    if (flip3) {
      model.context.pixelStorei(model.context.UNPACK_FLIP_Y_WEBGL, false);
    }
    model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * numComps * model._openGLRenderWindow.getDefaultTextureByteSize(dataType, model.oglNorm16Ext, model.useHalfFloat);
    publicAPI.deactivate();
    return true;
  };
  publicAPI.createCubeFromRaw = (width, height, numComps, dataType, data) => {
    publicAPI.getOpenGLDataType(dataType);
    publicAPI.getInternalFormat(dataType, numComps);
    publicAPI.getFormat(dataType, numComps);
    if (!model.internalFormat || !model.format || !model.openGLDataType) {
      vtkErrorMacro14("Failed to determine texture parameters.");
      return false;
    }
    model.target = model.context.TEXTURE_CUBE_MAP;
    model.components = numComps;
    model.width = width;
    model.height = height;
    model.depth = 1;
    model.numberOfDimensions = 2;
    model._openGLRenderWindow.activateTexture(publicAPI);
    model.maxLevel = data.length / 6 - 1;
    publicAPI.createTexture();
    publicAPI.bind();
    const pixData = updateArrayDataType(dataType, data);
    const scaledData = scaleTextureToHighestPowerOfTwo(pixData);
    const invertedData = [];
    let widthLevel = model.width;
    let heightLevel = model.height;
    for (let i6 = 0; i6 < scaledData.length; i6++) {
      if (i6 % 6 === 0 && i6 !== 0) {
        widthLevel /= 2;
        heightLevel /= 2;
      }
      invertedData[i6] = newTypedArray(dataType, heightLevel * widthLevel * model.components);
      for (let y3 = 0; y3 < heightLevel; ++y3) {
        const row1 = y3 * widthLevel * model.components;
        const row2 = (heightLevel - y3 - 1) * widthLevel * model.components;
        invertedData[i6].set(scaledData[i6].slice(row2, row2 + widthLevel * model.components), row1);
      }
    }
    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);
    if (useTexStorage(dataType)) {
      model.context.texStorage2D(model.target, 6, model.internalFormat, model.width, model.height);
    }
    for (let i6 = 0; i6 < 6; i6++) {
      let j2 = 0;
      let w2 = model.width;
      let h5 = model.height;
      while (w2 >= 1 && h5 >= 1) {
        let tempData = null;
        if (j2 <= model.maxLevel) {
          tempData = invertedData[6 * j2 + i6];
        }
        if (useTexStorage(dataType)) {
          if (tempData != null) {
            model.context.texSubImage2D(model.context.TEXTURE_CUBE_MAP_POSITIVE_X + i6, j2, 0, 0, w2, h5, model.format, model.openGLDataType, tempData);
          }
        } else {
          model.context.texImage2D(model.context.TEXTURE_CUBE_MAP_POSITIVE_X + i6, j2, model.internalFormat, w2, h5, 0, model.format, model.openGLDataType, tempData);
        }
        j2++;
        w2 /= 2;
        h5 /= 2;
      }
    }
    model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * numComps * model._openGLRenderWindow.getDefaultTextureByteSize(dataType, model.oglNorm16Ext, model.useHalfFloat);
    publicAPI.deactivate();
    return true;
  };
  publicAPI.createDepthFromRaw = (width, height, dataType, data) => {
    publicAPI.getOpenGLDataType(dataType);
    model.format = model.context.DEPTH_COMPONENT;
    if (model._openGLRenderWindow.getWebgl2()) {
      if (dataType === VtkDataTypes2.FLOAT) {
        model.internalFormat = model.context.DEPTH_COMPONENT32F;
      } else {
        model.internalFormat = model.context.DEPTH_COMPONENT16;
      }
    } else {
      model.internalFormat = model.context.DEPTH_COMPONENT;
    }
    if (!model.internalFormat || !model.format || !model.openGLDataType) {
      vtkErrorMacro14("Failed to determine texture parameters.");
      return false;
    }
    model.target = model.context.TEXTURE_2D;
    model.components = 1;
    model.width = width;
    model.height = height;
    model.depth = 1;
    model.numberOfDimensions = 2;
    model._openGLRenderWindow.activateTexture(publicAPI);
    publicAPI.createTexture();
    publicAPI.bind();
    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);
    if (useTexStorage(dataType)) {
      model.context.texStorage2D(model.target, 1, model.internalFormat, model.width, model.height);
      if (data != null) {
        model.context.texSubImage2D(model.target, 0, 0, 0, model.width, model.height, model.format, model.openGLDataType, data);
      }
    } else {
      model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, data);
    }
    if (model.generateMipmap) {
      model.context.generateMipmap(model.target);
    }
    model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * model.components * model._openGLRenderWindow.getDefaultTextureByteSize(dataType, model.oglNorm16Ext, model.useHalfFloat);
    publicAPI.deactivate();
    return true;
  };
  publicAPI.create2DFromImage = (image2) => {
    publicAPI.getOpenGLDataType(VtkDataTypes2.UNSIGNED_CHAR);
    publicAPI.getInternalFormat(VtkDataTypes2.UNSIGNED_CHAR, 4);
    publicAPI.getFormat(VtkDataTypes2.UNSIGNED_CHAR, 4);
    if (!model.internalFormat || !model.format || !model.openGLDataType) {
      vtkErrorMacro14("Failed to determine texture parameters.");
      return false;
    }
    model.target = model.context.TEXTURE_2D;
    model.components = 4;
    model.depth = 1;
    model.numberOfDimensions = 2;
    model._openGLRenderWindow.activateTexture(publicAPI);
    publicAPI.createTexture();
    publicAPI.bind();
    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);
    const needNearestPowerOfTwo = !model._openGLRenderWindow.getWebgl2() && (!isPowerOfTwo(image2.width) || !isPowerOfTwo(image2.height));
    const canvas = document.createElement("canvas");
    canvas.width = needNearestPowerOfTwo ? nearestPowerOfTwo(image2.width) : image2.width;
    canvas.height = needNearestPowerOfTwo ? nearestPowerOfTwo(image2.height) : image2.height;
    model.width = canvas.width;
    model.height = canvas.height;
    const ctx = canvas.getContext("2d");
    ctx.translate(0, canvas.height);
    ctx.scale(1, -1);
    ctx.drawImage(image2, 0, 0, image2.width, image2.height, 0, 0, canvas.width, canvas.height);
    const safeImage = canvas;
    if (useTexStorage(VtkDataTypes2.UNSIGNED_CHAR)) {
      model.context.texStorage2D(model.target, 1, model.internalFormat, model.width, model.height);
      if (safeImage != null) {
        model.context.texSubImage2D(model.target, 0, 0, 0, model.width, model.height, model.format, model.openGLDataType, safeImage);
      }
    } else {
      model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, safeImage);
    }
    if (model.generateMipmap) {
      model.context.generateMipmap(model.target);
    }
    model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * model.components * model._openGLRenderWindow.getDefaultTextureByteSize(VtkDataTypes2.UNSIGNED_CHAR, model.oglNorm16Ext, model.useHalfFloat);
    publicAPI.deactivate();
    return true;
  };
  function computeScaleOffsets(min5, max5, numComps) {
    const offset3 = new Array(numComps);
    const scale7 = new Array(numComps);
    for (let c6 = 0; c6 < numComps; ++c6) {
      offset3[c6] = min5[c6];
      scale7[c6] = max5[c6] - min5[c6] || 1;
    }
    return {
      scale: scale7,
      offset: offset3
    };
  }
  function hasExactHalfFloat(offset3, scale7) {
    for (let c6 = 0; c6 < offset3.length; c6++) {
      const min5 = offset3[c6];
      const max5 = scale7[c6] + min5;
      if (min5 < -2048 || min5 > 2048 || max5 < -2048 || max5 > 2048) {
        return false;
      }
    }
    return true;
  }
  function setUseHalfFloat(dataType, offset3, scale7, preferSizeOverAccuracy) {
    publicAPI.getOpenGLDataType(dataType);
    let useHalfFloat = false;
    if (model._openGLRenderWindow.getWebgl2()) {
      useHalfFloat = model.openGLDataType === model.context.HALF_FLOAT;
    } else {
      const halfFloatExt = model.context.getExtension("OES_texture_half_float");
      useHalfFloat = halfFloatExt && model.openGLDataType === halfFloatExt.HALF_FLOAT_OES;
    }
    const isHalfFloat = useHalfFloat && (hasExactHalfFloat(offset3, scale7) || preferSizeOverAccuracy);
    model.useHalfFloat = isHalfFloat;
  }
  function processDataArray(dataArray, preferSizeOverAccuracy) {
    const numComps = dataArray.getNumberOfComponents();
    const dataType = dataArray.getDataType();
    const data = dataArray.getData();
    const minArray = new Array(numComps);
    const maxArray = new Array(numComps);
    for (let c6 = 0; c6 < numComps; ++c6) {
      const [min5, max5] = dataArray.getRange(c6);
      minArray[c6] = min5;
      maxArray[c6] = max5;
    }
    const scaleOffsets = computeScaleOffsets(minArray, maxArray, numComps);
    setUseHalfFloat(dataType, scaleOffsets.offset, scaleOffsets.scale, preferSizeOverAccuracy);
    if (!model.useHalfFloat) {
      publicAPI.getOpenGLDataType(dataType, true);
    }
    return {
      numComps,
      dataType,
      data,
      scaleOffsets
    };
  }
  publicAPI.create2DFilterableFromRaw = function(width, height, numberOfComponents, dataType, values) {
    let preferSizeOverAccuracy = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : false;
    return publicAPI.create2DFilterableFromDataArray(width, height, vtkDataArray$1.newInstance({
      numberOfComponents,
      dataType,
      values
    }), preferSizeOverAccuracy);
  };
  publicAPI.create2DFilterableFromDataArray = function(width, height, dataArray) {
    let preferSizeOverAccuracy = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    const {
      numComps,
      dataType,
      data
    } = processDataArray(dataArray, preferSizeOverAccuracy);
    publicAPI.create2DFromRaw(width, height, numComps, dataType, data);
  };
  publicAPI.create3DFromRaw = (width, height, depth, numComps, dataType, data) => {
    publicAPI.getOpenGLDataType(dataType);
    publicAPI.getInternalFormat(dataType, numComps);
    publicAPI.getFormat(dataType, numComps);
    if (!model.internalFormat || !model.format || !model.openGLDataType) {
      vtkErrorMacro14("Failed to determine texture parameters.");
      return false;
    }
    model.target = model.context.TEXTURE_3D;
    model.components = numComps;
    model.width = width;
    model.height = height;
    model.depth = depth;
    model.numberOfDimensions = 3;
    model._openGLRenderWindow.activateTexture(publicAPI);
    publicAPI.createTexture();
    publicAPI.bind();
    const dataArray = [data];
    const is3DArray = true;
    const pixData = updateArrayDataType(dataType, dataArray, is3DArray);
    const scaledData = scaleTextureToHighestPowerOfTwo(pixData);
    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);
    if (useTexStorage(dataType)) {
      model.context.texStorage3D(model.target, 1, model.internalFormat, model.width, model.height, model.depth);
      if (scaledData[0] != null) {
        model.context.texSubImage3D(model.target, 0, 0, 0, 0, model.width, model.height, model.depth, model.format, model.openGLDataType, scaledData[0]);
      }
    } else {
      model.context.texImage3D(model.target, 0, model.internalFormat, model.width, model.height, model.depth, 0, model.format, model.openGLDataType, scaledData[0]);
    }
    if (model.generateMipmap) {
      model.context.generateMipmap(model.target);
    }
    model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * model.components * model._openGLRenderWindow.getDefaultTextureByteSize(dataType, model.oglNorm16Ext, model.useHalfFloat);
    publicAPI.deactivate();
    return true;
  };
  publicAPI.create3DFilterableFromRaw = function(width, height, depth, numberOfComponents, dataType, values) {
    let preferSizeOverAccuracy = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : false;
    return publicAPI.create3DFilterableFromDataArray(width, height, depth, vtkDataArray$1.newInstance({
      numberOfComponents,
      dataType,
      values
    }), preferSizeOverAccuracy);
  };
  publicAPI.create3DFilterableFromDataArray = function(width, height, depth, dataArray) {
    let preferSizeOverAccuracy = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
    const {
      numComps,
      dataType,
      data,
      scaleOffsets
    } = processDataArray(dataArray, preferSizeOverAccuracy);
    const numPixelsIn = width * height * depth;
    const offset3 = [];
    const scale7 = [];
    for (let c6 = 0; c6 < numComps; ++c6) {
      offset3[c6] = 0;
      scale7[c6] = 1;
    }
    model.volumeInfo = {
      scale: scale7,
      offset: offset3,
      dataComputedScale: scaleOffsets.scale,
      dataComputedOffset: scaleOffsets.offset,
      width,
      height,
      depth
    };
    const scaleOffsetsCopy = structuredClone(scaleOffsets);
    if (model._openGLRenderWindow.getWebgl2()) {
      if (model.oglNorm16Ext && !model.useHalfFloat && dataType === VtkDataTypes2.SHORT) {
        for (let c6 = 0; c6 < numComps; ++c6) {
          model.volumeInfo.scale[c6] = 32767;
        }
        return publicAPI.create3DFromRaw(width, height, depth, numComps, dataType, data);
      }
      if (model.oglNorm16Ext && !model.useHalfFloat && dataType === VtkDataTypes2.UNSIGNED_SHORT) {
        for (let c6 = 0; c6 < numComps; ++c6) {
          model.volumeInfo.scale[c6] = 65535;
        }
        return publicAPI.create3DFromRaw(width, height, depth, numComps, dataType, data);
      }
      if (dataType === VtkDataTypes2.FLOAT || model.useHalfFloat && (dataType === VtkDataTypes2.SHORT || dataType === VtkDataTypes2.UNSIGNED_SHORT)) {
        return publicAPI.create3DFromRaw(width, height, depth, numComps, dataType, data);
      }
      if (dataType === VtkDataTypes2.UNSIGNED_CHAR) {
        for (let c6 = 0; c6 < numComps; ++c6) {
          model.volumeInfo.scale[c6] = 255;
        }
        return publicAPI.create3DFromRaw(width, height, depth, numComps, dataType, data);
      }
      const newArray2 = new Float32Array(numPixelsIn * numComps);
      model.volumeInfo.offset = scaleOffsetsCopy.offset;
      model.volumeInfo.scale = scaleOffsetsCopy.scale;
      let count = 0;
      const scaleInverse = scaleOffsetsCopy.scale.map((s9) => 1 / s9);
      for (let i6 = 0; i6 < numPixelsIn; i6++) {
        for (let nc = 0; nc < numComps; nc++) {
          newArray2[count] = (data[count] - scaleOffsetsCopy.offset[nc]) * scaleInverse[nc];
          count++;
        }
      }
      return publicAPI.create3DFromRaw(width, height, depth, numComps, VtkDataTypes2.FLOAT, newArray2);
    }
    let volCopyData = (outArray, outIdx2, inValue, smin, smax) => {
      outArray[outIdx2] = inValue;
    };
    let dataTypeToUse = VtkDataTypes2.UNSIGNED_CHAR;
    if (dataType === VtkDataTypes2.UNSIGNED_CHAR) {
      for (let c6 = 0; c6 < numComps; ++c6) {
        scaleOffsetsCopy.offset[c6] = 0;
        scaleOffsetsCopy.scale[c6] = 255;
      }
    } else if (model.context.getExtension("OES_texture_float") && model.context.getExtension("OES_texture_float_linear")) {
      dataTypeToUse = VtkDataTypes2.FLOAT;
      volCopyData = (outArray, outIdx2, inValue, soffset, sscale) => {
        outArray[outIdx2] = (inValue - soffset) / sscale;
      };
    } else {
      dataTypeToUse = VtkDataTypes2.UNSIGNED_CHAR;
      volCopyData = (outArray, outIdx2, inValue, soffset, sscale) => {
        outArray[outIdx2] = 255 * (inValue - soffset) / sscale;
      };
    }
    publicAPI.getOpenGLDataType(dataTypeToUse);
    publicAPI.getInternalFormat(dataTypeToUse, numComps);
    publicAPI.getFormat(dataTypeToUse, numComps);
    if (!model.internalFormat || !model.format || !model.openGLDataType) {
      vtkErrorMacro14("Failed to determine texture parameters.");
      return false;
    }
    model.target = model.context.TEXTURE_2D;
    model.components = numComps;
    model.depth = 1;
    model.numberOfDimensions = 2;
    let maxTexDim = model.context.getParameter(model.context.MAX_TEXTURE_SIZE);
    if (maxTexDim > 4096 && (dataTypeToUse === VtkDataTypes2.FLOAT || numComps >= 3)) {
      maxTexDim = 4096;
    }
    let xstride = 1;
    let ystride = 1;
    if (numPixelsIn > maxTexDim * maxTexDim) {
      xstride = Math.ceil(Math.sqrt(numPixelsIn / (maxTexDim * maxTexDim)));
      ystride = xstride;
    }
    let targetWidth = Math.sqrt(numPixelsIn) / xstride;
    targetWidth = nearestPowerOfTwo(targetWidth);
    const xreps = Math.floor(targetWidth * xstride / width);
    const yreps = Math.ceil(depth / xreps);
    const targetHeight = nearestPowerOfTwo(height * yreps / ystride);
    model.width = targetWidth;
    model.height = targetHeight;
    model._openGLRenderWindow.activateTexture(publicAPI);
    publicAPI.createTexture();
    publicAPI.bind();
    model.volumeInfo.xreps = xreps;
    model.volumeInfo.yreps = yreps;
    model.volumeInfo.xstride = xstride;
    model.volumeInfo.ystride = ystride;
    model.volumeInfo.offset = scaleOffsetsCopy.offset;
    model.volumeInfo.scale = scaleOffsetsCopy.scale;
    let newArray;
    const pixCount = targetWidth * targetHeight * numComps;
    if (dataTypeToUse === VtkDataTypes2.FLOAT) {
      newArray = new Float32Array(pixCount);
    } else {
      newArray = new Uint8Array(pixCount);
    }
    let outIdx = 0;
    const tileWidth = Math.floor(width / xstride);
    const tileHeight = Math.floor(height / ystride);
    for (let yRep = 0; yRep < yreps; yRep++) {
      const xrepsThisRow = Math.min(xreps, depth - yRep * xreps);
      const outXContIncr = numComps * (model.width - xrepsThisRow * Math.floor(width / xstride));
      for (let tileY = 0; tileY < tileHeight; tileY++) {
        for (let xRep = 0; xRep < xrepsThisRow; xRep++) {
          const inOffset = numComps * ((yRep * xreps + xRep) * width * height + ystride * tileY * width);
          for (let tileX = 0; tileX < tileWidth; tileX++) {
            for (let nc = 0; nc < numComps; nc++) {
              volCopyData(newArray, outIdx, data[inOffset + xstride * tileX * numComps + nc], scaleOffsetsCopy.offset[nc], scaleOffsetsCopy.scale[nc]);
              outIdx++;
            }
          }
        }
        outIdx += outXContIncr;
      }
    }
    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);
    if (useTexStorage(dataTypeToUse)) {
      model.context.texStorage2D(model.target, 1, model.internalFormat, model.width, model.height);
      if (newArray != null) {
        model.context.texSubImage2D(model.target, 0, 0, 0, model.width, model.height, model.format, model.openGLDataType, newArray);
      }
    } else {
      model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, newArray);
    }
    publicAPI.deactivate();
    return true;
  };
  publicAPI.setOpenGLRenderWindow = (rw) => {
    if (model._openGLRenderWindow === rw) {
      return;
    }
    publicAPI.releaseGraphicsResources();
    model._openGLRenderWindow = rw;
    model.context = null;
    if (rw) {
      model.context = model._openGLRenderWindow.getContext();
    }
  };
  publicAPI.getMaximumTextureSize = (ctx) => {
    if (ctx && ctx.isCurrent()) {
      return ctx.getIntegerv(ctx.MAX_TEXTURE_SIZE);
    }
    return -1;
  };
}
var DEFAULT_VALUES29 = {
  _openGLRenderWindow: null,
  _forceInternalFormat: false,
  context: null,
  handle: 0,
  sendParametersTime: null,
  textureBuildTime: null,
  numberOfDimensions: 0,
  target: 0,
  format: 0,
  openGLDataType: 0,
  components: 0,
  width: 0,
  height: 0,
  depth: 0,
  autoParameters: true,
  wrapS: Wrap2.CLAMP_TO_EDGE,
  wrapT: Wrap2.CLAMP_TO_EDGE,
  wrapR: Wrap2.CLAMP_TO_EDGE,
  minificationFilter: Filter2.NEAREST,
  magnificationFilter: Filter2.NEAREST,
  minLOD: -1e3,
  maxLOD: 1e3,
  baseLevel: 0,
  maxLevel: 1e3,
  generateMipmap: false,
  // use half float by default, but it will get set
  // to false if the context does not support it or
  // the voxel intensity range is out of the accurate
  // range of half float
  useHalfFloat: true,
  oglNorm16Ext: null,
  allocatedGPUMemoryInBytes: 0
};
function extend30(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES29, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.sendParametersTime = {};
  obj(model.sendParametersTime, {
    mtime: 0
  });
  model.textureBuildTime = {};
  obj(model.textureBuildTime, {
    mtime: 0
  });
  set6(publicAPI, model, ["format", "openGLDataType"]);
  setGet(publicAPI, model, ["keyMatrixTime", "minificationFilter", "magnificationFilter", "wrapS", "wrapT", "wrapR", "generateMipmap", "oglNorm16Ext"]);
  get(publicAPI, model, ["width", "height", "volumeInfo", "components", "handle", "target", "allocatedGPUMemoryInBytes"]);
  moveToProtected(publicAPI, model, ["openGLRenderWindow"]);
  vtkOpenGLTexture(publicAPI, model);
}
var newInstance31 = newInstance(extend30, "vtkOpenGLTexture");
var vtkOpenGLTexture$1 = __spreadValues({
  newInstance: newInstance31,
  extend: extend30
}, Constants6);
registerOverride("vtkTexture", newInstance31);

// node_modules/@kitware/vtk.js/Rendering/OpenGL/ReplacementShaderMapper.js
function implementReplaceShaderCoincidentOffset(publicAPI, model) {
  publicAPI.replaceShaderCoincidentOffset = (shaders, ren, actor) => {
    const cp = publicAPI.getCoincidentParameters(ren, actor);
    if (cp && (cp.factor !== 0 || cp.offset !== 0)) {
      let FSSource = shaders.Fragment;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Coincident::Dec", ["uniform float cfactor;", "uniform float coffset;"]).result;
      if (model.context.getExtension("EXT_frag_depth")) {
        if (cp.factor !== 0) {
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::UniformFlow::Impl", ["float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));", "//VTK::UniformFlow::Impl"], false).result;
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Depth::Impl", "gl_FragDepthEXT = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;").result;
        } else {
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Depth::Impl", "gl_FragDepthEXT = gl_FragCoord.z + 0.000016*coffset;").result;
        }
      }
      if (model._openGLRenderWindow.getWebgl2()) {
        if (cp.factor !== 0) {
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::UniformFlow::Impl", ["float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));", "//VTK::UniformFlow::Impl"], false).result;
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Depth::Impl", "gl_FragDepth = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;").result;
        } else {
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Depth::Impl", "gl_FragDepth = gl_FragCoord.z + 0.000016*coffset;").result;
        }
      }
      shaders.Fragment = FSSource;
    }
  };
}
function implementBuildShadersWithReplacements(publicAPI, model) {
  publicAPI.applyShaderReplacements = (shaders, viewSpec, pre) => {
    let shaderReplacements = null;
    if (viewSpec) {
      shaderReplacements = viewSpec.ShaderReplacements;
    }
    if (shaderReplacements) {
      for (let i6 = 0; i6 < shaderReplacements.length; i6++) {
        const currReplacement = shaderReplacements[i6];
        if (pre && currReplacement.replaceFirst || !pre && !currReplacement.replaceFirst) {
          const shaderType = currReplacement.shaderType;
          const ssrc = shaders[shaderType];
          const substituteRes = vtkShaderProgram$1.substitute(ssrc, currReplacement.originalValue, currReplacement.replacementValue, currReplacement.replaceAll);
          shaders[shaderType] = substituteRes.result;
        }
      }
    }
  };
  publicAPI.buildShaders = (shaders, ren, actor) => {
    publicAPI.getReplacedShaderTemplate(shaders, ren, actor);
    model.lastRenderPassShaderReplacement = model.currentRenderPass ? model.currentRenderPass.getShaderReplacement() : null;
    if (model.lastRenderPassShaderReplacement) {
      model.lastRenderPassShaderReplacement(shaders);
    }
    const openGLSpec = model.renderable.getViewSpecificProperties().OpenGL;
    publicAPI.applyShaderReplacements(shaders, openGLSpec, true);
    publicAPI.replaceShaderValues(shaders, ren, actor);
    publicAPI.applyShaderReplacements(shaders, openGLSpec);
  };
  publicAPI.getReplacedShaderTemplate = (shaders, ren, actor) => {
    const openGLSpecProp = model.renderable.getViewSpecificProperties().OpenGL;
    publicAPI.getShaderTemplate(shaders, ren, actor);
    let vertexShaderCode = shaders.Vertex;
    if (openGLSpecProp) {
      const vertexSpecProp = openGLSpecProp.VertexShaderCode;
      if (vertexSpecProp !== void 0 && vertexSpecProp !== "") {
        vertexShaderCode = vertexSpecProp;
      }
    }
    shaders.Vertex = vertexShaderCode;
    let fragmentShaderCode = shaders.Fragment;
    if (openGLSpecProp) {
      const fragmentSpecProp = openGLSpecProp.FragmentShaderCode;
      if (fragmentSpecProp !== void 0 && fragmentSpecProp !== "") {
        fragmentShaderCode = fragmentSpecProp;
      }
    }
    shaders.Fragment = fragmentShaderCode;
    let geometryShaderCode = shaders.Geometry;
    if (openGLSpecProp) {
      const geometrySpecProp = openGLSpecProp.GeometryShaderCode;
      if (geometrySpecProp !== void 0) {
        geometryShaderCode = geometrySpecProp;
      }
    }
    shaders.Geometry = geometryShaderCode;
  };
}
var vtkReplacementShaderMapper = {
  implementReplaceShaderCoincidentOffset,
  implementBuildShadersWithReplacements
};

// node_modules/@kitware/vtk.js/Common/Transform/Transform.js
var newInstance32;
function vtkTransform(publicAPI, model) {
  model.classHierarchy.push("vtkAbstractTransform", "vtkHomogeneousTransform", "vtkTransform");
  publicAPI.transformPoint = (point, out) => {
    vec3_exports.transformMat4(out, point, model.matrix);
    return out;
  };
  publicAPI.transformPoints = (points, out) => {
    const inPoint = new Float64Array(3);
    const outPoint = new Float64Array(3);
    for (let i6 = 0; i6 < points.length; i6 += 3) {
      inPoint[0] = points[i6];
      inPoint[1] = points[i6 + 1];
      inPoint[2] = points[i6 + 2];
      vec3_exports.transformMat4(outPoint, inPoint, model.matrix);
      out[i6] = outPoint[0];
      out[i6 + 1] = outPoint[1];
      out[i6 + 2] = outPoint[2];
    }
    return out;
  };
  publicAPI.preMultiply = () => {
    publicAPI.setPreMultiplyFlag(true);
  };
  publicAPI.postMultiply = () => {
    publicAPI.setPreMultiplyFlag(false);
  };
  publicAPI.transformMatrix = (matrix, out) => {
    if (model.preMultiplyFlag) {
      mat4_exports.multiply(out, model.matrix, matrix);
    } else {
      mat4_exports.multiply(out, matrix, model.matrix);
    }
    return out;
  };
  publicAPI.transformMatrices = (matrices, out) => {
    const inMat = new Float64Array(16);
    const outMat = new Float64Array(16);
    const transform2 = model.preMultiplyFlag ? () => mat4_exports.multiply(outMat, model.matrix, inMat) : () => mat4_exports.multiply(outMat, inMat, model.matrix);
    for (let i6 = 0; i6 < matrices.length; i6 += 16) {
      for (let j2 = 0; j2 < 16; ++j2) {
        inMat[j2] = matrices[i6 + j2];
      }
      transform2();
      for (let j2 = 0; j2 < 16; ++j2) {
        out[i6 + j2] = outMat[j2];
      }
    }
    return out;
  };
  publicAPI.getInverse = () => newInstance32({
    matrix: vtkMath.invertMatrix(Array.from(model.matrix), [], 4),
    preMultiplyFlag: model.preMultiplyFlag
  });
}
var DEFAULT_VALUES30 = {
  preMultiplyFlag: false,
  matrix: [...IDENTITY]
};
function extend31(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES30, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["preMultiplyFlag"]);
  macro.setGetArray(publicAPI, model, ["matrix"], 16);
  vtkTransform(publicAPI, model);
}
newInstance32 = macro.newInstance(extend31, "vtkTransform");
var vtkTransform$1 = {
  newInstance: newInstance32,
  extend: extend31
};

// node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkImageResliceMapperVS.glsl.js
var vtkImageResliceMapperVS = "//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkImageResliceMapperVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\n// all variables that represent positions or directions have a suffix\n// indicating the coordinate system they are in. The possible values are\n// MC - Model coordinates\n// WC - World coordinates\n// VC - View coordinates\n// DC - Display coordinates\n// TC - Texture coordinates\n\n// frag position in VC\n//VTK::PositionVC::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\nvoid main()\n{\n  //VTK::PositionVC::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Picking::Impl\n}\n";

// node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkImageResliceMapperFS.glsl.js
var vtkImageResliceMapperFS = "//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkImageResliceMapperFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// Template for the gpu image mapper fragment shader\n\n// VC position of this fragment\n//VTK::PositionVC::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// handle coincident offsets\n//VTK::Coincident::Dec\n\n//VTK::ZBuffer::Dec\n\n// the output of this shader\n//VTK::Output::Dec\n\nvoid main()\n{\n  // VC position of this fragment. This should not branch/return/discard.\n  //VTK::PositionVC::Impl\n\n  // Place any calls that require uniform flow (e.g. dFdx) here.\n  //VTK::UniformFlow::Impl\n\n  // Set gl_FragDepth here (gl_FragCoord.z by default)\n  //VTK::Depth::Impl\n\n  // Early depth peeling abort:\n  //VTK::DepthPeeling::PreColor\n\n  //VTK::TCoord::Impl\n\n  if (gl_FragData[0].a <= 0.0)\n    {\n    discard;\n    }\n\n  //VTK::DepthPeeling::Impl\n\n  //VTK::Picking::Impl\n\n  // handle coincident offsets\n  //VTK::Coincident::Impl\n\n  //VTK::ZBuffer::Impl\n\n  //VTK::RenderPassFragmentShader::Impl\n}\n";

// node_modules/@kitware/vtk.js/Rendering/Core/ImageProperty/Constants.js
var InterpolationType = {
  NEAREST: 0,
  LINEAR: 1
};
var Constants7 = {
  InterpolationType
};

// node_modules/@kitware/vtk.js/Rendering/OpenGL/ImageResliceMapper.js
var {
  vtkErrorMacro: vtkErrorMacro15
} = macro$1;
function computeFnToString(property, pwfun, numberOfComponents) {
  if (pwfun) {
    const iComps = property.getIndependentComponents();
    return `${pwfun.getMTime()}-${iComps}-${numberOfComponents}`;
  }
  return "0";
}
function safeMatrixMultiply(matrixArray, matrixType, tmpMat) {
  matrixType.identity(tmpMat);
  return matrixArray.reduce((res, matrix, index2) => {
    if (index2 === 0) {
      return matrix ? matrixType.copy(res, matrix) : matrixType.identity(res);
    }
    return matrix ? matrixType.multiply(res, res, matrix) : res;
  }, tmpMat);
}
function vtkOpenGLImageResliceMapper(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLImageResliceMapper");
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      model.currentRenderPass = null;
      model._openGLImageSlice = publicAPI.getFirstAncestorOfType("vtkOpenGLImageSlice");
      model._openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
      const ren = model._openGLRenderer.getRenderable();
      model._openGLCamera = model._openGLRenderer.getViewNodeFor(ren.getActiveCamera());
      model._openGLRenderWindow = model._openGLRenderer.getParent();
      model.context = model._openGLRenderWindow.getContext();
      model.tris.setOpenGLRenderWindow(model._openGLRenderWindow);
    }
  };
  publicAPI.translucentPass = (prepass, renderPass) => {
    if (prepass) {
      model.currentRenderPass = renderPass;
      publicAPI.render();
    }
  };
  publicAPI.zBufferPass = (prepass) => {
    if (prepass) {
      model.haveSeenDepthRequest = true;
      model.renderDepth = true;
      publicAPI.render();
      model.renderDepth = false;
    }
  };
  publicAPI.opaqueZBufferPass = (prepass) => publicAPI.zBufferPass(prepass);
  publicAPI.opaquePass = (prepass) => {
    if (prepass) {
      publicAPI.render();
    }
  };
  publicAPI.getCoincidentParameters = (ren, actor) => {
    if (model.renderable.getResolveCoincidentTopology()) {
      return model.renderable.getCoincidentTopologyPolygonOffsetParameters();
    }
    return null;
  };
  publicAPI.render = () => {
    const actor = model._openGLImageSlice.getRenderable();
    const ren = model._openGLRenderer.getRenderable();
    publicAPI.renderPiece(ren, actor);
  };
  publicAPI.renderPiece = (ren, actor) => {
    publicAPI.invokeEvent({
      type: "StartEvent"
    });
    model.renderable.update();
    model.currentInput = model.renderable.getInputData();
    if (!model.currentInput) {
      vtkErrorMacro15("No input!");
      return;
    }
    publicAPI.updateResliceGeometry();
    publicAPI.renderPieceStart(ren, actor);
    publicAPI.renderPieceDraw(ren, actor);
    publicAPI.renderPieceFinish(ren, actor);
    publicAPI.invokeEvent({
      type: "EndEvent"
    });
  };
  publicAPI.renderPieceStart = (ren, actor) => {
    publicAPI.updateBufferObjects(ren, actor);
    const iType = actor.getProperty().getInterpolationType();
    if (iType === InterpolationType.NEAREST) {
      model.openGLTexture.setMinificationFilter(Filter.NEAREST);
      model.openGLTexture.setMagnificationFilter(Filter.NEAREST);
      model.colorTexture.setMinificationFilter(Filter.NEAREST);
      model.colorTexture.setMagnificationFilter(Filter.NEAREST);
      model.pwfTexture.setMinificationFilter(Filter.NEAREST);
      model.pwfTexture.setMagnificationFilter(Filter.NEAREST);
    } else {
      model.openGLTexture.setMinificationFilter(Filter.LINEAR);
      model.openGLTexture.setMagnificationFilter(Filter.LINEAR);
      model.colorTexture.setMinificationFilter(Filter.LINEAR);
      model.colorTexture.setMagnificationFilter(Filter.LINEAR);
      model.pwfTexture.setMinificationFilter(Filter.LINEAR);
      model.pwfTexture.setMagnificationFilter(Filter.LINEAR);
    }
    model.lastBoundBO = null;
  };
  publicAPI.renderPieceDraw = (ren, actor) => {
    const gl = model.context;
    model.openGLTexture.activate();
    model.colorTexture.activate();
    model.pwfTexture.activate();
    publicAPI.updateShaders(model.tris, ren, actor);
    gl.drawArrays(gl.TRIANGLES, 0, model.tris.getCABO().getElementCount());
    model.tris.getVAO().release();
    model.openGLTexture.deactivate();
    model.colorTexture.deactivate();
    model.pwfTexture.deactivate();
  };
  publicAPI.renderPieceFinish = (ren, actor) => {
  };
  publicAPI.updateBufferObjects = (ren, actor) => {
    if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {
      publicAPI.buildBufferObjects(ren, actor);
    }
  };
  publicAPI.getNeedToRebuildBufferObjects = (ren, actor) => model.VBOBuildTime.getMTime() < publicAPI.getMTime() || model.VBOBuildTime.getMTime() < actor.getMTime() || model.VBOBuildTime.getMTime() < model.renderable.getMTime() || model.VBOBuildTime.getMTime() < actor.getProperty().getMTime() || model.VBOBuildTime.getMTime() < model.currentInput.getMTime() || model.VBOBuildTime.getMTime() < model.resliceGeom.getMTime();
  publicAPI.buildBufferObjects = (ren, actor) => {
    var _a9;
    const image2 = model.currentInput;
    if (!image2) {
      return;
    }
    const scalars = (_a9 = image2.getPointData()) == null ? void 0 : _a9.getScalars();
    if (!scalars) {
      return;
    }
    if (model._scalars !== scalars) {
      model._openGLRenderWindow.releaseGraphicsResourcesForObject(model._scalars);
      model._scalars = scalars;
    }
    const numComp = scalars.getNumberOfComponents();
    let toString3 = `${image2.getMTime()}A${scalars.getMTime()}`;
    const tex = model._openGLRenderWindow.getGraphicsResourceForObject(scalars);
    const reBuildTex = !(tex == null ? void 0 : tex.vtkObj) || (tex == null ? void 0 : tex.hash) !== toString3;
    if (reBuildTex) {
      if (!model.openGLTexture) {
        model.openGLTexture = vtkOpenGLTexture$1.newInstance();
        model.openGLTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      }
      const dims = image2.getDimensions();
      model.openGLTexture.setOglNorm16Ext(model.context.getExtension("EXT_texture_norm16"));
      model.openGLTexture.releaseGraphicsResources(model._openGLRenderWindow);
      model.openGLTexture.resetFormatAndType();
      model.openGLTexture.create3DFilterableFromDataArray(dims[0], dims[1], dims[2], scalars);
      if (scalars) {
        model._openGLRenderWindow.setGraphicsResourceForObject(scalars, model.openGLTexture, toString3);
      }
    } else {
      model.openGLTexture = tex.vtkObj;
    }
    const ppty = actor.getProperty();
    const iComps = ppty.getIndependentComponents();
    const numIComps = iComps ? numComp : 1;
    const textureHeight = iComps ? 2 * numIComps : 1;
    const colorTransferFunc = ppty.getRGBTransferFunction();
    toString3 = computeFnToString(ppty, colorTransferFunc, numIComps);
    const cTex = model._openGLRenderWindow.getGraphicsResourceForObject(colorTransferFunc);
    const reBuildC = !(cTex == null ? void 0 : cTex.vtkObj) || (cTex == null ? void 0 : cTex.hash) !== toString3 || model.colorTextureString !== toString3;
    if (reBuildC) {
      const cWidth = 1024;
      const cSize = cWidth * textureHeight * 3;
      const cTable = new Uint8ClampedArray(cSize);
      if (!model.colorTexture) {
        model.colorTexture = vtkOpenGLTexture$1.newInstance();
        model.colorTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      }
      if (colorTransferFunc) {
        const tmpTable = new Float32Array(cWidth * 3);
        for (let c6 = 0; c6 < numIComps; c6++) {
          const cfun = ppty.getRGBTransferFunction(c6);
          const cRange = cfun.getRange();
          cfun.getTable(cRange[0], cRange[1], cWidth, tmpTable, 1);
          if (iComps) {
            for (let i6 = 0; i6 < cWidth * 3; i6++) {
              cTable[c6 * cWidth * 6 + i6] = 255 * tmpTable[i6];
              cTable[c6 * cWidth * 6 + i6 + cWidth * 3] = 255 * tmpTable[i6];
            }
          } else {
            for (let i6 = 0; i6 < cWidth * 3; i6++) {
              cTable[c6 * cWidth * 6 + i6] = 255 * tmpTable[i6];
            }
          }
        }
        model.colorTexture.releaseGraphicsResources(model._openGLRenderWindow);
        model.colorTexture.resetFormatAndType();
        model.colorTexture.create2DFromRaw(cWidth, textureHeight, 3, VtkDataTypes.UNSIGNED_CHAR, cTable);
      } else {
        for (let i6 = 0; i6 < cWidth * 3; ++i6) {
          cTable[i6] = 255 * i6 / ((cWidth - 1) * 3);
          cTable[i6 + 1] = 255 * i6 / ((cWidth - 1) * 3);
          cTable[i6 + 2] = 255 * i6 / ((cWidth - 1) * 3);
        }
        model.colorTexture.releaseGraphicsResources(model._openGLRenderWindow);
        model.colorTexture.resetFormatAndType();
        model.colorTexture.create2DFromRaw(cWidth, 1, 3, VtkDataTypes.UNSIGNED_CHAR, cTable);
      }
      model.colorTextureString = toString3;
      if (colorTransferFunc) {
        model._openGLRenderWindow.setGraphicsResourceForObject(colorTransferFunc, model.colorTexture, model.colorTextureString);
      }
    } else {
      model.colorTexture = cTex.vtkObj;
      model.colorTextureString = cTex.hash;
    }
    const pwFunc = ppty.getPiecewiseFunction();
    toString3 = computeFnToString(ppty, pwFunc, numIComps);
    const pwfTex = model._openGLRenderWindow.getGraphicsResourceForObject(pwFunc);
    const reBuildPwf = !(pwfTex == null ? void 0 : pwfTex.vtkObj) || (pwfTex == null ? void 0 : pwfTex.hash) !== toString3 || model.pwfTextureString !== toString3;
    if (reBuildPwf) {
      const pwfWidth = 1024;
      const pwfSize = pwfWidth * textureHeight;
      const pwfTable = new Uint8ClampedArray(pwfSize);
      if (!model.pwfTexture) {
        model.pwfTexture = vtkOpenGLTexture$1.newInstance();
        model.pwfTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      }
      if (pwFunc) {
        const pwfFloatTable = new Float32Array(pwfSize);
        const tmpTable = new Float32Array(pwfWidth);
        for (let c6 = 0; c6 < numIComps; ++c6) {
          const pwfun = ppty.getPiecewiseFunction(c6);
          if (pwfun === null) {
            pwfFloatTable.fill(1);
          } else {
            const pwfRange = pwfun.getRange();
            pwfun.getTable(pwfRange[0], pwfRange[1], pwfWidth, tmpTable, 1);
            if (iComps) {
              for (let i6 = 0; i6 < pwfWidth; i6++) {
                pwfFloatTable[c6 * pwfWidth * 2 + i6] = tmpTable[i6];
                pwfFloatTable[c6 * pwfWidth * 2 + i6 + pwfWidth] = tmpTable[i6];
              }
            } else {
              for (let i6 = 0; i6 < pwfWidth; i6++) {
                pwfFloatTable[c6 * pwfWidth * 2 + i6] = tmpTable[i6];
              }
            }
          }
        }
        model.pwfTexture.releaseGraphicsResources(model._openGLRenderWindow);
        model.pwfTexture.resetFormatAndType();
        model.pwfTexture.create2DFromRaw(pwfWidth, textureHeight, 1, VtkDataTypes.FLOAT, pwfFloatTable);
      } else {
        pwfTable.fill(255);
        model.pwfTexture.releaseGraphicsResources(model._openGLRenderWindow);
        model.pwfTexture.resetFormatAndType();
        model.pwfTexture.create2DFromRaw(pwfWidth, 1, 1, VtkDataTypes.UNSIGNED_CHAR, pwfTable);
      }
      model.pwfTextureString = toString3;
      if (pwFunc) {
        model._openGLRenderWindow.setGraphicsResourceForObject(pwFunc, model.pwfTexture, model.pwfTextureString);
      }
    } else {
      model.pwfTexture = pwfTex.vtkObj;
      model.pwfTextureString = pwfTex.hash;
    }
    const vboString = `${model.resliceGeom.getMTime()}A${model.renderable.getSlabThickness()}`;
    if (!model.tris.getCABO().getElementCount() || model.VBOBuildString !== vboString) {
      const points = vtkDataArray$1.newInstance({
        numberOfComponents: 3,
        values: model.resliceGeom.getPoints().getData()
      });
      points.setName("points");
      const cells = vtkDataArray$1.newInstance({
        numberOfComponents: 1,
        values: model.resliceGeom.getPolys().getData()
      });
      const options = {
        points,
        cellOffset: 0
      };
      if (model.renderable.getSlabThickness() > 0) {
        const n9 = model.resliceGeom.getPointData().getNormals();
        if (!n9) {
          vtkErrorMacro15("Slab mode requested without normals");
        } else {
          options.normals = n9;
        }
      }
      model.tris.getCABO().createVBO(cells, "polys", Representation.SURFACE, options);
    }
    model.VBOBuildString = vboString;
    model.VBOBuildTime.modified();
  };
  publicAPI.updateShaders = (cellBO, ren, actor) => {
    model.lastBoundBO = cellBO;
    if (publicAPI.getNeedToRebuildShaders(cellBO, ren, actor)) {
      const shaders = {
        Vertex: null,
        Fragment: null,
        Geometry: null
      };
      publicAPI.buildShaders(shaders, ren, actor);
      const newShader = model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(shaders.Vertex, shaders.Fragment, shaders.Geometry);
      if (newShader !== cellBO.getProgram()) {
        cellBO.setProgram(newShader);
        cellBO.getVAO().releaseGraphicsResources();
      }
      cellBO.getShaderSourceTime().modified();
    } else {
      model._openGLRenderWindow.getShaderCache().readyShaderProgram(cellBO.getProgram());
    }
    cellBO.getVAO().bind();
    publicAPI.setMapperShaderParameters(cellBO, ren, actor);
    publicAPI.setCameraShaderParameters(cellBO, ren, actor);
    publicAPI.setPropertyShaderParameters(cellBO, ren, actor);
  };
  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {
    const program = cellBO.getProgram();
    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime.getMTime() > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {
      if (program.isUniformUsed("texture1")) {
        program.setUniformi("texture1", model.openGLTexture.getTextureUnit());
      }
      if (program.isAttributeUsed("vertexWC")) {
        if (!cellBO.getVAO().addAttributeArray(program, cellBO.getCABO(), "vertexWC", cellBO.getCABO().getVertexOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {
          vtkErrorMacro15("Error setting vertexWC in shader VAO.");
        }
      }
      if (program.isAttributeUsed("normalWC")) {
        if (!cellBO.getVAO().addAttributeArray(program, cellBO.getCABO(), "normalWC", cellBO.getCABO().getNormalOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {
          vtkErrorMacro15("Error setting normalWC in shader VAO.");
        }
      }
      if (program.isUniformUsed("slabThickness")) {
        program.setUniformf("slabThickness", model.renderable.getSlabThickness());
      }
      if (program.isUniformUsed("spacing")) {
        program.setUniform3fv("spacing", model.currentInput.getSpacing());
      }
      if (program.isUniformUsed("slabType")) {
        program.setUniformi("slabType", model.renderable.getSlabType());
      }
      if (program.isUniformUsed("slabType")) {
        program.setUniformi("slabType", model.renderable.getSlabType());
      }
      if (program.isUniformUsed("slabTrapezoid")) {
        program.setUniformi("slabTrapezoid", model.renderable.getSlabTrapezoidIntegration());
      }
      const shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();
      const inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;
      if (program.isUniformUsed("WCTCMatrix")) {
        const image2 = model.currentInput;
        const dim = image2.getDimensions();
        mat4_exports.copy(model.tmpMat4, image2.getIndexToWorld());
        mat4_exports.scale(model.tmpMat4, model.tmpMat4, dim);
        mat4_exports.invert(model.tmpMat4, model.tmpMat4);
        if (inverseShiftScaleMatrix) {
          mat4_exports.multiply(model.tmpMat4, model.tmpMat4, inverseShiftScaleMatrix);
        }
        program.setUniformMatrix("WCTCMatrix", model.tmpMat4);
      }
      if (program.isUniformUsed("vboScaling")) {
        program.setUniform3fv("vboScaling", cellBO.getCABO().getCoordScale());
      }
      cellBO.getAttributeUpdateTime().modified();
    }
    if (model.haveSeenDepthRequest) {
      cellBO.getProgram().setUniformi("depthRequest", model.renderDepth ? 1 : 0);
    }
    if (cellBO.getProgram().isUniformUsed("coffset")) {
      const cp = publicAPI.getCoincidentParameters(ren, actor);
      cellBO.getProgram().setUniformf("coffset", cp.offset);
      if (cellBO.getProgram().isUniformUsed("cfactor")) {
        cellBO.getProgram().setUniformf("cfactor", cp.factor);
      }
    }
  };
  publicAPI.setCameraShaderParameters = (cellBO, ren, actor) => {
    const keyMats = model._openGLCamera.getKeyMatrices(ren);
    const actMats = model._openGLImageSlice.getKeyMatrices();
    const shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();
    const inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;
    const program = cellBO.getProgram();
    if (program.isUniformUsed("MCPCMatrix")) {
      mat4_exports.identity(model.tmpMat4);
      program.setUniformMatrix("MCPCMatrix", safeMatrixMultiply([keyMats.wcpc, actMats.mcwc, inverseShiftScaleMatrix], mat4_exports, model.tmpMat4));
    }
    if (program.isUniformUsed("MCVCMatrix")) {
      mat4_exports.identity(model.tmpMat4);
      program.setUniformMatrix("MCVCMatrix", safeMatrixMultiply([keyMats.wcvc, actMats.mcwc, inverseShiftScaleMatrix], mat4_exports, model.tmpMat4));
    }
  };
  publicAPI.setPropertyShaderParameters = (cellBO, ren, actor) => {
    const program = cellBO.getProgram();
    const ppty = actor.getProperty();
    const opacity = ppty.getOpacity();
    program.setUniformf("opacity", opacity);
    const numComp = model.openGLTexture.getComponents();
    const iComps = ppty.getIndependentComponents();
    if (iComps) {
      for (let i6 = 0; i6 < numComp; ++i6) {
        program.setUniformf(`mix${i6}`, ppty.getComponentWeight(i6));
      }
    }
    const volInfo = model.openGLTexture.getVolumeInfo();
    for (let i6 = 0; i6 < numComp; i6++) {
      let cw = ppty.getColorWindow();
      let cl = ppty.getColorLevel();
      const target = iComps ? i6 : 0;
      const cfun = ppty.getRGBTransferFunction(target);
      if (cfun && ppty.getUseLookupTableScalarRange()) {
        const cRange = cfun.getRange();
        cw = cRange[1] - cRange[0];
        cl = 0.5 * (cRange[1] + cRange[0]);
      }
      const scale7 = volInfo.scale[i6] / cw;
      const shift3 = (volInfo.offset[i6] - cl) / cw + 0.5;
      program.setUniformf(`cshift${i6}`, shift3);
      program.setUniformf(`cscale${i6}`, scale7);
    }
    const texColorUnit = model.colorTexture.getTextureUnit();
    program.setUniformi("colorTexture1", texColorUnit);
    for (let i6 = 0; i6 < numComp; i6++) {
      let pwfScale = 1;
      let pwfShift = 0;
      const target = iComps ? i6 : 0;
      const pwfun = ppty.getPiecewiseFunction(target);
      if (pwfun) {
        const pwfRange = pwfun.getRange();
        const length4 = pwfRange[1] - pwfRange[0];
        const mid = 0.5 * (pwfRange[0] + pwfRange[1]);
        pwfScale = volInfo.scale[i6] / length4;
        pwfShift = (volInfo.offset[i6] - mid) / length4 + 0.5;
      }
      program.setUniformf(`pwfshift${i6}`, pwfShift);
      program.setUniformf(`pwfscale${i6}`, pwfScale);
    }
    const texOpacityUnit = model.pwfTexture.getTextureUnit();
    program.setUniformi("pwfTexture1", texOpacityUnit);
    program.setUniform4fv("backgroundColor", model.renderable.getBackgroundColor());
  };
  publicAPI.getNeedToRebuildShaders = (cellBO, ren, actor) => {
    var _a9;
    const tNumComp = model.openGLTexture.getComponents();
    const iComp = actor.getProperty().getIndependentComponents();
    const slabTh = model.renderable.getSlabThickness();
    const slabType = model.renderable.getSlabType();
    const slabTrap = model.renderable.getSlabTrapezoidIntegration();
    let needRebuild = false;
    if (!model.currentRenderPass && model.lastRenderPassShaderReplacement || model.currentRenderPass && model.currentRenderPass.getShaderReplacement() !== model.lastRenderPassShaderReplacement) {
      needRebuild = true;
    }
    if (needRebuild || model.lastHaveSeenDepthRequest !== model.haveSeenDepthRequest || ((_a9 = cellBO.getProgram()) == null ? void 0 : _a9.getHandle()) === 0 || model.lastTextureComponents !== tNumComp || model.lastIndependentComponents !== iComp || model.lastSlabThickness !== slabTh || model.lastSlabType !== slabType || model.lastSlabTrapezoidIntegration !== slabTrap) {
      model.lastHaveSeenDepthRequest = model.haveSeenDepthRequest;
      model.lastTextureComponents = tNumComp;
      model.lastIndependentComponents = iComp;
      model.lastSlabThickness = slabTh;
      model.lastSlabType = slabType;
      model.lastSlabTrapezoidIntegration = slabTrap;
      return true;
    }
    return false;
  };
  publicAPI.getShaderTemplate = (shaders, ren, actor) => {
    shaders.Vertex = vtkImageResliceMapperVS;
    shaders.Fragment = vtkImageResliceMapperFS;
    shaders.Geometry = "";
  };
  publicAPI.replaceShaderValues = (shaders, ren, actor) => {
    publicAPI.replaceShaderTCoord(shaders, ren, actor);
    publicAPI.replaceShaderPositionVC(shaders, ren, actor);
    if (model.haveSeenDepthRequest) {
      let FSSource = shaders.Fragment;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ZBuffer::Dec", "uniform int depthRequest;").result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ZBuffer::Impl", ["if (depthRequest == 1) {", "float iz = floor(gl_FragCoord.z*65535.0 + 0.1);", "float rf = floor(iz/256.0)/255.0;", "float gf = mod(iz,256.0)/255.0;", "gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result;
      shaders.Fragment = FSSource;
    }
    publicAPI.replaceShaderCoincidentOffset(shaders, ren, actor);
  };
  publicAPI.replaceShaderTCoord = (shaders, ren, actor) => {
    let VSSource = shaders.Vertex;
    const GSSource = shaders.Geometry;
    let FSSource = shaders.Fragment;
    const tcoordVSDec = ["uniform mat4 WCTCMatrix;", "out vec3 fragTexCoord;"];
    const slabThickness = model.renderable.getSlabThickness();
    VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::TCoord::Dec", tcoordVSDec).result;
    const tcoordVSImpl = ["fragTexCoord = (WCTCMatrix * vertexWC).xyz;"];
    VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::TCoord::Impl", tcoordVSImpl).result;
    const tNumComp = model.openGLTexture.getComponents();
    const iComps = actor.getProperty().getIndependentComponents();
    let tcoordFSDec = [
      "in vec3 fragTexCoord;",
      "uniform highp sampler3D texture1;",
      "uniform mat4 WCTCMatrix;",
      // color shift and scale
      "uniform float cshift0;",
      "uniform float cscale0;",
      // pwf shift and scale
      "uniform float pwfshift0;",
      "uniform float pwfscale0;",
      // color and pwf textures
      "uniform sampler2D colorTexture1;",
      "uniform sampler2D pwfTexture1;",
      // opacity
      "uniform float opacity;",
      // background color
      "uniform vec4 backgroundColor;"
    ];
    if (iComps) {
      for (let comp = 1; comp < tNumComp; comp++) {
        tcoordFSDec = tcoordFSDec.concat([
          // color shift and scale
          `uniform float cshift${comp};`,
          `uniform float cscale${comp};`,
          // weighting shift and scale
          `uniform float pwfshift${comp};`,
          `uniform float pwfscale${comp};`
        ]);
      }
      switch (tNumComp) {
        case 1:
          tcoordFSDec = tcoordFSDec.concat(["uniform float mix0;", "#define height0 0.5"]);
          break;
        case 2:
          tcoordFSDec = tcoordFSDec.concat(["uniform float mix0;", "uniform float mix1;", "#define height0 0.25", "#define height1 0.75"]);
          break;
        case 3:
          tcoordFSDec = tcoordFSDec.concat(["uniform float mix0;", "uniform float mix1;", "uniform float mix2;", "#define height0 0.17", "#define height1 0.5", "#define height2 0.83"]);
          break;
        case 4:
          tcoordFSDec = tcoordFSDec.concat(["uniform float mix0;", "uniform float mix1;", "uniform float mix2;", "uniform float mix3;", "#define height0 0.125", "#define height1 0.375", "#define height2 0.625", "#define height3 0.875"]);
          break;
        default:
          vtkErrorMacro15("Unsupported number of independent coordinates.");
      }
    }
    if (slabThickness > 0) {
      tcoordFSDec = tcoordFSDec.concat(["uniform vec3 spacing;", "uniform float slabThickness;", "uniform int slabType;", "uniform int slabTrapezoid;", "uniform vec3 vboScaling;"]);
      tcoordFSDec = tcoordFSDec.concat(["vec4 compositeValue(vec4 currVal, vec4 valToComp, int trapezoid)", "{", "  vec4 retVal = vec4(1.0);", "  if (slabType == 0) // min", "  {", "    retVal = min(currVal, valToComp);", "  }", "  else if (slabType == 1) // max", "  {", "    retVal = max(currVal, valToComp);", "  }", "  else if (slabType == 3) // sum", "  {", "    retVal = currVal + (trapezoid > 0 ? 0.5 * valToComp : valToComp); ", "  }", "  else // mean", "  {", "    retVal = currVal + (trapezoid > 0 ? 0.5 * valToComp : valToComp); ", "  }", "  return retVal;", "}"]);
    }
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Dec", tcoordFSDec).result;
    let tcoordFSImpl = ["if (any(greaterThan(fragTexCoord, vec3(1.0))) || any(lessThan(fragTexCoord, vec3(0.0))))", "{", "  // set the background color and exit", "  gl_FragData[0] = backgroundColor;", "  return;", "}", "vec4 tvalue = texture(texture1, fragTexCoord);"];
    if (slabThickness > 0) {
      tcoordFSImpl = tcoordFSImpl.concat(["// Get the first and last samples", "int numSlices = 1;", "float scaling = min(min(spacing.x, spacing.y), spacing.z) * 0.5;", "vec3 normalxspacing = scaling * normalWCVSOutput;", "float distTraveled = length(normalxspacing);", "int trapezoid = 0;", "while (distTraveled < slabThickness * 0.5)", "{", "  distTraveled += length(normalxspacing);", "  float fnumSlices = float(numSlices);", "  if (distTraveled > slabThickness * 0.5)", "  {", "    // Before stepping outside the slab, sample at the boundaries", "    normalxspacing = normalWCVSOutput * slabThickness * 0.5 / fnumSlices;", "    trapezoid = slabTrapezoid;", "  }", "  vec3 fragTCoordNeg = (WCTCMatrix * vec4(vertexWCVSOutput.xyz - fnumSlices * normalxspacing * vboScaling, 1.0)).xyz;", "  if (!any(greaterThan(fragTCoordNeg, vec3(1.0))) && !any(lessThan(fragTCoordNeg, vec3(0.0))))", "  {", "    vec4 newVal = texture(texture1, fragTCoordNeg);", "    tvalue = compositeValue(tvalue, newVal, trapezoid);", "    numSlices += 1;", "  }", "  vec3 fragTCoordPos = (WCTCMatrix * vec4(vertexWCVSOutput.xyz + fnumSlices * normalxspacing * vboScaling, 1.0)).xyz;", "  if (!any(greaterThan(fragTCoordNeg, vec3(1.0))) && !any(lessThan(fragTCoordNeg, vec3(0.0))))", "  {", "    vec4 newVal = texture(texture1, fragTCoordPos);", "    tvalue = compositeValue(tvalue, newVal, trapezoid);", "    numSlices += 1;", "  }", "}", "// Finally, if slab type is *mean*, divide the sum by the numSlices", "if (slabType == 2)", "{", "  tvalue = tvalue / float(numSlices);", "}"]);
    }
    if (iComps) {
      const rgba = ["r", "g", "b", "a"];
      for (let comp = 0; comp < tNumComp; ++comp) {
        tcoordFSImpl = tcoordFSImpl.concat([`vec3 tcolor${comp} = mix${comp} * texture2D(colorTexture1, vec2(tvalue.${rgba[comp]} * cscale${comp} + cshift${comp}, height${comp})).rgb;`, `float compWeight${comp} = mix${comp} * texture2D(pwfTexture1, vec2(tvalue.${rgba[comp]} * pwfscale${comp} + pwfshift${comp}, height${comp})).r;`]);
      }
      switch (tNumComp) {
        case 1:
          tcoordFSImpl = tcoordFSImpl.concat(["gl_FragData[0] = vec4(tcolor0.rgb, compWeight0 * opacity);"]);
          break;
        case 2:
          tcoordFSImpl = tcoordFSImpl.concat(["float weightSum = compWeight0 + compWeight1;", "gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);"]);
          break;
        case 3:
          tcoordFSImpl = tcoordFSImpl.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2;", "gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);"]);
          break;
        case 4:
          tcoordFSImpl = tcoordFSImpl.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;", "gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);"]);
          break;
        default:
          vtkErrorMacro15("Unsupported number of independent coordinates.");
      }
    } else {
      switch (tNumComp) {
        case 1:
          tcoordFSImpl = tcoordFSImpl.concat(["// Dependent components", "float intensity = tvalue.r;", "vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;", "float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;", "gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);"]);
          break;
        case 2:
          tcoordFSImpl = tcoordFSImpl.concat(["float intensity = tvalue.r*cscale0 + cshift0;", "gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tvalue.g + pwfshift0);"]);
          break;
        case 3:
          tcoordFSImpl = tcoordFSImpl.concat(["vec4 tcolor = cscale0*tvalue + cshift0;", "gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,", "  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,", "  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);"]);
          break;
        default:
          tcoordFSImpl = tcoordFSImpl.concat(["vec4 tcolor = cscale0*tvalue + cshift0;", "gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,", "  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,", "  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);"]);
      }
    }
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", tcoordFSImpl).result;
    shaders.Vertex = VSSource;
    shaders.Fragment = FSSource;
    shaders.Geometry = GSSource;
  };
  publicAPI.replaceShaderPositionVC = (shaders, ren, actor) => {
    let VSSource = shaders.Vertex;
    const GSSource = shaders.Geometry;
    let FSSource = shaders.Fragment;
    const slabThickness = model.renderable.getSlabThickness();
    let posVCVSDec = ["attribute vec4 vertexWC;"];
    posVCVSDec = posVCVSDec.concat([`//${publicAPI.getMTime()}${model.resliceGeomUpdateString}`]);
    if (slabThickness > 0) {
      posVCVSDec = posVCVSDec.concat(["attribute vec3 normalWC;", "varying vec3 normalWCVSOutput;", "varying vec4 vertexWCVSOutput;"]);
    }
    VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::PositionVC::Dec", posVCVSDec).result;
    let posVCVSImpl = ["gl_Position = MCPCMatrix * vertexWC;"];
    if (slabThickness > 0) {
      posVCVSImpl = posVCVSImpl.concat(["normalWCVSOutput = normalWC;", "vertexWCVSOutput = vertexWC;"]);
    }
    VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::PositionVC::Impl", posVCVSImpl).result;
    VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Camera::Dec", ["uniform mat4 MCPCMatrix;", "uniform mat4 MCVCMatrix;"]).result;
    let posVCFSDec = [];
    if (slabThickness > 0) {
      posVCFSDec = posVCFSDec.concat(["varying vec3 normalWCVSOutput;", "varying vec4 vertexWCVSOutput;"]);
    }
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::PositionVC::Dec", posVCFSDec).result;
    shaders.Vertex = VSSource;
    shaders.Geometry = GSSource;
    shaders.Fragment = FSSource;
  };
  function isVectorAxisAligned(n9) {
    vtkMath.normalize(n9);
    const tmpN = [0, 0, 0];
    for (let i6 = 0; i6 < 3; ++i6) {
      vec3_exports.zero(tmpN);
      tmpN[i6] = 1;
      const dotP = vtkMath.dot(n9, tmpN);
      if (dotP < -0.999 || dotP > 0.999) {
        return [true, i6];
      }
    }
    return [false, 2];
  }
  publicAPI.updateResliceGeometry = () => {
    var _a9;
    let resGeomString = "";
    const image2 = model.currentInput;
    const imageBounds = image2 == null ? void 0 : image2.getBounds();
    let orthoSlicing = true;
    let orthoAxis = 2;
    const slicePD = model.renderable.getSlicePolyData();
    const slicePlane = model.renderable.getSlicePlane();
    if (slicePD) {
      resGeomString = resGeomString.concat(`PolyData${slicePD.getMTime()}`);
    } else if (slicePlane) {
      resGeomString = resGeomString.concat(`Plane${slicePlane.getMTime()}`);
      if (image2) {
        resGeomString = resGeomString.concat(`Image${image2.getMTime()}`);
      }
      const w2io = mat3_exports.fromValues(image2 == null ? void 0 : image2.getDirection());
      mat3_exports.invert(w2io, w2io);
      const imageLocalNormal = [...slicePlane.getNormal()];
      vec3_exports.transformMat3(imageLocalNormal, imageLocalNormal, w2io);
      [orthoSlicing, orthoAxis] = isVectorAxisAligned(imageLocalNormal);
    } else {
      const plane = vtkPlane$1.newInstance();
      plane.setNormal(0, 0, 1);
      let bds = [0, 1, 0, 1, 0, 1];
      if (image2) {
        bds = imageBounds;
      }
      plane.setOrigin(bds[0], bds[2], 0.5 * (bds[5] + bds[4]));
      model.renderable.setSlicePlane(plane);
      resGeomString = resGeomString.concat(`Plane${slicePlane == null ? void 0 : slicePlane.getMTime()}`);
      if (image2) {
        resGeomString = resGeomString.concat(`Image${image2.getMTime()}`);
      }
    }
    if (!model.resliceGeom || model.resliceGeomUpdateString !== resGeomString) {
      if (slicePD) {
        if (!model.resliceGeom) {
          model.resliceGeom = vtkPolyData$1.newInstance();
        }
        model.resliceGeom.getPoints().setData(slicePD.getPoints().getData(), 3);
        model.resliceGeom.getPolys().setData(slicePD.getPolys().getData(), 1);
        model.resliceGeom.getPointData().setNormals(slicePD.getPointData().getNormals());
      } else if (slicePlane) {
        if (!orthoSlicing) {
          model.outlineFilter.setInputData(image2);
          model.cutter.setInputConnection(model.outlineFilter.getOutputPort());
          model.cutter.setCutFunction(slicePlane);
          model.lineToSurfaceFilter.setInputConnection(model.cutter.getOutputPort());
          model.lineToSurfaceFilter.update();
          if (!model.resliceGeom) {
            model.resliceGeom = vtkPolyData$1.newInstance();
          }
          const planePD = model.lineToSurfaceFilter.getOutputData();
          model.resliceGeom.getPoints().setData(planePD.getPoints().getData(), 3);
          model.resliceGeom.getPolys().setData(planePD.getPolys().getData(), 1);
          model.resliceGeom.getPointData().setNormals(planePD.getPointData().getNormals());
          const n9 = slicePlane.getNormal();
          const npts = model.resliceGeom.getNumberOfPoints();
          vtkMath.normalize(n9);
          const normalsData = new Float32Array(npts * 3);
          for (let i6 = 0; i6 < npts; ++i6) {
            normalsData[3 * i6] = n9[0];
            normalsData[3 * i6 + 1] = n9[1];
            normalsData[3 * i6 + 2] = n9[2];
          }
          const normals = vtkDataArray$1.newInstance({
            numberOfComponents: 3,
            values: normalsData,
            name: "Normals"
          });
          model.resliceGeom.getPointData().setNormals(normals);
        } else {
          const ptsArray = new Float32Array(12);
          const indexSpacePlaneOrigin = image2.worldToIndex(slicePlane.getOrigin(), [0, 0, 0]);
          const otherAxes = [(orthoAxis + 1) % 3, (orthoAxis + 2) % 3].sort();
          const dim = image2.getDimensions();
          const ext = [0, dim[0] - 1, 0, dim[1] - 1, 0, dim[2] - 1];
          let ptIdx = 0;
          for (let i6 = 0; i6 < 2; ++i6) {
            for (let j2 = 0; j2 < 2; ++j2) {
              ptsArray[ptIdx + orthoAxis] = indexSpacePlaneOrigin[orthoAxis];
              ptsArray[ptIdx + otherAxes[0]] = ext[2 * otherAxes[0] + j2];
              ptsArray[ptIdx + otherAxes[1]] = ext[2 * otherAxes[1] + i6];
              ptIdx += 3;
            }
          }
          model.transform.setMatrix(image2.getIndexToWorld());
          model.transform.transformPoints(ptsArray, ptsArray);
          const cellArray = new Uint16Array(8);
          cellArray[0] = 3;
          cellArray[1] = 0;
          cellArray[2] = 1;
          cellArray[3] = 3;
          cellArray[4] = 3;
          cellArray[5] = 0;
          cellArray[6] = 3;
          cellArray[7] = 2;
          const n9 = slicePlane.getNormal();
          vtkMath.normalize(n9);
          const normalsData = new Float32Array(12);
          for (let i6 = 0; i6 < 4; ++i6) {
            normalsData[3 * i6] = n9[0];
            normalsData[3 * i6 + 1] = n9[1];
            normalsData[3 * i6 + 2] = n9[2];
          }
          if (!model.resliceGeom) {
            model.resliceGeom = vtkPolyData$1.newInstance();
          }
          model.resliceGeom.getPoints().setData(ptsArray, 3);
          model.resliceGeom.getPolys().setData(cellArray, 1);
          const normals = vtkDataArray$1.newInstance({
            numberOfComponents: 3,
            values: normalsData,
            name: "Normals"
          });
          model.resliceGeom.getPointData().setNormals(normals);
        }
      } else {
        vtkErrorMacro15("Something went wrong.", "A default slice plane should have been created in the beginning of", "updateResliceGeometry.");
      }
      model.resliceGeomUpdateString = resGeomString;
      (_a9 = model.resliceGeom) == null ? void 0 : _a9.modified();
    }
  };
  publicAPI.setOpenGLTexture = (oglTex) => {
    if (oglTex) {
      model.openGLTexture = oglTex;
      model._externalOpenGLTexture = true;
    }
  };
}
var DEFAULT_VALUES31 = {
  VBOBuildTime: {},
  VBOBuildString: null,
  haveSeenDepthRequest: false,
  lastHaveSeenDepthRequest: false,
  lastIndependentComponents: false,
  lastTextureComponents: 0,
  lastSlabThickness: 0,
  lastSlabTrapezoidIntegration: 0,
  lastSlabType: -1,
  openGLTexture: null,
  colorTextureString: null,
  pwfTextureString: null,
  resliceGeom: null,
  resliceGeomUpdateString: null,
  tris: null,
  colorTexture: null,
  pwfTexture: null,
  _externalOpenGLTexture: false,
  _scalars: null
};
function extend32(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES31, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  vtkReplacementShaderMapper.implementReplaceShaderCoincidentOffset(publicAPI, model, initialValues);
  vtkReplacementShaderMapper.implementBuildShadersWithReplacements(publicAPI, model, initialValues);
  model.tris = vtkHelper.newInstance();
  model.openGLTexture = null;
  model.colorTexture = null;
  model.pwfTexture = null;
  model.VBOBuildTime = {};
  obj(model.VBOBuildTime);
  model.tmpMat4 = mat4_exports.identity(new Float64Array(16));
  model.outlineFilter = vtkImageDataOutlineFilter$1.newInstance();
  model.outlineFilter.setGenerateFaces(true);
  model.outlineFilter.setGenerateLines(false);
  model.cubePolyData = vtkPolyData$1.newInstance();
  model.cutter = vtkCutter$1.newInstance();
  model.lineToSurfaceFilter = vtkClosedPolyLineToSurfaceFilter$1.newInstance();
  model.transform = vtkTransform$1.newInstance();
  get(publicAPI, model, ["openGLTexture"]);
  vtkOpenGLImageResliceMapper(publicAPI, model);
}
var newInstance33 = newInstance(extend32, "vtkOpenGLImageResliceMapper");
registerOverride("vtkImageResliceMapper", newInstance33);

// node_modules/@kitware/vtk.js/Rendering/Core/ImageMapper/Constants.js
var SlicingMode = {
  NONE: -1,
  I: 0,
  J: 1,
  K: 2,
  X: 3,
  Y: 4,
  Z: 5
};
var Constants8 = {
  SlicingMode
};

// node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkPolyDataVS.glsl.js
var vtkPolyDataVS = "//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyDataVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nattribute vec4 vertexMC;\n\n// frag position in VC\n//VTK::PositionVC::Dec\n\n// optional normal declaration\n//VTK::Normal::Dec\n\n// extra lighting parameters\n//VTK::Light::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// material property values\n//VTK::Color::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\n// picking support\n//VTK::Picking::Dec\n\nvoid main()\n{\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Clip::Impl\n\n  //VTK::PrimID::Impl\n\n  //VTK::PositionVC::Impl\n\n  //VTK::Light::Impl\n\n  //VTK::Picking::Impl\n}\n";

// node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkPolyDataFS.glsl.js
var vtkPolyDataFS = "//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyDataFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// Template for the polydata mappers fragment shader\n\nuniform int PrimitiveIDOffset;\n\n// VC position of this fragment\n//VTK::PositionVC::Dec\n\n// optional color passed in from the vertex shader, vertexColor\n//VTK::Color::Dec\n\n// optional surface normal declaration\n//VTK::Normal::Dec\n\n// extra lighting parameters\n//VTK::Light::Dec\n\n// define vtkImageLabelOutlineOn\n//VTK::ImageLabelOutlineOn\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// Depth Peeling Support\n//VTK::DepthPeeling::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// label outline \n//VTK::LabelOutline::Dec\n\n// the output of this shader\n//VTK::Output::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\n// handle coincident offsets\n//VTK::Coincident::Dec\n\n//VTK::ZBuffer::Dec\n\n//VTK::LabelOutlineHelperFunction\n\nvoid main()\n{\n  // VC position of this fragment. This should not branch/return/discard.\n  //VTK::PositionVC::Impl\n\n  // Place any calls that require uniform flow (e.g. dFdx) here.\n  //VTK::UniformFlow::Impl\n\n  // Set gl_FragDepth here (gl_FragCoord.z by default)\n  //VTK::Depth::Impl\n\n  // Early depth peeling abort:\n  //VTK::DepthPeeling::PreColor\n\n  // Apple Bug\n  //VTK::PrimID::Impl\n\n  //VTK::Clip::Impl\n\n  //VTK::Color::Impl\n\n  // Generate the normal if we are not passed in one\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Light::Impl\n\n  if (gl_FragData[0].a <= 0.0)\n    {\n    discard;\n    }\n\n  //VTK::DepthPeeling::Impl\n\n  //VTK::Picking::Impl\n\n  // handle coincident offsets\n  //VTK::Coincident::Impl\n\n  //VTK::ZBuffer::Impl\n\n  //VTK::RenderPassFragmentShader::Impl\n}\n";

// node_modules/@kitware/vtk.js/Rendering/OpenGL/ImageMapper.js
var {
  vtkErrorMacro: vtkErrorMacro16
} = macro$1;
var {
  SlicingMode: SlicingMode2
} = Constants8;
function computeFnToString2(property, pwfun, numberOfComponents) {
  if (pwfun) {
    const iComps = property.getIndependentComponents();
    return `${pwfun.getMTime()}-${iComps}-${numberOfComponents}`;
  }
  return "0";
}
function splitStringOnEnter(inputString) {
  const lines = inputString.split("\n");
  const trimmedLines = [];
  for (let i6 = 0; i6 < lines.length; ++i6) {
    const trimmedLine = lines[i6].trim();
    if (trimmedLine.length > 0) {
      trimmedLines.push(trimmedLine);
    }
  }
  return trimmedLines;
}
function vtkOpenGLImageMapper(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLImageMapper");
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      model.currentRenderPass = null;
      model.openGLImageSlice = publicAPI.getFirstAncestorOfType("vtkOpenGLImageSlice");
      model._openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
      model._openGLRenderWindow = model._openGLRenderer.getParent();
      model.context = model._openGLRenderWindow.getContext();
      model.tris.setOpenGLRenderWindow(model._openGLRenderWindow);
      const ren = model._openGLRenderer.getRenderable();
      model.openGLCamera = model._openGLRenderer.getViewNodeFor(ren.getActiveCamera());
      if (model.renderable.isA("vtkImageMapper") && model.renderable.getSliceAtFocalPoint()) {
        model.renderable.setSliceFromCamera(ren.getActiveCamera());
      }
    }
  };
  publicAPI.translucentPass = (prepass, renderPass) => {
    if (prepass) {
      model.currentRenderPass = renderPass;
      publicAPI.render();
    }
  };
  publicAPI.zBufferPass = (prepass) => {
    if (prepass) {
      model.haveSeenDepthRequest = true;
      model.renderDepth = true;
      publicAPI.render();
      model.renderDepth = false;
    }
  };
  publicAPI.opaqueZBufferPass = (prepass) => publicAPI.zBufferPass(prepass);
  publicAPI.opaquePass = (prepass) => {
    if (prepass) {
      publicAPI.render();
    }
  };
  publicAPI.getCoincidentParameters = (ren, actor) => {
    if (model.renderable.getResolveCoincidentTopology()) {
      return model.renderable.getCoincidentTopologyPolygonOffsetParameters();
    }
    return null;
  };
  publicAPI.render = () => {
    const actor = model.openGLImageSlice.getRenderable();
    const ren = model._openGLRenderer.getRenderable();
    publicAPI.renderPiece(ren, actor);
  };
  publicAPI.getShaderTemplate = (shaders, ren, actor) => {
    shaders.Vertex = vtkPolyDataVS;
    shaders.Fragment = vtkPolyDataFS;
    shaders.Geometry = "";
  };
  publicAPI.replaceShaderValues = (shaders, ren, actor) => {
    let VSSource = shaders.Vertex;
    let FSSource = shaders.Fragment;
    VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Camera::Dec", ["uniform mat4 MCPCMatrix;"]).result;
    VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::PositionVC::Impl", ["  gl_Position = MCPCMatrix * vertexMC;"]).result;
    VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::TCoord::Impl", "tcoordVCVSOutput = tcoordMC;").result;
    VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::TCoord::Dec", "attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;").result;
    const tNumComp = model.openGLTexture.getComponents();
    const iComps = actor.getProperty().getIndependentComponents();
    let tcoordDec = [
      "varying vec2 tcoordVCVSOutput;",
      // color shift and scale
      "uniform float cshift0;",
      "uniform float cscale0;",
      // pwf shift and scale
      "uniform float pwfshift0;",
      "uniform float pwfscale0;",
      "uniform sampler2D texture1;",
      "uniform sampler2D colorTexture1;",
      "uniform sampler2D pwfTexture1;",
      "uniform sampler2D labelOutlineTexture1;",
      "uniform float opacity;",
      "uniform float outlineOpacity;"
    ];
    if (iComps) {
      for (let comp = 1; comp < tNumComp; comp++) {
        tcoordDec = tcoordDec.concat([
          // color shift and scale
          `uniform float cshift${comp};`,
          `uniform float cscale${comp};`,
          // weighting shift and scale
          `uniform float pwfshift${comp};`,
          `uniform float pwfscale${comp};`
        ]);
      }
      switch (tNumComp) {
        case 1:
          tcoordDec = tcoordDec.concat(["uniform float mix0;", "#define height0 0.5"]);
          break;
        case 2:
          tcoordDec = tcoordDec.concat(["uniform float mix0;", "uniform float mix1;", "#define height0 0.25", "#define height1 0.75"]);
          break;
        case 3:
          tcoordDec = tcoordDec.concat(["uniform float mix0;", "uniform float mix1;", "uniform float mix2;", "#define height0 0.17", "#define height1 0.5", "#define height2 0.83"]);
          break;
        case 4:
          tcoordDec = tcoordDec.concat(["uniform float mix0;", "uniform float mix1;", "uniform float mix2;", "uniform float mix3;", "#define height0 0.125", "#define height1 0.375", "#define height2 0.625", "#define height3 0.875"]);
          break;
        default:
          vtkErrorMacro16("Unsupported number of independent coordinates.");
      }
    }
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Dec", tcoordDec).result;
    const vtkImageLabelOutline = actor.getProperty().getUseLabelOutline();
    if (vtkImageLabelOutline === true) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::LabelOutline::Dec", ["uniform int outlineThickness;", "uniform float vpWidth;", "uniform float vpHeight;", "uniform float vpOffsetX;", "uniform float vpOffsetY;", "uniform mat4 PCWCMatrix;", "uniform mat4 vWCtoIDX;", "uniform ivec3 imageDimensions;"]).result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ImageLabelOutlineOn", "#define vtkImageLabelOutlineOn").result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::LabelOutlineHelperFunction", ["#ifdef vtkImageLabelOutlineOn", "vec3 fragCoordToIndexSpace(vec4 fragCoord) {", "  vec4 pcPos = vec4(", "    (fragCoord.x / vpWidth - vpOffsetX - 0.5) * 2.0,", "    (fragCoord.y / vpHeight - vpOffsetY - 0.5) * 2.0,", "    (fragCoord.z - 0.5) * 2.0,", "    1.0);", "", "  vec4 worldCoord = PCWCMatrix * pcPos;", "  vec4 vertex = (worldCoord/worldCoord.w);", "", "  vec3 index = (vWCtoIDX * vertex).xyz;", "", "  // half voxel fix for labelmapOutline", "  return (index + vec3(0.5)) / vec3(imageDimensions);", "}", "#endif"]).result;
    }
    if (iComps) {
      const rgba = ["r", "g", "b", "a"];
      let tcoordImpl = ["vec4 tvalue = texture2D(texture1, tcoordVCVSOutput);"];
      for (let comp = 0; comp < tNumComp; comp++) {
        tcoordImpl = tcoordImpl.concat([`vec3 tcolor${comp} = mix${comp} * texture2D(colorTexture1, vec2(tvalue.${rgba[comp]} * cscale${comp} + cshift${comp}, height${comp})).rgb;`, `float compWeight${comp} = mix${comp} * texture2D(pwfTexture1, vec2(tvalue.${rgba[comp]} * pwfscale${comp} + pwfshift${comp}, height${comp})).r;`]);
      }
      switch (tNumComp) {
        case 1:
          tcoordImpl = tcoordImpl.concat(["gl_FragData[0] = vec4(tcolor0.rgb, opacity);"]);
          break;
        case 2:
          tcoordImpl = tcoordImpl.concat(["float weightSum = compWeight0 + compWeight1;", "gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);"]);
          break;
        case 3:
          tcoordImpl = tcoordImpl.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2;", "gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);"]);
          break;
        case 4:
          tcoordImpl = tcoordImpl.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;", "gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);"]);
          break;
        default:
          vtkErrorMacro16("Unsupported number of independent coordinates.");
      }
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", tcoordImpl).result;
    } else {
      switch (tNumComp) {
        case 1:
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", [...splitStringOnEnter(`
                #ifdef vtkImageLabelOutlineOn
                  vec3 centerPosIS = fragCoordToIndexSpace(gl_FragCoord); 
                  float centerValue = texture2D(texture1, centerPosIS.xy).r;
                  bool pixelOnBorder = false;
                  vec3 tColor = texture2D(colorTexture1, vec2(centerValue * cscale0 + cshift0, 0.5)).rgb;
                  float scalarOpacity = texture2D(pwfTexture1, vec2(centerValue * pwfscale0 + pwfshift0, 0.5)).r;
                  float opacityToUse = scalarOpacity * opacity;
                  int segmentIndex = int(centerValue * 255.0);
                  float textureCoordinate = float(segmentIndex - 1) / 1024.0;
                  float textureValue = texture2D(labelOutlineTexture1, vec2(textureCoordinate, 0.5)).r;
                  int actualThickness = int(textureValue * 255.0);

                  if (segmentIndex == 0){
                    gl_FragData[0] = vec4(0.0, 1.0, 1.0, 0.0);
                    return;
                  }

                  for (int i = -actualThickness; i <= actualThickness; i++) {
                    for (int j = -actualThickness; j <= actualThickness; j++) {
                      if (i == 0 || j == 0) {
                        continue;
                      }
                      vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(i),
                        gl_FragCoord.y + float(j),
                        gl_FragCoord.z, gl_FragCoord.w);
                      vec3 neighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);
                      float value = texture2D(texture1, neighborPosIS.xy).r;
                      if (value != centerValue) {
                        pixelOnBorder = true;
                        break;
                      }
                    }
                    if (pixelOnBorder == true) {
                      break;
                    }
                  }
                  if (pixelOnBorder == true) {
                    gl_FragData[0] = vec4(tColor, outlineOpacity);
                  }
                  else {
                    gl_FragData[0] = vec4(tColor, opacityToUse);
                  }
                #else
                  float intensity = texture2D(texture1, tcoordVCVSOutput).r;
                  vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;
                  float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;
                  gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);
                #endif
                `)]).result;
          break;
        case 2:
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", ["vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);", "float intensity = tcolor.r*cscale0 + cshift0;", "gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tcolor.g + pwfshift0);"]).result;
          break;
        case 3:
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", ["vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;", "gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,", "  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,", "  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);"]).result;
          break;
        default:
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", ["vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;", "gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,", "  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,", "  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);"]).result;
      }
    }
    if (model.haveSeenDepthRequest) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ZBuffer::Dec", "uniform int depthRequest;").result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ZBuffer::Impl", ["if (depthRequest == 1) {", "float iz = floor(gl_FragCoord.z*65535.0 + 0.1);", "float rf = floor(iz/256.0)/255.0;", "float gf = mod(iz,256.0)/255.0;", "gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result;
    }
    shaders.Vertex = VSSource;
    shaders.Fragment = FSSource;
    publicAPI.replaceShaderClip(shaders, ren, actor);
    publicAPI.replaceShaderCoincidentOffset(shaders, ren, actor);
  };
  publicAPI.replaceShaderClip = (shaders, ren, actor) => {
    let VSSource = shaders.Vertex;
    let FSSource = shaders.Fragment;
    if (model.renderable.getNumberOfClippingPlanes()) {
      let numClipPlanes = model.renderable.getNumberOfClippingPlanes();
      if (numClipPlanes > 6) {
        vtkErrorMacro2("OpenGL has a limit of 6 clipping planes");
        numClipPlanes = 6;
      }
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Clip::Dec", ["uniform int numClipPlanes;", "uniform vec4 clipPlanes[6];", "varying float clipDistancesVSOutput[6];"]).result;
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Clip::Impl", ["for (int planeNum = 0; planeNum < 6; planeNum++)", "    {", "    if (planeNum >= numClipPlanes)", "        {", "        break;", "        }", "    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);", "    }"]).result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Clip::Dec", ["uniform int numClipPlanes;", "varying float clipDistancesVSOutput[6];"]).result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Clip::Impl", ["for (int planeNum = 0; planeNum < 6; planeNum++)", "    {", "    if (planeNum >= numClipPlanes)", "        {", "        break;", "        }", "    if (clipDistancesVSOutput[planeNum] < 0.0) discard;", "    }"]).result;
    }
    shaders.Vertex = VSSource;
    shaders.Fragment = FSSource;
  };
  publicAPI.getNeedToRebuildShaders = (cellBO, ren, actor) => {
    var _a9;
    const tNumComp = model.openGLTexture.getComponents();
    const iComp = actor.getProperty().getIndependentComponents();
    let needRebuild = false;
    if (!model.currentRenderPass && model.lastRenderPassShaderReplacement || model.currentRenderPass && model.currentRenderPass.getShaderReplacement() !== model.lastRenderPassShaderReplacement) {
      needRebuild = true;
    }
    if (needRebuild || model.lastHaveSeenDepthRequest !== model.haveSeenDepthRequest || ((_a9 = cellBO.getProgram()) == null ? void 0 : _a9.getHandle()) === 0 || model.lastTextureComponents !== tNumComp || model.lastIndependentComponents !== iComp) {
      model.lastHaveSeenDepthRequest = model.haveSeenDepthRequest;
      model.lastTextureComponents = tNumComp;
      model.lastIndependentComponents = iComp;
      return true;
    }
    return false;
  };
  publicAPI.updateShaders = (cellBO, ren, actor) => {
    model.lastBoundBO = cellBO;
    if (publicAPI.getNeedToRebuildShaders(cellBO, ren, actor)) {
      const shaders = {
        Vertex: null,
        Fragment: null,
        Geometry: null
      };
      publicAPI.buildShaders(shaders, ren, actor);
      const newShader = model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(shaders.Vertex, shaders.Fragment, shaders.Geometry);
      if (newShader !== cellBO.getProgram()) {
        cellBO.setProgram(newShader);
        cellBO.getVAO().releaseGraphicsResources();
      }
      cellBO.getShaderSourceTime().modified();
    } else {
      model._openGLRenderWindow.getShaderCache().readyShaderProgram(cellBO.getProgram());
    }
    cellBO.getVAO().bind();
    publicAPI.setMapperShaderParameters(cellBO, ren, actor);
    publicAPI.setCameraShaderParameters(cellBO, ren, actor);
    publicAPI.setPropertyShaderParameters(cellBO, ren, actor);
  };
  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {
    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {
      if (cellBO.getProgram().isAttributeUsed("vertexMC")) {
        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), "vertexMC", cellBO.getCABO().getVertexOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {
          vtkErrorMacro16("Error setting vertexMC in shader VAO.");
        }
      }
      if (cellBO.getProgram().isAttributeUsed("tcoordMC") && cellBO.getCABO().getTCoordOffset()) {
        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), "tcoordMC", cellBO.getCABO().getTCoordOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, cellBO.getCABO().getTCoordComponents(), model.context.FALSE)) {
          vtkErrorMacro16("Error setting tcoordMC in shader VAO.");
        }
      }
      cellBO.getAttributeUpdateTime().modified();
    }
    const texUnit = model.openGLTexture.getTextureUnit();
    cellBO.getProgram().setUniformi("texture1", texUnit);
    const numComp = model.openGLTexture.getComponents();
    const iComps = actor.getProperty().getIndependentComponents();
    if (iComps) {
      for (let i6 = 0; i6 < numComp; i6++) {
        cellBO.getProgram().setUniformf(`mix${i6}`, actor.getProperty().getComponentWeight(i6));
      }
    }
    const oglShiftScale = model.openGLTexture.getShiftAndScale();
    for (let i6 = 0; i6 < numComp; i6++) {
      let cw = actor.getProperty().getColorWindow();
      let cl = actor.getProperty().getColorLevel();
      const target = iComps ? i6 : 0;
      const cfun = actor.getProperty().getRGBTransferFunction(target);
      if (cfun && actor.getProperty().getUseLookupTableScalarRange()) {
        const cRange = cfun.getRange();
        cw = cRange[1] - cRange[0];
        cl = 0.5 * (cRange[1] + cRange[0]);
      }
      const scale7 = oglShiftScale.scale / cw;
      const shift3 = (oglShiftScale.shift - cl) / cw + 0.5;
      cellBO.getProgram().setUniformf(`cshift${i6}`, shift3);
      cellBO.getProgram().setUniformf(`cscale${i6}`, scale7);
    }
    for (let i6 = 0; i6 < numComp; i6++) {
      let pwfScale = 1;
      let pwfShift = 0;
      const target = iComps ? i6 : 0;
      const pwfun = actor.getProperty().getPiecewiseFunction(target);
      if (pwfun) {
        const pwfRange = pwfun.getRange();
        const length4 = pwfRange[1] - pwfRange[0];
        const mid = 0.5 * (pwfRange[0] + pwfRange[1]);
        pwfScale = oglShiftScale.scale / length4;
        pwfShift = (oglShiftScale.shift - mid) / length4 + 0.5;
      }
      cellBO.getProgram().setUniformf(`pwfshift${i6}`, pwfShift);
      cellBO.getProgram().setUniformf(`pwfscale${i6}`, pwfScale);
    }
    if (model.haveSeenDepthRequest) {
      cellBO.getProgram().setUniformi("depthRequest", model.renderDepth ? 1 : 0);
    }
    if (cellBO.getProgram().isUniformUsed("coffset")) {
      const cp = publicAPI.getCoincidentParameters(ren, actor);
      cellBO.getProgram().setUniformf("coffset", cp.offset);
      if (cellBO.getProgram().isUniformUsed("cfactor")) {
        cellBO.getProgram().setUniformf("cfactor", cp.factor);
      }
    }
    const texColorUnit = model.colorTexture.getTextureUnit();
    cellBO.getProgram().setUniformi("colorTexture1", texColorUnit);
    const texOpacityUnit = model.pwfTexture.getTextureUnit();
    cellBO.getProgram().setUniformi("pwfTexture1", texOpacityUnit);
    const outlineThicknessUnit = model.labelOutlineThicknessTexture.getTextureUnit();
    cellBO.getProgram().setUniformi("labelOutlineTexture1", outlineThicknessUnit);
    if (model.renderable.getNumberOfClippingPlanes()) {
      let numClipPlanes = model.renderable.getNumberOfClippingPlanes();
      if (numClipPlanes > 6) {
        vtkErrorMacro2("OpenGL has a limit of 6 clipping planes");
        numClipPlanes = 6;
      }
      const shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();
      const inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;
      const mat = inverseShiftScaleMatrix ? mat4_exports.copy(model.imagematinv, actor.getMatrix()) : actor.getMatrix();
      if (inverseShiftScaleMatrix) {
        mat4_exports.transpose(mat, mat);
        mat4_exports.multiply(mat, mat, inverseShiftScaleMatrix);
        mat4_exports.transpose(mat, mat);
      }
      mat4_exports.transpose(model.imagemat, model.currentInput.getIndexToWorld());
      mat4_exports.multiply(model.imagematinv, mat, model.imagemat);
      const planeEquations = [];
      for (let i6 = 0; i6 < numClipPlanes; i6++) {
        const planeEquation = [];
        model.renderable.getClippingPlaneInDataCoords(model.imagematinv, i6, planeEquation);
        for (let j2 = 0; j2 < 4; j2++) {
          planeEquations.push(planeEquation[j2]);
        }
      }
      cellBO.getProgram().setUniformi("numClipPlanes", numClipPlanes);
      cellBO.getProgram().setUniform4fv("clipPlanes", planeEquations);
    }
    const vtkImageLabelOutline = actor.getProperty().getUseLabelOutline();
    if (vtkImageLabelOutline === true) {
      const outlineOpacity = actor.getProperty().getLabelOutlineOpacity();
      cellBO.getProgram().setUniformf("outlineOpacity", outlineOpacity);
    }
  };
  publicAPI.setCameraShaderParameters = (cellBO, ren, actor) => {
    const program = cellBO.getProgram();
    const actMats = model.openGLImageSlice.getKeyMatrices();
    const image2 = model.currentInput;
    const i2wmat4 = image2.getIndexToWorld();
    mat4_exports.multiply(model.imagemat, actMats.mcwc, i2wmat4);
    const keyMats = model.openGLCamera.getKeyMatrices(ren);
    mat4_exports.multiply(model.imagemat, keyMats.wcpc, model.imagemat);
    if (cellBO.getCABO().getCoordShiftAndScaleEnabled()) {
      const inverseShiftScaleMat = cellBO.getCABO().getInverseShiftAndScaleMatrix();
      mat4_exports.multiply(model.imagemat, model.imagemat, inverseShiftScaleMat);
    }
    program.setUniformMatrix("MCPCMatrix", model.imagemat);
    const vtkImageLabelOutline = actor.getProperty().getUseLabelOutline();
    if (vtkImageLabelOutline === true) {
      const worldToIndex = image2.getWorldToIndex();
      const imageDimensions = image2.getDimensions();
      program.setUniform3i("imageDimensions", imageDimensions[0], imageDimensions[1], 1);
      program.setUniformMatrix("vWCtoIDX", worldToIndex);
      const labelOutlineKeyMats = model.openGLCamera.getKeyMatrices(ren);
      mat4_exports.invert(model.projectionToWorld, labelOutlineKeyMats.wcpc);
      model.openGLCamera.getKeyMatrices(ren);
      program.setUniformMatrix("PCWCMatrix", model.projectionToWorld);
      const size3 = publicAPI.getRenderTargetSize();
      program.setUniformf("vpWidth", size3[0]);
      program.setUniformf("vpHeight", size3[1]);
      const offset3 = publicAPI.getRenderTargetOffset();
      program.setUniformf("vpOffsetX", offset3[0] / size3[0]);
      program.setUniformf("vpOffsetY", offset3[1] / size3[1]);
    }
  };
  publicAPI.setPropertyShaderParameters = (cellBO, ren, actor) => {
    const program = cellBO.getProgram();
    const ppty = actor.getProperty();
    const opacity = ppty.getOpacity();
    program.setUniformf("opacity", opacity);
  };
  publicAPI.renderPieceStart = (ren, actor) => {
    publicAPI.updateBufferObjects(ren, actor);
    model.lastBoundBO = null;
  };
  publicAPI.renderPieceDraw = (ren, actor) => {
    const gl = model.context;
    model.openGLTexture.activate();
    model.colorTexture.activate();
    model.labelOutlineThicknessTexture.activate();
    model.pwfTexture.activate();
    if (model.tris.getCABO().getElementCount()) {
      publicAPI.updateShaders(model.tris, ren, actor);
      gl.drawArrays(gl.TRIANGLES, 0, model.tris.getCABO().getElementCount());
      model.tris.getVAO().release();
    }
    model.openGLTexture.deactivate();
    model.colorTexture.deactivate();
    model.labelOutlineThicknessTexture.deactivate();
    model.pwfTexture.deactivate();
  };
  publicAPI.renderPieceFinish = (ren, actor) => {
  };
  publicAPI.renderPiece = (ren, actor) => {
    publicAPI.invokeEvent({
      type: "StartEvent"
    });
    model.renderable.update();
    model.currentInput = model.renderable.getCurrentImage();
    publicAPI.invokeEvent({
      type: "EndEvent"
    });
    if (!model.currentInput) {
      vtkErrorMacro16("No input!");
      return;
    }
    publicAPI.renderPieceStart(ren, actor);
    publicAPI.renderPieceDraw(ren, actor);
    publicAPI.renderPieceFinish(ren, actor);
  };
  publicAPI.computeBounds = (ren, actor) => {
    if (!publicAPI.getInput()) {
      uninitializeBounds(model.bounds);
      return;
    }
    model.bounds = publicAPI.getInput().getBounds();
  };
  publicAPI.updateBufferObjects = (ren, actor) => {
    if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {
      publicAPI.buildBufferObjects(ren, actor);
    }
  };
  publicAPI.getNeedToRebuildBufferObjects = (ren, actor) => {
    if (model.VBOBuildTime.getMTime() < publicAPI.getMTime() || model.VBOBuildTime.getMTime() < actor.getMTime() || model.VBOBuildTime.getMTime() < model.renderable.getMTime() || model.VBOBuildTime.getMTime() < actor.getProperty().getMTime() || model.VBOBuildTime.getMTime() < model.currentInput.getMTime()) {
      return true;
    }
    return false;
  };
  publicAPI.buildBufferObjects = (ren, actor) => {
    var _a9, _b2;
    const image2 = model.currentInput;
    if (!image2) {
      return;
    }
    const imgScalars = image2.getPointData() && image2.getPointData().getScalars();
    if (!imgScalars) {
      return;
    }
    const dataType = imgScalars.getDataType();
    const numComp = imgScalars.getNumberOfComponents();
    const actorProperty = actor.getProperty();
    const iType = actorProperty.getInterpolationType();
    const iComps = actorProperty.getIndependentComponents();
    const numIComps = iComps ? numComp : 1;
    const textureHeight = iComps ? 2 * numIComps : 1;
    const colorTransferFunc = actorProperty.getRGBTransferFunction();
    const cfunToString = computeFnToString2(actorProperty, colorTransferFunc, numIComps);
    const cTex = model._openGLRenderWindow.getGraphicsResourceForObject(colorTransferFunc);
    const reBuildC = !(cTex == null ? void 0 : cTex.vtkObj) || (cTex == null ? void 0 : cTex.hash) !== cfunToString || model.colorTextureString !== cfunToString;
    if (reBuildC) {
      const cWidth = 1024;
      const cSize = cWidth * textureHeight * 3;
      const cTable = new Uint8ClampedArray(cSize);
      if (!model.colorTexture) {
        model.colorTexture = vtkOpenGLTexture$1.newInstance({
          resizable: true
        });
        model.colorTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      }
      if (iType === InterpolationType.NEAREST) {
        model.colorTexture.setMinificationFilter(Filter.NEAREST);
        model.colorTexture.setMagnificationFilter(Filter.NEAREST);
      } else {
        model.colorTexture.setMinificationFilter(Filter.LINEAR);
        model.colorTexture.setMagnificationFilter(Filter.LINEAR);
      }
      if (colorTransferFunc) {
        const tmpTable = new Float32Array(cWidth * 3);
        for (let c6 = 0; c6 < numIComps; c6++) {
          const cfun = actorProperty.getRGBTransferFunction(c6);
          const cRange = cfun.getRange();
          cfun.getTable(cRange[0], cRange[1], cWidth, tmpTable, 1);
          if (iComps) {
            for (let i6 = 0; i6 < cWidth * 3; i6++) {
              cTable[c6 * cWidth * 6 + i6] = 255 * tmpTable[i6];
              cTable[c6 * cWidth * 6 + i6 + cWidth * 3] = 255 * tmpTable[i6];
            }
          } else {
            for (let i6 = 0; i6 < cWidth * 3; i6++) {
              cTable[c6 * cWidth * 6 + i6] = 255 * tmpTable[i6];
            }
          }
        }
        model.colorTexture.releaseGraphicsResources(model._openGLRenderWindow);
        model.colorTexture.resetFormatAndType();
        model.colorTexture.create2DFromRaw(cWidth, textureHeight, 3, VtkDataTypes.UNSIGNED_CHAR, cTable);
      } else {
        for (let i6 = 0; i6 < cWidth * 3; ++i6) {
          cTable[i6] = 255 * i6 / ((cWidth - 1) * 3);
          cTable[i6 + 1] = 255 * i6 / ((cWidth - 1) * 3);
          cTable[i6 + 2] = 255 * i6 / ((cWidth - 1) * 3);
        }
        model.colorTexture.create2DFromRaw(cWidth, 1, 3, VtkDataTypes.UNSIGNED_CHAR, cTable);
      }
      model.colorTextureString = cfunToString;
      if (colorTransferFunc) {
        model._openGLRenderWindow.setGraphicsResourceForObject(colorTransferFunc, model.colorTexture, model.colorTextureString);
      }
    } else {
      model.colorTexture = cTex.vtkObj;
      model.colorTextureString = cTex.hash;
    }
    const pwFunc = actorProperty.getPiecewiseFunction();
    const pwfunToString = computeFnToString2(actorProperty, pwFunc, numIComps);
    const pwfTex = model._openGLRenderWindow.getGraphicsResourceForObject(pwFunc);
    const reBuildPwf = !(pwfTex == null ? void 0 : pwfTex.vtkObj) || (pwfTex == null ? void 0 : pwfTex.hash) !== pwfunToString || model.pwfTextureString !== pwfunToString;
    if (reBuildPwf) {
      const pwfWidth = 1024;
      const pwfSize = pwfWidth * textureHeight;
      const pwfTable = new Uint8ClampedArray(pwfSize);
      if (!model.pwfTexture) {
        model.pwfTexture = vtkOpenGLTexture$1.newInstance({
          resizable: true
        });
        model.pwfTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      }
      if (iType === InterpolationType.NEAREST) {
        model.pwfTexture.setMinificationFilter(Filter.NEAREST);
        model.pwfTexture.setMagnificationFilter(Filter.NEAREST);
      } else {
        model.pwfTexture.setMinificationFilter(Filter.LINEAR);
        model.pwfTexture.setMagnificationFilter(Filter.LINEAR);
      }
      if (pwFunc) {
        const pwfFloatTable = new Float32Array(pwfSize);
        const tmpTable = new Float32Array(pwfWidth);
        for (let c6 = 0; c6 < numIComps; ++c6) {
          const pwfun = actorProperty.getPiecewiseFunction(c6);
          if (pwfun === null) {
            pwfFloatTable.fill(1);
          } else {
            const pwfRange = pwfun.getRange();
            pwfun.getTable(pwfRange[0], pwfRange[1], pwfWidth, tmpTable, 1);
            if (iComps) {
              for (let i6 = 0; i6 < pwfWidth; i6++) {
                pwfFloatTable[c6 * pwfWidth * 2 + i6] = tmpTable[i6];
                pwfFloatTable[c6 * pwfWidth * 2 + i6 + pwfWidth] = tmpTable[i6];
              }
            } else {
              for (let i6 = 0; i6 < pwfWidth; i6++) {
                pwfFloatTable[c6 * pwfWidth * 2 + i6] = tmpTable[i6];
              }
            }
          }
        }
        model.pwfTexture.releaseGraphicsResources(model._openGLRenderWindow);
        model.pwfTexture.resetFormatAndType();
        model.pwfTexture.create2DFromRaw(pwfWidth, textureHeight, 1, VtkDataTypes.FLOAT, pwfFloatTable);
      } else {
        pwfTable.fill(255);
        model.pwfTexture.create2DFromRaw(pwfWidth, 1, 1, VtkDataTypes.UNSIGNED_CHAR, pwfTable);
      }
      model.pwfTextureString = pwfunToString;
      if (pwFunc) {
        model._openGLRenderWindow.setGraphicsResourceForObject(pwFunc, model.pwfTexture, model.pwfTextureString);
      }
    } else {
      model.pwfTexture = pwfTex.vtkObj;
      model.pwfTextureString = pwfTex.hash;
    }
    publicAPI.updatelabelOutlineThicknessTexture(actor);
    const {
      ijkMode
    } = model.renderable.getClosestIJKAxis();
    let slice = model.renderable.getSlice();
    if (ijkMode !== model.renderable.getSlicingMode()) {
      slice = model.renderable.getSliceAtPosition(slice);
    }
    const nSlice = model.renderable.isA("vtkImageArrayMapper") ? model.renderable.getSubSlice() : Math.round(slice);
    const ext = image2.getExtent();
    let sliceOffset;
    if (ijkMode === SlicingMode2.I) {
      sliceOffset = nSlice - ext[0];
    }
    if (ijkMode === SlicingMode2.J) {
      sliceOffset = nSlice - ext[2];
    }
    if (ijkMode === SlicingMode2.K || ijkMode === SlicingMode2.NONE) {
      sliceOffset = nSlice - ext[4];
    }
    const toString3 = `${slice}A${image2.getMTime()}A${imgScalars.getMTime()}B${publicAPI.getMTime()}C${model.renderable.getSlicingMode()}D${actor.getProperty().getInterpolationType()}`;
    if (model.VBOBuildString !== toString3) {
      const dims = image2.getDimensions();
      if (!model.openGLTexture) {
        model.openGLTexture = vtkOpenGLTexture$1.newInstance({
          resizable: true
        });
        model.openGLTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      }
      model.openGLTexture.setOglNorm16Ext(model.context.getExtension("EXT_texture_norm16"));
      if (iType === InterpolationType.NEAREST) {
        if ((/* @__PURE__ */ new Set([1, 3, 4])).has(numComp) && dataType === VtkDataTypes.UNSIGNED_CHAR && !iComps) {
          model.openGLTexture.setGenerateMipmap(true);
          model.openGLTexture.setMinificationFilter(Filter.NEAREST);
        } else {
          model.openGLTexture.setMinificationFilter(Filter.NEAREST);
        }
        model.openGLTexture.setMagnificationFilter(Filter.NEAREST);
      } else {
        if (numComp === 4 && dataType === VtkDataTypes.UNSIGNED_CHAR && !iComps) {
          model.openGLTexture.setGenerateMipmap(true);
          model.openGLTexture.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);
        } else {
          model.openGLTexture.setMinificationFilter(Filter.LINEAR);
        }
        model.openGLTexture.setMagnificationFilter(Filter.LINEAR);
      }
      model.openGLTexture.setWrapS(Wrap.CLAMP_TO_EDGE);
      model.openGLTexture.setWrapT(Wrap.CLAMP_TO_EDGE);
      const sliceSize = dims[0] * dims[1] * numComp;
      const ptsArray = new Float32Array(12);
      const tcoordArray = new Float32Array(8);
      for (let i6 = 0; i6 < 4; i6++) {
        tcoordArray[i6 * 2] = i6 % 2 ? 1 : 0;
        tcoordArray[i6 * 2 + 1] = i6 > 1 ? 1 : 0;
      }
      const sliceDepth = [SlicingMode2.X, SlicingMode2.Y, SlicingMode2.Z].includes(model.renderable.getSlicingMode()) ? slice : nSlice;
      const spatialExt = image2.getSpatialExtent();
      const basicScalars = imgScalars.getData();
      let scalars = null;
      if (ijkMode === SlicingMode2.I) {
        scalars = new basicScalars.constructor(dims[2] * dims[1] * numComp);
        let id = 0;
        for (let k2 = 0; k2 < dims[2]; k2++) {
          for (let j2 = 0; j2 < dims[1]; j2++) {
            let bsIdx = (sliceOffset + j2 * dims[0] + k2 * dims[0] * dims[1]) * numComp;
            id = (k2 * dims[1] + j2) * numComp;
            const end = bsIdx + numComp;
            while (bsIdx < end) {
              scalars[id++] = basicScalars[bsIdx++];
            }
          }
        }
        dims[0] = dims[1];
        dims[1] = dims[2];
        ptsArray[0] = sliceDepth;
        ptsArray[1] = spatialExt[2];
        ptsArray[2] = spatialExt[4];
        ptsArray[3] = sliceDepth;
        ptsArray[4] = spatialExt[3];
        ptsArray[5] = spatialExt[4];
        ptsArray[6] = sliceDepth;
        ptsArray[7] = spatialExt[2];
        ptsArray[8] = spatialExt[5];
        ptsArray[9] = sliceDepth;
        ptsArray[10] = spatialExt[3];
        ptsArray[11] = spatialExt[5];
      } else if (ijkMode === SlicingMode2.J) {
        scalars = new basicScalars.constructor(dims[2] * dims[0] * numComp);
        let id = 0;
        for (let k2 = 0; k2 < dims[2]; k2++) {
          for (let i6 = 0; i6 < dims[0]; i6++) {
            let bsIdx = (i6 + sliceOffset * dims[0] + k2 * dims[0] * dims[1]) * numComp;
            id = (k2 * dims[0] + i6) * numComp;
            const end = bsIdx + numComp;
            while (bsIdx < end) {
              scalars[id++] = basicScalars[bsIdx++];
            }
          }
        }
        dims[1] = dims[2];
        ptsArray[0] = spatialExt[0];
        ptsArray[1] = sliceDepth;
        ptsArray[2] = spatialExt[4];
        ptsArray[3] = spatialExt[1];
        ptsArray[4] = sliceDepth;
        ptsArray[5] = spatialExt[4];
        ptsArray[6] = spatialExt[0];
        ptsArray[7] = sliceDepth;
        ptsArray[8] = spatialExt[5];
        ptsArray[9] = spatialExt[1];
        ptsArray[10] = sliceDepth;
        ptsArray[11] = spatialExt[5];
      } else if (ijkMode === SlicingMode2.K || ijkMode === SlicingMode2.NONE) {
        scalars = basicScalars.subarray(sliceOffset * sliceSize, (sliceOffset + 1) * sliceSize);
        ptsArray[0] = spatialExt[0];
        ptsArray[1] = spatialExt[2];
        ptsArray[2] = sliceDepth;
        ptsArray[3] = spatialExt[1];
        ptsArray[4] = spatialExt[2];
        ptsArray[5] = sliceDepth;
        ptsArray[6] = spatialExt[0];
        ptsArray[7] = spatialExt[3];
        ptsArray[8] = sliceDepth;
        ptsArray[9] = spatialExt[1];
        ptsArray[10] = spatialExt[3];
        ptsArray[11] = sliceDepth;
      } else {
        vtkErrorMacro16("Reformat slicing not yet supported.");
      }
      const tex = model._openGLRenderWindow.getGraphicsResourceForObject(scalars);
      if (!(tex == null ? void 0 : tex.vtkObj)) {
        if (model._scalars !== scalars) {
          model._openGLRenderWindow.releaseGraphicsResourcesForObject(model._scalars);
          model._scalars = scalars;
        }
        model.openGLTexture.resetFormatAndType();
        model.openGLTexture.create2DFilterableFromRaw(dims[0], dims[1], numComp, imgScalars.getDataType(), scalars, (_b2 = (_a9 = model.renderable).getPreferSizeOverAccuracy) == null ? void 0 : _b2.call(_a9));
        model._openGLRenderWindow.setGraphicsResourceForObject(scalars, model.openGLTexture, model.VBOBuildString);
      } else {
        model.openGLTexture = tex.vtkObj;
        model.VBOBuildString = tex.hash;
      }
      model.openGLTexture.activate();
      model.openGLTexture.sendParameters();
      model.openGLTexture.deactivate();
      const points = vtkDataArray$1.newInstance({
        numberOfComponents: 3,
        values: ptsArray
      });
      points.setName("points");
      const tcoords = vtkDataArray$1.newInstance({
        numberOfComponents: 2,
        values: tcoordArray
      });
      tcoords.setName("tcoords");
      const cellArray = new Uint16Array(8);
      cellArray[0] = 3;
      cellArray[1] = 0;
      cellArray[2] = 1;
      cellArray[3] = 3;
      cellArray[4] = 3;
      cellArray[5] = 0;
      cellArray[6] = 3;
      cellArray[7] = 2;
      const cells = vtkDataArray$1.newInstance({
        numberOfComponents: 1,
        values: cellArray
      });
      model.tris.getCABO().createVBO(cells, "polys", Representation.SURFACE, {
        points,
        tcoords,
        cellOffset: 0
      });
      model.VBOBuildTime.modified();
      model.VBOBuildString = toString3;
    }
  };
  publicAPI.updatelabelOutlineThicknessTexture = (image2) => {
    if (!model.labelOutlineThicknessTexture) {
      model.labelOutlineThicknessTexture = vtkOpenGLTexture$1.newInstance({
        resizable: false
      });
      model.labelOutlineThicknessTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
    }
    const labelOutlineThicknessArray = image2.getProperty().getLabelOutlineThickness();
    const lTex = model._openGLRenderWindow.getGraphicsResourceForObject(labelOutlineThicknessArray);
    const toString3 = `${labelOutlineThicknessArray.join("-")}`;
    const reBuildL = !(lTex == null ? void 0 : lTex.vtkObj) || (lTex == null ? void 0 : lTex.hash) !== toString3 || model.labelOutlineThicknessTextureString !== toString3;
    if (reBuildL) {
      const lWidth = 1024;
      const lHeight = 1;
      const lSize = lWidth * lHeight;
      const lTable = new Uint8Array(lSize);
      for (let i6 = 0; i6 < lWidth; ++i6) {
        const thickness = typeof labelOutlineThicknessArray[i6] !== "undefined" ? labelOutlineThicknessArray[i6] : labelOutlineThicknessArray[0];
        lTable[i6] = thickness;
      }
      model.labelOutlineThicknessTexture.releaseGraphicsResources(model._openGLRenderWindow);
      model.labelOutlineThicknessTexture.resetFormatAndType();
      model.labelOutlineThicknessTexture.setMinificationFilter(Filter.NEAREST);
      model.labelOutlineThicknessTexture.setMagnificationFilter(Filter.NEAREST);
      model.labelOutlineThicknessTexture.create2DFromRaw(lWidth, lHeight, 1, VtkDataTypes.UNSIGNED_CHAR, lTable);
      model.labelOutlineThicknessTextureString = toString3;
      if (labelOutlineThicknessArray) {
        model._openGLRenderWindow.setGraphicsResourceForObject(labelOutlineThicknessArray, model.labelOutlineThicknessTexture, model.labelOutlineThicknessTextureString);
      }
    } else {
      model.labelOutlineThicknessTexture = lTex.vtkObj;
      model.labelOutlineThicknessTextureString = lTex.hash;
    }
  };
  publicAPI.getRenderTargetSize = () => {
    if (model._useSmallViewport) {
      return [model._smallViewportWidth, model._smallViewportHeight];
    }
    const {
      usize,
      vsize
    } = model._openGLRenderer.getTiledSizeAndOrigin();
    return [usize, vsize];
  };
  publicAPI.getRenderTargetOffset = () => {
    const {
      lowerLeftU,
      lowerLeftV
    } = model._openGLRenderer.getTiledSizeAndOrigin();
    return [lowerLeftU, lowerLeftV];
  };
}
var DEFAULT_VALUES32 = {
  VBOBuildTime: 0,
  VBOBuildString: null,
  openGLTexture: null,
  tris: null,
  imagemat: null,
  imagematinv: null,
  colorTexture: null,
  pwfTexture: null,
  labelOutlineThicknessTexture: null,
  labelOutlineThicknessTextureString: null,
  lastHaveSeenDepthRequest: false,
  haveSeenDepthRequest: false,
  lastTextureComponents: 0,
  _scalars: null
};
function extend33(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES32, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  vtkReplacementShaderMapper.implementReplaceShaderCoincidentOffset(publicAPI, model, initialValues);
  vtkReplacementShaderMapper.implementBuildShadersWithReplacements(publicAPI, model, initialValues);
  model.tris = vtkHelper.newInstance();
  model.imagemat = mat4_exports.identity(new Float64Array(16));
  model.imagematinv = mat4_exports.identity(new Float64Array(16));
  model.projectionToWorld = mat4_exports.identity(new Float64Array(16));
  model.idxToView = mat4_exports.identity(new Float64Array(16));
  model.idxNormalMatrix = mat3_exports.identity(new Float64Array(9));
  model.modelToView = mat4_exports.identity(new Float64Array(16));
  model.projectionToView = mat4_exports.identity(new Float64Array(16));
  setGet(publicAPI, model, []);
  model.VBOBuildTime = {};
  obj(model.VBOBuildTime);
  vtkOpenGLImageMapper(publicAPI, model);
}
var newInstance34 = newInstance(extend33, "vtkOpenGLImageMapper");
registerOverride("vtkAbstractImageMapper", newInstance34);

// node_modules/@kitware/vtk.js/Rendering/Core/ImageCPRMapper/Constants.js
var ProjectionMode = {
  MAX: 0,
  MIN: 1,
  AVERAGE: 2
};

// node_modules/@kitware/vtk.js/Rendering/OpenGL/ImageCPRMapper.js
var {
  vtkErrorMacro: vtkErrorMacro17
} = macro;
function computeFnToString3(property, fn, numberOfComponents) {
  const pwfun = fn.apply(property);
  if (pwfun) {
    const iComps = property.getIndependentComponents();
    return `${property.getMTime()}-${iComps}-${numberOfComponents}`;
  }
  return "0";
}
function vtkOpenGLImageCPRMapper(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLImageCPRMapper");
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      model.currentRenderPass = null;
      model.openGLImageSlice = publicAPI.getFirstAncestorOfType("vtkOpenGLImageSlice");
      model._openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
      model._openGLRenderWindow = model._openGLRenderer.getParent();
      model.context = model._openGLRenderWindow.getContext();
      model.openGLCamera = model._openGLRenderer.getViewNodeFor(model._openGLRenderer.getRenderable().getActiveCamera());
      model.tris.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.volumeTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.colorTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.pwfTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
    }
  };
  publicAPI.opaquePass = (prepass, renderPass) => {
    if (prepass) {
      model.currentRenderPass = renderPass;
      publicAPI.render();
    }
  };
  publicAPI.opaqueZBufferPass = (prepass) => {
    if (prepass) {
      model.haveSeenDepthRequest = true;
      model.renderDepth = true;
      publicAPI.render();
      model.renderDepth = false;
    }
  };
  publicAPI.getCoincidentParameters = (ren, actor) => {
    if (model.renderable.getResolveCoincidentTopology()) {
      return model.renderable.getCoincidentTopologyPolygonOffsetParameters();
    }
    return null;
  };
  publicAPI.render = () => {
    const prop = model.openGLImageSlice.getRenderable();
    const ren = model._openGLRenderer.getRenderable();
    publicAPI.renderPiece(ren, prop);
  };
  publicAPI.renderPiece = (ren, prop) => {
    publicAPI.invokeEvent({
      type: "StartEvent"
    });
    model.renderable.update();
    publicAPI.invokeEvent({
      type: "EndEvent"
    });
    if (!model.renderable.preRenderCheck()) {
      return;
    }
    model.currentImageDataInput = model.renderable.getInputData(0);
    model.currentCenterlineInput = model.renderable.getOrientedCenterline();
    publicAPI.renderPieceStart(ren, prop);
    publicAPI.renderPieceDraw(ren, prop);
    publicAPI.renderPieceFinish(ren, prop);
  };
  publicAPI.renderPieceStart = (ren, actor) => {
    publicAPI.updateBufferObjects(ren, actor);
  };
  publicAPI.renderPieceDraw = (ren, actor) => {
    const gl = model.context;
    model.volumeTexture.activate();
    model.colorTexture.activate();
    model.pwfTexture.activate();
    if (model.tris.getCABO().getElementCount()) {
      publicAPI.updateShaders(model.tris, ren, actor);
      gl.drawArrays(gl.TRIANGLES, 0, model.tris.getCABO().getElementCount());
      model.tris.getVAO().release();
    }
    model.volumeTexture.deactivate();
    model.colorTexture.deactivate();
    model.pwfTexture.deactivate();
  };
  publicAPI.renderPieceFinish = (ren, actor) => {
  };
  publicAPI.updateBufferObjects = (ren, actor) => {
    if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {
      publicAPI.buildBufferObjects(ren, actor);
    }
  };
  publicAPI.getNeedToRebuildBufferObjects = (ren, actor) => {
    const vmtime = model.VBOBuildTime.getMTime();
    if (vmtime < publicAPI.getMTime() || vmtime < model.renderable.getMTime() || vmtime < actor.getMTime() || vmtime < model.currentImageDataInput.getMTime() || vmtime < model.currentCenterlineInput.getMTime()) {
      return true;
    }
    return false;
  };
  publicAPI.buildBufferObjects = (ren, actor) => {
    var _a9;
    const image2 = model.currentImageDataInput;
    const centerline = model.currentCenterlineInput;
    const actorProperty = actor.getProperty();
    if (actorProperty.getInterpolationType() === InterpolationType.NEAREST) {
      model.volumeTexture.setMinificationFilter(Filter.NEAREST);
      model.volumeTexture.setMagnificationFilter(Filter.NEAREST);
      model.colorTexture.setMinificationFilter(Filter.NEAREST);
      model.colorTexture.setMagnificationFilter(Filter.NEAREST);
      model.pwfTexture.setMinificationFilter(Filter.NEAREST);
      model.pwfTexture.setMagnificationFilter(Filter.NEAREST);
    } else {
      model.volumeTexture.setMinificationFilter(Filter.LINEAR);
      model.volumeTexture.setMagnificationFilter(Filter.LINEAR);
      model.colorTexture.setMinificationFilter(Filter.LINEAR);
      model.colorTexture.setMagnificationFilter(Filter.LINEAR);
      model.pwfTexture.setMinificationFilter(Filter.LINEAR);
      model.pwfTexture.setMagnificationFilter(Filter.LINEAR);
    }
    const imageTime = image2.getMTime();
    if (model.volumeTextureTime !== imageTime) {
      const dims = image2.getDimensions();
      const scalars2 = image2.getPointData().getScalars();
      if (!scalars2) {
        return;
      }
      model.volumeTexture.setOglNorm16Ext(model.context.getExtension("EXT_texture_norm16"));
      model.volumeTexture.releaseGraphicsResources(model._openGLRenderWindow);
      model.volumeTexture.resetFormatAndType();
      model.volumeTexture.create3DFilterableFromRaw(dims[0], dims[1], dims[2], scalars2.getNumberOfComponents(), scalars2.getDataType(), scalars2.getData(), model.renderable.getPreferSizeOverAccuracy());
      model.volumeTextureTime = imageTime;
    }
    const scalars = image2.getPointData() && image2.getPointData().getScalars();
    if (!scalars) {
      return;
    }
    const numComp = scalars.getNumberOfComponents();
    const ppty = actor.getProperty();
    const iComps = ppty.getIndependentComponents();
    const numIComps = iComps ? numComp : 1;
    const textureHeight = iComps ? 2 * numIComps : 1;
    const cfunToString = computeFnToString3(ppty, ppty.getRGBTransferFunction, numIComps);
    if (model.colorTextureString !== cfunToString) {
      const cWidth = 1024;
      const cSize = cWidth * textureHeight * 3;
      const cTable = new Uint8ClampedArray(cSize);
      let cfun = ppty.getRGBTransferFunction();
      if (cfun) {
        const tmpTable = new Float32Array(cWidth * 3);
        for (let c6 = 0; c6 < numIComps; c6++) {
          cfun = ppty.getRGBTransferFunction(c6);
          const cRange = cfun.getRange();
          cfun.getTable(cRange[0], cRange[1], cWidth, tmpTable, 1);
          if (iComps) {
            for (let i6 = 0; i6 < cWidth * 3; i6++) {
              cTable[c6 * cWidth * 6 + i6] = 255 * tmpTable[i6];
              cTable[c6 * cWidth * 6 + i6 + cWidth * 3] = 255 * tmpTable[i6];
            }
          } else {
            for (let i6 = 0; i6 < cWidth * 3; i6++) {
              cTable[c6 * cWidth * 6 + i6] = 255 * tmpTable[i6];
            }
          }
        }
        model.colorTexture.releaseGraphicsResources(model._openGLRenderWindow);
        model.colorTexture.resetFormatAndType();
        model.colorTexture.create2DFromRaw(cWidth, textureHeight, 3, VtkDataTypes.UNSIGNED_CHAR, cTable);
      } else {
        for (let i6 = 0; i6 < cWidth * 3; ++i6) {
          cTable[i6] = 255 * i6 / ((cWidth - 1) * 3);
          cTable[i6 + 1] = 255 * i6 / ((cWidth - 1) * 3);
          cTable[i6 + 2] = 255 * i6 / ((cWidth - 1) * 3);
        }
        model.colorTexture.create2DFromRaw(cWidth, 1, 3, VtkDataTypes.UNSIGNED_CHAR, cTable);
      }
      model.colorTextureString = cfunToString;
    }
    const pwfunToString = computeFnToString3(ppty, ppty.getPiecewiseFunction, numIComps);
    if (model.pwfTextureString !== pwfunToString) {
      const pwfWidth = 1024;
      const pwfSize = pwfWidth * textureHeight;
      const pwfTable = new Uint8ClampedArray(pwfSize);
      let pwfun = ppty.getPiecewiseFunction();
      model.pwfTexture.releaseGraphicsResources(model._openGLRenderWindow);
      model.pwfTexture.resetFormatAndType();
      if (pwfun) {
        const pwfFloatTable = new Float32Array(pwfSize);
        const tmpTable = new Float32Array(pwfWidth);
        for (let c6 = 0; c6 < numIComps; ++c6) {
          pwfun = ppty.getPiecewiseFunction(c6);
          if (pwfun === null) {
            pwfFloatTable.fill(1);
          } else {
            const pwfRange = pwfun.getRange();
            pwfun.getTable(pwfRange[0], pwfRange[1], pwfWidth, tmpTable, 1);
            if (iComps) {
              for (let i6 = 0; i6 < pwfWidth; i6++) {
                pwfFloatTable[c6 * pwfWidth * 2 + i6] = tmpTable[i6];
                pwfFloatTable[c6 * pwfWidth * 2 + i6 + pwfWidth] = tmpTable[i6];
              }
            } else {
              for (let i6 = 0; i6 < pwfWidth; i6++) {
                pwfFloatTable[c6 * pwfWidth * 2 + i6] = tmpTable[i6];
              }
            }
          }
        }
        model.pwfTexture.create2DFromRaw(pwfWidth, textureHeight, 1, VtkDataTypes.FLOAT, pwfFloatTable);
      } else {
        pwfTable.fill(255);
        model.pwfTexture.create2DFromRaw(pwfWidth, 1, 1, VtkDataTypes.UNSIGNED_CHAR, pwfTable);
      }
      model.pwfTextureString = pwfunToString;
    }
    if (model.VBOBuildTime.getMTime() < model.renderable.getMTime() || model.VBOBuildTime.getMTime() < centerline.getMTime()) {
      const nPoints = centerline.getNumberOfPoints();
      const nLines = nPoints <= 1 ? 0 : nPoints - 1;
      const distances = centerline.getDistancesToFirstPoint();
      const totalHeight = model.renderable.getHeight();
      const nPts = 4 * nLines;
      const ptsArray = new Float32Array(3 * nPts);
      const widthMC = model.renderable.getWidth();
      for (let lineIdx = 0, offset3 = 0; lineIdx < nLines; ++lineIdx) {
        ptsArray.set([0, totalHeight - distances[lineIdx], 0], offset3);
        offset3 += 3;
        ptsArray.set([widthMC, totalHeight - distances[lineIdx], 0], offset3);
        offset3 += 3;
        ptsArray.set([widthMC, totalHeight - distances[lineIdx + 1], 0], offset3);
        offset3 += 3;
        ptsArray.set([0, totalHeight - distances[lineIdx + 1], 0], offset3);
        offset3 += 3;
      }
      const points = vtkDataArray$1.newInstance({
        numberOfComponents: 3,
        values: ptsArray
      });
      points.setName("points");
      const cellArray = new Uint16Array(5 * nLines);
      for (let lineIdx = 0, offset3 = 0, ptIdx = 0; lineIdx < nLines; ++lineIdx) {
        cellArray.set([4, ptIdx + 3, ptIdx + 2, ptIdx + 1, ptIdx], offset3);
        offset3 += 5;
        ptIdx += 4;
      }
      const cells = vtkDataArray$1.newInstance({
        numberOfComponents: 1,
        values: cellArray
      });
      const pointsDataArray = centerline.getPoints();
      const centerlinePositionArray = new Float32Array(3 * nPts);
      const pa = new Array(3);
      const pb = new Array(3);
      for (let lineIdx = 0, offset3 = 0; lineIdx < nLines; ++lineIdx) {
        pointsDataArray.getPoint(lineIdx, pa);
        pointsDataArray.getPoint(lineIdx + 1, pb);
        centerlinePositionArray.set(pa, offset3);
        offset3 += 3;
        centerlinePositionArray.set(pa, offset3);
        offset3 += 3;
        centerlinePositionArray.set(pb, offset3);
        offset3 += 3;
        centerlinePositionArray.set(pb, offset3);
        offset3 += 3;
      }
      const centerlinePosition = vtkDataArray$1.newInstance({
        numberOfComponents: 3,
        values: centerlinePositionArray,
        name: "centerlinePosition"
      });
      const quadIndexArray = new Float32Array(nPts);
      for (let lineIdx = 0, offset3 = 0; lineIdx < nLines; ++lineIdx) {
        quadIndexArray.set([
          0,
          // Top left
          1,
          // Top right
          3,
          // Bottom right
          2
          // Bottom left
        ], offset3);
        offset3 += 4;
      }
      const quadIndex = vtkDataArray$1.newInstance({
        numberOfComponents: 1,
        values: quadIndexArray,
        name: "quadIndex"
      });
      const customAttributes = [centerlinePosition, quadIndex];
      if (!model.renderable.getUseUniformOrientation()) {
        const orientationQuats = (_a9 = model.renderable.getOrientedCenterline().getOrientations()) != null ? _a9 : [];
        const centerlineTopOrientationArray = new Float32Array(4 * nPts);
        const centerlineBotOrientationArray = new Float32Array(4 * nPts);
        for (let quadIdx = 0; quadIdx < nLines; ++quadIdx) {
          const topQuat = orientationQuats[quadIdx];
          const botQuat = orientationQuats[quadIdx + 1];
          for (let pointInQuadIdx = 0; pointInQuadIdx < 4; ++pointInQuadIdx) {
            const pointIdx = pointInQuadIdx + 4 * quadIdx;
            const quaternionArrayOffset = 4 * pointIdx;
            centerlineTopOrientationArray.set(topQuat, quaternionArrayOffset);
            centerlineBotOrientationArray.set(botQuat, quaternionArrayOffset);
          }
        }
        const centerlineTopOrientation = vtkDataArray$1.newInstance({
          numberOfComponents: 4,
          values: centerlineTopOrientationArray,
          name: "centerlineTopOrientation"
        });
        const centerlineBotOrientation = vtkDataArray$1.newInstance({
          numberOfComponents: 4,
          values: centerlineBotOrientationArray,
          name: "centerlineBotOrientation"
        });
        customAttributes.push(centerlineTopOrientation, centerlineBotOrientation);
      }
      model.tris.getCABO().createVBO(cells, "polys", Representation.SURFACE, {
        points,
        customAttributes
      });
      model.VBOBuildTime.modified();
    }
  };
  publicAPI.getNeedToRebuildShaders = (cellBO, ren, actor) => {
    const tNumComp = model.volumeTexture.getComponents();
    const iComp = actor.getProperty().getIndependentComponents();
    const useCenterPoint = !!model.renderable.getCenterPoint();
    const useUniformOrientation = model.renderable.getUseUniformOrientation();
    const projectionMode = model.renderable.isProjectionEnabled() && model.renderable.getProjectionMode();
    if (cellBO.getProgram() === 0 || model.lastUseCenterPoint !== useCenterPoint || model.lastUseUniformOrientation !== useUniformOrientation || model.lastProjectionMode !== projectionMode || model.lastHaveSeenDepthRequest !== model.haveSeenDepthRequest || model.lastTextureComponents !== tNumComp || model.lastIndependentComponents !== iComp) {
      model.lastUseCenterPoint = useCenterPoint;
      model.lastUseUniformOrientation = useUniformOrientation;
      model.lastProjectionMode = projectionMode;
      model.lastHaveSeenDepthRequest = model.haveSeenDepthRequest;
      model.lastTextureComponents = tNumComp;
      model.lastIndependentComponents = iComp;
      return true;
    }
    return false;
  };
  publicAPI.buildShaders = (shaders, ren, actor) => {
    publicAPI.getShaderTemplate(shaders, ren, actor);
    publicAPI.replaceShaderValues(shaders, ren, actor);
  };
  publicAPI.replaceShaderValues = (shaders, ren, actor) => {
    let VSSource = shaders.Vertex;
    let FSSource = shaders.Fragment;
    const applyQuaternionToVecShaderFunction = ["vec3 applyQuaternionToVec(vec4 q, vec3 v) {", "  float uvx = q.y * v.z - q.z * v.y;", "  float uvy = q.z * v.x - q.x * v.z;", "  float uvz = q.x * v.y - q.y * v.x;", "  float uuvx = q.y * uvz - q.z * uvy;", "  float uuvy = q.z * uvx - q.x * uvz;", "  float uuvz = q.x * uvy - q.y * uvx;", "  float w2 = q.w * 2.0;", "  uvx *= w2;", "  uvy *= w2;", "  uvz *= w2;", "  uuvx *= 2.0;", "  uuvy *= 2.0;", "  uuvz *= 2.0;", "  return vec3(v.x + uvx + uuvx, v.y + uvy + uuvy, v.z + uvz + uuvz);", "}"];
    VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Camera::Dec", ["uniform mat4 MCPCMatrix;"]).result;
    VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::PositionVC::Impl", ["  gl_Position = MCPCMatrix * vertexMC;"]).result;
    const vsColorDec = ["attribute vec3 centerlinePosition;", "attribute float quadIndex;", "uniform float width;", "out vec2 quadOffsetVSOutput;", "out vec3 centerlinePosVSOutput;"];
    const useProjection = model.renderable.isProjectionEnabled();
    const isDirectionUniform = model.renderable.getUseUniformOrientation();
    if (isDirectionUniform) {
      vsColorDec.push("out vec3 samplingDirVSOutput;", "uniform vec4 centerlineOrientation;", "uniform vec3 tangentDirection;", ...applyQuaternionToVecShaderFunction);
      if (useProjection) {
        vsColorDec.push("out vec3 projectionDirVSOutput;", "uniform vec3 bitangentDirection;");
      }
    } else {
      vsColorDec.push("out vec4 centerlineTopOrientationVSOutput;", "out vec4 centerlineBotOrientationVSOutput;", "attribute vec4 centerlineTopOrientation;", "attribute vec4 centerlineBotOrientation;");
    }
    VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Color::Dec", vsColorDec).result;
    const vsColorImpl = [
      // quadOffsetVSOutput.x: left = -0.5* width; right = 0.5 * width
      // quadOffsetVSOutput.y: bottom = 0.0; top = 1.0;
      "quadOffsetVSOutput = vec2(width * (mod(quadIndex, 2.0) == 0.0 ? -0.5 : 0.5), quadIndex > 1.0 ? 0.0 : 1.0);",
      "centerlinePosVSOutput = centerlinePosition;"
    ];
    if (isDirectionUniform) {
      vsColorImpl.push("samplingDirVSOutput = applyQuaternionToVec(centerlineOrientation, tangentDirection);");
      if (useProjection) {
        vsColorImpl.push("projectionDirVSOutput = applyQuaternionToVec(centerlineOrientation, bitangentDirection);");
      }
    } else {
      vsColorImpl.push("centerlineTopOrientationVSOutput = centerlineTopOrientation;", "centerlineBotOrientationVSOutput = centerlineBotOrientation;");
    }
    VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Color::Impl", vsColorImpl).result;
    const tNumComp = model.volumeTexture.getComponents();
    const iComps = actor.getProperty().getIndependentComponents();
    let tcoordFSDec = [
      // used to compute texture coordinates of the sample
      "uniform mat4 MCTCMatrix; // Model coordinates to texture coordinates",
      "in vec2 quadOffsetVSOutput;",
      "in vec3 centerlinePosVSOutput;",
      // volume texture
      "uniform highp sampler3D volumeTexture;",
      // color and pwf textures
      "uniform sampler2D colorTexture1;",
      "uniform sampler2D pwfTexture1;",
      // opacity
      "uniform float opacity;",
      // background color (out of volume samples)
      "uniform vec4 backgroundColor;",
      // color shift and scale
      `uniform float cshift0;`,
      `uniform float cscale0;`,
      // weighting shift and scale
      `uniform float pwfshift0;`,
      `uniform float pwfscale0;`
    ];
    if (useProjection) {
      tcoordFSDec.push("uniform vec3 volumeSizeMC;", "uniform int projectionSlabNumberOfSamples;", "uniform float projectionConstantOffset;", "uniform float projectionStepLength;");
    }
    if (isDirectionUniform) {
      tcoordFSDec.push("in vec3 samplingDirVSOutput;");
      if (useProjection) {
        tcoordFSDec.push("in vec3 projectionDirVSOutput;");
      }
    } else {
      tcoordFSDec.push("uniform vec3 tangentDirection;", "in vec4 centerlineTopOrientationVSOutput;", "in vec4 centerlineBotOrientationVSOutput;", ...applyQuaternionToVecShaderFunction);
      if (useProjection) {
        tcoordFSDec.push("uniform vec3 bitangentDirection;");
      }
    }
    const centerPoint = model.renderable.getCenterPoint();
    if (centerPoint) {
      tcoordFSDec.push("uniform vec3 globalCenterPoint;");
    }
    if (iComps) {
      for (let comp = 1; comp < tNumComp; comp++) {
        tcoordFSDec = tcoordFSDec.concat([
          // color shift and scale
          `uniform float cshift${comp};`,
          `uniform float cscale${comp};`,
          // weighting shift and scale
          `uniform float pwfshift${comp};`,
          `uniform float pwfscale${comp};`
        ]);
      }
      switch (tNumComp) {
        case 1:
          tcoordFSDec = tcoordFSDec.concat(["uniform float mix0;", "#define height0 0.5"]);
          break;
        case 2:
          tcoordFSDec = tcoordFSDec.concat(["uniform float mix0;", "uniform float mix1;", "#define height0 0.25", "#define height1 0.75"]);
          break;
        case 3:
          tcoordFSDec = tcoordFSDec.concat(["uniform float mix0;", "uniform float mix1;", "uniform float mix2;", "#define height0 0.17", "#define height1 0.5", "#define height2 0.83"]);
          break;
        case 4:
          tcoordFSDec = tcoordFSDec.concat(["uniform float mix0;", "uniform float mix1;", "uniform float mix2;", "uniform float mix3;", "#define height0 0.125", "#define height1 0.375", "#define height2 0.625", "#define height3 0.875"]);
          break;
        default:
          vtkErrorMacro17("Unsupported number of independent coordinates.");
      }
    }
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Dec", tcoordFSDec).result;
    let tcoordFSImpl = [];
    if (isDirectionUniform) {
      tcoordFSImpl.push("vec3 samplingDirection = samplingDirVSOutput;");
      if (useProjection) {
        tcoordFSImpl.push("vec3 projectionDirection = projectionDirVSOutput;");
      }
    } else {
      tcoordFSImpl.push(
        // Slerp / Lerp
        "vec4 q0 = centerlineBotOrientationVSOutput;",
        "vec4 q1 = centerlineTopOrientationVSOutput;",
        "float qCosAngle = dot(q0, q1);",
        "vec4 interpolatedOrientation;",
        "if (qCosAngle > 0.999 || qCosAngle < -0.999) {",
        "  // Use LERP instead of SLERP when the two quaternions are close or opposite",
        "  interpolatedOrientation = normalize(mix(q0, q1, quadOffsetVSOutput.y));",
        "} else {",
        "  float omega = acos(qCosAngle);",
        "  interpolatedOrientation = normalize(sin((1.0 - quadOffsetVSOutput.y) * omega) * q0 + sin(quadOffsetVSOutput.y * omega) * q1);",
        "}",
        "vec3 samplingDirection = applyQuaternionToVec(interpolatedOrientation, tangentDirection);"
      );
      if (useProjection) {
        tcoordFSImpl.push("vec3 projectionDirection = applyQuaternionToVec(interpolatedOrientation, bitangentDirection);");
      }
    }
    if (centerPoint) {
      tcoordFSImpl.push("float baseOffset = dot(samplingDirection, globalCenterPoint - centerlinePosVSOutput);", "float horizontalOffset = quadOffsetVSOutput.x + baseOffset;");
    } else {
      tcoordFSImpl.push("float horizontalOffset = quadOffsetVSOutput.x;");
    }
    tcoordFSImpl.push("vec3 volumePosMC = centerlinePosVSOutput + horizontalOffset * samplingDirection;", "vec3 volumePosTC = (MCTCMatrix * vec4(volumePosMC, 1.0)).xyz;", "if (any(lessThan(volumePosTC, vec3(0.0))) || any(greaterThan(volumePosTC, vec3(1.0))))", "{", "  // set the background color and exit", "  gl_FragData[0] = backgroundColor;", "  return;", "}");
    if (useProjection) {
      const projectionMode = model.renderable.getProjectionMode();
      switch (projectionMode) {
        case ProjectionMode.MIN:
          tcoordFSImpl.push("const vec4 initialProjectionTextureValue = vec4(1.0);");
          break;
        case ProjectionMode.MAX:
        case ProjectionMode.AVERAGE:
        default:
          tcoordFSImpl.push("const vec4 initialProjectionTextureValue = vec4(0.0);");
          break;
      }
      tcoordFSImpl.push("vec3 projectionScaledDirection = projectionDirection / volumeSizeMC;", "vec3 projectionStep = projectionStepLength * projectionScaledDirection;", "vec3 projectionStartPosition = volumePosTC + projectionConstantOffset * projectionScaledDirection;", "vec4 tvalue = initialProjectionTextureValue;", "for (int projectionSampleIdx = 0; projectionSampleIdx < projectionSlabNumberOfSamples; ++projectionSampleIdx) {", "  vec3 projectionSamplePosition = projectionStartPosition + float(projectionSampleIdx) * projectionStep;", "  vec4 sampledTextureValue = texture(volumeTexture, projectionSamplePosition);");
      switch (projectionMode) {
        case ProjectionMode.MAX:
          tcoordFSImpl.push("  tvalue = max(tvalue, sampledTextureValue);");
          break;
        case ProjectionMode.MIN:
          tcoordFSImpl.push("  tvalue = min(tvalue, sampledTextureValue);");
          break;
        case ProjectionMode.AVERAGE:
        default:
          tcoordFSImpl.push("  tvalue = tvalue + sampledTextureValue;");
          break;
      }
      tcoordFSImpl.push("}");
      if (projectionMode === ProjectionMode.AVERAGE) {
        tcoordFSImpl.push("tvalue = tvalue / float(projectionSlabNumberOfSamples);");
      }
    } else {
      tcoordFSImpl.push("vec4 tvalue = texture(volumeTexture, volumePosTC);");
    }
    if (iComps) {
      const rgba = ["r", "g", "b", "a"];
      for (let comp = 0; comp < tNumComp; ++comp) {
        tcoordFSImpl = tcoordFSImpl.concat([`vec3 tcolor${comp} = mix${comp} * texture2D(colorTexture1, vec2(tvalue.${rgba[comp]} * cscale${comp} + cshift${comp}, height${comp})).rgb;`, `float compWeight${comp} = mix${comp} * texture2D(pwfTexture1, vec2(tvalue.${rgba[comp]} * pwfscale${comp} + pwfshift${comp}, height${comp})).r;`]);
      }
      switch (tNumComp) {
        case 1:
          tcoordFSImpl = tcoordFSImpl.concat(["gl_FragData[0] = vec4(tcolor0.rgb, compWeight0 * opacity);"]);
          break;
        case 2:
          tcoordFSImpl = tcoordFSImpl.concat(["float weightSum = compWeight0 + compWeight1;", "gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);"]);
          break;
        case 3:
          tcoordFSImpl = tcoordFSImpl.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2;", "gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);"]);
          break;
        case 4:
          tcoordFSImpl = tcoordFSImpl.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;", "gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);"]);
          break;
        default:
          vtkErrorMacro17("Unsupported number of independent coordinates.");
      }
    } else {
      switch (tNumComp) {
        case 1:
          tcoordFSImpl = tcoordFSImpl.concat(["// Dependent components", "float intensity = tvalue.r;", "vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;", "float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;", "gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);"]);
          break;
        case 2:
          tcoordFSImpl = tcoordFSImpl.concat(["float intensity = tvalue.r*cscale0 + cshift0;", "gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tvalue.g + pwfshift0);"]);
          break;
        case 3:
          tcoordFSImpl = tcoordFSImpl.concat(["vec4 tcolor = cscale0*tvalue + cshift0;", "gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,", "  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,", "  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);"]);
          break;
        default:
          tcoordFSImpl = tcoordFSImpl.concat(["vec4 tcolor = cscale0*tvalue + cshift0;", "gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,", "  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,", "  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);"]);
      }
    }
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", tcoordFSImpl).result;
    if (model.haveSeenDepthRequest) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ZBuffer::Dec", "uniform int depthRequest;").result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ZBuffer::Impl", ["if (depthRequest == 1) {", "float iz = floor(gl_FragCoord.z*65535.0 + 0.1);", "float rf = floor(iz/256.0)/255.0;", "float gf = mod(iz,256.0)/255.0;", "gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result;
    }
    shaders.Vertex = VSSource;
    shaders.Fragment = FSSource;
    publicAPI.replaceShaderClip(shaders, ren, actor);
    publicAPI.replaceShaderCoincidentOffset(shaders, ren, actor);
  };
  publicAPI.replaceShaderClip = (shaders, ren, actor) => {
    let VSSource = shaders.Vertex;
    let FSSource = shaders.Fragment;
    if (model.renderable.getNumberOfClippingPlanes()) {
      let numClipPlanes = model.renderable.getNumberOfClippingPlanes();
      if (numClipPlanes > 6) {
        macro.vtkErrorMacro("OpenGL has a limit of 6 clipping planes");
        numClipPlanes = 6;
      }
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Clip::Dec", ["uniform int numClipPlanes;", "uniform vec4 clipPlanes[6];", "varying float clipDistancesVSOutput[6];"]).result;
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Clip::Impl", ["for (int planeNum = 0; planeNum < 6; planeNum++)", "    {", "    if (planeNum >= numClipPlanes)", "        {", "        break;", "        }", "    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);", "    }"]).result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Clip::Dec", ["uniform int numClipPlanes;", "varying float clipDistancesVSOutput[6];"]).result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Clip::Impl", ["for (int planeNum = 0; planeNum < 6; planeNum++)", "    {", "    if (planeNum >= numClipPlanes)", "        {", "        break;", "        }", "    if (clipDistancesVSOutput[planeNum] < 0.0) discard;", "    }"]).result;
    }
    shaders.Vertex = VSSource;
    shaders.Fragment = FSSource;
  };
  publicAPI.getShaderTemplate = (shaders, ren, actor) => {
    shaders.Vertex = vtkPolyDataVS;
    shaders.Fragment = vtkPolyDataFS;
    shaders.Geometry = "";
  };
  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {
    const program = cellBO.getProgram();
    const cellArrayBufferObject = cellBO.getCABO();
    if (cellArrayBufferObject.getElementCount() && (model.VBOBuildTime.getMTime() > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {
      if (program.isAttributeUsed("vertexMC")) {
        if (!cellBO.getVAO().addAttributeArray(program, cellArrayBufferObject, "vertexMC", cellArrayBufferObject.getVertexOffset(), cellArrayBufferObject.getStride(), model.context.FLOAT, 3, model.context.FALSE)) {
          vtkErrorMacro17("Error setting vertexMC in shader VAO.");
        }
      }
      cellBO.getCABO().getCustomData().forEach((data) => {
        if (data && program.isAttributeUsed(data.name) && !cellBO.getVAO().addAttributeArray(program, cellArrayBufferObject, data.name, data.offset, cellArrayBufferObject.getStride(), model.context.FLOAT, data.components, model.context.FALSE)) {
          vtkErrorMacro17(`Error setting ${data.name} in shader VAO.`);
        }
      });
      cellBO.getAttributeUpdateTime().modified();
    }
    const texUnit = model.volumeTexture.getTextureUnit();
    program.setUniformi("volumeTexture", texUnit);
    program.setUniformf("width", model.renderable.getWidth());
    cellBO.getProgram().setUniform4fv("backgroundColor", model.renderable.getBackgroundColor());
    if (program.isUniformUsed("tangentDirection")) {
      const tangentDirection = model.renderable.getTangentDirection();
      cellBO.getProgram().setUniform3fArray("tangentDirection", tangentDirection);
    }
    if (program.isUniformUsed("bitangentDirection")) {
      const bitangentDirection = model.renderable.getBitangentDirection();
      cellBO.getProgram().setUniform3fArray("bitangentDirection", bitangentDirection);
    }
    if (program.isUniformUsed("centerlineOrientation")) {
      const uniformOrientation = model.renderable.getUniformOrientation();
      cellBO.getProgram().setUniform4fv("centerlineOrientation", uniformOrientation);
    }
    if (program.isUniformUsed("globalCenterPoint")) {
      const centerPoint = model.renderable.getCenterPoint();
      program.setUniform3fArray("globalCenterPoint", centerPoint);
    }
    if (model.renderable.isProjectionEnabled()) {
      const image3 = model.currentImageDataInput;
      const spacing = image3.getSpacing();
      const dimensions = image3.getDimensions();
      const projectionSlabThickness = model.renderable.getProjectionSlabThickness();
      const projectionSlabNumberOfSamples = model.renderable.getProjectionSlabNumberOfSamples();
      const volumeSize = vec3_exports.mul([], spacing, dimensions);
      program.setUniform3fArray("volumeSizeMC", volumeSize);
      program.setUniformi("projectionSlabNumberOfSamples", projectionSlabNumberOfSamples);
      const constantOffset = -0.5 * projectionSlabThickness;
      program.setUniformf("projectionConstantOffset", constantOffset);
      const stepLength = projectionSlabThickness / (projectionSlabNumberOfSamples - 1);
      program.setUniformf("projectionStepLength", stepLength);
    }
    const image2 = model.currentImageDataInput;
    const MCICMatrix = image2.getWorldToIndex();
    const ICTCMatrix = mat4_exports.fromScaling(new Float32Array(16), vec3_exports.inverse([], image2.getDimensions()));
    const MCTCMatrix = mat4_exports.mul(ICTCMatrix, ICTCMatrix, MCICMatrix);
    program.setUniformMatrix("MCTCMatrix", MCTCMatrix);
    if (model.haveSeenDepthRequest) {
      cellBO.getProgram().setUniformi("depthRequest", model.renderDepth ? 1 : 0);
    }
    if (model.renderable.getNumberOfClippingPlanes()) {
      let numClipPlanes = model.renderable.getNumberOfClippingPlanes();
      if (numClipPlanes > 6) {
        macro.vtkErrorMacro("OpenGL has a limit of 6 clipping planes");
        numClipPlanes = 6;
      }
      const shiftScaleEnabled = cellArrayBufferObject.getCoordShiftAndScaleEnabled();
      const inverseShiftScaleMatrix = shiftScaleEnabled ? cellArrayBufferObject.getInverseShiftAndScaleMatrix() : null;
      const mat = inverseShiftScaleMatrix ? mat4_exports.copy(model.imagematinv, actor.getMatrix()) : actor.getMatrix();
      if (inverseShiftScaleMatrix) {
        mat4_exports.transpose(mat, mat);
        mat4_exports.multiply(mat, mat, inverseShiftScaleMatrix);
        mat4_exports.transpose(mat, mat);
      }
      mat4_exports.transpose(model.imagemat, model.currentImageDataInput.getIndexToWorld());
      mat4_exports.multiply(model.imagematinv, mat, model.imagemat);
      const planeEquations = [];
      for (let i6 = 0; i6 < numClipPlanes; i6++) {
        const planeEquation = [];
        model.renderable.getClippingPlaneInDataCoords(model.imagematinv, i6, planeEquation);
        for (let j2 = 0; j2 < 4; j2++) {
          planeEquations.push(planeEquation[j2]);
        }
      }
      program.setUniformi("numClipPlanes", numClipPlanes);
      program.setUniform4fv("clipPlanes", planeEquations);
    }
    if (program.isUniformUsed("coffset")) {
      const cp = publicAPI.getCoincidentParameters(ren, actor);
      program.setUniformf("coffset", cp.offset);
      if (program.isUniformUsed("cfactor")) {
        program.setUniformf("cfactor", cp.factor);
      }
    }
  };
  publicAPI.setCameraShaderParameters = (cellBO, ren, actor) => {
    const MCWCMatrix = model.openGLImageSlice.getKeyMatrices().mcwc;
    const WCPCMatrix = model.openGLCamera.getKeyMatrices(ren).wcpc;
    mat4_exports.multiply(model.imagemat, WCPCMatrix, MCWCMatrix);
    if (cellBO.getCABO().getCoordShiftAndScaleEnabled()) {
      const inverseShiftScaleMat = cellBO.getCABO().getInverseShiftAndScaleMatrix();
      mat4_exports.multiply(model.imagemat, model.imagemat, inverseShiftScaleMat);
    }
    cellBO.getProgram().setUniformMatrix("MCPCMatrix", model.imagemat);
  };
  publicAPI.setPropertyShaderParameters = (cellBO, ren, actor) => {
    const program = cellBO.getProgram();
    const ppty = actor.getProperty();
    const opacity = ppty.getOpacity();
    program.setUniformf("opacity", opacity);
    const numComp = model.volumeTexture.getComponents();
    const iComps = ppty.getIndependentComponents();
    if (iComps) {
      for (let i6 = 0; i6 < numComp; ++i6) {
        program.setUniformf(`mix${i6}`, ppty.getComponentWeight(i6));
      }
    }
    const volInfo = model.volumeTexture.getVolumeInfo();
    for (let i6 = 0; i6 < numComp; i6++) {
      let cw = ppty.getColorWindow();
      let cl = ppty.getColorLevel();
      const target = iComps ? i6 : 0;
      const cfun = ppty.getRGBTransferFunction(target);
      if (cfun && ppty.getUseLookupTableScalarRange()) {
        const cRange = cfun.getRange();
        cw = cRange[1] - cRange[0];
        cl = 0.5 * (cRange[1] + cRange[0]);
      }
      const scale7 = volInfo.scale[i6] / cw;
      const shift3 = (volInfo.offset[i6] - cl) / cw + 0.5;
      program.setUniformf(`cshift${i6}`, shift3);
      program.setUniformf(`cscale${i6}`, scale7);
    }
    const texColorUnit = model.colorTexture.getTextureUnit();
    program.setUniformi("colorTexture1", texColorUnit);
    for (let i6 = 0; i6 < numComp; i6++) {
      let pwfScale = 1;
      let pwfShift = 0;
      const target = iComps ? i6 : 0;
      const pwfun = ppty.getPiecewiseFunction(target);
      if (pwfun) {
        const pwfRange = pwfun.getRange();
        const length4 = pwfRange[1] - pwfRange[0];
        const mid = 0.5 * (pwfRange[0] + pwfRange[1]);
        pwfScale = volInfo.scale[i6] / length4;
        pwfShift = (volInfo.offset[i6] - mid) / length4 + 0.5;
      }
      program.setUniformf(`pwfshift${i6}`, pwfShift);
      program.setUniformf(`pwfscale${i6}`, pwfScale);
    }
    const texOpacityUnit = model.pwfTexture.getTextureUnit();
    program.setUniformi("pwfTexture1", texOpacityUnit);
  };
  publicAPI.updateShaders = (cellBO, ren, actor) => {
    if (publicAPI.getNeedToRebuildShaders(cellBO, ren, actor)) {
      const shaders = {
        Vertex: null,
        Fragment: null,
        Geometry: null
      };
      publicAPI.buildShaders(shaders, ren, actor);
      const newShader = model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(shaders.Vertex, shaders.Fragment, shaders.Geometry);
      if (newShader !== cellBO.getProgram()) {
        cellBO.setProgram(newShader);
        cellBO.getVAO().releaseGraphicsResources();
      }
      cellBO.getShaderSourceTime().modified();
    } else {
      model._openGLRenderWindow.getShaderCache().readyShaderProgram(cellBO.getProgram());
    }
    cellBO.getVAO().bind();
    publicAPI.setMapperShaderParameters(cellBO, ren, actor);
    publicAPI.setCameraShaderParameters(cellBO, ren, actor);
    publicAPI.setPropertyShaderParameters(cellBO, ren, actor);
  };
}
var DEFAULT_VALUES33 = {
  currentRenderPass: null,
  volumeTexture: null,
  volumeTextureTime: 0,
  colorTexture: null,
  colorTextureString: null,
  pwfTexture: null,
  pwfTextureString: null,
  tris: null,
  lastHaveSeenDepthRequest: false,
  haveSeenDepthRequest: false,
  lastTextureComponents: 0,
  lastIndependentComponents: 0,
  imagemat: null,
  imagematinv: null
};
function extend34(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES33, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  vtkReplacementShaderMapper.implementReplaceShaderCoincidentOffset(publicAPI, model, initialValues);
  macro.algo(publicAPI, model, 2, 0);
  model.tris = vtkHelper.newInstance();
  model.volumeTexture = vtkOpenGLTexture$1.newInstance();
  model.colorTexture = vtkOpenGLTexture$1.newInstance();
  model.pwfTexture = vtkOpenGLTexture$1.newInstance();
  model.imagemat = mat4_exports.identity(new Float64Array(16));
  model.imagematinv = mat4_exports.identity(new Float64Array(16));
  model.VBOBuildTime = {};
  macro.obj(model.VBOBuildTime, {
    mtime: 0
  });
  vtkOpenGLImageCPRMapper(publicAPI, model);
}
var newInstance35 = macro.newInstance(extend34, "vtkOpenGLImageCPRMapper");
var STATIC8 = {};
var index = __spreadValues({
  newInstance: newInstance35,
  extend: extend34
}, STATIC8);
registerOverride("vtkImageCPRMapper", newInstance35);

// node_modules/@kitware/vtk.js/Rendering/OpenGL/ImageSlice.js
function vtkOpenGLImageSlice(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLImageSlice");
  publicAPI.buildPass = (prepass) => {
    if (!model.renderable || !model.renderable.getVisibility()) {
      return;
    }
    if (prepass) {
      if (!model.renderable) {
        return;
      }
      model._openGLRenderWindow = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderWindow");
      model._openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
      model.context = model._openGLRenderWindow.getContext();
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.renderable.getMapper());
      publicAPI.removeUnusedNodes();
    }
  };
  publicAPI.traverseZBufferPass = (renderPass) => {
    if (!model.renderable || !model.renderable.getNestedVisibility() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.children.forEach((child) => {
      child.traverse(renderPass);
    });
    publicAPI.apply(renderPass, false);
  };
  publicAPI.traverseOpaqueZBufferPass = (renderPass) => publicAPI.traverseOpaquePass(renderPass);
  publicAPI.traverseOpaquePass = (renderPass) => {
    if (!model.renderable || !model.renderable.getNestedVisibility() || !model.renderable.getIsOpaque() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.children.forEach((child) => {
      child.traverse(renderPass);
    });
    publicAPI.apply(renderPass, false);
  };
  publicAPI.traverseTranslucentPass = (renderPass) => {
    if (!model.renderable || !model.renderable.getNestedVisibility() || model.renderable.getIsOpaque() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.children.forEach((child) => {
      child.traverse(renderPass);
    });
    publicAPI.apply(renderPass, false);
  };
  publicAPI.queryPass = (prepass, renderPass) => {
    if (prepass) {
      if (!model.renderable || !model.renderable.getVisibility()) {
        return;
      }
      if (model.renderable.getIsOpaque()) {
        renderPass.incrementOpaqueActorCount();
      } else {
        renderPass.incrementTranslucentActorCount();
      }
    }
  };
  publicAPI.zBufferPass = (prepass, renderPass) => publicAPI.opaquePass(prepass, renderPass);
  publicAPI.opaqueZBufferPass = (prepass, renderPass) => publicAPI.opaquePass(prepass, renderPass);
  publicAPI.opaquePass = (prepass, renderPass) => {
    if (prepass) {
      model.context.depthMask(true);
    }
  };
  publicAPI.translucentPass = (prepass, renderPass) => {
    model.context.depthMask(!prepass);
  };
  publicAPI.getKeyMatrices = () => {
    if (model.renderable.getMTime() > model.keyMatrixTime.getMTime()) {
      mat4_exports.copy(model.keyMatrices.mcwc, model.renderable.getMatrix());
      mat4_exports.transpose(model.keyMatrices.mcwc, model.keyMatrices.mcwc);
      model.keyMatrixTime.modified();
    }
    return model.keyMatrices;
  };
}
var DEFAULT_VALUES34 = {
  context: null,
  keyMatrixTime: null,
  keyMatrices: null
};
function extend35(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES34, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.keyMatrixTime = {};
  obj(model.keyMatrixTime, {
    mtime: 0
  });
  model.keyMatrices = {
    mcwc: mat4_exports.identity(new Float64Array(16))
  };
  setGet(publicAPI, model, ["context"]);
  vtkOpenGLImageSlice(publicAPI, model);
}
var newInstance36 = newInstance(extend35, "vtkOpenGLImageSlice");
registerOverride("vtkImageSlice", newInstance36);

// node_modules/@kitware/vtk.js/Rendering/OpenGL/Volume.js
function vtkOpenGLVolume(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLVolume");
  publicAPI.buildPass = (prepass) => {
    if (!model.renderable || !model.renderable.getVisibility()) {
      return;
    }
    if (prepass) {
      model._openGLRenderWindow = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderWindow");
      model._openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
      model.context = model._openGLRenderWindow.getContext();
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.renderable.getMapper());
      publicAPI.removeUnusedNodes();
    }
  };
  publicAPI.queryPass = (prepass, renderPass) => {
    if (prepass) {
      if (!model.renderable || !model.renderable.getVisibility()) {
        return;
      }
      renderPass.incrementVolumeCount();
    }
  };
  publicAPI.traverseVolumePass = (renderPass) => {
    if (!model.renderable || !model.renderable.getNestedVisibility() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.children[0].traverse(renderPass);
    publicAPI.apply(renderPass, false);
  };
  publicAPI.volumePass = (prepass) => {
    if (!model.renderable || !model.renderable.getVisibility()) {
      return;
    }
    model.context.depthMask(!prepass);
  };
  publicAPI.getKeyMatrices = () => {
    if (model.renderable.getMTime() > model.keyMatrixTime.getMTime()) {
      model.renderable.computeMatrix();
      mat4_exports.copy(model.MCWCMatrix, model.renderable.getMatrix());
      mat4_exports.transpose(model.MCWCMatrix, model.MCWCMatrix);
      if (model.renderable.getIsIdentity()) {
        mat3_exports.identity(model.normalMatrix);
      } else {
        mat3_exports.fromMat4(model.normalMatrix, model.MCWCMatrix);
        mat3_exports.invert(model.normalMatrix, model.normalMatrix);
        mat3_exports.transpose(model.normalMatrix, model.normalMatrix);
      }
      model.keyMatrixTime.modified();
    }
    return {
      mcwc: model.MCWCMatrix,
      normalMatrix: model.normalMatrix
    };
  };
}
var DEFAULT_VALUES35 = {
  // context: null,
  // keyMatrixTime: null,
  // normalMatrix: null,
  // MCWCMatrix: null,
  // _openGLRenderWindow: null,
};
function extend36(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES35, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.keyMatrixTime = {};
  obj(model.keyMatrixTime, {
    mtime: 0
  });
  model.normalMatrix = new Float64Array(9);
  model.MCWCMatrix = new Float64Array(16);
  setGet(publicAPI, model, ["context"]);
  vtkOpenGLVolume(publicAPI, model);
}
var newInstance37 = newInstance(extend36, "vtkOpenGLVolume");
registerOverride("vtkVolume", newInstance37);

// node_modules/@kitware/vtk.js/Rendering/OpenGL/VolumeMapper.js
var import_fast_deep_equal2 = __toESM(require_fast_deep_equal());

// node_modules/@kitware/vtk.js/Rendering/OpenGL/Framebuffer.js
function vtkFramebuffer(publicAPI, model) {
  model.classHierarchy.push("vtkFramebuffer");
  publicAPI.getBothMode = () => model.context.FRAMEBUFFER;
  publicAPI.saveCurrentBindingsAndBuffers = (modeIn) => {
    const mode = typeof modeIn !== "undefined" ? modeIn : publicAPI.getBothMode();
    publicAPI.saveCurrentBindings(mode);
    publicAPI.saveCurrentBuffers(mode);
  };
  publicAPI.saveCurrentBindings = (modeIn) => {
    if (!model.context) {
      vtkErrorMacro2("you must set the OpenGLRenderWindow before calling saveCurrentBindings");
      return;
    }
    const gl = model.context;
    model.previousDrawBinding = gl.getParameter(model.context.FRAMEBUFFER_BINDING);
    model.previousActiveFramebuffer = model._openGLRenderWindow.getActiveFramebuffer();
  };
  publicAPI.saveCurrentBuffers = (modeIn) => {
  };
  publicAPI.restorePreviousBindingsAndBuffers = (modeIn) => {
    const mode = typeof modeIn !== "undefined" ? modeIn : publicAPI.getBothMode();
    publicAPI.restorePreviousBindings(mode);
    publicAPI.restorePreviousBuffers(mode);
  };
  publicAPI.restorePreviousBindings = (modeIn) => {
    if (!model.context) {
      vtkErrorMacro2("you must set the OpenGLRenderWindow before calling restorePreviousBindings");
      return;
    }
    const gl = model.context;
    gl.bindFramebuffer(gl.FRAMEBUFFER, model.previousDrawBinding);
    model._openGLRenderWindow.setActiveFramebuffer(model.previousActiveFramebuffer);
  };
  publicAPI.restorePreviousBuffers = (modeIn) => {
  };
  publicAPI.bind = function() {
    let modeArg = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    let mode = modeArg;
    if (mode === null) {
      mode = model.context.FRAMEBUFFER;
    }
    model.context.bindFramebuffer(mode, model.glFramebuffer);
    for (let i6 = 0; i6 < model.colorBuffers.length; i6++) {
      model.colorBuffers[i6].bind();
    }
    model._openGLRenderWindow.setActiveFramebuffer(publicAPI);
  };
  publicAPI.create = (width, height) => {
    if (!model.context) {
      vtkErrorMacro2("you must set the OpenGLRenderWindow before calling create");
      return;
    }
    model.glFramebuffer = model.context.createFramebuffer();
    model.glFramebuffer.width = width;
    model.glFramebuffer.height = height;
  };
  publicAPI.setColorBuffer = function(texture) {
    let attachment = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    const gl = model.context;
    if (!gl) {
      vtkErrorMacro2("you must set the OpenGLRenderWindow before calling setColorBuffer");
      return;
    }
    let glAttachment = gl.COLOR_ATTACHMENT0;
    if (attachment > 0) {
      if (model._openGLRenderWindow.getWebgl2()) {
        glAttachment += attachment;
      } else {
        vtkErrorMacro2("Using multiple framebuffer attachments requires WebGL 2");
        return;
      }
    }
    model.colorBuffers[attachment] = texture;
    gl.framebufferTexture2D(gl.FRAMEBUFFER, glAttachment, gl.TEXTURE_2D, texture.getHandle(), 0);
  };
  publicAPI.removeColorBuffer = function() {
    let attachment = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    const gl = model.context;
    if (!gl) {
      vtkErrorMacro2("you must set the OpenGLRenderWindow before calling removeColorBuffer");
      return;
    }
    let glAttachment = gl.COLOR_ATTACHMENT0;
    if (attachment > 0) {
      if (model._openGLRenderWindow.getWebgl2()) {
        glAttachment += attachment;
      } else {
        vtkErrorMacro2("Using multiple framebuffer attachments requires WebGL 2");
        return;
      }
    }
    gl.framebufferTexture2D(gl.FRAMEBUFFER, glAttachment, gl.TEXTURE_2D, null, 0);
    model.colorBuffers = model.colorBuffers.splice(attachment, 1);
  };
  publicAPI.setDepthBuffer = (texture) => {
    if (!model.context) {
      vtkErrorMacro2("you must set the OpenGLRenderWindow before calling setDepthBuffer");
      return;
    }
    if (model._openGLRenderWindow.getWebgl2()) {
      const gl = model.context;
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, texture.getHandle(), 0);
    } else {
      vtkErrorMacro2("Attaching depth buffer textures to fbo requires WebGL 2");
    }
  };
  publicAPI.removeDepthBuffer = () => {
    if (!model.context) {
      vtkErrorMacro2("you must set the OpenGLRenderWindow before calling removeDepthBuffer");
      return;
    }
    if (model._openGLRenderWindow.getWebgl2()) {
      const gl = model.context;
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, null, 0);
    } else {
      vtkErrorMacro2("Attaching depth buffer textures to framebuffers requires WebGL 2");
    }
  };
  publicAPI.getGLFramebuffer = () => model.glFramebuffer;
  publicAPI.setOpenGLRenderWindow = (rw) => {
    if (model._openGLRenderWindow === rw) {
      return;
    }
    publicAPI.releaseGraphicsResources();
    model._openGLRenderWindow = rw;
    model.context = null;
    if (rw) {
      model.context = model._openGLRenderWindow.getContext();
    }
  };
  publicAPI.releaseGraphicsResources = () => {
    if (model.glFramebuffer) {
      model.context.deleteFramebuffer(model.glFramebuffer);
    }
  };
  publicAPI.getSize = () => {
    if (model.glFramebuffer == null) return null;
    return [model.glFramebuffer.width, model.glFramebuffer.height];
  };
  publicAPI.populateFramebuffer = () => {
    if (!model.context) {
      vtkErrorMacro2("you must set the OpenGLRenderWindow before calling populateFrameBuffer");
      return;
    }
    publicAPI.bind();
    const gl = model.context;
    const texture = vtkOpenGLTexture$1.newInstance();
    texture.setOpenGLRenderWindow(model._openGLRenderWindow);
    texture.setMinificationFilter(Filter.LINEAR);
    texture.setMagnificationFilter(Filter.LINEAR);
    texture.create2DFromRaw(model.glFramebuffer.width, model.glFramebuffer.height, 4, VtkDataTypes.UNSIGNED_CHAR, null);
    publicAPI.setColorBuffer(texture);
    model.depthTexture = gl.createRenderbuffer();
    gl.bindRenderbuffer(gl.RENDERBUFFER, model.depthTexture);
    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, model.glFramebuffer.width, model.glFramebuffer.height);
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, model.depthTexture);
  };
  publicAPI.getColorTexture = () => model.colorBuffers[0];
}
var DEFAULT_VALUES36 = {
  // _openGLRenderWindow: null,
  glFramebuffer: null,
  colorBuffers: null,
  depthTexture: null,
  previousDrawBinding: 0,
  previousReadBinding: 0,
  previousDrawBuffer: 0,
  previousReadBuffer: 0,
  previousActiveFramebuffer: null
};
function extend37(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES36, initialValues);
  obj(publicAPI, model);
  if (model.colorBuffers) {
    vtkErrorMacro2("you cannot initialize colorBuffers through the constructor. You should call setColorBuffer() instead.");
  }
  model.colorBuffers = [];
  getArray(publicAPI, model, ["colorBuffers"]);
  vtkFramebuffer(publicAPI, model);
}
var newInstance38 = newInstance(extend37, "vtkFramebuffer");
var vtkOpenGLFramebuffer = {
  newInstance: newInstance38,
  extend: extend37
};

// node_modules/@kitware/vtk.js/Rendering/Core/VolumeProperty/Constants.js
var InterpolationType2 = {
  NEAREST: 0,
  LINEAR: 1,
  FAST_LINEAR: 2
};
var OpacityMode = {
  FRACTIONAL: 0,
  PROPORTIONAL: 1
};
var ColorMixPreset = {
  CUSTOM: 0,
  ADDITIVE: 1,
  COLORIZE: 2
};

// node_modules/@kitware/vtk.js/Rendering/Core/VolumeMapper/Constants.js
var BlendMode = {
  COMPOSITE_BLEND: 0,
  MAXIMUM_INTENSITY_BLEND: 1,
  MINIMUM_INTENSITY_BLEND: 2,
  AVERAGE_INTENSITY_BLEND: 3,
  ADDITIVE_INTENSITY_BLEND: 4,
  RADON_TRANSFORM_BLEND: 5
};

// node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkVolumeVS.glsl.js
var vtkVolumeVS = "//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyDataVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nattribute vec4 vertexDC;\n\nvarying vec3 vertexVCVSOutput;\nuniform mat4 PCVCMatrix;\n\nuniform float dcxmin;\nuniform float dcxmax;\nuniform float dcymin;\nuniform float dcymax;\n\nvoid main()\n{\n  // dcsmall is the device coords reduced to the\n  // x y area covered by the volume\n  vec4 dcsmall = vec4(\n    dcxmin + 0.5 * (vertexDC.x + 1.0) * (dcxmax - dcxmin),\n    dcymin + 0.5 * (vertexDC.y + 1.0) * (dcymax - dcymin),\n    vertexDC.z,\n    vertexDC.w);\n  vec4 vcpos = PCVCMatrix * dcsmall;\n  vertexVCVSOutput = vcpos.xyz/vcpos.w;\n  gl_Position = dcsmall;\n}\n";

// node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkVolumeFS.glsl.js
var vtkVolumeFS = `//VTK::System::Dec

/*=========================================================================

  Program:   Visualization Toolkit
  Module:    vtkVolumeFS.glsl

  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen
  All rights reserved.
  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.

     This software is distributed WITHOUT ANY WARRANTY; without even
     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
     PURPOSE.  See the above copyright notice for more information.

=========================================================================*/
// Template for the volume mappers fragment shader

// the output of this shader
//VTK::Output::Dec

varying vec3 vertexVCVSOutput;

// first declare the settings from the mapper
// that impact the code paths in here

// always set vtkNumComponents 1,2,3,4
//VTK::NumComponents

// possibly define vtkTrilinearOn
//VTK::TrilinearOn

// possibly define UseIndependentComponents
//VTK::IndependentComponentsOn

// possibly define vtkCustomComponentsColorMix
//VTK::CustomComponentsColorMixOn

// possibly define any "proportional" components
//VTK::vtkProportionalComponents

// possibly define any components that are forced to nearest interpolation
//VTK::vtkForceNearestComponents

// Define the blend mode to use
#define vtkBlendMode //VTK::BlendMode

// Possibly define vtkImageLabelOutlineOn
//VTK::ImageLabelOutlineOn

#ifdef vtkImageLabelOutlineOn

uniform float outlineOpacity;
uniform float vpWidth;
uniform float vpHeight;
uniform float vpOffsetX;
uniform float vpOffsetY;
uniform mat4 PCWCMatrix;
uniform mat4 vWCtoIDX;
#endif

// define vtkLightComplexity
//VTK::LightComplexity
#if vtkLightComplexity > 0
uniform float vSpecularPower;
uniform float vAmbient;
uniform float vDiffuse;
uniform float vSpecular;
//VTK::Light::Dec
#endif

//VTK::VolumeShadowOn
//VTK::SurfaceShadowOn
//VTK::localAmbientOcclusionOn
//VTK::LAO::Dec
//VTK::VolumeShadow::Dec

// define vtkComputeNormalFromOpacity
//VTK::vtkComputeNormalFromOpacity

// possibly define vtkGradientOpacityOn
//VTK::GradientOpacityOn
#ifdef vtkGradientOpacityOn
uniform float goscale0;
uniform float goshift0;
uniform float gomin0;
uniform float gomax0;
#ifdef UseIndependentComponents
#if vtkNumComponents > 1
uniform float goscale1;
uniform float goshift1;
uniform float gomin1;
uniform float gomax1;
#if vtkNumComponents > 2
uniform float goscale2;
uniform float goshift2;
uniform float gomin2;
uniform float gomax2;
#if vtkNumComponents > 3
uniform float goscale3;
uniform float goshift3;
uniform float gomin3;
uniform float gomax3;
#endif
#endif
#endif
#endif
#endif

// if you want to see the raw tiled
// data in webgl1 uncomment the following line
// #define debugtile

// camera values
uniform float camThick;
uniform float camNear;
uniform float camFar;
uniform int cameraParallel;

// values describing the volume geometry
uniform vec3 vOriginVC;
uniform vec3 vSpacing;
uniform ivec3 volumeDimensions; // 3d texture dimensions
uniform vec3 vPlaneNormal0;
uniform float vPlaneDistance0;
uniform vec3 vPlaneNormal1;
uniform float vPlaneDistance1;
uniform vec3 vPlaneNormal2;
uniform float vPlaneDistance2;
uniform vec3 vPlaneNormal3;
uniform float vPlaneDistance3;
uniform vec3 vPlaneNormal4;
uniform float vPlaneDistance4;
uniform vec3 vPlaneNormal5;
uniform float vPlaneDistance5;

//VTK::ClipPlane::Dec

// opacity and color textures
uniform sampler2D otexture;
uniform float oshift0;
uniform float oscale0;
uniform sampler2D ctexture;
uniform float cshift0;
uniform float cscale0;

#if vtkNumComponents >= 2
uniform float oshift1;
uniform float oscale1;
uniform float cshift1;
uniform float cscale1;
#endif
#if vtkNumComponents >= 3
uniform float oshift2;
uniform float oscale2;
uniform float cshift2;
uniform float cscale2;
#endif
#if vtkNumComponents >= 4
uniform float oshift3;
uniform float oscale3;
uniform float cshift3;
uniform float cscale3;
#endif

// jitter texture
uniform sampler2D jtexture;
uniform sampler2D ttexture;


// some 3D texture values
uniform float sampleDistance;
uniform vec3 vVCToIJK;

// the heights defined below are the locations
// for the up to four components of the tfuns
// the tfuns have a height of 2XnumComps pixels so the
// values are computed to hit the middle of the two rows
// for that component
#ifdef UseIndependentComponents
#if vtkNumComponents == 1
uniform float mix0;
#define height0 0.5
#endif
#if vtkNumComponents == 2
uniform float mix0;
uniform float mix1;
#define height0 0.25
#define height1 0.75
#endif
#if vtkNumComponents == 3
uniform float mix0;
uniform float mix1;
uniform float mix2;
#define height0 0.17
#define height1 0.5
#define height2 0.83
#endif
#if vtkNumComponents == 4
uniform float mix0;
uniform float mix1;
uniform float mix2;
uniform float mix3;
#define height0 0.125
#define height1 0.375
#define height2 0.625
#define height3 0.875
#endif
#endif

uniform vec4 ipScalarRangeMin;
uniform vec4 ipScalarRangeMax;

// declaration for intermixed geometry
//VTK::ZBuffer::Dec

//=======================================================================
// global and custom variables (a temporary section before photorealistics rendering module is complete)
vec3 rayDirVC;
float sampleDistanceISVS;
float sampleDistanceIS;

#define SQRT3    1.7321
#define INV4PI   0.0796
#define EPSILON  0.001
#define PI       3.1415
#define PI2      9.8696

//=======================================================================
// Webgl2 specific version of functions
#if __VERSION__ == 300

uniform highp sampler3D texture1;

vec4 getTextureValue(vec3 pos)
{
  vec4 tmp = texture(texture1, pos);

  #if defined(vtkComponent0ForceNearest) || \\
      defined(vtkComponent1ForceNearest) || \\
      defined(vtkComponent2ForceNearest) || \\
      defined(vtkComponent3ForceNearest)
    vec3 nearestPos = (floor(pos * vec3(volumeDimensions)) + 0.5) / vec3(volumeDimensions);
    vec4 nearestValue = texture(texture1, nearestPos);
    #ifdef vtkComponent0ForceNearest
      tmp[0] = nearestValue[0];
    #endif
    #ifdef vtkComponent1ForceNearest
      tmp[1] = nearestValue[1];
    #endif
    #ifdef vtkComponent2ForceNearest
      tmp[2] = nearestValue[2];
    #endif
    #ifdef vtkComponent3ForceNearest
      tmp[3] = nearestValue[3];
    #endif
  #endif

  #ifndef UseIndependentComponents
    #if vtkNumComponents == 1
      tmp.a = tmp.r;
    #endif
    #if vtkNumComponents == 2
      tmp.a = tmp.g;
    #endif
    #if vtkNumComponents == 3
      tmp.a = length(tmp.rgb);
    #endif
  #endif

  return tmp;
}

//=======================================================================
// WebGL1 specific version of functions
#else

uniform sampler2D texture1;

uniform float texWidth;
uniform float texHeight;
uniform int xreps;
uniform int xstride;
uniform int ystride;

// if computing trilinear values from multiple z slices
#ifdef vtkTrilinearOn
vec4 getTextureValue(vec3 ijk)
{
  float zoff = 1.0/float(volumeDimensions.z);
  vec4 val1 = getOneTextureValue(ijk);
  vec4 val2 = getOneTextureValue(vec3(ijk.xy, ijk.z + zoff));

  float indexZ = float(volumeDimensions)*ijk.z;
  float zmix =  indexZ - floor(indexZ);

  return mix(val1, val2, zmix);
}

vec4 getOneTextureValue(vec3 ijk)
#else // nearest or fast linear
vec4 getTextureValue(vec3 ijk)
#endif
{
  vec3 tdims = vec3(volumeDimensions);

#ifdef debugtile
  vec2 tpos = vec2(ijk.x, ijk.y);
  vec4 tmp = texture2D(texture1, tpos);
  tmp.a = 1.0;

#else
  int z = int(ijk.z * tdims.z);
  int yz = z / xreps;
  int xz = z - yz*xreps;

  int tileWidth = volumeDimensions.x/xstride;
  int tileHeight = volumeDimensions.y/ystride;

  xz *= tileWidth;
  yz *= tileHeight;

  float ni = float(xz) + (ijk.x*float(tileWidth));
  float nj = float(yz) + (ijk.y*float(tileHeight));

  vec2 tpos = vec2(ni/texWidth, nj/texHeight);

  vec4 tmp = texture2D(texture1, tpos);

#if vtkNumComponents == 1
  tmp.a = tmp.r;
#endif
#if vtkNumComponents == 2
  tmp.g = tmp.a;
#endif
#if vtkNumComponents == 3
  tmp.a = length(tmp.rgb);
#endif
#endif

  return tmp;
}

// End of Webgl1 specific code
//=======================================================================
#endif

//=======================================================================
// transformation between VC and IS space

// convert vector position from idx to vc
#if (vtkLightComplexity > 0) || (defined vtkClippingPlanesOn)
vec3 IStoVC(vec3 posIS){
  vec3 posVC = posIS / vVCToIJK;
  return posVC.x * vPlaneNormal0 +
         posVC.y * vPlaneNormal2 +
         posVC.z * vPlaneNormal4 +
         vOriginVC;
}

// convert vector position from vc to idx
vec3 VCtoIS(vec3 posVC){
  posVC = posVC - vOriginVC;
  posVC = vec3(
    dot(posVC, vPlaneNormal0),
    dot(posVC, vPlaneNormal2),
    dot(posVC, vPlaneNormal4));
  return posVC * vVCToIJK;
}
#endif

//Rotate vector to view coordinate
#if (vtkLightComplexity > 0) || (defined vtkGradientOpacityOn)
void rotateToViewCoord(inout vec3 dirIS){
  dirIS.xyz =
    dirIS.x * vPlaneNormal0 +
    dirIS.y * vPlaneNormal2 +
    dirIS.z * vPlaneNormal4;
}

//Rotate vector to idx coordinate
vec3 rotateToIDX(vec3 dirVC){
  vec3 dirIS;
  dirIS.xyz = vec3(
    dot(dirVC, vPlaneNormal0),
    dot(dirVC, vPlaneNormal2),
    dot(dirVC, vPlaneNormal4));
  return dirIS;
}
#endif

//=======================================================================
// Given a normal compute the gradient opacity factors
float computeGradientOpacityFactor(
  float normalMag, float goscale, float goshift, float gomin, float gomax)
{
  return clamp(normalMag * goscale + goshift, gomin, gomax);
}

//=======================================================================
// compute the normal and gradient magnitude for a position, uses forward difference
#if (vtkLightComplexity > 0) || (defined vtkGradientOpacityOn)
  #ifdef vtkClippingPlanesOn
    void adjustClippedVoxelValues(vec3 pos, vec3 texPos[3], inout vec3 g1)
    {
      vec3 g1VC[3];
      for (int i = 0; i < 3; ++i)
      {
        g1VC[i] = IStoVC(texPos[i]);
      }
      vec3 posVC = IStoVC(pos);
      for (int i = 0; i < clip_numPlanes; ++i)
      {
        for (int j = 0; j < 3; ++j)
        {
          if(dot(vec3(vClipPlaneOrigins[i] - g1VC[j].xyz), vClipPlaneNormals[i]) > 0.0)
          {
            g1[j] = 0.0;
          }
        }
      }
    }
  #endif

  #ifdef vtkComputeNormalFromOpacity
    vec4 computeDensityNormal(vec3 opacityUCoords[2], float opactityTextureHeight, float gradientOpacity) {
      vec3 opacityG1, opacityG2;
      opacityG1.x = texture2D(otexture, vec2(opacityUCoords[0].x, opactityTextureHeight)).r;
      opacityG1.y = texture2D(otexture, vec2(opacityUCoords[0].y, opactityTextureHeight)).r;
      opacityG1.z = texture2D(otexture, vec2(opacityUCoords[0].z, opactityTextureHeight)).r;
      opacityG2.x = texture2D(otexture, vec2(opacityUCoords[1].x, opactityTextureHeight)).r;
      opacityG2.y = texture2D(otexture, vec2(opacityUCoords[1].y, opactityTextureHeight)).r;
      opacityG2.z = texture2D(otexture, vec2(opacityUCoords[1].z, opactityTextureHeight)).r;
      opacityG1.xyz *= gradientOpacity;
      opacityG2.xyz *= gradientOpacity;

      vec4 opacityG = vec4(opacityG1 - opacityG2, 1.0f);
      // divide by spacing
      opacityG.xyz /= vSpacing;
      opacityG.w = length(opacityG.xyz);
      // rotate to View Coords
      rotateToViewCoord(opacityG.xyz);
      if (!all(equal(opacityG.xyz, vec3(0.0)))) {
        return vec4(normalize(opacityG.xyz),opacityG.w);
      } else {
        return vec4(0.0);
      }
    }

    vec4 computeNormalForDensity(vec3 pos, vec3 tstep, out vec3 scalarInterp[2], const int opacityComponent)
    {
      vec3 xvec = vec3(tstep.x, 0.0, 0.0);
      vec3 yvec = vec3(0.0, tstep.y, 0.0);
      vec3 zvec = vec3(0.0, 0.0, tstep.z);
      vec3 texPosPVec[3];
      texPosPVec[0] = pos + xvec;
      texPosPVec[1] = pos + yvec;
      texPosPVec[2] = pos + zvec;
      vec3 texPosNVec[3];
      texPosNVec[0] = pos - xvec;
      texPosNVec[1] = pos - yvec;
      texPosNVec[2] = pos - zvec;
      vec3 g1, g2;

      scalarInterp[0].x = getTextureValue(texPosPVec[0])[opacityComponent];
      scalarInterp[0].y = getTextureValue(texPosPVec[1])[opacityComponent];
      scalarInterp[0].z = getTextureValue(texPosPVec[2])[opacityComponent];
      scalarInterp[1].x = getTextureValue(texPosNVec[0])[opacityComponent];
      scalarInterp[1].y = getTextureValue(texPosNVec[1])[opacityComponent];
      scalarInterp[1].z = getTextureValue(texPosNVec[2])[opacityComponent];

      #ifdef vtkClippingPlanesOn
        adjustClippedVoxelValues(pos, texPosPVec, scalarInterp[0]);
        adjustClippedVoxelValues(pos, texPosNVec, scalarInterp[1]);
      #endif
      vec4 result;
      result.x = scalarInterp[0].x - scalarInterp[1].x;
      result.y = scalarInterp[0].y - scalarInterp[1].y;
      result.z = scalarInterp[0].z - scalarInterp[1].z;
      // divide by spacing
      result.xyz /= vSpacing;
      result.w = length(result.xyz);
      // rotate to View Coords
      rotateToViewCoord(result.xyz);
      if (length(result.xyz) > 0.0) {
        return vec4(normalize(result.xyz),result.w);
      } else {
        return vec4(0.0);
      }
    }
  #endif

  // only works with dependent components
  vec4 computeNormal(vec3 pos, vec3 tstep)
  {
    vec3 xvec = vec3(tstep.x, 0.0, 0.0);
    vec3 yvec = vec3(0.0, tstep.y, 0.0);
    vec3 zvec = vec3(0.0, 0.0, tstep.z);
    vec3 texPosPVec[3];
    texPosPVec[0] = pos + xvec;
    texPosPVec[1] = pos + yvec;
    texPosPVec[2] = pos + zvec;
    vec3 texPosNVec[3];
    texPosNVec[0] = pos - xvec;
    texPosNVec[1] = pos - yvec;
    texPosNVec[2] = pos - zvec;
    vec3 g1, g2;
    g1.x = getTextureValue(texPosPVec[0]).a;
    g1.y = getTextureValue(texPosPVec[1]).a;
    g1.z = getTextureValue(texPosPVec[2]).a;
    g2.x = getTextureValue(texPosNVec[0]).a;
    g2.y = getTextureValue(texPosNVec[1]).a;
    g2.z = getTextureValue(texPosNVec[2]).a;
    #ifdef vtkClippingPlanesOn
      adjustClippedVoxelValues(pos, texPosPVec, g1);
      adjustClippedVoxelValues(pos, texPosNVec, g2);
    #endif
    vec4 result;
    result = vec4(g1 - g2, -1.0);
    // divide by spacing
    result.xyz /= vSpacing;
    result.w = length(result.xyz);
    if (result.w > 0.0){
      // rotate to View Coords
      rotateToViewCoord(result.xyz);
      return vec4(normalize(result.xyz),result.w);
    } else {
      return vec4(0.0);
    }
  }
#endif

#ifdef vtkImageLabelOutlineOn
vec3 fragCoordToIndexSpace(vec4 fragCoord) {
  vec4 pcPos = vec4(
    (fragCoord.x / vpWidth - vpOffsetX - 0.5) * 2.0,
    (fragCoord.y / vpHeight - vpOffsetY - 0.5) * 2.0,
    (fragCoord.z - 0.5) * 2.0,
    1.0);

  vec4 worldCoord = PCWCMatrix * pcPos;
  vec4 vertex = (worldCoord/worldCoord.w);

  vec3 index = (vWCtoIDX * vertex).xyz;

  // half voxel fix for labelmapOutline
  return (index + vec3(0.5)) / vec3(volumeDimensions);
}
#endif

//=======================================================================
// compute the normals and gradient magnitudes for a position
// for independent components
mat4 computeMat4Normal(vec3 pos, vec4 tValue, vec3 tstep)
{
  mat4 result;
  vec4 distX = getTextureValue(pos + vec3(tstep.x, 0.0, 0.0)) - tValue;
  vec4 distY = getTextureValue(pos + vec3(0.0, tstep.y, 0.0)) - tValue;
  vec4 distZ = getTextureValue(pos + vec3(0.0, 0.0, tstep.z)) - tValue;

  // divide by spacing
  distX /= vSpacing.x;
  distY /= vSpacing.y;
  distZ /= vSpacing.z;

  mat3 rot;
  rot[0] = vPlaneNormal0;
  rot[1] = vPlaneNormal2;
  rot[2] = vPlaneNormal4;

#if !defined(vtkComponent0Proportional)
  result[0].xyz = vec3(distX.r, distY.r, distZ.r);
  result[0].a = length(result[0].xyz);
  result[0].xyz *= rot;
  if (result[0].w > 0.0)
  {
    result[0].xyz /= result[0].w;
  }
#endif

// optionally compute the 2nd component
#if vtkNumComponents >= 2 && !defined(vtkComponent1Proportional)
  result[1].xyz = vec3(distX.g, distY.g, distZ.g);
  result[1].a = length(result[1].xyz);
  result[1].xyz *= rot;
  if (result[1].w > 0.0)
  {
    result[1].xyz /= result[1].w;
  }
#endif

// optionally compute the 3rd component
#if vtkNumComponents >= 3 && !defined(vtkComponent2Proportional)
  result[2].xyz = vec3(distX.b, distY.b, distZ.b);
  result[2].a = length(result[2].xyz);
  result[2].xyz *= rot;
  if (result[2].w > 0.0)
  {
    result[2].xyz /= result[2].w;
  }
#endif

// optionally compute the 4th component
#if vtkNumComponents >= 4 && !defined(vtkComponent3Proportional)
  result[3].xyz = vec3(distX.a, distY.a, distZ.a);
  result[3].a = length(result[3].xyz);
  result[3].xyz *= rot;
  if (result[3].w > 0.0)
  {
    result[3].xyz /= result[3].w;
  }
#endif

  return result;
}

//=======================================================================
// global shadow - secondary ray
#if defined(VolumeShadowOn) || defined(localAmbientOcclusionOn)
float random()
{
  float rand = fract(sin(dot(gl_FragCoord.xy,vec2(12.9898,78.233)))*43758.5453123);
  float jitter=texture2D(jtexture,gl_FragCoord.xy/32.).r;
  uint pcg_state = floatBitsToUint(jitter);
  uint state = pcg_state;
  pcg_state = pcg_state * uint(747796405) + uint(2891336453);
  uint word = ((state >> ((state >> uint(28)) + uint(4))) ^ state) * uint(277803737);
  return (float((((word >> uint(22)) ^ word) >> 1 ))/float(2147483647) + rand)/2.0;
}
#endif

#ifdef VolumeShadowOn
// henyey greenstein phase function
float phase_function(float cos_angle)
{
  // divide by 2.0 instead of 4pi to increase intensity
  return ((1.0-anisotropy2)/pow(1.0+anisotropy2-2.0*anisotropy*cos_angle, 1.5))/2.0;
}

// Computes the intersection between a ray and a box
struct Hit
{
  float tmin;
  float tmax;
};

struct Ray
{
  vec3 origin;
  vec3 dir;
  vec3 invDir;
};

bool BBoxIntersect(vec3 boundMin, vec3 boundMax, const Ray r, out Hit hit)
{
  vec3 tbot = r.invDir * (boundMin - r.origin);
  vec3 ttop = r.invDir * (boundMax - r.origin);
  vec3 tmin = min(ttop, tbot);
  vec3 tmax = max(ttop, tbot);
  vec2 t = max(tmin.xx, tmin.yz);
  float t0 = max(t.x, t.y);
  t = min(tmax.xx, tmax.yz);
  float t1 = min(t.x, t.y);
  hit.tmin = t0;
  hit.tmax = t1;
  return t1 > max(t0,0.0);
}

// As BBoxIntersect requires the inverse of the ray coords,
// this function is used to avoid numerical issues
void safe_0_vector(inout Ray ray)
{
  if(abs(ray.dir.x) < EPSILON) ray.dir.x = sign(ray.dir.x) * EPSILON;
  if(abs(ray.dir.y) < EPSILON) ray.dir.y = sign(ray.dir.y) * EPSILON;
  if(abs(ray.dir.z) < EPSILON) ray.dir.z = sign(ray.dir.z) * EPSILON;
}

float volume_shadow(vec3 posIS, vec3 lightDirNormIS)
{
  float shadow = 1.0;
  float opacity = 0.0;

  // modify sample distance with a random number between 1.5 and 3.0
  float sampleDistanceISVS_jitter = sampleDistanceISVS * mix(1.5, 3.0, random());
  float opacityPrev = texture2D(otexture, vec2(getTextureValue(posIS).r * oscale0 + oshift0, 0.5)).r;

  // in case the first sample near surface has a very tiled light ray, we need to offset start position
  posIS += sampleDistanceISVS_jitter * lightDirNormIS;

  // compute the start and end points for the ray
  Ray ray;
  Hit hit;
  ray.origin = posIS;
  ray.dir = lightDirNormIS;
  safe_0_vector(ray);
  ray.invDir = 1.0/ray.dir;

  if(!BBoxIntersect(vec3(0.0),vec3(1.0), ray, hit))
  {
    return 1.0;
  }
  float maxdist = hit.tmax;

  // interpolate shadow ray length between: 1 unit of sample distance in IS to SQRT3, based on globalIlluminationReach
  float maxgi = mix(sampleDistanceISVS_jitter,SQRT3,giReach);
  maxdist = min(maxdist,maxgi);
  if(maxdist < EPSILON) {
    return 1.0;
  }

  float current_dist = 0.0;
  float current_step = length(sampleDistanceISVS_jitter * lightDirNormIS);
  float clamped_step = 0.0;

  vec4 scalar = vec4(0.0);
  while(current_dist < maxdist)
  {
#ifdef vtkClippingPlanesOn
    vec3 posVC = IStoVC(posIS);
    for (int i = 0; i < clip_numPlanes; ++i)
    {
      if (dot(vec3(vClipPlaneOrigins[i] - posVC), vClipPlaneNormals[i]) > 0.0)
      {
        current_dist = maxdist;
      }
    }
#endif
    scalar = getTextureValue(posIS);
    opacity = texture2D(otexture, vec2(scalar.r * oscale0 + oshift0, 0.5)).r;
    #if defined(vtkGradientOpacityOn) && !defined(UseIndependentComponents)
      vec4 normal = computeNormal(posIS, vec3(1.0/vec3(volumeDimensions)));
      opacity *= computeGradientOpacityFactor(normal.w, goscale0, goshift0, gomin0, gomax0);
    #endif
    shadow *= 1.0 - opacity;

    // optimization: early termination
    if (shadow < EPSILON){
      return 0.0;
    }

    clamped_step = min(maxdist - current_dist, current_step);
    posIS += clamped_step * lightDirNormIS;
    current_dist += current_step;
  }

  return shadow;
}

vec3 applyShadowRay(vec3 tColor, vec3 posIS, vec3 viewDirectionVC)
{
  vec3 vertLight = vec3(0.0);
  vec3 secondary_contrib = vec3(0.0);
  // here we assume only positional light, no effect of cones
  for (int i = 0; i < lightNum; i++)
  {
    #if(vtkLightComplexity==3)
      if (lightPositional[i] == 1){
        vertLight = lightPositionVC[i] - IStoVC(posIS);
      }else{
        vertLight = - lightDirectionVC[i];
      }
    #else
      vertLight = - lightDirectionVC[i];
    #endif
    // here we assume achromatic light, only intensity
    float dDotL = dot(viewDirectionVC, normalize(vertLight));
    // isotropic scatter returns 0.5 instead of 1/4pi to increase intensity
    float phase_attenuation = 0.5;
    if (abs(anisotropy) > EPSILON){
      phase_attenuation = phase_function(dDotL);
    }
    float vol_shadow = volume_shadow(posIS, normalize(rotateToIDX(vertLight)));
    secondary_contrib += tColor * vDiffuse * lightColor[i] * vol_shadow * phase_attenuation;
    secondary_contrib += tColor * vAmbient;
  }
  return secondary_contrib;
}
#endif

//=======================================================================
// local ambient occlusion
#ifdef localAmbientOcclusionOn
vec3 sample_direction_uniform(int i)
{
  float rand = random() * 0.5;
  float theta = PI2 * (kernelSample[i][0] + rand);
  float phi = acos(2.0 * (kernelSample[i][1] + rand) -1.0) / 2.5;
  return normalize(vec3(cos(theta)*sin(phi), sin(theta)*sin(phi), cos(phi)));
}

// return a matrix that transform startDir into z axis; startDir should be normalized
mat3 zBaseRotationalMatrix(vec3 startDir){
  vec3 axis = cross(startDir, vec3(0.0,0.0,1.0));
  float cosA = startDir.z;
  float k = 1.0 / (1.0 + cosA);
  mat3 matrix = mat3((axis.x * axis.x * k) + cosA, (axis.y * axis.x * k) - axis.z, (axis.z * axis.x * k) + axis.y,
              (axis.x * axis.y * k) + axis.z, (axis.y * axis.y * k) + cosA, (axis.z * axis.y * k) - axis.x,
              (axis.x * axis.z * k) - axis.y, (axis.y * axis.z * k) + axis.x, (axis.z * axis.z * k) + cosA);
  return matrix;
}

float computeLAO(vec3 posIS, float op, vec3 lightDir, vec4 normal){
  // apply LAO only at selected locations, otherwise return full brightness
  if (normal.w > 0.0 && op > 0.05){
    float total_transmittance = 0.0;
    mat3 inverseRotateBasis = inverse(zBaseRotationalMatrix(normalize(-normal.xyz)));
    vec3 currPos, randomDirStep;
    float weight, transmittance, opacity;
    for (int i = 0; i < kernelSize; i++)
    {
      randomDirStep = inverseRotateBasis * sample_direction_uniform(i) * sampleDistanceIS;
      weight = 1.0 - dot(normalize(lightDir), normalize(randomDirStep));
      currPos = posIS;
      transmittance = 1.0;
      for (int j = 0; j < kernelRadius ; j++){
        currPos += randomDirStep;
        // check if it's at clipping plane, if so return full brightness
        if (all(greaterThan(currPos, vec3(EPSILON))) && all(lessThan(currPos,vec3(1.0-EPSILON)))){
          opacity = texture2D(otexture, vec2(getTextureValue(currPos).r * oscale0 + oshift0, 0.5)).r;
          #ifdef vtkGradientOpacityOn
             opacity *= computeGradientOpacityFactor(normal.w, goscale0, goshift0, gomin0, gomax0);
          #endif
          transmittance *= 1.0 - opacity;
        }
        else{
          break;
        }
      }
      total_transmittance += transmittance / float(kernelRadius) * weight;

      // early termination if fully translucent
      if (total_transmittance > 1.0 - EPSILON){
        return 1.0;
      }
    }
    // average transmittance and reduce variance
    return clamp(total_transmittance / float(kernelSize), 0.3, 1.0);
  } else {
    return 1.0;
  }
}
#endif

//=======================================================================
// surface light contribution
#if vtkLightComplexity > 0
  void applyLighting(inout vec3 tColor, vec4 normal)
  {
    vec3 diffuse = vec3(0.0, 0.0, 0.0);
    vec3 specular = vec3(0.0, 0.0, 0.0);
    float df, sf = 0.0;
    for (int i = 0; i < lightNum; i++){
        df = abs(dot(normal.rgb, -lightDirectionVC[i]));
        diffuse += df * lightColor[i];
        sf = pow( abs(dot(lightHalfAngleVC[i],normal.rgb)), vSpecularPower);
        specular += sf * lightColor[i];
    }
    tColor.rgb = tColor.rgb*(diffuse*vDiffuse + vAmbient) + specular*vSpecular;
  }
  #ifdef SurfaceShadowOn
  #if vtkLightComplexity < 3
    vec3 applyLightingDirectional(vec3 posIS, vec4 tColor, vec4 normal)
    {
      // everything in VC
      vec3 diffuse = vec3(0.0);
      vec3 specular = vec3(0.0);
      #ifdef localAmbientOcclusionOn
        vec3 ambient = vec3(0.0);
      #endif
      vec3 vertLightDirection;
      for (int i = 0; i < lightNum; i++){
        float ndotL,vdotR;
        vertLightDirection = lightDirectionVC[i];
        ndotL = dot(normal.xyz, vertLightDirection);
        if (ndotL < 0.0 && twoSidedLighting)
        {
          ndotL = -ndotL;
        }
        if (ndotL > 0.0)
        {
          diffuse += ndotL * lightColor[i];
          //specular
          vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));
          if (vdotR > 0.0)
          {
            specular += pow(vdotR, vSpecularPower) * lightColor[i];
          }
        }
        #ifdef localAmbientOcclusionOn
            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);
        #endif
      }
      #ifdef localAmbientOcclusionOn
        return tColor.rgb * (diffuse * vDiffuse + vAmbient * ambient) + specular*vSpecular;
      #else
        return tColor.rgb * (diffuse * vDiffuse + vAmbient) + specular*vSpecular;
      #endif
    }
  #else
    vec3 applyLightingPositional(vec3 posIS, vec4 tColor, vec4 normal, vec3 posVC)
    {
      // everything in VC
      vec3 diffuse = vec3(0.0);
      vec3 specular = vec3(0.0);
      #ifdef localAmbientOcclusionOn
        vec3 ambient = vec3(0.0);
      #endif
      vec3 vertLightDirection;
      for (int i = 0; i < lightNum; i++){
        float distance,attenuation,ndotL,vdotR;
        vec3 lightDir;
        if (lightPositional[i] == 1){
          lightDir = lightDirectionVC[i];
          vertLightDirection = posVC - lightPositionVC[i];
          distance = length(vertLightDirection);
          vertLightDirection = normalize(vertLightDirection);
          attenuation = 1.0 / (lightAttenuation[i].x
                              + lightAttenuation[i].y * distance
                              + lightAttenuation[i].z * distance * distance);
          // per OpenGL standard cone angle is 90 or less for a spot light
          if (lightConeAngle[i] <= 90.0){
            float coneDot = dot(vertLightDirection, lightDir);
            if (coneDot >= cos(radians(lightConeAngle[i]))){  // if inside cone
              attenuation = attenuation * pow(coneDot, lightExponent[i]);
            }
            else {
              attenuation = 0.0;
            }
          }
          ndotL = dot(normal.xyz, vertLightDirection);
          if (ndotL < 0.0 && twoSidedLighting)
          {
            ndotL = -ndotL;
          }
          if (ndotL > 0.0)
          {
            diffuse += ndotL * attenuation * lightColor[i];
            //specular
            vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));
            if (vdotR > 0.0)
            {
              specular += pow(vdotR, vSpecularPower) * attenuation * lightColor[i];
            }
          }
          #ifdef localAmbientOcclusionOn
            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);
          #endif
        } else {
          vertLightDirection = lightDirectionVC[i];
          ndotL = dot(normal.xyz, vertLightDirection);
          if (ndotL < 0.0 && twoSidedLighting)
          {
            ndotL = -ndotL;
          }
          if (ndotL > 0.0)
          {
            diffuse += ndotL * lightColor[i];
            //specular
            vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));
            if (vdotR > 0.0)
            {
              specular += pow(vdotR, vSpecularPower) * lightColor[i];
            }
          }
          #ifdef localAmbientOcclusionOn
            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);
          #endif
        }
      }
      #ifdef localAmbientOcclusionOn
        return tColor.rgb * (diffuse * vDiffuse + vAmbient * ambient) + specular*vSpecular;
      #else
        return tColor.rgb * (diffuse * vDiffuse + vAmbient) + specular*vSpecular;
      #endif
    }
  #endif
  #endif
#endif

// LAO of surface shadows and volume shadows only work with dependent components
vec3 applyAllLightning(vec3 tColor, float alpha, vec3 posIS, vec4 normalLight) {
  #if vtkLightComplexity > 0
    // surface shadows if needed
    #ifdef SurfaceShadowOn
      #if vtkLightComplexity < 3
        vec3 tColorS = applyLightingDirectional(posIS, vec4(tColor, alpha), normalLight);
      #else
        vec3 tColorS = applyLightingPositional(posIS, vec4(tColor, alpha), normalLight, IStoVC(posIS));
      #endif
    #endif

    // volume shadows if needed
    #ifdef VolumeShadowOn
      vec3 tColorVS = applyShadowRay(tColor, posIS, rayDirVC);
    #endif

    // merge
    #ifdef VolumeShadowOn
      #ifdef SurfaceShadowOn
        // surface shadows + volumetric shadows
        float vol_coef = volumetricScatteringBlending * (1.0 - alpha / 2.0) * (1.0 - atan(normalLight.w) * INV4PI);
        tColor = (1.0-vol_coef) * tColorS + vol_coef * tColorVS;
      #else
        // volumetric shadows only
        tColor = tColorVS;
      #endif
    #else
      #ifdef SurfaceShadowOn
        // surface shadows only
        tColor = tColorS;
      #else
        // no shadows
        applyLighting(tColor, normal3);
      #endif
    #endif
  #endif
  return tColor;
}

//=======================================================================
// Given a texture value compute the color and opacity
//
vec4 getColorForValue(vec4 tValue, vec3 posIS, vec3 tstep)
{
#ifdef vtkImageLabelOutlineOn
  vec3 centerPosIS = fragCoordToIndexSpace(gl_FragCoord); // pos in texture space
  vec4 centerValue = getTextureValue(centerPosIS);
  bool pixelOnBorder = false;
  vec4 tColor = texture2D(ctexture, vec2(centerValue.r * cscale0 + cshift0, 0.5));

  // Get alpha of segment from opacity function.
  tColor.a = texture2D(otexture, vec2(centerValue.r * oscale0 + oshift0, 0.5)).r;

  int segmentIndex = int(centerValue.r * 255.0);
  
  // Use texture sampling for outlineThickness
  float textureCoordinate = float(segmentIndex - 1) / 1024.0;
  float textureValue = texture2D(ttexture, vec2(textureCoordinate, 0.5)).r;

  int actualThickness = int(textureValue * 255.0);


  // If it is the background (segment index 0), we should quickly bail out. 
  // Previously, this was determined by tColor.a, which was incorrect as it
  // prevented the outline from appearing when the fill is 0.
  if (segmentIndex == 0){
    return vec4(0, 0, 0, 0);
  }

  // Only perform outline check on fragments rendering voxels that aren't invisible.
  // Saves a bunch of needless checks on the background.
  // TODO define epsilon when building shader?
  for (int i = -actualThickness; i <= actualThickness; i++) {
    for (int j = -actualThickness; j <= actualThickness; j++) {
      if (i == 0 || j == 0) {
        continue;
      }

      vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(i),
        gl_FragCoord.y + float(j),
        gl_FragCoord.z, gl_FragCoord.w);

      vec3 neighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);
      vec4 value = getTextureValue(neighborPosIS);

      // If any of my neighbours are not the same value as I
      // am, this means I am on the border of the segment.
      // We can break the loops
      if (any(notEqual(value, centerValue))) {
        pixelOnBorder = true;
        break;
      }
    }

    if (pixelOnBorder == true) {
      break;
    }
  }

  // If I am on the border, I am displayed at full opacity
  if (pixelOnBorder == true) {
    tColor.a = outlineOpacity;
  }

  return tColor;

#else
  // compute the normal and gradient magnitude if needed
  // We compute it as a vec4 if possible otherwise a mat4

  #ifdef UseIndependentComponents
    // sample textures
    vec3 tColor0 = texture2D(ctexture, vec2(tValue.r * cscale0 + cshift0, height0)).rgb;
    float pwfValue0 = texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, height0)).r;

    #if vtkNumComponents > 1
      vec3 tColor1 = texture2D(ctexture, vec2(tValue.g * cscale1 + cshift1, height1)).rgb;
      float pwfValue1 = texture2D(otexture, vec2(tValue.g * oscale1 + oshift1, height1)).r;

      #if vtkNumComponents > 2
        vec3 tColor2 = texture2D(ctexture, vec2(tValue.b * cscale2 + cshift2, height2)).rgb;
        float pwfValue2 = texture2D(otexture, vec2(tValue.b * oscale2 + oshift2, height2)).r;

        #if vtkNumComponents > 3
          vec3 tColor3 = texture2D(ctexture, vec2(tValue.a * cscale3 + cshift3, height3)).rgb;
          float pwfValue3 = texture2D(otexture, vec2(tValue.a * oscale3 + oshift3, height3)).r;
        #endif
      #endif
    #endif

    #if !defined(vtkCustomComponentsColorMix)
      // default path for component color mix

      // compute the normal vectors as needed
      #if (vtkLightComplexity > 0) || defined(vtkGradientOpacityOn)
        mat4 normalMat = computeMat4Normal(posIS, tValue, tstep);
      #endif

      // compute gradient opacity factors as needed
      vec4 goFactor = vec4(1.0, 1.0 ,1.0 ,1.0);
      #if defined(vtkGradientOpacityOn)
        #if !defined(vtkComponent0Proportional)
          goFactor.x =
            computeGradientOpacityFactor(normalMat[0].a, goscale0, goshift0, gomin0, gomax0);
        #endif
        #if vtkNumComponents > 1
          #if !defined(vtkComponent1Proportional)
            goFactor.y =
              computeGradientOpacityFactor(normalMat[1].a, goscale1, goshift1, gomin1, gomax1);
          #endif
          #if vtkNumComponents > 2
            #if !defined(vtkComponent2Proportional)
              goFactor.z =
                computeGradientOpacityFactor(normalMat[2].a, goscale2, goshift2, gomin2, gomax2);
            #endif
            #if vtkNumComponents > 3
              #if !defined(vtkComponent3Proportional)
                goFactor.w =
                  computeGradientOpacityFactor(normalMat[3].a, goscale3, goshift3, gomin3, gomax3);
              #endif
            #endif
          #endif
        #endif
      #endif

      // process color and opacity for each component
      #if !defined(vtkComponent0Proportional)
        float alpha = goFactor.x*mix0*pwfValue0;
        #if vtkLightComplexity > 0
          applyLighting(tColor0, normalMat[0]);
        #endif
      #else
        tColor0 *= pwfValue0;
        float alpha = mix(pwfValue0, 1.0, (1.0 - mix0));
      #endif

      #if vtkNumComponents > 1
        #if !defined(vtkComponent1Proportional)
          alpha += goFactor.y*mix1*pwfValue1;
          #if vtkLightComplexity > 0
            applyLighting(tColor1, normalMat[1]);
          #endif
        #else
          tColor1 *= pwfValue1;
          alpha *= mix(pwfValue1, 1.0, (1.0 - mix1));
        #endif

        #if vtkNumComponents > 2
          #if !defined(vtkComponent2Proportional)
            alpha += goFactor.z*mix2*pwfValue2;
            #if vtkLightComplexity > 0
              applyLighting(tColor2, normalMat[2]);
            #endif
          #else
            tColor2 *= pwfValue2;
            alpha *= mix(pwfValue2, 1.0, (1.0 - mix2));
          #endif
        #endif

        #if vtkNumComponents > 3
          #if !defined(vtkComponent3Proportional)
            alpha += goFactor.w*mix3*pwfValue3;
            #if vtkLightComplexity > 0
              applyLighting(tColor3, normalMat[3]);
            #endif
          #else
            tColor3 *= pwfValue3;
            alpha *= mix(pwfValue3, 1.0, (1.0 - mix3));
          #endif
        #endif
      #endif

      // perform final independent blend
      vec3 tColor = mix0 * tColor0;
      #if vtkNumComponents > 1
        tColor += mix1 * tColor1;
        #if vtkNumComponents > 2
          tColor += mix2 * tColor2;
          #if vtkNumComponents > 3
            tColor += mix3 * tColor3;
          #endif
        #endif
      #endif

      return vec4(tColor, alpha);
    #else
      /*
       * Mix the color information from all the independent components to get a single rgba output
       * Gradient opactity factors and normals are not computed
       *
       * You can compute these using:
       * - computeMat4Normal: always available, compute normal only for non proportional components, used by default independent component mix
       * - computeDensityNormal & computeNormalForDensity: available if ((LightComplexity > 0) || GradientOpacityOn) && ComputeNormalFromOpacity),
       *                                                   used by dependent component color mix, see code for Additive preset in OpenGl/VolumeMapper
       * - computeGradientOpacityFactor: always available, used in a lot of places
       *
       * Using applyAllLightning() is advised for shading but some features don't work well with it (volume shadows, LAO)
       * mix0, mix1, ... are defined for each component that is used and correspond to the componentWeight
       */
      //VTK::CustomComponentsColorMix::Impl
    #endif
  #else
    // dependent components

    // compute normal if needed
    #if (vtkLightComplexity > 0) || defined(vtkGradientOpacityOn)
      // use component 3 of the opacity texture as getTextureValue() sets alpha to the opacity value
      #ifdef vtkComputeNormalFromOpacity
        vec3 scalarInterp[2];
        vec4 normal0 = computeNormalForDensity(posIS, tstep, scalarInterp, 3);
      #else
        vec4 normal0 = computeNormal(posIS, tstep);
      #endif
    #endif

    // compute gradient opacity factor enabled
    #if defined(vtkGradientOpacityOn)
      float gradientOpacity = computeGradientOpacityFactor(normal0.a, goscale0, goshift0, gomin0, gomax0);
    #else
      const float gradientOpacity = 1.0;
    #endif

    // get color and opacity
    #if vtkNumComponents == 1
      vec3 tColor = texture2D(ctexture, vec2(tValue.r * cscale0 + cshift0, 0.5)).rgb;
      float alpha = gradientOpacity*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;
      if (alpha < EPSILON){
        return vec4(0.0);
      }
    #endif
    #if vtkNumComponents == 2
      vec3 tColor = vec3(tValue.r * cscale0 + cshift0);
      float alpha = gradientOpacity*texture2D(otexture, vec2(tValue.a * oscale1 + oshift1, 0.5)).r;
    #endif
    #if vtkNumComponents == 3
      vec3 tColor;
      tColor.r = tValue.r * cscale0 + cshift0;
      tColor.g = tValue.g * cscale1 + cshift1;
      tColor.b = tValue.b * cscale2 + cshift2;
      float alpha = gradientOpacity*texture2D(otexture, vec2(tValue.a * oscale0 + oshift0, 0.5)).r;
    #endif
    #if vtkNumComponents == 4
      vec3 tColor;
      tColor.r = tValue.r * cscale0 + cshift0;
      tColor.g = tValue.g * cscale1 + cshift1;
      tColor.b = tValue.b * cscale2 + cshift2;
      float alpha = gradientOpacity*texture2D(otexture, vec2(tValue.a * oscale3 + oshift3, 0.5)).r;
    #endif

    // lighting
    #if (vtkLightComplexity > 0)
      #ifdef vtkComputeNormalFromOpacity
        vec4 normalLight;
        if (!all(equal(normal0, vec4(0.0)))) {
          scalarInterp[0] = scalarInterp[0] * oscale0 + oshift0;
          scalarInterp[1] = scalarInterp[1] * oscale0 + oshift0;
          normalLight = computeDensityNormal(scalarInterp, 0.5, gradientOpacity);
          if (all(equal(normalLight, vec4(0.0)))) {
            normalLight = normal0;
          }
        }
      #else
        vec4 normalLight = normal0;
      #endif
      tColor = applyAllLightning(tColor, alpha, posIS, normalLight);
    #endif

    return vec4(tColor, alpha);
  #endif // dependent
#endif
}

bool valueWithinScalarRange(vec4 val, vec4 min, vec4 max) {
  bool withinRange = false;
  #if vtkNumComponents == 1
    if (val.r >= min.r && val.r <= max.r) {
      withinRange = true;
    }
  #else
    #ifdef UseIndependentComponents
      #if vtkNumComponents == 2
        if (val.r >= min.r && val.r <= max.r &&
            val.g >= min.g && val.g <= max.g) {
          withinRange = true;
        }
      #else
        if (all(greaterThanEqual(val, ipScalarRangeMin)) &&
            all(lessThanEqual(val, ipScalarRangeMax))) {
          withinRange = true;
        }
      #endif
    #endif
  #endif
  return withinRange;
}

//=======================================================================
// Apply the specified blend mode operation along the ray's path.
//
void applyBlend(vec3 posIS, vec3 endIS, vec3 tdims)
{
  vec3 tstep = 1.0/tdims;

  // start slightly inside and apply some jitter
  vec3 delta = endIS - posIS;
  vec3 stepIS = normalize(delta)*sampleDistanceIS;
  float raySteps = length(delta)/sampleDistanceIS;

  // avoid 0.0 jitter
  float jitter = 0.01 + 0.99*texture2D(jtexture, gl_FragCoord.xy/32.0).r;
  float stepsTraveled = jitter;

  // local vars for the loop
  vec4 color = vec4(0.0, 0.0, 0.0, 0.0);
  vec4 tValue;
  vec4 tColor;

  // if we have less than one step then pick the middle point
  // as our value
  // if (raySteps <= 1.0)
  // {
  //   posIS = (posIS + endIS)*0.5;
  // }

  // Perform initial step at the volume boundary
  // compute the scalar
  tValue = getTextureValue(posIS);

  #if vtkBlendMode == 0 // COMPOSITE_BLEND
    // now map through opacity and color
    tColor = getColorForValue(tValue, posIS, tstep);

    // handle very thin volumes
    if (raySteps <= 1.0)
    {
      tColor.a = 1.0 - pow(1.0 - tColor.a, raySteps);
      gl_FragData[0] = tColor;
      return;
    }

    tColor.a = 1.0 - pow(1.0 - tColor.a, jitter);
    color = vec4(tColor.rgb*tColor.a, tColor.a);
    posIS += (jitter*stepIS);

    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)
    {
      if (stepsTraveled + 1.0 >= raySteps) { break; }

      // compute the scalar
      tValue = getTextureValue(posIS);

      // now map through opacity and color
      tColor = getColorForValue(tValue, posIS, tstep);

      float mix = (1.0 - color.a);

      // this line should not be needed but nvidia seems to not handle
      // the break correctly on windows/chrome 58 angle
      //mix = mix * sign(max(raySteps - stepsTraveled - 1.0, 0.0));

      color = color + vec4(tColor.rgb*tColor.a, tColor.a)*mix;
      stepsTraveled++;
      posIS += stepIS;
      if (color.a > 0.99) { color.a = 1.0; break; }
    }

    if (color.a < 0.99 && (raySteps - stepsTraveled) > 0.0)
    {
      posIS = endIS;

      // compute the scalar
      tValue = getTextureValue(posIS);

      // now map through opacity and color
      tColor = getColorForValue(tValue, posIS, tstep);
      tColor.a = 1.0 - pow(1.0 - tColor.a, raySteps - stepsTraveled);

      float mix = (1.0 - color.a);
      color = color + vec4(tColor.rgb*tColor.a, tColor.a)*mix;
    }

    gl_FragData[0] = vec4(color.rgb/color.a, color.a);
  #endif
  #if vtkBlendMode == 1 || vtkBlendMode == 2
    // MAXIMUM_INTENSITY_BLEND || MINIMUM_INTENSITY_BLEND
    // Find maximum/minimum intensity along the ray.

    // Define the operation we will use (min or max)
    #if vtkBlendMode == 1
    #define OP max
    #else
    #define OP min
    #endif

    // If the clipping range is shorter than the sample distance
    // we can skip the sampling loop along the ray.
    if (raySteps <= 1.0)
    {
      gl_FragData[0] = getColorForValue(tValue, posIS, tstep);
      return;
    }

    vec4 value = tValue;
    posIS += (jitter*stepIS);

    // Sample along the ray until MaximumSamplesValue,
    // ending slightly inside the total distance
    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)
    {
      // If we have reached the last step, break
      if (stepsTraveled + 1.0 >= raySteps) { break; }

      // compute the scalar
      tValue = getTextureValue(posIS);

      // Update the maximum value if necessary
      value = OP(tValue, value);

      // Otherwise, continue along the ray
      stepsTraveled++;
      posIS += stepIS;
    }

    // Perform the last step along the ray using the
    // residual distance
    posIS = endIS;
    tValue = getTextureValue(posIS);
    value = OP(tValue, value);

    // Now map through opacity and color
    gl_FragData[0] = getColorForValue(value, posIS, tstep);
  #endif
  #if vtkBlendMode == 3 || vtkBlendMode == 4 //AVERAGE_INTENSITY_BLEND || ADDITIVE_BLEND
    vec4 sum = vec4(0.);

    if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {
      sum += tValue;
    }

    if (raySteps <= 1.0) {
      gl_FragData[0] = getColorForValue(sum, posIS, tstep);
      return;
    }

    posIS += (jitter*stepIS);

    // Sample along the ray until MaximumSamplesValue,
    // ending slightly inside the total distance
    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)
    {
      // If we have reached the last step, break
      if (stepsTraveled + 1.0 >= raySteps) { break; }

      // compute the scalar
      tValue = getTextureValue(posIS);

      // One can control the scalar range by setting the AverageIPScalarRange to disregard scalar values, not in the range of interest, from the average computation.
      // Notes:
      // - We are comparing all values in the texture to see if any of them
      //   are outside of the scalar range. In the future we might want to allow
      //   scalar ranges for each component.
      if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {
        // Sum the values across each step in the path
        sum += tValue;
      }
      stepsTraveled++;
      posIS += stepIS;
    }

    // Perform the last step along the ray using the
    // residual distance
    posIS = endIS;

    // compute the scalar
    tValue = getTextureValue(posIS);

    // One can control the scalar range by setting the IPScalarRange to disregard scalar values, not in the range of interest, from the average computation
    if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {
      sum += tValue;

      stepsTraveled++;
    }

    #if vtkBlendMode == 3 // Average
      sum /= vec4(stepsTraveled, stepsTraveled, stepsTraveled, 1.0);
    #endif

    gl_FragData[0] = getColorForValue(sum, posIS, tstep);
  #endif
  #if vtkBlendMode == 5 // RADON
    float normalizedRayIntensity = 1.0;

    // handle very thin volumes
    if (raySteps <= 1.0)
    {
      tValue = getTextureValue(posIS);
      normalizedRayIntensity = normalizedRayIntensity - sampleDistance*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;
      gl_FragData[0] = texture2D(ctexture, vec2(normalizedRayIntensity, 0.5));
      return;
    }

    posIS += (jitter*stepIS);

    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)
    {
      if (stepsTraveled + 1.0 >= raySteps) { break; }

      // compute the scalar value
      tValue = getTextureValue(posIS);

      // Convert scalar value to normalizedRayIntensity coefficient and accumulate normalizedRayIntensity
      normalizedRayIntensity = normalizedRayIntensity - sampleDistance*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;

      posIS += stepIS;
      stepsTraveled++;
    }

    // map normalizedRayIntensity to color
    gl_FragData[0] = texture2D(ctexture, vec2(normalizedRayIntensity , 0.5));

  #endif
}

//=======================================================================
// Compute a new start and end point for a given ray based
// on the provided bounded clipping plane (aka a rectangle)
void getRayPointIntersectionBounds(
  vec3 rayPos, vec3 rayDir,
  vec3 planeDir, float planeDist,
  inout vec2 tbounds, vec3 vPlaneX, vec3 vPlaneY,
  float vSize1, float vSize2)
{
  float result = dot(rayDir, planeDir);
  if (abs(result) < 1e-6)
  {
    return;
  }
  result = -1.0 * (dot(rayPos, planeDir) + planeDist) / result;
  vec3 xposVC = rayPos + rayDir*result;
  vec3 vxpos = xposVC - vOriginVC;
  vec2 vpos = vec2(
    dot(vxpos, vPlaneX),
    dot(vxpos, vPlaneY));

  // on some apple nvidia systems this does not work
  // if (vpos.x < 0.0 || vpos.x > vSize1 ||
  //     vpos.y < 0.0 || vpos.y > vSize2)
  // even just
  // if (vpos.x < 0.0 || vpos.y < 0.0)
  // fails
  // so instead we compute a value that represents in and out
  //and then compute the return using this value
  float xcheck = max(0.0, vpos.x * (vpos.x - vSize1)); //  0 means in bounds
  float check = sign(max(xcheck, vpos.y * (vpos.y - vSize2))); //  0 means in bounds, 1 = out

  tbounds = mix(
   vec2(min(tbounds.x, result), max(tbounds.y, result)), // in value
   tbounds, // out value
   check);  // 0 in 1 out
}

//=======================================================================
// given a
// - ray direction (rayDir)
// - starting point (vertexVCVSOutput)
// - bounding planes of the volume
// - optionally depth buffer values
// - far clipping plane
// compute the start/end distances of the ray we need to cast
vec2 computeRayDistances(vec3 rayDir, vec3 tdims)
{
  vec2 dists = vec2(100.0*camFar, -1.0);

  vec3 vSize = vSpacing*tdims;

  // all this is in View Coordinates
  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,
    vPlaneNormal0, vPlaneDistance0, dists, vPlaneNormal2, vPlaneNormal4,
    vSize.y, vSize.z);
  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,
    vPlaneNormal1, vPlaneDistance1, dists, vPlaneNormal2, vPlaneNormal4,
    vSize.y, vSize.z);
  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,
    vPlaneNormal2, vPlaneDistance2, dists, vPlaneNormal0, vPlaneNormal4,
    vSize.x, vSize.z);
  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,
    vPlaneNormal3, vPlaneDistance3, dists, vPlaneNormal0, vPlaneNormal4,
    vSize.x, vSize.z);
  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,
    vPlaneNormal4, vPlaneDistance4, dists, vPlaneNormal0, vPlaneNormal2,
    vSize.x, vSize.y);
  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,
    vPlaneNormal5, vPlaneDistance5, dists, vPlaneNormal0, vPlaneNormal2,
    vSize.x, vSize.y);

  //VTK::ClipPlane::Impl

  // do not go behind front clipping plane
  dists.x = max(0.0,dists.x);

  // do not go PAST far clipping plane
  float farDist = -camThick/rayDir.z;
  dists.y = min(farDist,dists.y);

  // Do not go past the zbuffer value if set
  // This is used for intermixing opaque geometry
  //VTK::ZBuffer::Impl

  return dists;
}

//=======================================================================
// Compute the index space starting position (pos) and end
// position
//
void computeIndexSpaceValues(out vec3 pos, out vec3 endPos, vec3 rayDir, vec2 dists)
{
  // compute starting and ending values in volume space
  pos = vertexVCVSOutput + dists.x*rayDir;
  pos = pos - vOriginVC;
  // convert to volume basis and origin
  pos = vec3(
    dot(pos, vPlaneNormal0),
    dot(pos, vPlaneNormal2),
    dot(pos, vPlaneNormal4));

  endPos = vertexVCVSOutput + dists.y*rayDir;
  endPos = endPos - vOriginVC;
  endPos = vec3(
    dot(endPos, vPlaneNormal0),
    dot(endPos, vPlaneNormal2),
    dot(endPos, vPlaneNormal4));

  float delta = length(endPos - pos);

  pos *= vVCToIJK;
  endPos *= vVCToIJK;

  float delta2 = length(endPos - pos);
  sampleDistanceIS = sampleDistance*delta2/delta;
  #ifdef VolumeShadowOn
    sampleDistanceISVS = sampleDistanceIS * volumeShadowSamplingDistFactor;
  #endif
}

void main()
{

  if (cameraParallel == 1)
  {
    // Camera is parallel, so the rayDir is just the direction of the camera.
    rayDirVC = vec3(0.0, 0.0, -1.0);
  } else {
    // camera is at 0,0,0 so rayDir for perspective is just the vc coord
    rayDirVC = normalize(vertexVCVSOutput);
  }

  vec3 tdims = vec3(volumeDimensions);

  // compute the start and end points for the ray
  vec2 rayStartEndDistancesVC = computeRayDistances(rayDirVC, tdims);

  // do we need to composite? aka does the ray have any length
  // If not, bail out early
  if (rayStartEndDistancesVC.y <= rayStartEndDistancesVC.x)
  {
    discard;
  }

  // IS = Index Space
  vec3 posIS;
  vec3 endIS;
  computeIndexSpaceValues(posIS, endIS, rayDirVC, rayStartEndDistancesVC);

  // Perform the blending operation along the ray
  applyBlend(posIS, endIS, tdims);
}
`;

// node_modules/@kitware/vtk.js/Rendering/OpenGL/VolumeMapper.js
var {
  vtkWarningMacro: vtkWarningMacro7,
  vtkErrorMacro: vtkErrorMacro18
} = macro$1;
function computeFnToString4(pwfun, useIComps, numberOfComponents) {
  return pwfun ? `${pwfun.getMTime()}-${useIComps}-${numberOfComponents}` : "0";
}
function getColorCodeFromPreset(colorMixPreset) {
  switch (colorMixPreset) {
    case ColorMixPreset.CUSTOM:
      return "//VTK::CustomColorMix";
    case ColorMixPreset.ADDITIVE:
      return `
        // compute normals
        mat4 normalMat = computeMat4Normal(posIS, tValue, tstep);
        #if (vtkLightComplexity > 0) && defined(vtkComputeNormalFromOpacity)
          vec3 scalarInterp0[2];
          vec4 normalLight0 = computeNormalForDensity(posIS, tstep, scalarInterp0, 0);
          scalarInterp0[0] = scalarInterp0[0] * oscale0 + oshift0;
          scalarInterp0[1] = scalarInterp0[1] * oscale0 + oshift0;
          normalLight0 = computeDensityNormal(scalarInterp0, height0, 1.0);

          vec3 scalarInterp1[2];
          vec4 normalLight1 = computeNormalForDensity(posIS, tstep, scalarInterp1, 1);
          scalarInterp1[0] = scalarInterp1[0] * oscale1 + oshift1;
          scalarInterp1[1] = scalarInterp1[1] * oscale1 + oshift1;
          normalLight1 = computeDensityNormal(scalarInterp1, height1, 1.0);
        #else
          vec4 normalLight0 = normalMat[0];
          vec4 normalLight1 = normalMat[1];
        #endif

        // compute opacities
        float opacity0 = pwfValue0;
        float opacity1 = pwfValue1;
        #ifdef vtkGradientOpacityOn
          float gof0 = computeGradientOpacityFactor(normalMat[0].a, goscale0, goshift0, gomin0, gomax0);
          opacity0 *= gof0;
          float gof1 = computeGradientOpacityFactor(normalMat[1].a, goscale1, goshift1, gomin1, gomax1);
          opacity1 *= gof1;
        #endif
        float opacitySum = opacity0 + opacity1;
        if (opacitySum <= 0.0) {
          return vec4(0.0);
        }

        // mix the colors and opacities
        tColor0 = applyAllLightning(tColor0, opacity0, posIS, normalLight0);
        tColor1 = applyAllLightning(tColor1, opacity1, posIS, normalLight1);
        vec3 mixedColor = (opacity0 * tColor0 + opacity1 * tColor1) / opacitySum;
        return vec4(mixedColor, min(1.0, opacitySum));
`;
    case ColorMixPreset.COLORIZE:
      return `
        // compute normals
        mat4 normalMat = computeMat4Normal(posIS, tValue, tstep);
        #if (vtkLightComplexity > 0) && defined(vtkComputeNormalFromOpacity)
          vec3 scalarInterp0[2];
          vec4 normalLight0 = computeNormalForDensity(posIS, tstep, scalarInterp0, 0);
          scalarInterp0[0] = scalarInterp0[0] * oscale0 + oshift0;
          scalarInterp0[1] = scalarInterp0[1] * oscale0 + oshift0;
          normalLight0 = computeDensityNormal(scalarInterp0, height0, 1.0);
        #else
          vec4 normalLight0 = normalMat[0];
        #endif

        // compute opacities
        float opacity0 = pwfValue0;
        #ifdef vtkGradientOpacityOn
          float gof0 = computeGradientOpacityFactor(normalMat[0].a, goscale0, goshift0, gomin0, gomax0);
          opacity0 *= gof0;
        #endif

        // mix the colors and opacities
        vec3 color = tColor0 * mix(vec3(1.0), tColor1, pwfValue1);
        color = applyAllLightning(color, opacity0, posIS, normalLight0);
        return vec4(color, opacity0);
`;
    default:
      return null;
  }
}
function vtkOpenGLVolumeMapper(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLVolumeMapper");
  publicAPI.buildPass = () => {
    model.zBufferTexture = null;
  };
  publicAPI.zBufferPass = (prepass, renderPass) => {
    if (prepass) {
      const zbt = renderPass.getZBufferTexture();
      if (zbt !== model.zBufferTexture) {
        model.zBufferTexture = zbt;
      }
    }
  };
  publicAPI.opaqueZBufferPass = (prepass, renderPass) => publicAPI.zBufferPass(prepass, renderPass);
  publicAPI.volumePass = (prepass, renderPass) => {
    if (prepass) {
      model._openGLRenderWindow = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderWindow");
      model.context = model._openGLRenderWindow.getContext();
      model.tris.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.jitterTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.framebuffer.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.scalarTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.colorTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.opacityTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.labelOutlineThicknessTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.openGLVolume = publicAPI.getFirstAncestorOfType("vtkOpenGLVolume");
      const actor = model.openGLVolume.getRenderable();
      model._openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
      const ren = model._openGLRenderer.getRenderable();
      model.openGLCamera = model._openGLRenderer.getViewNodeFor(ren.getActiveCamera());
      publicAPI.renderPiece(ren, actor);
    }
  };
  publicAPI.getShaderTemplate = (shaders, ren, actor) => {
    shaders.Vertex = vtkVolumeVS;
    shaders.Fragment = vtkVolumeFS;
    shaders.Geometry = "";
  };
  publicAPI.useIndependentComponents = (actorProperty) => {
    var _a9, _b2;
    const iComps = actorProperty.getIndependentComponents();
    const image2 = model.currentInput;
    const numComp = (_b2 = (_a9 = image2 == null ? void 0 : image2.getPointData()) == null ? void 0 : _a9.getScalars()) == null ? void 0 : _b2.getNumberOfComponents();
    const colorMixPreset = actorProperty.getColorMixPreset();
    return iComps && numComp >= 2 || !!colorMixPreset;
  };
  publicAPI.replaceShaderValues = (shaders, ren, actor) => {
    const actorProps = actor.getProperty();
    let FSSource = shaders.Fragment;
    const iType = actorProps.getInterpolationType();
    if (iType === InterpolationType2.LINEAR) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TrilinearOn", "#define vtkTrilinearOn").result;
    }
    const vtkImageLabelOutline = actorProps.getUseLabelOutline();
    if (vtkImageLabelOutline === true) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ImageLabelOutlineOn", "#define vtkImageLabelOutlineOn").result;
    }
    const numComp = model.scalarTexture.getComponents();
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::NumComponents", `#define vtkNumComponents ${numComp}`).result;
    const useIndependentComps = publicAPI.useIndependentComponents(actorProps);
    if (useIndependentComps) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::IndependentComponentsOn", "#define UseIndependentComponents").result;
    }
    const proportionalComponents = [];
    const forceNearestComponents = [];
    for (let nc = 0; nc < numComp; nc++) {
      if (actorProps.getOpacityMode(nc) === OpacityMode.PROPORTIONAL) {
        proportionalComponents.push(`#define vtkComponent${nc}Proportional`);
      }
      if (actorProps.getForceNearestInterpolation(nc)) {
        forceNearestComponents.push(`#define vtkComponent${nc}ForceNearest`);
      }
    }
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::vtkProportionalComponents", proportionalComponents.join("\n")).result;
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::vtkForceNearestComponents", forceNearestComponents.join("\n")).result;
    const colorMixPreset = actorProps.getColorMixPreset();
    const colorMixCode = getColorCodeFromPreset(colorMixPreset);
    if (colorMixCode) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::CustomComponentsColorMixOn", "#define vtkCustomComponentsColorMix").result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::CustomComponentsColorMix::Impl", colorMixCode).result;
    }
    const ext = model.currentInput.getSpatialExtent();
    const spc = model.currentInput.getSpacing();
    const vsize = new Float64Array(3);
    vec3_exports.set(vsize, (ext[1] - ext[0]) * spc[0], (ext[3] - ext[2]) * spc[1], (ext[5] - ext[4]) * spc[2]);
    const maxSamples = vec3_exports.length(vsize) / publicAPI.getCurrentSampleDistance(ren);
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::MaximumSamplesValue", `${Math.ceil(maxSamples)}`).result;
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::LightComplexity", `#define vtkLightComplexity ${model.lightComplexity}`).result;
    if (model.lightComplexity > 0) {
      if (model.renderable.getVolumetricScatteringBlending() > 0) {
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::VolumeShadowOn", `#define VolumeShadowOn`).result;
      }
      if (model.renderable.getVolumetricScatteringBlending() < 1) {
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::SurfaceShadowOn", `#define SurfaceShadowOn`).result;
      }
      if (model.renderable.getLocalAmbientOcclusion() && actorProps.getAmbient() > 0) {
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::localAmbientOcclusionOn", `#define localAmbientOcclusionOn`).result;
      }
    }
    const numIComps = useIndependentComps ? numComp : 1;
    model.gopacity = false;
    for (let nc = 0; !model.gopacity && nc < numIComps; ++nc) {
      model.gopacity || (model.gopacity = actorProps.getUseGradientOpacity(nc));
    }
    if (model.gopacity) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::GradientOpacityOn", "#define vtkGradientOpacityOn").result;
    }
    if (model.renderable.getComputeNormalFromOpacity()) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::vtkComputeNormalFromOpacity", `#define vtkComputeNormalFromOpacity`).result;
    }
    if (model.zBufferTexture !== null) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ZBuffer::Dec", ["uniform sampler2D zBufferTexture;", "uniform float vpZWidth;", "uniform float vpZHeight;"]).result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ZBuffer::Impl", ["vec4 depthVec = texture2D(zBufferTexture, vec2(gl_FragCoord.x / vpZWidth, gl_FragCoord.y/vpZHeight));", "float zdepth = (depthVec.r*256.0 + depthVec.g)/257.0;", "zdepth = zdepth * 2.0 - 1.0;", "if (cameraParallel == 0) {", "zdepth = -2.0 * camFar * camNear / (zdepth*(camFar-camNear)-(camFar+camNear)) - camNear;}", "else {", "zdepth = (zdepth + 1.0) * 0.5 * (camFar - camNear);}\n", "zdepth = -zdepth/rayDir.z;", "dists.y = min(zdepth,dists.y);"]).result;
    }
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::BlendMode", `${model.renderable.getBlendMode()}`).result;
    shaders.Fragment = FSSource;
    publicAPI.replaceShaderLight(shaders, ren, actor);
    publicAPI.replaceShaderClippingPlane(shaders, ren, actor);
  };
  publicAPI.replaceShaderLight = (shaders, ren, actor) => {
    if (model.lightComplexity === 0) {
      return;
    }
    let FSSource = shaders.Fragment;
    let lightNum = 0;
    ren.getLights().forEach((light) => {
      if (light.getSwitch()) {
        lightNum += 1;
      }
    });
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Light::Dec", [`uniform int lightNum;`, `uniform bool twoSidedLighting;`, `uniform vec3 lightColor[${lightNum}];`, `uniform vec3 lightDirectionVC[${lightNum}]; // normalized`, `uniform vec3 lightHalfAngleVC[${lightNum}];`, "//VTK::Light::Dec"], false).result;
    if (model.lightComplexity === 3) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Light::Dec", [`uniform vec3 lightPositionVC[${lightNum}];`, `uniform vec3 lightAttenuation[${lightNum}];`, `uniform float lightConeAngle[${lightNum}];`, `uniform float lightExponent[${lightNum}];`, `uniform int lightPositional[${lightNum}];`], false).result;
    }
    if (model.renderable.getVolumetricScatteringBlending() > 0) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::VolumeShadow::Dec", [`uniform float volumetricScatteringBlending;`, `uniform float giReach;`, `uniform float volumeShadowSamplingDistFactor;`, `uniform float anisotropy;`, `uniform float anisotropy2;`], false).result;
    }
    if (model.renderable.getLocalAmbientOcclusion() && actor.getProperty().getAmbient() > 0) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::LAO::Dec", [`uniform int kernelRadius;`, `uniform vec2 kernelSample[${model.renderable.getLAOKernelRadius()}];`, `uniform int kernelSize;`], false).result;
    }
    shaders.Fragment = FSSource;
  };
  publicAPI.replaceShaderClippingPlane = (shaders, ren, actor) => {
    let FSSource = shaders.Fragment;
    if (model.renderable.getClippingPlanes().length > 0) {
      const clipPlaneSize = model.renderable.getClippingPlanes().length;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ClipPlane::Dec", [`uniform vec3 vClipPlaneNormals[6];`, `uniform float vClipPlaneDistances[6];`, `uniform vec3 vClipPlaneOrigins[6];`, `uniform int clip_numPlanes;`, "//VTK::ClipPlane::Dec", "#define vtkClippingPlanesOn"], false).result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ClipPlane::Impl", [`for(int i = 0; i < ${clipPlaneSize}; i++) {`, "  float rayDirRatio = dot(rayDir, vClipPlaneNormals[i]);", "  float equationResult = dot(vertexVCVSOutput, vClipPlaneNormals[i]) + vClipPlaneDistances[i];", "  if (rayDirRatio == 0.0)", "  {", "    if (equationResult < 0.0) dists.x = dists.y;", "    continue;", "  }", "  float result = -1.0 * equationResult / rayDirRatio;", "  if (rayDirRatio < 0.0) dists.y = min(dists.y, result);", "  else dists.x = max(dists.x, result);", "}", "//VTK::ClipPlane::Impl"], false).result;
    }
    shaders.Fragment = FSSource;
  };
  const recomputeLightComplexity = (actor, lights) => {
    let lightComplexity = 0;
    if (actor.getProperty().getShade() && model.renderable.getBlendMode() === BlendMode.COMPOSITE_BLEND) {
      lightComplexity = 0;
      model.numberOfLights = 0;
      lights.forEach((light) => {
        const status = light.getSwitch();
        if (status > 0) {
          model.numberOfLights++;
          if (lightComplexity === 0) {
            lightComplexity = 1;
          }
        }
        if (lightComplexity === 1 && (model.numberOfLights > 1 || light.getIntensity() !== 1 || !light.lightTypeIsHeadLight())) {
          lightComplexity = 2;
        }
        if (lightComplexity < 3 && light.getPositional()) {
          lightComplexity = 3;
        }
      });
    }
    if (lightComplexity !== model.lightComplexity) {
      model.lightComplexity = lightComplexity;
      publicAPI.modified();
    }
  };
  publicAPI.getNeedToRebuildShaders = (cellBO, ren, actor) => {
    var _a9;
    const actorProps = actor.getProperty();
    recomputeLightComplexity(actor, ren.getLights());
    const numComp = model.scalarTexture.getComponents();
    const opacityModes = [];
    const forceNearestInterps = [];
    for (let nc = 0; nc < numComp; nc++) {
      opacityModes.push(actorProps.getOpacityMode(nc));
      forceNearestInterps.push(actorProps.getForceNearestInterpolation(nc));
    }
    const ext = model.currentInput.getSpatialExtent();
    const spc = model.currentInput.getSpacing();
    const vsize = new Float64Array(3);
    vec3_exports.set(vsize, (ext[1] - ext[0]) * spc[0], (ext[3] - ext[2]) * spc[1], (ext[5] - ext[4]) * spc[2]);
    const maxSamples = vec3_exports.length(vsize) / publicAPI.getCurrentSampleDistance(ren);
    const hasZBufferTexture = !!model.zBufferTexture;
    const state = {
      iComps: actorProps.getIndependentComponents(),
      colorMixPreset: actorProps.getColorMixPreset(),
      interpolationType: actorProps.getInterpolationType(),
      useLabelOutline: actorProps.getUseLabelOutline(),
      numComp,
      maxSamples,
      useGradientOpacity: actorProps.getUseGradientOpacity(0),
      blendMode: model.renderable.getBlendMode(),
      hasZBufferTexture,
      opacityModes,
      forceNearestInterps
    };
    if (((_a9 = cellBO.getProgram()) == null ? void 0 : _a9.getHandle()) === 0 || cellBO.getShaderSourceTime().getMTime() < publicAPI.getMTime() || cellBO.getShaderSourceTime().getMTime() < model.renderable.getMTime() || !model.previousState || !(0, import_fast_deep_equal2.default)(model.previousState, state)) {
      model.previousState = state;
      return true;
    }
    return false;
  };
  publicAPI.updateShaders = (cellBO, ren, actor) => {
    if (publicAPI.getNeedToRebuildShaders(cellBO, ren, actor)) {
      const shaders = {
        Vertex: null,
        Fragment: null,
        Geometry: null
      };
      publicAPI.buildShaders(shaders, ren, actor);
      const newShader = model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(shaders.Vertex, shaders.Fragment, shaders.Geometry);
      if (newShader !== cellBO.getProgram()) {
        cellBO.setProgram(newShader);
        cellBO.getVAO().releaseGraphicsResources();
      }
      cellBO.getShaderSourceTime().modified();
    } else {
      model._openGLRenderWindow.getShaderCache().readyShaderProgram(cellBO.getProgram());
    }
    cellBO.getVAO().bind();
    publicAPI.setMapperShaderParameters(cellBO, ren, actor);
    publicAPI.setCameraShaderParameters(cellBO, ren, actor);
    publicAPI.setPropertyShaderParameters(cellBO, ren, actor);
    publicAPI.getClippingPlaneShaderParameters(cellBO, ren, actor);
  };
  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {
    const program = cellBO.getProgram();
    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime.getMTime() > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {
      if (program.isAttributeUsed("vertexDC")) {
        if (!cellBO.getVAO().addAttributeArray(program, cellBO.getCABO(), "vertexDC", cellBO.getCABO().getVertexOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {
          vtkErrorMacro18("Error setting vertexDC in shader VAO.");
        }
      }
      cellBO.getAttributeUpdateTime().modified();
    }
    program.setUniformi("texture1", model.scalarTexture.getTextureUnit());
    program.setUniformf("sampleDistance", publicAPI.getCurrentSampleDistance(ren));
    const volInfo = model.scalarTexture.getVolumeInfo();
    const ipScalarRange = model.renderable.getIpScalarRange();
    const minVals = [];
    const maxVals = [];
    for (let i6 = 0; i6 < 4; i6++) {
      minVals[i6] = ipScalarRange[0] * volInfo.dataComputedScale[i6] + volInfo.dataComputedOffset[i6];
      maxVals[i6] = ipScalarRange[1] * volInfo.dataComputedScale[i6] + volInfo.dataComputedOffset[i6];
      minVals[i6] = (minVals[i6] - volInfo.offset[i6]) / volInfo.scale[i6];
      maxVals[i6] = (maxVals[i6] - volInfo.offset[i6]) / volInfo.scale[i6];
    }
    program.setUniform4f("ipScalarRangeMin", minVals[0], minVals[1], minVals[2], minVals[3]);
    program.setUniform4f("ipScalarRangeMax", maxVals[0], maxVals[1], maxVals[2], maxVals[3]);
    if (model.zBufferTexture !== null) {
      program.setUniformi("zBufferTexture", model.zBufferTexture.getTextureUnit());
      const size3 = model._useSmallViewport ? [model._smallViewportWidth, model._smallViewportHeight] : model._openGLRenderWindow.getFramebufferSize();
      program.setUniformf("vpZWidth", size3[0]);
      program.setUniformf("vpZHeight", size3[1]);
    }
  };
  publicAPI.setCameraShaderParameters = (cellBO, ren, actor) => {
    const keyMats = model.openGLCamera.getKeyMatrices(ren);
    const actMats = model.openGLVolume.getKeyMatrices();
    mat4_exports.multiply(model.modelToView, keyMats.wcvc, actMats.mcwc);
    const program = cellBO.getProgram();
    const cam = model.openGLCamera.getRenderable();
    const crange = cam.getClippingRange();
    program.setUniformf("camThick", crange[1] - crange[0]);
    program.setUniformf("camNear", crange[0]);
    program.setUniformf("camFar", crange[1]);
    const bounds = model.currentInput.getBounds();
    const dims = model.currentInput.getDimensions();
    const pos = new Float64Array(3);
    const dir = new Float64Array(3);
    let dcxmin = 1;
    let dcxmax = -1;
    let dcymin = 1;
    let dcymax = -1;
    for (let i6 = 0; i6 < 8; ++i6) {
      vec3_exports.set(pos, bounds[i6 % 2], bounds[2 + Math.floor(i6 / 2) % 2], bounds[4 + Math.floor(i6 / 4)]);
      vec3_exports.transformMat4(pos, pos, model.modelToView);
      if (!cam.getParallelProjection()) {
        vec3_exports.normalize(dir, pos);
        const t9 = -crange[0] / pos[2];
        vec3_exports.scale(pos, dir, t9);
      }
      vec3_exports.transformMat4(pos, pos, keyMats.vcpc);
      dcxmin = Math.min(pos[0], dcxmin);
      dcxmax = Math.max(pos[0], dcxmax);
      dcymin = Math.min(pos[1], dcymin);
      dcymax = Math.max(pos[1], dcymax);
    }
    program.setUniformf("dcxmin", dcxmin);
    program.setUniformf("dcxmax", dcxmax);
    program.setUniformf("dcymin", dcymin);
    program.setUniformf("dcymax", dcymax);
    if (program.isUniformUsed("cameraParallel")) {
      program.setUniformi("cameraParallel", cam.getParallelProjection());
    }
    const ext = model.currentInput.getSpatialExtent();
    const spc = model.currentInput.getSpacing();
    const vsize = new Float64Array(3);
    vec3_exports.set(vsize, (ext[1] - ext[0]) * spc[0], (ext[3] - ext[2]) * spc[1], (ext[5] - ext[4]) * spc[2]);
    program.setUniform3f("vSpacing", spc[0], spc[1], spc[2]);
    vec3_exports.set(pos, ext[0], ext[2], ext[4]);
    model.currentInput.indexToWorldVec3(pos, pos);
    vec3_exports.transformMat4(pos, pos, model.modelToView);
    program.setUniform3f("vOriginVC", pos[0], pos[1], pos[2]);
    const i2wmat4 = model.currentInput.getIndexToWorld();
    mat4_exports.multiply(model.idxToView, model.modelToView, i2wmat4);
    mat3_exports.multiply(model.idxNormalMatrix, keyMats.normalMatrix, actMats.normalMatrix);
    mat3_exports.multiply(model.idxNormalMatrix, model.idxNormalMatrix, model.currentInput.getDirectionByReference());
    const maxSamples = vec3_exports.length(vsize) / publicAPI.getCurrentSampleDistance(ren);
    if (maxSamples > model.renderable.getMaximumSamplesPerRay()) {
      vtkWarningMacro7(`The number of steps required ${Math.ceil(maxSamples)} is larger than the
        specified maximum number of steps ${model.renderable.getMaximumSamplesPerRay()}.
        Please either change the
        volumeMapper sampleDistance or its maximum number of samples.`);
    }
    const vctoijk = new Float64Array(3);
    vec3_exports.set(vctoijk, 1, 1, 1);
    vec3_exports.divide(vctoijk, vctoijk, vsize);
    program.setUniform3f("vVCToIJK", vctoijk[0], vctoijk[1], vctoijk[2]);
    program.setUniform3i("volumeDimensions", dims[0], dims[1], dims[2]);
    if (!model._openGLRenderWindow.getWebgl2()) {
      const volInfo = model.scalarTexture.getVolumeInfo();
      program.setUniformf("texWidth", model.scalarTexture.getWidth());
      program.setUniformf("texHeight", model.scalarTexture.getHeight());
      program.setUniformi("xreps", volInfo.xreps);
      program.setUniformi("xstride", volInfo.xstride);
      program.setUniformi("ystride", volInfo.ystride);
    }
    const normal = new Float64Array(3);
    const pos2 = new Float64Array(3);
    for (let i6 = 0; i6 < 6; ++i6) {
      switch (i6) {
        case 1:
          vec3_exports.set(normal, -1, 0, 0);
          vec3_exports.set(pos2, ext[0], ext[2], ext[4]);
          break;
        case 2:
          vec3_exports.set(normal, 0, 1, 0);
          vec3_exports.set(pos2, ext[1], ext[3], ext[5]);
          break;
        case 3:
          vec3_exports.set(normal, 0, -1, 0);
          vec3_exports.set(pos2, ext[0], ext[2], ext[4]);
          break;
        case 4:
          vec3_exports.set(normal, 0, 0, 1);
          vec3_exports.set(pos2, ext[1], ext[3], ext[5]);
          break;
        case 5:
          vec3_exports.set(normal, 0, 0, -1);
          vec3_exports.set(pos2, ext[0], ext[2], ext[4]);
          break;
        case 0:
        default:
          vec3_exports.set(normal, 1, 0, 0);
          vec3_exports.set(pos2, ext[1], ext[3], ext[5]);
          break;
      }
      vec3_exports.transformMat3(normal, normal, model.idxNormalMatrix);
      vec3_exports.transformMat4(pos2, pos2, model.idxToView);
      const dist3 = -1 * vec3_exports.dot(pos2, normal);
      program.setUniform3f(`vPlaneNormal${i6}`, normal[0], normal[1], normal[2]);
      program.setUniformf(`vPlaneDistance${i6}`, dist3);
    }
    if (actor.getProperty().getUseLabelOutline()) {
      const image2 = model.currentInput;
      const worldToIndex = image2.getWorldToIndex();
      program.setUniformMatrix("vWCtoIDX", worldToIndex);
      const camera = ren.getActiveCamera();
      const [cRange0, cRange1] = camera.getClippingRange();
      const distance3 = camera.getDistance();
      camera.setClippingRange(distance3, distance3 + 0.1);
      const labelOutlineKeyMats = model.openGLCamera.getKeyMatrices(ren);
      mat4_exports.invert(model.projectionToWorld, labelOutlineKeyMats.wcpc);
      camera.setClippingRange(cRange0, cRange1);
      model.openGLCamera.getKeyMatrices(ren);
      program.setUniformMatrix("PCWCMatrix", model.projectionToWorld);
      const size3 = publicAPI.getRenderTargetSize();
      program.setUniformf("vpWidth", size3[0]);
      program.setUniformf("vpHeight", size3[1]);
      const offset3 = publicAPI.getRenderTargetOffset();
      program.setUniformf("vpOffsetX", offset3[0] / size3[0]);
      program.setUniformf("vpOffsetY", offset3[1] / size3[1]);
    }
    mat4_exports.invert(model.projectionToView, keyMats.vcpc);
    program.setUniformMatrix("PCVCMatrix", model.projectionToView);
    if (model.lightComplexity === 0) {
      return;
    }
    let lightNum = 0;
    const lightColor = [];
    const lightDir = [];
    const halfAngle = [];
    ren.getLights().forEach((light) => {
      const status = light.getSwitch();
      if (status > 0) {
        const dColor = light.getColor();
        const intensity = light.getIntensity();
        lightColor[0 + lightNum * 3] = dColor[0] * intensity;
        lightColor[1 + lightNum * 3] = dColor[1] * intensity;
        lightColor[2 + lightNum * 3] = dColor[2] * intensity;
        const ldir = light.getDirection();
        vec3_exports.set(normal, ldir[0], ldir[1], ldir[2]);
        vec3_exports.transformMat3(normal, normal, keyMats.normalMatrix);
        vec3_exports.normalize(normal, normal);
        lightDir[0 + lightNum * 3] = normal[0];
        lightDir[1 + lightNum * 3] = normal[1];
        lightDir[2 + lightNum * 3] = normal[2];
        halfAngle[0 + lightNum * 3] = -0.5 * normal[0];
        halfAngle[1 + lightNum * 3] = -0.5 * normal[1];
        halfAngle[2 + lightNum * 3] = -0.5 * (normal[2] - 1);
        lightNum++;
      }
    });
    program.setUniformi("twoSidedLighting", ren.getTwoSidedLighting());
    program.setUniformi("lightNum", lightNum);
    program.setUniform3fv("lightColor", lightColor);
    program.setUniform3fv("lightDirectionVC", lightDir);
    program.setUniform3fv("lightHalfAngleVC", halfAngle);
    if (model.lightComplexity === 3) {
      lightNum = 0;
      const lightPositionVC = [];
      const lightAttenuation = [];
      const lightConeAngle = [];
      const lightExponent = [];
      const lightPositional = [];
      ren.getLights().forEach((light) => {
        const status = light.getSwitch();
        if (status > 0) {
          const attenuation = light.getAttenuationValues();
          lightAttenuation[0 + lightNum * 3] = attenuation[0];
          lightAttenuation[1 + lightNum * 3] = attenuation[1];
          lightAttenuation[2 + lightNum * 3] = attenuation[2];
          lightExponent[lightNum] = light.getExponent();
          lightConeAngle[lightNum] = light.getConeAngle();
          lightPositional[lightNum] = light.getPositional();
          const lp = light.getTransformedPosition();
          vec3_exports.transformMat4(lp, lp, model.modelToView);
          lightPositionVC[0 + lightNum * 3] = lp[0];
          lightPositionVC[1 + lightNum * 3] = lp[1];
          lightPositionVC[2 + lightNum * 3] = lp[2];
          lightNum += 1;
        }
      });
      program.setUniform3fv("lightPositionVC", lightPositionVC);
      program.setUniform3fv("lightAttenuation", lightAttenuation);
      program.setUniformfv("lightConeAngle", lightConeAngle);
      program.setUniformfv("lightExponent", lightExponent);
      program.setUniformiv("lightPositional", lightPositional);
    }
    if (model.renderable.getVolumetricScatteringBlending() > 0) {
      program.setUniformf("giReach", model.renderable.getGlobalIlluminationReach());
      program.setUniformf("volumetricScatteringBlending", model.renderable.getVolumetricScatteringBlending());
      program.setUniformf("volumeShadowSamplingDistFactor", model.renderable.getVolumeShadowSamplingDistFactor());
      program.setUniformf("anisotropy", model.renderable.getAnisotropy());
      program.setUniformf("anisotropy2", __pow(model.renderable.getAnisotropy(), 2));
    }
    if (model.renderable.getLocalAmbientOcclusion() && actor.getProperty().getAmbient() > 0) {
      const ks = model.renderable.getLAOKernelSize();
      program.setUniformi("kernelSize", ks);
      const kernelSample = [];
      for (let i6 = 0; i6 < ks; i6++) {
        kernelSample[i6 * 2] = Math.random() * 0.5;
        kernelSample[i6 * 2 + 1] = Math.random() * 0.5;
      }
      program.setUniform2fv("kernelSample", kernelSample);
      program.setUniformi("kernelRadius", model.renderable.getLAOKernelRadius());
    }
  };
  publicAPI.setPropertyShaderParameters = (cellBO, ren, actor) => {
    const program = cellBO.getProgram();
    program.setUniformi("ctexture", model.colorTexture.getTextureUnit());
    program.setUniformi("otexture", model.opacityTexture.getTextureUnit());
    program.setUniformi("jtexture", model.jitterTexture.getTextureUnit());
    program.setUniformi("ttexture", model.labelOutlineThicknessTexture.getTextureUnit());
    const volInfo = model.scalarTexture.getVolumeInfo();
    const vprop = actor.getProperty();
    const numComp = model.scalarTexture.getComponents();
    const useIndependentComps = publicAPI.useIndependentComponents(vprop);
    if (useIndependentComps) {
      for (let i6 = 0; i6 < numComp; i6++) {
        program.setUniformf(`mix${i6}`, actor.getProperty().getComponentWeight(i6));
      }
    }
    for (let i6 = 0; i6 < numComp; i6++) {
      const target = useIndependentComps ? i6 : 0;
      const sscale = volInfo.scale[i6];
      const ofun = vprop.getScalarOpacity(target);
      const oRange = ofun.getRange();
      const oscale = sscale / (oRange[1] - oRange[0]);
      const oshift = (volInfo.offset[i6] - oRange[0]) / (oRange[1] - oRange[0]);
      program.setUniformf(`oshift${i6}`, oshift);
      program.setUniformf(`oscale${i6}`, oscale);
      const cfun = vprop.getRGBTransferFunction(target);
      const cRange = cfun.getRange();
      const cshift = (volInfo.offset[i6] - cRange[0]) / (cRange[1] - cRange[0]);
      const cScale = sscale / (cRange[1] - cRange[0]);
      program.setUniformf(`cshift${i6}`, cshift);
      program.setUniformf(`cscale${i6}`, cScale);
    }
    if (model.gopacity) {
      if (useIndependentComps) {
        for (let nc = 0; nc < numComp; ++nc) {
          const sscale = volInfo.scale[nc];
          const useGO = vprop.getUseGradientOpacity(nc);
          if (useGO) {
            const gomin = vprop.getGradientOpacityMinimumOpacity(nc);
            const gomax = vprop.getGradientOpacityMaximumOpacity(nc);
            program.setUniformf(`gomin${nc}`, gomin);
            program.setUniformf(`gomax${nc}`, gomax);
            const goRange = [vprop.getGradientOpacityMinimumValue(nc), vprop.getGradientOpacityMaximumValue(nc)];
            program.setUniformf(`goscale${nc}`, sscale * (gomax - gomin) / (goRange[1] - goRange[0]));
            program.setUniformf(`goshift${nc}`, -goRange[0] * (gomax - gomin) / (goRange[1] - goRange[0]) + gomin);
          } else {
            program.setUniformf(`gomin${nc}`, 1);
            program.setUniformf(`gomax${nc}`, 1);
            program.setUniformf(`goscale${nc}`, 0);
            program.setUniformf(`goshift${nc}`, 1);
          }
        }
      } else {
        const sscale = volInfo.scale[numComp - 1];
        const gomin = vprop.getGradientOpacityMinimumOpacity(0);
        const gomax = vprop.getGradientOpacityMaximumOpacity(0);
        program.setUniformf("gomin0", gomin);
        program.setUniformf("gomax0", gomax);
        const goRange = [vprop.getGradientOpacityMinimumValue(0), vprop.getGradientOpacityMaximumValue(0)];
        program.setUniformf("goscale0", sscale * (gomax - gomin) / (goRange[1] - goRange[0]));
        program.setUniformf("goshift0", -goRange[0] * (gomax - gomin) / (goRange[1] - goRange[0]) + gomin);
      }
    }
    const vtkImageLabelOutline = actor.getProperty().getUseLabelOutline();
    if (vtkImageLabelOutline === true) {
      const labelOutlineOpacity = actor.getProperty().getLabelOutlineOpacity();
      program.setUniformf("outlineOpacity", labelOutlineOpacity);
    }
    if (model.lightComplexity > 0) {
      program.setUniformf("vAmbient", vprop.getAmbient());
      program.setUniformf("vDiffuse", vprop.getDiffuse());
      program.setUniformf("vSpecular", vprop.getSpecular());
      program.setUniformf("vSpecularPower", vprop.getSpecularPower());
    }
  };
  publicAPI.getClippingPlaneShaderParameters = (cellBO, ren, actor) => {
    if (model.renderable.getClippingPlanes().length > 0) {
      const keyMats = model.openGLCamera.getKeyMatrices(ren);
      const clipPlaneNormals = [];
      const clipPlaneDistances = [];
      const clipPlaneOrigins = [];
      const clipPlanes = model.renderable.getClippingPlanes();
      const clipPlaneSize = clipPlanes.length;
      for (let i6 = 0; i6 < clipPlaneSize; ++i6) {
        const clipPlaneNormal = clipPlanes[i6].getNormal();
        const clipPlanePos = clipPlanes[i6].getOrigin();
        vec3_exports.transformMat3(clipPlaneNormal, clipPlaneNormal, keyMats.normalMatrix);
        vec3_exports.transformMat4(clipPlanePos, clipPlanePos, keyMats.wcvc);
        const clipPlaneDist = -1 * vec3_exports.dot(clipPlanePos, clipPlaneNormal);
        clipPlaneNormals.push(clipPlaneNormal[0]);
        clipPlaneNormals.push(clipPlaneNormal[1]);
        clipPlaneNormals.push(clipPlaneNormal[2]);
        clipPlaneDistances.push(clipPlaneDist);
        clipPlaneOrigins.push(clipPlanePos[0]);
        clipPlaneOrigins.push(clipPlanePos[1]);
        clipPlaneOrigins.push(clipPlanePos[2]);
      }
      const program = cellBO.getProgram();
      program.setUniform3fv(`vClipPlaneNormals`, clipPlaneNormals);
      program.setUniformfv(`vClipPlaneDistances`, clipPlaneDistances);
      program.setUniform3fv(`vClipPlaneOrigins`, clipPlaneOrigins);
      program.setUniformi(`clip_numPlanes`, clipPlaneSize);
    }
  };
  publicAPI.delete = chain(() => {
    if (model._animationRateSubscription) {
      model._animationRateSubscription.unsubscribe();
      model._animationRateSubscription = null;
    }
  }, publicAPI.delete);
  publicAPI.getRenderTargetSize = () => {
    if (model._useSmallViewport) {
      return [model._smallViewportWidth, model._smallViewportHeight];
    }
    const {
      usize,
      vsize
    } = model._openGLRenderer.getTiledSizeAndOrigin();
    return [usize, vsize];
  };
  publicAPI.getRenderTargetOffset = () => {
    const {
      lowerLeftU,
      lowerLeftV
    } = model._openGLRenderer.getTiledSizeAndOrigin();
    return [lowerLeftU, lowerLeftV];
  };
  publicAPI.getCurrentSampleDistance = (ren) => {
    const rwi = ren.getVTKWindow().getInteractor();
    const baseSampleDistance = model.renderable.getSampleDistance();
    if (rwi.isAnimating()) {
      const factor = model.renderable.getInteractionSampleDistanceFactor();
      return baseSampleDistance * factor;
    }
    return baseSampleDistance;
  };
  publicAPI.renderPieceStart = (ren, actor) => {
    const rwi = ren.getVTKWindow().getInteractor();
    if (!model._lastScale) {
      model._lastScale = model.renderable.getInitialInteractionScale();
    }
    model._useSmallViewport = false;
    if (rwi.isAnimating() && model._lastScale > 1.5) {
      model._useSmallViewport = true;
    }
    if (!model._animationRateSubscription) {
      model._animationRateSubscription = rwi.onAnimationFrameRateUpdate(() => {
        if (model.renderable.getAutoAdjustSampleDistances()) {
          const frate = rwi.getRecentAnimationFrameRate();
          const adjustment = rwi.getDesiredUpdateRate() / frate;
          if (adjustment > 1.15 || adjustment < 0.85) {
            model._lastScale *= adjustment;
          }
          if (model._lastScale > 400) {
            model._lastScale = 400;
          }
          if (model._lastScale < 1.5) {
            model._lastScale = 1.5;
          }
        } else {
          model._lastScale = model.renderable.getImageSampleDistance() * model.renderable.getImageSampleDistance();
        }
      });
    }
    if (model._useSmallViewport) {
      const size3 = model._openGLRenderWindow.getFramebufferSize();
      const scaleFactor = 1 / Math.sqrt(model._lastScale);
      model._smallViewportWidth = Math.ceil(scaleFactor * size3[0]);
      model._smallViewportHeight = Math.ceil(scaleFactor * size3[1]);
      if (model._smallViewportHeight > size3[1]) {
        model._smallViewportHeight = size3[1];
      }
      if (model._smallViewportWidth > size3[0]) {
        model._smallViewportWidth = size3[0];
      }
      model.framebuffer.saveCurrentBindingsAndBuffers();
      if (model.framebuffer.getGLFramebuffer() === null) {
        model.framebuffer.create(size3[0], size3[1]);
        model.framebuffer.populateFramebuffer();
      } else {
        const fbSize = model.framebuffer.getSize();
        if (!fbSize || fbSize[0] !== size3[0] || fbSize[1] !== size3[1]) {
          model.framebuffer.create(size3[0], size3[1]);
          model.framebuffer.populateFramebuffer();
        }
      }
      model.framebuffer.bind();
      const gl = model.context;
      gl.clearColor(0, 0, 0, 0);
      gl.colorMask(true, true, true, true);
      gl.clear(gl.COLOR_BUFFER_BIT);
      gl.viewport(0, 0, model._smallViewportWidth, model._smallViewportHeight);
      model.fvp = [model._smallViewportWidth / size3[0], model._smallViewportHeight / size3[1]];
    }
    model.context.disable(model.context.DEPTH_TEST);
    publicAPI.updateBufferObjects(ren, actor);
    const iType = actor.getProperty().getInterpolationType();
    if (iType === InterpolationType2.NEAREST) {
      model.scalarTexture.setMinificationFilter(Filter.NEAREST);
      model.scalarTexture.setMagnificationFilter(Filter.NEAREST);
    } else {
      model.scalarTexture.setMinificationFilter(Filter.LINEAR);
      model.scalarTexture.setMagnificationFilter(Filter.LINEAR);
    }
    if (model.zBufferTexture !== null) {
      model.zBufferTexture.activate();
    }
  };
  publicAPI.renderPieceDraw = (ren, actor) => {
    const gl = model.context;
    model.scalarTexture.activate();
    model.opacityTexture.activate();
    model.labelOutlineThicknessTexture.activate();
    model.colorTexture.activate();
    model.jitterTexture.activate();
    publicAPI.updateShaders(model.tris, ren, actor);
    gl.drawArrays(gl.TRIANGLES, 0, model.tris.getCABO().getElementCount());
    model.tris.getVAO().release();
    model.scalarTexture.deactivate();
    model.colorTexture.deactivate();
    model.opacityTexture.deactivate();
    model.labelOutlineThicknessTexture.deactivate();
    model.jitterTexture.deactivate();
  };
  publicAPI.renderPieceFinish = (ren, actor) => {
    if (model.zBufferTexture !== null) {
      model.zBufferTexture.deactivate();
    }
    if (model._useSmallViewport) {
      model.framebuffer.restorePreviousBindingsAndBuffers();
      if (model.copyShader === null) {
        model.copyShader = model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(["//VTK::System::Dec", "attribute vec4 vertexDC;", "uniform vec2 tfactor;", "varying vec2 tcoord;", "void main() { tcoord = vec2(vertexDC.x*0.5 + 0.5, vertexDC.y*0.5 + 0.5) * tfactor; gl_Position = vertexDC; }"].join("\n"), ["//VTK::System::Dec", "//VTK::Output::Dec", "uniform sampler2D texture1;", "varying vec2 tcoord;", "void main() { gl_FragData[0] = texture2D(texture1,tcoord); }"].join("\n"), "");
        const program = model.copyShader;
        model.copyVAO = vtkVertexArrayObject.newInstance();
        model.copyVAO.setOpenGLRenderWindow(model._openGLRenderWindow);
        model.tris.getCABO().bind();
        if (!model.copyVAO.addAttributeArray(program, model.tris.getCABO(), "vertexDC", model.tris.getCABO().getVertexOffset(), model.tris.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {
          vtkErrorMacro18("Error setting vertexDC in copy shader VAO.");
        }
      } else {
        model._openGLRenderWindow.getShaderCache().readyShaderProgram(model.copyShader);
      }
      const size3 = model._openGLRenderWindow.getFramebufferSize();
      model.context.viewport(0, 0, size3[0], size3[1]);
      const tex = model.framebuffer.getColorTexture();
      tex.activate();
      model.copyShader.setUniformi("texture", tex.getTextureUnit());
      model.copyShader.setUniform2f("tfactor", model.fvp[0], model.fvp[1]);
      const gl = model.context;
      gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
      model.context.drawArrays(model.context.TRIANGLES, 0, model.tris.getCABO().getElementCount());
      tex.deactivate();
      gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
    }
  };
  publicAPI.renderPiece = (ren, actor) => {
    publicAPI.invokeEvent({
      type: "StartEvent"
    });
    model.renderable.update();
    model.currentInput = model.renderable.getInputData();
    publicAPI.invokeEvent({
      type: "EndEvent"
    });
    if (!model.currentInput) {
      vtkErrorMacro18("No input!");
      return;
    }
    publicAPI.renderPieceStart(ren, actor);
    publicAPI.renderPieceDraw(ren, actor);
    publicAPI.renderPieceFinish(ren, actor);
  };
  publicAPI.computeBounds = (ren, actor) => {
    if (!publicAPI.getInput()) {
      uninitializeBounds(model.Bounds);
      return;
    }
    model.bounds = publicAPI.getInput().getBounds();
  };
  publicAPI.updateBufferObjects = (ren, actor) => {
    if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {
      publicAPI.buildBufferObjects(ren, actor);
    }
  };
  publicAPI.getNeedToRebuildBufferObjects = (ren, actor) => {
    if (model.VBOBuildTime.getMTime() < publicAPI.getMTime() || model.VBOBuildTime.getMTime() < actor.getMTime() || model.VBOBuildTime.getMTime() < model.renderable.getMTime() || model.VBOBuildTime.getMTime() < actor.getProperty().getMTime() || model.VBOBuildTime.getMTime() < model.currentInput.getMTime()) {
      return true;
    }
    return false;
  };
  publicAPI.buildBufferObjects = (ren, actor) => {
    const image2 = model.currentInput;
    if (!image2) {
      return;
    }
    const scalars = image2.getPointData() && image2.getPointData().getScalars();
    if (!scalars) {
      return;
    }
    if (model._scalars !== scalars) {
      model._openGLRenderWindow.releaseGraphicsResourcesForObject(model._scalars);
      model._scalars = scalars;
    }
    const vprop = actor.getProperty();
    if (!model.jitterTexture.getHandle()) {
      const oTable = new Uint8Array(32 * 32);
      for (let i6 = 0; i6 < 32 * 32; ++i6) {
        oTable[i6] = 255 * Math.random();
      }
      model.jitterTexture.setMinificationFilter(Filter.LINEAR);
      model.jitterTexture.setMagnificationFilter(Filter.LINEAR);
      model.jitterTexture.create2DFromRaw(32, 32, 1, VtkDataTypes.UNSIGNED_CHAR, oTable);
    }
    const numComp = scalars.getNumberOfComponents();
    const useIndependentComps = publicAPI.useIndependentComponents(vprop);
    const numIComps = useIndependentComps ? numComp : 1;
    const scalarOpacityFunc = vprop.getScalarOpacity();
    const opTex = model._openGLRenderWindow.getGraphicsResourceForObject(scalarOpacityFunc);
    let toString3 = computeFnToString4(scalarOpacityFunc, useIndependentComps, numIComps);
    const reBuildOp = !opTex.vtkObj || opTex.hash !== toString3 || model.opacityTextureString !== toString3;
    if (reBuildOp) {
      const oWidth = 1024;
      const oSize = oWidth * 2 * numIComps;
      const ofTable = new Float32Array(oSize);
      const tmpTable = new Float32Array(oWidth);
      for (let c6 = 0; c6 < numIComps; ++c6) {
        const ofun = vprop.getScalarOpacity(c6);
        const opacityFactor = publicAPI.getCurrentSampleDistance(ren) / vprop.getScalarOpacityUnitDistance(c6);
        const oRange = ofun.getRange();
        ofun.getTable(oRange[0], oRange[1], oWidth, tmpTable, 1);
        for (let i6 = 0; i6 < oWidth; ++i6) {
          ofTable[c6 * oWidth * 2 + i6] = 1 - __pow(1 - tmpTable[i6], opacityFactor);
          ofTable[c6 * oWidth * 2 + i6 + oWidth] = ofTable[c6 * oWidth * 2 + i6];
        }
      }
      model.opacityTexture.releaseGraphicsResources(model._openGLRenderWindow);
      model.opacityTexture.resetFormatAndType();
      model.opacityTexture.setMinificationFilter(Filter.LINEAR);
      model.opacityTexture.setMagnificationFilter(Filter.LINEAR);
      if (model._openGLRenderWindow.getWebgl2() || model.context.getExtension("OES_texture_float") && model.context.getExtension("OES_texture_float_linear")) {
        model.opacityTexture.create2DFromRaw(oWidth, 2 * numIComps, 1, VtkDataTypes.FLOAT, ofTable);
      } else {
        const oTable = new Uint8ClampedArray(oSize);
        for (let i6 = 0; i6 < oSize; ++i6) {
          oTable[i6] = 255 * ofTable[i6];
        }
        model.opacityTexture.create2DFromRaw(oWidth, 2 * numIComps, 1, VtkDataTypes.UNSIGNED_CHAR, oTable);
      }
      model.opacityTextureString = toString3;
      if (scalarOpacityFunc) {
        model._openGLRenderWindow.setGraphicsResourceForObject(scalarOpacityFunc, model.opacityTexture, model.opacityTextureString);
      }
    } else {
      model.opacityTexture = opTex.vtkObj;
      model.opacityTextureString = opTex.hash;
    }
    const colorTransferFunc = vprop.getRGBTransferFunction();
    toString3 = computeFnToString4(colorTransferFunc, useIndependentComps, numIComps);
    const cTex = model._openGLRenderWindow.getGraphicsResourceForObject(colorTransferFunc);
    const reBuildC = !(cTex == null ? void 0 : cTex.vtkObj) || (cTex == null ? void 0 : cTex.hash) !== toString3 || model.colorTextureString !== toString3;
    if (reBuildC) {
      const cWidth = 1024;
      const cSize = cWidth * 2 * numIComps * 3;
      const cTable = new Uint8ClampedArray(cSize);
      const tmpTable = new Float32Array(cWidth * 3);
      for (let c6 = 0; c6 < numIComps; ++c6) {
        const cfun = vprop.getRGBTransferFunction(c6);
        const cRange = cfun.getRange();
        cfun.getTable(cRange[0], cRange[1], cWidth, tmpTable, 1);
        for (let i6 = 0; i6 < cWidth * 3; ++i6) {
          cTable[c6 * cWidth * 6 + i6] = 255 * tmpTable[i6];
          cTable[c6 * cWidth * 6 + i6 + cWidth * 3] = 255 * tmpTable[i6];
        }
      }
      model.colorTexture.releaseGraphicsResources(model._openGLRenderWindow);
      model.colorTexture.resetFormatAndType();
      model.colorTexture.setMinificationFilter(Filter.LINEAR);
      model.colorTexture.setMagnificationFilter(Filter.LINEAR);
      model.colorTexture.create2DFromRaw(cWidth, 2 * numIComps, 3, VtkDataTypes.UNSIGNED_CHAR, cTable);
      model.colorTextureString = toString3;
      if (colorTransferFunc) {
        model._openGLRenderWindow.setGraphicsResourceForObject(colorTransferFunc, model.colorTexture, model.colorTextureString);
      }
    } else {
      model.colorTexture = cTex.vtkObj;
      model.colorTextureString = cTex.hash;
    }
    publicAPI.updateLabelOutlineThicknessTexture(actor);
    const tex = model._openGLRenderWindow.getGraphicsResourceForObject(scalars);
    toString3 = `${image2.getMTime()}A${scalars.getMTime()}`;
    const reBuildTex = !(tex == null ? void 0 : tex.vtkObj) || (tex == null ? void 0 : tex.hash) !== toString3;
    if (reBuildTex) {
      const dims = image2.getDimensions();
      model.scalarTexture.setOglNorm16Ext(model.context.getExtension("EXT_texture_norm16"));
      model.scalarTexture.releaseGraphicsResources(model._openGLRenderWindow);
      model.scalarTexture.resetFormatAndType();
      model.scalarTexture.create3DFilterableFromDataArray(dims[0], dims[1], dims[2], scalars, model.renderable.getPreferSizeOverAccuracy());
      if (scalars) {
        model._openGLRenderWindow.setGraphicsResourceForObject(scalars, model.scalarTexture, toString3);
      }
    } else {
      model.scalarTexture = tex.vtkObj;
    }
    if (!model.tris.getCABO().getElementCount()) {
      const ptsArray = new Float32Array(12);
      for (let i6 = 0; i6 < 4; i6++) {
        ptsArray[i6 * 3] = i6 % 2 * 2 - 1;
        ptsArray[i6 * 3 + 1] = i6 > 1 ? 1 : -1;
        ptsArray[i6 * 3 + 2] = -1;
      }
      const cellArray = new Uint16Array(8);
      cellArray[0] = 3;
      cellArray[1] = 0;
      cellArray[2] = 1;
      cellArray[3] = 3;
      cellArray[4] = 3;
      cellArray[5] = 0;
      cellArray[6] = 3;
      cellArray[7] = 2;
      const points = vtkDataArray$1.newInstance({
        numberOfComponents: 3,
        values: ptsArray
      });
      points.setName("points");
      const cells = vtkDataArray$1.newInstance({
        numberOfComponents: 1,
        values: cellArray
      });
      model.tris.getCABO().createVBO(cells, "polys", Representation.SURFACE, {
        points,
        cellOffset: 0
      });
    }
    model.VBOBuildTime.modified();
  };
  publicAPI.updateLabelOutlineThicknessTexture = (volume) => {
    const labelOutlineThicknessArray = volume.getProperty().getLabelOutlineThickness();
    const lTex = model._openGLRenderWindow.getGraphicsResourceForObject(labelOutlineThicknessArray);
    const toString3 = `${labelOutlineThicknessArray.join("-")}`;
    const reBuildL = !(lTex == null ? void 0 : lTex.vtkObj) || (lTex == null ? void 0 : lTex.hash) !== toString3 || model.labelOutlineThicknessTextureString !== toString3;
    if (reBuildL) {
      const lWidth = 1024;
      const lHeight = 1;
      const lSize = lWidth * lHeight;
      const lTable = new Uint8Array(lSize);
      for (let i6 = 0; i6 < lWidth; ++i6) {
        const thickness = typeof labelOutlineThicknessArray[i6] !== "undefined" ? labelOutlineThicknessArray[i6] : labelOutlineThicknessArray[0];
        lTable[i6] = thickness;
      }
      model.labelOutlineThicknessTexture.releaseGraphicsResources(model._openGLRenderWindow);
      model.labelOutlineThicknessTexture.resetFormatAndType();
      model.labelOutlineThicknessTexture.setMinificationFilter(Filter.NEAREST);
      model.labelOutlineThicknessTexture.setMagnificationFilter(Filter.NEAREST);
      model.labelOutlineThicknessTexture.create2DFromRaw(lWidth, lHeight, 1, VtkDataTypes.UNSIGNED_CHAR, lTable);
      model.labelOutlineThicknessTextureString = toString3;
      if (labelOutlineThicknessArray) {
        model._openGLRenderWindow.setGraphicsResourceForObject(labelOutlineThicknessArray, model.labelOutlineThicknessTexture, model.labelOutlineThicknessTextureString);
      }
    } else {
      model.labelOutlineThicknessTexture = lTex.vtkObj;
      model.labelOutlineThicknessTextureString = lTex.hash;
    }
  };
}
var DEFAULT_VALUES37 = {
  context: null,
  VBOBuildTime: null,
  scalarTexture: null,
  opacityTexture: null,
  opacityTextureString: null,
  colorTexture: null,
  colorTextureString: null,
  jitterTexture: null,
  labelOutlineThicknessTexture: null,
  labelOutlineThicknessTextureString: null,
  tris: null,
  framebuffer: null,
  copyShader: null,
  copyVAO: null,
  lastXYF: 1,
  targetXYF: 1,
  zBufferTexture: null,
  lastZBufferTexture: null,
  lightComplexity: 0,
  fullViewportTime: 1,
  idxToView: null,
  idxNormalMatrix: null,
  modelToView: null,
  projectionToView: null,
  avgWindowArea: 0,
  avgFrameTime: 0,
  _scalars: null
};
function extend38(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES37, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  vtkReplacementShaderMapper.implementBuildShadersWithReplacements(publicAPI, model, initialValues);
  model.VBOBuildTime = {};
  obj(model.VBOBuildTime, {
    mtime: 0
  });
  model.tris = vtkHelper.newInstance();
  model.scalarTexture = vtkOpenGLTexture$1.newInstance();
  model.opacityTexture = vtkOpenGLTexture$1.newInstance();
  model.colorTexture = vtkOpenGLTexture$1.newInstance();
  model.jitterTexture = vtkOpenGLTexture$1.newInstance();
  model.jitterTexture.setWrapS(Wrap.REPEAT);
  model.jitterTexture.setWrapT(Wrap.REPEAT);
  model.labelOutlineThicknessTexture = vtkOpenGLTexture$1.newInstance();
  model.framebuffer = vtkOpenGLFramebuffer.newInstance();
  model.idxToView = mat4_exports.identity(new Float64Array(16));
  model.idxNormalMatrix = mat3_exports.identity(new Float64Array(9));
  model.modelToView = mat4_exports.identity(new Float64Array(16));
  model.projectionToView = mat4_exports.identity(new Float64Array(16));
  model.projectionToWorld = mat4_exports.identity(new Float64Array(16));
  setGet(publicAPI, model, ["context"]);
  vtkOpenGLVolumeMapper(publicAPI, model);
}
var newInstance39 = newInstance(extend38, "vtkOpenGLVolumeMapper");
registerOverride("vtkVolumeMapper", newInstance39);

// node_modules/@kitware/vtk.js/Rendering/OpenGL/PixelSpaceCallbackMapper.js
var {
  vtkDebugMacro: vtkDebugMacro4
} = macro$1;
function vtkOpenGLPixelSpaceCallbackMapper(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLPixelSpaceCallbackMapper");
  publicAPI.opaquePass = (prepass, renderPass) => {
    model._openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
    model._openGLRenderWindow = model._openGLRenderer.getParent();
    const aspectRatio = model._openGLRenderer.getAspectRatio();
    const camera = model._openGLRenderer ? model._openGLRenderer.getRenderable().getActiveCamera() : null;
    const tsize = model._openGLRenderer.getTiledSizeAndOrigin();
    let texels = null;
    if (model.renderable.getUseZValues()) {
      const zbt = renderPass.getZBufferTexture();
      const width = Math.floor(zbt.getWidth());
      const height = Math.floor(zbt.getHeight());
      const gl = model._openGLRenderWindow.getContext();
      zbt.bind();
      const fb = renderPass.getFramebuffer();
      if (!fb) {
        vtkDebugMacro4("No framebuffer to save/restore");
      } else {
        fb.saveCurrentBindingsAndBuffers();
      }
      const framebuffer = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, zbt.getHandle(), 0);
      if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE) {
        texels = new Uint8Array(width * height * 4);
        gl.viewport(0, 0, width, height);
        gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, texels);
      }
      if (fb) {
        fb.restorePreviousBindingsAndBuffers();
      }
      gl.deleteFramebuffer(framebuffer);
    }
    model.renderable.invokeCallback(model.renderable.getInputData(), camera, aspectRatio, tsize, texels);
  };
  publicAPI.queryPass = (prepass, renderPass) => {
    if (prepass) {
      if (model.renderable.getUseZValues()) {
        renderPass.requestDepth();
      }
    }
  };
}
var DEFAULT_VALUES38 = {};
function extend39(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES38, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  vtkOpenGLPixelSpaceCallbackMapper(publicAPI, model);
}
var newInstance40 = newInstance(extend39, "vtkOpenGLPixelSpaceCallbackMapper");
registerOverride("vtkPixelSpaceCallbackMapper", newInstance40);

// node_modules/@kitware/vtk.js/Rendering/WebGPU/ViewNodeFactory.js
var CLASS_MAPPING2 = /* @__PURE__ */ Object.create(null);
function registerOverride2(className, fn) {
  CLASS_MAPPING2[className] = fn;
}
function vtkWebGPUViewNodeFactory(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUViewNodeFactory");
}
var DEFAULT_VALUES39 = {};
function extend40(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES39, initialValues);
  model.overrides = CLASS_MAPPING2;
  vtkViewNodeFactory$1.extend(publicAPI, model, initialValues);
  vtkWebGPUViewNodeFactory(publicAPI, model);
}
var newInstance41 = macro.newInstance(extend40, "vtkWebGPUViewNodeFactory");
var vtkWebGPUViewNodeFactory$1 = {
  newInstance: newInstance41,
  extend: extend40
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/Camera.js
function vtkWebGPUCamera(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUCamera");
  publicAPI.getProjectionMatrix = (outMat, aspect, cRange, windowCenter) => {
    mat4_exports.identity(outMat);
    if (model.renderable.getParallelProjection()) {
      const parallelScale = model.renderable.getParallelScale();
      const width = parallelScale * aspect;
      const height = parallelScale;
      const xmin = (windowCenter[0] - 1) * width;
      const xmax = (windowCenter[0] + 1) * width;
      const ymin = (windowCenter[1] - 1) * height;
      const ymax = (windowCenter[1] + 1) * height;
      const xr = 1 / (xmax - xmin);
      const yr = 1 / (ymax - ymin);
      outMat[0] = 2 * xr;
      outMat[5] = 2 * yr;
      outMat[10] = 1 / (cRange[1] - cRange[0]);
      outMat[12] = (xmax + xmin) * xr;
      outMat[13] = (ymax + ymin) * yr;
      outMat[14] = cRange[1] / (cRange[1] - cRange[0]);
    } else {
      const tmp = Math.tan(Math.PI * model.renderable.getViewAngle() / 360);
      let width;
      let height;
      if (model.renderable.getUseHorizontalViewAngle() === true) {
        width = cRange[0] * tmp;
        height = cRange[0] * tmp / aspect;
      } else {
        width = cRange[0] * tmp * aspect;
        height = cRange[0] * tmp;
      }
      const xmin = (windowCenter[0] - 1) * width;
      const xmax = (windowCenter[0] + 1) * width;
      const ymin = (windowCenter[1] - 1) * height;
      const ymax = (windowCenter[1] + 1) * height;
      outMat[0] = 2 * cRange[0] / (xmax - xmin);
      outMat[5] = 2 * cRange[0] / (ymax - ymin);
      outMat[12] = (xmin + xmax) / (xmax - xmin);
      outMat[13] = (ymin + ymax) / (ymax - ymin);
      outMat[10] = 0;
      outMat[14] = cRange[0];
      outMat[11] = -1;
      outMat[15] = 0;
    }
  };
  publicAPI.convertToOpenGLDepth = (val) => {
    if (model.renderable.getParallelProjection()) {
      return 1 - val;
    }
    const cRange = model.renderable.getClippingRangeByReference();
    let zval = -cRange[0] / val;
    zval = (cRange[0] + cRange[1]) / (cRange[1] - cRange[0]) + 2 * cRange[0] * cRange[1] / (zval * (cRange[1] - cRange[0]));
    return 0.5 * zval + 0.5;
  };
  publicAPI.getKeyMatrices = (webGPURenderer) => {
    const ren = webGPURenderer.getRenderable();
    const webGPURenderWindow = webGPURenderer.getParent();
    if (Math.max(webGPURenderWindow.getMTime(), publicAPI.getMTime(), ren.getMTime(), model.renderable.getMTime(), webGPURenderer.getStabilizedTime()) > model.keyMatrixTime.getMTime()) {
      const wcvc = model.renderable.getViewMatrix();
      mat4_exports.copy(model.keyMatrices.normalMatrix, wcvc);
      model.keyMatrices.normalMatrix[3] = 0;
      model.keyMatrices.normalMatrix[7] = 0;
      model.keyMatrices.normalMatrix[11] = 0;
      mat4_exports.invert(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);
      mat4_exports.transpose(model.keyMatrices.wcvc, wcvc);
      const center = webGPURenderer.getStabilizedCenterByReference();
      mat4_exports.translate(model.keyMatrices.scvc, model.keyMatrices.wcvc, center);
      const aspectRatio = webGPURenderer.getAspectRatio();
      const cRange = model.renderable.getClippingRangeByReference();
      publicAPI.getProjectionMatrix(model.keyMatrices.vcpc, aspectRatio, cRange, model.renderable.getWindowCenterByReference());
      mat4_exports.multiply(model.keyMatrices.scpc, model.keyMatrices.vcpc, model.keyMatrices.scvc);
      mat4_exports.invert(model.keyMatrices.pcsc, model.keyMatrices.scpc);
      model.keyMatrixTime.modified();
    }
    return model.keyMatrices;
  };
}
var DEFAULT_VALUES40 = {
  keyMatrixTime: null,
  keyMatrices: null
};
function extend41(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES40, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.keyMatrixTime = {};
  macro.obj(model.keyMatrixTime);
  model.keyMatrices = {
    normalMatrix: new Float64Array(16),
    vcpc: new Float64Array(16),
    pcsc: new Float64Array(16),
    wcvc: new Float64Array(16),
    scpc: new Float64Array(16),
    scvc: new Float64Array(16)
  };
  macro.setGet(publicAPI, model, ["keyMatrixTime"]);
  vtkWebGPUCamera(publicAPI, model);
}
var newInstance42 = macro.newInstance(extend41);
registerOverride2("vtkCamera", newInstance42);

// node_modules/@kitware/vtk.js/Rendering/WebGPU/BindGroup.js
function vtkWebGPUBindGroup(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUBindGroup");
  publicAPI.setBindables = (bindables) => {
    if (model.bindables.length === bindables.length) {
      let allMatch = true;
      for (let i6 = 0; i6 < model.bindables.length; i6++) {
        if (model.bindables[i6] !== bindables[i6]) {
          allMatch = false;
        }
      }
      if (allMatch) {
        return;
      }
    }
    model.bindables = bindables;
    publicAPI.modified();
  };
  publicAPI.getBindGroupLayout = (device) => {
    const entries = [];
    for (let i6 = 0; i6 < model.bindables.length; i6++) {
      const entry = model.bindables[i6].getBindGroupLayoutEntry();
      entry.binding = i6;
      entries.push(entry);
    }
    return device.getBindGroupLayout({
      entries
    });
  };
  publicAPI.getBindGroup = (device) => {
    let mtime = publicAPI.getMTime();
    for (let i6 = 0; i6 < model.bindables.length; i6++) {
      const tm = model.bindables[i6].getBindGroupTime().getMTime();
      mtime = tm > mtime ? tm : mtime;
    }
    if (mtime < model.bindGroupTime.getMTime()) {
      return model.bindGroup;
    }
    const entries = [];
    for (let i6 = 0; i6 < model.bindables.length; i6++) {
      const entry = model.bindables[i6].getBindGroupEntry();
      entry.binding = i6;
      entries.push(entry);
    }
    model.bindGroup = device.getHandle().createBindGroup({
      layout: publicAPI.getBindGroupLayout(device),
      entries,
      label: model.label
    });
    model.bindGroupTime.modified();
    return model.bindGroup;
  };
  publicAPI.getShaderCode = (pipeline) => {
    const lines = [];
    const bgroup = pipeline.getBindGroupLayoutCount(model.label);
    for (let i6 = 0; i6 < model.bindables.length; i6++) {
      lines.push(model.bindables[i6].getShaderCode(i6, bgroup));
    }
    return lines.join("\n");
  };
}
var DEFAULT_VALUES41 = {
  device: null,
  handle: null,
  label: null
};
function extend42(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES41, initialValues);
  macro.obj(publicAPI, model);
  model.bindables = [];
  model.bindGroupTime = {};
  macro.obj(model.bindGroupTime, {
    mtime: 0
  });
  macro.get(publicAPI, model, ["bindGroupTime", "handle", "sizeInBytes", "usage"]);
  macro.setGet(publicAPI, model, ["label", "device", "arrayInformation"]);
  vtkWebGPUBindGroup(publicAPI, model);
}
var newInstance43 = macro.newInstance(extend42);
var vtkWebGPUBindGroup$1 = {
  newInstance: newInstance43,
  extend: extend42
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/ShaderModule.js
function vtkWebGPUShaderModule(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUShaderModule");
  publicAPI.initialize = (device, shaderDesc) => {
    model.device = device;
    model.handle = model.device.getHandle().createShaderModule({
      code: shaderDesc.getCode()
    });
  };
}
var DEFAULT_VALUES42 = {
  device: null,
  handle: null
};
function extend43(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES42, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["lastCameraMTime"]);
  macro.setGet(publicAPI, model, ["device", "handle"]);
  vtkWebGPUShaderModule(publicAPI, model);
}
var newInstance44 = macro.newInstance(extend43, "vtkWebGPUShaderModule");
var vtkWebGPUShaderModule$1 = {
  newInstance: newInstance44,
  extend: extend43
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/ShaderCache.js
function substitute2(source, search, replace) {
  let all3 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
  const replaceStr = Array.isArray(replace) ? replace.join("\n") : replace;
  let replaced = false;
  if (source.search(search) !== -1) {
    replaced = true;
  }
  let gflag = "";
  if (all3) {
    gflag = "g";
  }
  const regex = new RegExp(search, gflag);
  const resultstr = source.replace(regex, replaceStr);
  return {
    replace: replaced,
    result: resultstr
  };
}
function vtkWebGPUShaderCache(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUShaderCache");
  publicAPI.getShaderModule = (shaderDesc) => {
    const sType = shaderDesc.getType();
    const sHash = shaderDesc.getHash();
    const keys = model._shaderModules.keys();
    for (let i6 = 0; i6 < keys.length; i6++) {
      const key = keys[i6];
      if (key.getHash() === sHash && key.getType() === sType) {
        return model._shaderModules.get(key);
      }
    }
    const sm = vtkWebGPUShaderModule$1.newInstance();
    sm.initialize(model.device, shaderDesc);
    model._shaderModules.set(shaderDesc, sm);
    return sm;
  };
}
var DEFAULT_VALUES43 = {
  shaderModules: null,
  device: null,
  window: null
};
function extend44(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES43, initialValues);
  model._shaderModules = /* @__PURE__ */ new Map();
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["device", "window"]);
  vtkWebGPUShaderCache(publicAPI, model);
}
var newInstance45 = macro.newInstance(extend44, "vtkWebGPUShaderCache");
var vtkWebGPUShaderCache$1 = {
  newInstance: newInstance45,
  extend: extend44,
  substitute: substitute2
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/Pipeline.js
function vtkWebGPUPipeline(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUPipeline");
  publicAPI.getShaderDescriptions = () => model.shaderDescriptions;
  publicAPI.initialize = (device, hash) => {
    model.pipelineDescription = model.renderEncoder.getPipelineSettings();
    model.pipelineDescription.primitive.topology = model.topology;
    model.pipelineDescription.vertex = model.vertexState;
    model.pipelineDescription.label = hash;
    const bindGroupLayouts = [];
    for (let i6 = 0; i6 < model.layouts.length; i6++) {
      bindGroupLayouts.push(model.layouts[i6].layout);
    }
    model.pipelineLayout = device.getHandle().createPipelineLayout({
      bindGroupLayouts
    });
    model.pipelineDescription.layout = model.pipelineLayout;
    for (let i6 = 0; i6 < model.shaderDescriptions.length; i6++) {
      const sd = model.shaderDescriptions[i6];
      const sm = device.getShaderModule(sd);
      if (sd.getType() === "vertex") {
        model.pipelineDescription.vertex.module = sm.getHandle();
        model.pipelineDescription.vertex.entryPoint = "main";
      }
      if (sd.getType() === "fragment") {
        model.pipelineDescription.fragment.module = sm.getHandle();
        model.pipelineDescription.fragment.entryPoint = "main";
      }
    }
    model.handle = device.getHandle().createRenderPipeline(model.pipelineDescription);
  };
  publicAPI.getShaderDescription = (stype) => {
    for (let i6 = 0; i6 < model.shaderDescriptions.length; i6++) {
      if (model.shaderDescriptions[i6].getType() === stype) return model.shaderDescriptions[i6];
    }
    return null;
  };
  publicAPI.addBindGroupLayout = (bindGroup) => {
    if (!bindGroup) {
      return;
    }
    model.layouts.push({
      layout: bindGroup.getBindGroupLayout(model.device),
      label: bindGroup.getLabel()
    });
  };
  publicAPI.getBindGroupLayout = (idx) => model.layouts[idx].layout;
  publicAPI.getBindGroupLayoutCount = (llabel) => {
    for (let i6 = 0; i6 < model.layouts.length; i6++) {
      if (model.layouts[i6].label === llabel) {
        return i6;
      }
    }
    return 0;
  };
  publicAPI.bindVertexInput = (renderEncoder, vInput) => {
    vInput.bindBuffers(renderEncoder);
  };
}
var DEFAULT_VALUES44 = {
  handle: null,
  layouts: null,
  renderEncoder: null,
  shaderDescriptions: null,
  vertexState: null,
  topology: null,
  pipelineDescription: null
};
function extend45(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES44, initialValues);
  obj(publicAPI, model);
  model.layouts = [];
  model.shaderDescriptions = [];
  get(publicAPI, model, ["handle", "pipelineDescription"]);
  setGet(publicAPI, model, ["device", "renderEncoder", "topology", "vertexState"]);
  vtkWebGPUPipeline(publicAPI, model);
}
var newInstance46 = newInstance(extend45, "vtkWebGPUPipeline");
var vtkWebGPUPipeline$1 = {
  newInstance: newInstance46,
  extend: extend45
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/ShaderDescription.js
function vtkWebGPUShaderDescription(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUShaderDescription");
  publicAPI.hasOutput = (name) => model.outputNames.includes(name);
  publicAPI.addOutput = function(type, name) {
    let interpolation = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0;
    model.outputTypes.push(type);
    model.outputNames.push(name);
    model.outputInterpolations.push(interpolation);
  };
  publicAPI.addBuiltinOutput = (type, name) => {
    model.builtinOutputTypes.push(type);
    model.builtinOutputNames.push(name);
  };
  publicAPI.addBuiltinInput = (type, name) => {
    model.builtinInputTypes.push(type);
    model.builtinInputNames.push(name);
  };
  publicAPI.replaceShaderCode = (priorStage, vertexInput) => {
    const inputImpl = [];
    let iodec = [];
    if (vertexInput) {
      inputImpl.push(vertexInput.getShaderCode());
    }
    if (priorStage || model.builtinInputNames.length) {
      const inputStruct = [];
      inputStruct.push(`struct ${model.type}Input
{`);
      if (priorStage) {
        const inputNames = priorStage.getOutputNamesByReference();
        const inputTypes = priorStage.getOutputTypesByReference();
        const inputInterpolations = priorStage.getOutputInterpolationsByReference();
        for (let i6 = 0; i6 < inputNames.length; i6++) {
          if (inputInterpolations[i6] !== void 0) {
            inputStruct.push(`  @location(${i6}) @interpolate(${inputInterpolations[i6]}) ${inputNames[i6]} : ${inputTypes[i6]},`);
          } else {
            inputStruct.push(`  @location(${i6}) ${inputNames[i6]} : ${inputTypes[i6]},`);
          }
        }
      }
      for (let i6 = 0; i6 < model.builtinInputNames.length; i6++) {
        inputStruct.push(`  ${model.builtinInputNames[i6]} : ${model.builtinInputTypes[i6]},`);
      }
      if (inputStruct.length > 1) {
        inputStruct.push("};");
        iodec = inputStruct;
        inputImpl[inputImpl.length - 1] += ",";
        inputImpl.push(`input: ${model.type}Input`);
      }
    }
    if (inputImpl.length) {
      model.code = vtkWebGPUShaderCache$1.substitute(model.code, "//VTK::IOStructs::Input", inputImpl).result;
    }
    if (model.outputNames.length + model.builtinOutputNames.length) {
      const outputStruct = [`struct ${model.type}Output
{`];
      for (let i6 = 0; i6 < model.outputNames.length; i6++) {
        if (model.outputInterpolations[i6] !== void 0) {
          outputStruct.push(`  @location(${i6}) @interpolate(${model.outputInterpolations[i6]}) ${model.outputNames[i6]} : ${model.outputTypes[i6]},`);
        } else {
          outputStruct.push(`  @location(${i6}) ${model.outputNames[i6]} : ${model.outputTypes[i6]},`);
        }
      }
      for (let i6 = 0; i6 < model.builtinOutputNames.length; i6++) {
        outputStruct.push(`  ${model.builtinOutputNames[i6]} : ${model.builtinOutputTypes[i6]},`);
      }
      outputStruct.push("};");
      iodec = iodec.concat(outputStruct);
      model.code = vtkWebGPUShaderCache$1.substitute(model.code, "//VTK::IOStructs::Output", [`-> ${model.type}Output`]).result;
    }
    model.code = vtkWebGPUShaderCache$1.substitute(model.code, "//VTK::IOStructs::Dec", iodec).result;
  };
}
var DEFAULT_VALUES45 = {
  type: null,
  // 'vertex' or 'fragment'
  hash: null,
  code: null,
  outputNames: null,
  outputTypes: null
};
function extend46(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES45, initialValues);
  model.outputNames = [];
  model.outputTypes = [];
  model.outputInterpolations = [];
  model.builtinOutputNames = [];
  model.builtinOutputTypes = [];
  model.builtinInputNames = [];
  model.builtinInputTypes = [];
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["type", "hash", "code"]);
  macro.getArray(publicAPI, model, ["outputTypes", "outputNames", "outputInterpolations"]);
  vtkWebGPUShaderDescription(publicAPI, model);
}
var newInstance47 = macro.newInstance(extend46, "vtkWebGPUShaderDescription");
var vtkWebGPUShaderDescription$1 = {
  newInstance: newInstance47,
  extend: extend46
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/Types.js
var textureDetails = {
  // 8-bit formats
  r8unorm: {
    numComponents: 1,
    nativeType: Uint8Array,
    stride: 1,
    elementSize: 1,
    sampleType: "float"
  },
  r8snorm: {
    numComponents: 1,
    nativeType: Int8Array,
    stride: 1,
    elementSize: 1,
    sampleType: "float"
  },
  r8uint: {
    numComponents: 1,
    nativeType: Uint8Array,
    stride: 1,
    elementSize: 1,
    sampleType: "uint"
  },
  r8sint: {
    numComponents: 1,
    nativeType: Int8Array,
    stride: 1,
    elementSize: 1,
    sampleType: "sint"
  },
  // 16-bit formats
  r16uint: {
    numComponents: 1,
    nativeType: Uint16Array,
    stride: 2,
    elementSize: 2,
    sampleType: "uint"
  },
  r16sint: {
    numComponents: 1,
    nativeType: Int16Array,
    stride: 2,
    elementSize: 2,
    sampleType: "sint"
  },
  r16float: {
    numComponents: 1,
    nativeType: Float32Array,
    stride: 2,
    elementSize: 2,
    sampleType: "float"
  },
  rg8unorm: {
    numComponents: 2,
    nativeType: Uint8Array,
    stride: 2,
    elementSize: 1,
    sampleType: "float"
  },
  rg8snorm: {
    numComponents: 2,
    nativeType: Int8Array,
    stride: 2,
    elementSize: 1,
    sampleType: "float"
  },
  rg8uint: {
    numComponents: 2,
    nativeType: Uint8Array,
    stride: 2,
    elementSize: 1,
    sampleType: "uint"
  },
  rg8sint: {
    numComponents: 2,
    nativeType: Int8Array,
    stride: 2,
    elementSize: 1,
    sampleType: "sint"
  },
  // 32-bit formats
  r32uint: {
    numComponents: 1,
    nativeType: Uint32Array,
    stride: 4,
    elementSize: 4,
    sampleType: "uint"
  },
  r32sint: {
    numComponents: 1,
    nativeType: Int32Array,
    stride: 4,
    elementSize: 4,
    sampleType: "sint"
  },
  r32float: {
    numComponents: 1,
    nativeType: Float32Array,
    stride: 4,
    elementSize: 4,
    sampleType: "unfilterable-float"
  },
  rg16uint: {
    numComponents: 2,
    nativeType: Uint16Array,
    stride: 4,
    elementSize: 2,
    sampleType: "uint"
  },
  rg16sint: {
    numComponents: 2,
    nativeType: Int16Array,
    stride: 4,
    elementSize: 2,
    sampleType: "sint"
  },
  rg16float: {
    numComponents: 2,
    nativeType: Float32Array,
    stride: 4,
    elementSize: 2,
    sampleType: "float"
  },
  rgba8unorm: {
    numComponents: 4,
    nativeType: Uint8Array,
    stride: 4,
    elementSize: 1,
    sampleType: "float"
  },
  "rgba8unorm-srgb": {
    numComponents: 4,
    nativeType: Uint8Array,
    stride: 4,
    elementSize: 1,
    sampleType: "float"
  },
  rgba8snorm: {
    numComponents: 4,
    nativeType: Int8Array,
    stride: 4,
    elementSize: 1,
    sampleType: "float"
  },
  rgba8uint: {
    numComponents: 4,
    nativeType: Uint8Array,
    stride: 4,
    elementSize: 1,
    sampleType: "uint"
  },
  rgba8sint: {
    numComponents: 4,
    nativeType: Int8Array,
    stride: 4,
    elementSize: 1,
    sampleType: "sint"
  },
  bgra8unorm: {
    numComponents: 4,
    nativeType: Uint8Array,
    stride: 4,
    elementSize: 1,
    sampleType: "float"
  },
  "bgra8unorm-srgb": {
    numComponents: 4,
    nativeType: Uint8Array,
    stride: 4,
    elementSize: 1,
    sampleType: "float"
  },
  // Packed 32-bit formats
  rgb9e5ufloat: {
    numComponents: 4,
    nativeType: Uint32Array,
    stride: 4,
    sampleType: "float"
  },
  rgb10a2unorm: {
    numComponents: 4,
    nativeType: Uint32Array,
    stride: 4,
    sampleType: "float"
  },
  rg11b10ufloat: {
    numComponents: 4,
    nativeType: Float32Array,
    stride: 4,
    sampleType: "float"
  },
  // 64-bit formats
  rg32uint: {
    numComponents: 2,
    nativeType: Uint32Array,
    stride: 8,
    elementSize: 4,
    sampleType: "uint"
  },
  rg32sint: {
    numComponents: 2,
    nativeType: Int32Array,
    stride: 8,
    elementSize: 4,
    sampleType: "sint"
  },
  rg32float: {
    numComponents: 2,
    nativeType: Float32Array,
    stride: 8,
    elementSize: 4,
    sampleType: "unfilterable-float"
  },
  rgba16uint: {
    numComponents: 4,
    nativeType: Uint16Array,
    stride: 8,
    elementSize: 2,
    sampleType: "uint"
  },
  rgba16sint: {
    numComponents: 4,
    nativeType: Int16Array,
    stride: 8,
    elementSize: 2,
    sampleType: "sint"
  },
  rgba16float: {
    numComponents: 4,
    nativeType: Float32Array,
    stride: 8,
    elementSize: 2,
    sampleType: "float"
  },
  // 128-bit formats
  rgba32uint: {
    numComponents: 4,
    nativeType: Uint32Array,
    stride: 16,
    elementSize: 4,
    sampleType: "uint"
  },
  rgba32sint: {
    numComponents: 4,
    nativeType: Int32Array,
    stride: 16,
    elementSize: 4,
    sampleType: "sint"
  },
  rgba32float: {
    numComponents: 4,
    nativeType: Float32Array,
    stride: 16,
    elementSize: 4,
    sampleType: "unfilterable-float"
  },
  // Depth and stencil formats
  stencil8: {
    numComponents: 1,
    nativeType: Uint8Array,
    stride: 1,
    elementSize: 1,
    sampleType: "uint"
  },
  depth16unorm: {
    numComponents: 1,
    nativeType: Uint16Array,
    stride: 2,
    elementSize: 2,
    sampleType: "depth"
  },
  depth24plus: {
    numComponents: 1,
    nativeType: Uint32Array,
    stride: 4,
    elementSize: 3,
    sampleType: "depth"
  },
  "depth24plus-stencil8": {
    numComponents: 2,
    nativeType: Uint32Array,
    stride: 4,
    sampleType: "mixed"
  },
  depth32float: {
    numComponents: 1,
    nativeType: Float32Array,
    stride: 4,
    elementSize: 4,
    sampleType: "depth"
  }
};
function getDetailsFromTextureFormat(format) {
  if (!format || format.length < 6) return 0;
  if (format in textureDetails === true) {
    return textureDetails[format];
  }
  vtkErrorMacro2(`unknown format ${format}`);
  return null;
}
function getByteStrideFromBufferFormat(format) {
  if (!format || format.length < 5) return 0;
  let numComp = 1;
  if (format[format.length - 2] === "x") {
    numComp = Number(format[format.length - 1]);
  }
  const sizeStart = numComp === 1 ? format.length - 1 : format.length - 3;
  const num = Number(format[sizeStart]);
  if (Number.isNaN(num)) {
    vtkErrorMacro2(`unknown format ${format}`);
    return 0;
  }
  const typeSize = 5 - num / 2;
  return numComp * typeSize;
}
function getNumberOfComponentsFromBufferFormat(format) {
  if (!format || format.length < 5) return 0;
  let numComp = 1;
  if (format[format.length - 2] === "x") {
    numComp = Number(format[format.length - 1]);
  }
  return numComp;
}
function getNativeTypeFromBufferFormat(format) {
  if (!format || format.length < 5) return 0;
  let result;
  if (format[0] === "f") {
    result = "Float";
  } else if (format[0] === "s") {
    result = "Int";
  } else if (format[0] === "u") {
    result = "Uint";
  } else {
    vtkErrorMacro2(`unknown format ${format}`);
    return void 0;
  }
  const base = format.split("x")[0];
  const num = Number(base[base.length - 1]);
  if (Number.isNaN(num)) {
    vtkErrorMacro2(`unknown format ${format}`);
    return void 0;
  }
  result += 8 * (5 - num / 2);
  result += "Array";
  return result;
}
function getShaderTypeFromBufferFormat(format) {
  let dataType;
  if (format[0] === "f" || format[1] === "n") {
    dataType = "f32";
  } else if (format[0] === "s" && format[1] === "i") {
    dataType = "i32";
  } else if (format[0] === "u" && format[1] === "i") {
    dataType = "u32";
  } else {
    vtkErrorMacro2(`unknown format ${format}`);
    return void 0;
  }
  let numComp = 1;
  if (format[format.length - 2] === "x") {
    numComp = Number(format[format.length - 1]);
  }
  if (numComp === 4) return `vec4<${dataType}>`;
  if (numComp === 3) return `vec3<${dataType}>`;
  if (numComp === 2) return `vec2<${dataType}>`;
  return dataType;
}
function getByteStrideFromShaderFormat(format) {
  if (!format) return 0;
  let numComp = 1;
  if (format.substring(0, 3) === "vec") {
    numComp = Number(format[3]);
  } else if (format.substring(0, 3) === "mat") {
    numComp = format[3] * format[5];
  }
  const typeSize = 4;
  return numComp * typeSize;
}
function getNativeTypeFromShaderFormat(format) {
  if (!format) return void 0;
  if (format.includes("f32")) return "Float32Array";
  if (format.includes("i32")) return "Int32Array";
  if (format.includes("u32")) return "Uint32Array";
  vtkErrorMacro2(`unknown format ${format}`);
  return void 0;
}
var vtkWebGPUTypes = {
  getDetailsFromTextureFormat,
  getByteStrideFromBufferFormat,
  getNumberOfComponentsFromBufferFormat,
  getNativeTypeFromBufferFormat,
  getShaderTypeFromBufferFormat,
  getByteStrideFromShaderFormat,
  getNativeTypeFromShaderFormat
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/VertexInput.js
function arraysEqual(a4, b3) {
  if (a4 === b3) return true;
  if (a4 == null || b3 == null) return false;
  if (a4.length !== b3.length) return false;
  for (let i6 = 0; i6 < a4.length; ++i6) {
    if (!b3.includes(a4[i6])) return false;
  }
  return true;
}
function vtkWebGPUVertexInput(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUVertexInput");
  publicAPI.addBuffer = function(buffer, inames) {
    let stepMode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "vertex";
    let names = inames;
    if (!Array.isArray(names)) {
      names = [names];
    }
    for (let i6 = 0; i6 < model.inputs.length; i6++) {
      if (arraysEqual(model.inputs[i6].names, names)) {
        if (model.inputs[i6].buffer === buffer) {
          return;
        }
        model.inputs[i6].buffer = buffer;
        return;
      }
    }
    model.inputs.push({
      buffer,
      stepMode,
      names
    });
    model.inputs = model.inputs.sort((v1, v2) => {
      if (v1.names[0] < v2.names[0]) {
        return -1;
      }
      if (v1.names[0] > v2.names[0]) {
        return 1;
      }
      return 0;
    });
  };
  publicAPI.removeBufferIfPresent = (name) => {
    for (let i6 = 0; i6 < model.inputs.length; i6++) {
      if (model.inputs[i6].names.includes(name)) {
        model.inputs.splice(i6, 1);
      }
    }
  };
  publicAPI.getBuffer = (name) => {
    for (let i6 = 0; i6 < model.inputs.length; i6++) {
      if (model.inputs[i6].names.includes(name)) {
        return model.inputs[i6].buffer;
      }
    }
    return null;
  };
  publicAPI.hasAttribute = (name) => {
    for (let i6 = 0; i6 < model.inputs.length; i6++) {
      if (model.inputs[i6].names.includes(name)) {
        return true;
      }
    }
    return false;
  };
  publicAPI.getAttributeTime = (name) => {
    for (let i6 = 0; i6 < model.inputs.length; i6++) {
      if (model.inputs[i6].names.includes(name)) {
        return model.inputs[i6].buffer.getSourceTime();
      }
    }
    return 0;
  };
  publicAPI.getShaderCode = () => {
    let result = "";
    let nameCount = 0;
    for (let i6 = 0; i6 < model.inputs.length; i6++) {
      for (let nm = 0; nm < model.inputs[i6].names.length; nm++) {
        const arrayInfo = model.inputs[i6].buffer.getArrayInformation()[nm];
        const type = vtkWebGPUTypes.getShaderTypeFromBufferFormat(arrayInfo.format);
        if (nameCount > 0) {
          result += ",\n";
        }
        result = `${result}  @location(${nameCount}) ${model.inputs[i6].names[nm]} : ${type}`;
        nameCount++;
      }
    }
    return result;
  };
  publicAPI.getVertexInputInformation = () => {
    const info = {};
    if (model.inputs.length) {
      const vertexBuffers = [];
      let nameCount = 0;
      for (let i6 = 0; i6 < model.inputs.length; i6++) {
        const buf = model.inputs[i6].buffer;
        const buffer = {
          arrayStride: buf.getStrideInBytes(),
          stepMode: model.inputs[i6].stepMode,
          attributes: []
        };
        const arrayInfo = buf.getArrayInformation();
        for (let nm = 0; nm < model.inputs[i6].names.length; nm++) {
          buffer.attributes.push({
            shaderLocation: nameCount,
            offset: arrayInfo[nm].offset,
            format: arrayInfo[nm].format
          });
          nameCount++;
        }
        vertexBuffers.push(buffer);
      }
      info.buffers = vertexBuffers;
    }
    return info;
  };
  publicAPI.bindBuffers = (renderEncoder) => {
    for (let i6 = 0; i6 < model.inputs.length; i6++) {
      renderEncoder.setVertexBuffer(i6, model.inputs[i6].buffer.getHandle());
    }
    if (model.indexBuffer) {
      renderEncoder.setIndexBuffer(model.indexBuffer.getHandle(), model.indexBuffer.getArrayInformation()[0].format);
    }
  };
  publicAPI.getReady = () => {
  };
  publicAPI.releaseGraphicsResources = () => {
    if (model.created) {
      model.inputs = [];
      model.bindingDescriptions = [];
      model.attributeDescriptions = [];
    }
  };
}
var DEFAULT_VALUES46 = {
  inputs: null,
  bindingDescriptions: false,
  attributeDescriptions: null,
  indexBuffer: null
};
function extend47(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES46, initialValues);
  obj(publicAPI, model);
  model.bindingDescriptions = [];
  model.attributeDescriptions = [];
  model.inputs = [];
  setGet(publicAPI, model, ["created", "device", "handle", "indexBuffer"]);
  vtkWebGPUVertexInput(publicAPI, model);
}
var newInstance48 = newInstance(extend47, "vtkWebGPUVertexInput");
var vtkWebGPUVertexInput$1 = {
  newInstance: newInstance48,
  extend: extend47
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/SimpleMapper.js
var vtkWebGPUSimpleMapperVS = `
//VTK::Renderer::Dec

//VTK::Color::Dec

//VTK::Normal::Dec

//VTK::TCoord::Dec

//VTK::Select::Dec

//VTK::Mapper::Dec

//VTK::IOStructs::Dec

@vertex
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output : vertexOutput;

  // var vertex: vec4<f32> = vertexBC;

  //VTK::Color::Impl

  //VTK::Normal::Impl

  //VTK::TCoord::Impl

  //VTK::Select::Impl

  //VTK::Position::Impl

  return output;
}
`;
var vtkWebGPUSimpleMapperFS = `
//VTK::Renderer::Dec

//VTK::Color::Dec

//VTK::Normal::Dec

//VTK::TCoord::Dec

//VTK::Select::Dec

//VTK::RenderEncoder::Dec

//VTK::Mapper::Dec

//VTK::IOStructs::Dec

@fragment
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output : fragmentOutput;

  //VTK::Color::Impl

  //VTK::Normal::Impl

  //VTK::Light::Impl

  //VTK::TCoord::Impl

  //VTK::Select::Impl

  // var computedColor:vec4<f32> = vec4<f32>(1.0,0.5,0.5,1.0);

  //VTK::RenderEncoder::Impl
  return output;
}
`;
function vtkWebGPUSimpleMapper(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUSimpleMapper");
  publicAPI.generateShaderDescriptions = (hash, pipeline, vertexInput) => {
    const vDesc = vtkWebGPUShaderDescription$1.newInstance({
      type: "vertex",
      hash,
      code: model.vertexShaderTemplate
    });
    const fDesc = vtkWebGPUShaderDescription$1.newInstance({
      type: "fragment",
      hash,
      code: model.fragmentShaderTemplate
    });
    const sdrs = pipeline.getShaderDescriptions();
    sdrs.push(vDesc);
    sdrs.push(fDesc);
    const scode = model.vertexShaderTemplate + model.fragmentShaderTemplate;
    const re = new RegExp("//VTK::[^:]*::", "g");
    const unique = scode.match(re).filter((v2, i6, a4) => a4.indexOf(v2) === i6);
    const fnames = unique.map((v2) => `replaceShader${v2.substring(7, v2.length - 2)}`);
    for (let i6 = 0; i6 < fnames.length; i6++) {
      const fname = fnames[i6];
      if (fname !== "replaceShaderIOStructs" && model.shaderReplacements.has(fname)) {
        model.shaderReplacements.get(fname)(hash, pipeline, vertexInput);
      }
    }
    publicAPI.replaceShaderIOStructs(hash, pipeline, vertexInput);
  };
  publicAPI.replaceShaderIOStructs = (hash, pipeline, vertexInput) => {
    const vDesc = pipeline.getShaderDescription("vertex");
    vDesc.replaceShaderCode(null, vertexInput);
    const fDesc = pipeline.getShaderDescription("fragment");
    fDesc.replaceShaderCode(vDesc);
  };
  publicAPI.replaceShaderRenderEncoder = (hash, pipeline, vertexInput) => {
    model.renderEncoder.replaceShaderCode(pipeline);
  };
  model.shaderReplacements.set("replaceShaderRenderEncoder", publicAPI.replaceShaderRenderEncoder);
  publicAPI.replaceShaderRenderer = (hash, pipeline, vertexInput) => {
    if (!model.WebGPURenderer) {
      return;
    }
    const ubocode = model.WebGPURenderer.getBindGroup().getShaderCode(pipeline);
    const vDesc = pipeline.getShaderDescription("vertex");
    let code = vDesc.getCode();
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Renderer::Dec", [ubocode]).result;
    vDesc.setCode(code);
    const fDesc = pipeline.getShaderDescription("fragment");
    code = fDesc.getCode();
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Renderer::Dec", [ubocode]).result;
    fDesc.setCode(code);
  };
  model.shaderReplacements.set("replaceShaderRenderer", publicAPI.replaceShaderRenderer);
  publicAPI.replaceShaderMapper = (hash, pipeline, vertexInput) => {
    const ubocode = model.bindGroup.getShaderCode(pipeline);
    const vDesc = pipeline.getShaderDescription("vertex");
    let code = vDesc.getCode();
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Mapper::Dec", [ubocode]).result;
    vDesc.setCode(code);
    const fDesc = pipeline.getShaderDescription("fragment");
    fDesc.addBuiltinInput("bool", "@builtin(front_facing) frontFacing");
    code = fDesc.getCode();
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Mapper::Dec", [ubocode]).result;
    fDesc.setCode(code);
  };
  model.shaderReplacements.set("replaceShaderMapper", publicAPI.replaceShaderMapper);
  publicAPI.replaceShaderPosition = (hash, pipeline, vertexInput) => {
    const vDesc = pipeline.getShaderDescription("vertex");
    vDesc.addBuiltinOutput("vec4<f32>", "@builtin(position) Position");
    let code = vDesc.getCode();
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Position::Impl", ["    output.Position = rendererUBO.SCPCMatrix*vertexBC;"]).result;
    vDesc.setCode(code);
  };
  model.shaderReplacements.set("replaceShaderPosition", publicAPI.replaceShaderPosition);
  publicAPI.replaceShaderTCoord = (hash, pipeline, vertexInput) => {
    const vDesc = pipeline.getShaderDescription("vertex");
    vDesc.addOutput("vec2<f32>", "tcoordVS");
  };
  model.shaderReplacements.set("replaceShaderTCoord", publicAPI.replaceShaderTCoord);
  publicAPI.addTextureView = (view) => {
    if (model.textureViews.includes(view)) {
      return;
    }
    model.textureViews.push(view);
  };
  publicAPI.prepareToDraw = (renderEncoder) => {
    model.renderEncoder = renderEncoder;
    publicAPI.updateInput();
    publicAPI.updateBuffers();
    publicAPI.updateBindings();
    publicAPI.updatePipeline();
  };
  publicAPI.updateInput = () => {
  };
  publicAPI.updateBuffers = () => {
  };
  publicAPI.updateBindings = () => {
    model.bindGroup.setBindables(publicAPI.getBindables());
  };
  publicAPI.computePipelineHash = () => {
  };
  publicAPI.registerDrawCallback = (encoder2) => {
    encoder2.registerDrawCallback(model.pipeline, publicAPI.draw);
  };
  publicAPI.prepareAndDraw = (encoder2) => {
    publicAPI.prepareToDraw(encoder2);
    encoder2.setPipeline(model.pipeline);
    publicAPI.draw(encoder2);
  };
  publicAPI.draw = (renderEncoder) => {
    const pipeline = renderEncoder.getBoundPipeline();
    renderEncoder.activateBindGroup(model.bindGroup);
    if (model.WebGPURenderer) {
      model.WebGPURenderer.bindUBO(renderEncoder);
    }
    pipeline.bindVertexInput(renderEncoder, model.vertexInput);
    const indexBuffer = model.vertexInput.getIndexBuffer();
    if (indexBuffer) {
      renderEncoder.drawIndexed(indexBuffer.getIndexCount(), model.numberOfInstances, 0, 0, 0);
    } else {
      renderEncoder.draw(model.numberOfVertices, model.numberOfInstances, 0, 0);
    }
  };
  publicAPI.getBindables = () => {
    const bindables = [...model.additionalBindables];
    if (model.UBO) {
      bindables.push(model.UBO);
    }
    if (model.SSBO) {
      bindables.push(model.SSBO);
    }
    for (let t9 = 0; t9 < model.textureViews.length; t9++) {
      bindables.push(model.textureViews[t9]);
      const samp = model.textureViews[t9].getSampler();
      if (samp) {
        bindables.push(samp);
      }
    }
    return bindables;
  };
  publicAPI.updatePipeline = () => {
    publicAPI.computePipelineHash();
    model.pipeline = model.device.getPipeline(model.pipelineHash);
    if (!model.pipeline) {
      model.pipeline = vtkWebGPUPipeline$1.newInstance();
      model.pipeline.setDevice(model.device);
      if (model.WebGPURenderer) {
        model.pipeline.addBindGroupLayout(model.WebGPURenderer.getBindGroup());
      }
      model.pipeline.addBindGroupLayout(model.bindGroup);
      publicAPI.generateShaderDescriptions(model.pipelineHash, model.pipeline, model.vertexInput);
      model.pipeline.setTopology(model.topology);
      model.pipeline.setRenderEncoder(model.renderEncoder);
      model.pipeline.setVertexState(model.vertexInput.getVertexInputInformation());
      model.device.createPipeline(model.pipelineHash, model.pipeline);
    }
  };
}
var DEFAULT_VALUES47 = {
  additionalBindables: void 0,
  bindGroup: null,
  device: null,
  fragmentShaderTemplate: null,
  numberOfInstances: 1,
  numberOfVertices: 0,
  pipelineHash: null,
  shaderReplacements: null,
  SSBO: null,
  textureViews: null,
  topology: "triangle-list",
  UBO: null,
  vertexShaderTemplate: null,
  WebGPURenderer: null
};
function extend48(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES47, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.textureViews = [];
  model.vertexInput = vtkWebGPUVertexInput$1.newInstance();
  model.bindGroup = vtkWebGPUBindGroup$1.newInstance({
    label: "mapperBG"
  });
  model.additionalBindables = [];
  model.fragmentShaderTemplate = model.fragmentShaderTemplate || vtkWebGPUSimpleMapperFS;
  model.vertexShaderTemplate = model.vertexShaderTemplate || vtkWebGPUSimpleMapperVS;
  model.shaderReplacements = /* @__PURE__ */ new Map();
  macro.get(publicAPI, model, ["pipeline", "vertexInput"]);
  macro.setGet(publicAPI, model, ["additionalBindables", "device", "fragmentShaderTemplate", "interpolate", "numberOfInstances", "numberOfVertices", "pipelineHash", "shaderReplacements", "SSBO", "textureViews", "topology", "UBO", "vertexShaderTemplate", "WebGPURenderer"]);
  vtkWebGPUSimpleMapper(publicAPI, model);
}
var newInstance49 = macro.newInstance(extend48, "vtkWebGPUSimpleMapper");
var vtkWebGPUSimpleMapper$1 = {
  newInstance: newInstance49,
  extend: extend48
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/FullScreenQuad.js
function vtkWebGPUFullScreenQuad(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUFullScreenQuad");
  publicAPI.replaceShaderPosition = (hash, pipeline, vertexInput) => {
    const vDesc = pipeline.getShaderDescription("vertex");
    vDesc.addBuiltinOutput("vec4<f32>", "@builtin(position) Position");
    vDesc.addOutput("vec4<f32>", "vertexVC");
    let code = vDesc.getCode();
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Position::Impl", ["output.tcoordVS = vec2<f32>(vertexBC.x * 0.5 + 0.5, 1.0 - vertexBC.y * 0.5 - 0.5);", "output.Position = vec4<f32>(vertexBC, 1.0);", "output.vertexVC = vec4<f32>(vertexBC, 1);"]).result;
    vDesc.setCode(code);
  };
  model.shaderReplacements.set("replaceShaderPosition", publicAPI.replaceShaderPosition);
  publicAPI.updateBuffers = () => {
    const buff = model.device.getBufferManager().getFullScreenQuadBuffer();
    model.vertexInput.addBuffer(buff, ["vertexBC"]);
    model.numberOfVertices = 6;
  };
}
var DEFAULT_VALUES48 = {};
function extend49(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES48, initialValues);
  vtkWebGPUSimpleMapper$1.extend(publicAPI, model, initialValues);
  vtkWebGPUFullScreenQuad(publicAPI, model);
}
var newInstance50 = macro.newInstance(extend49, "vtkWebGPUFullScreenQuad");
var vtkWebGPUFullScreenQuad$1 = {
  newInstance: newInstance50,
  extend: extend49
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/BufferManager/Constants.js
var BufferUsage = {
  Verts: 0,
  Lines: 1,
  Triangles: 2,
  Strips: 3,
  LinesFromStrips: 4,
  LinesFromTriangles: 5,
  Points: 6,
  UniformArray: 7,
  PointArray: 8,
  NormalsFromPoints: 9,
  Texture: 10,
  RawVertex: 11,
  Storage: 12,
  Index: 13
};
var PrimitiveTypes = {
  Start: 0,
  Points: 0,
  Lines: 1,
  Triangles: 2,
  TriangleStrips: 3,
  TriangleEdges: 4,
  TriangleStripEdges: 5,
  End: 6
};
var Constants9 = {
  BufferUsage,
  PrimitiveTypes
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/Buffer.js
var forwarded = ["getMappedRange", "mapAsync", "unmap"];
function bufferSubData(device, destBuffer, destOffset, srcArrayBuffer) {
  const byteCount = srcArrayBuffer.byteLength;
  const srcBuffer = device.createBuffer({
    size: byteCount,
    /* eslint-disable no-undef */
    usage: GPUBufferUsage.COPY_SRC,
    /* eslint-enable no-undef */
    mappedAtCreation: true
  });
  const arrayBuffer = srcBuffer.getMappedRange(0, byteCount);
  new Uint8Array(arrayBuffer).set(new Uint8Array(srcArrayBuffer));
  srcBuffer.unmap();
  const encoder2 = device.createCommandEncoder();
  encoder2.copyBufferToBuffer(srcBuffer, 0, destBuffer, destOffset, byteCount);
  const commandBuffer = encoder2.finish();
  const queue = device.queue;
  queue.submit([commandBuffer]);
  srcBuffer.destroy();
}
function vtkWebGPUBuffer(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUBuffer");
  publicAPI.create = (sizeInBytes, usage) => {
    model.handle = model.device.getHandle().createBuffer({
      size: sizeInBytes,
      usage,
      label: model.label
    });
    model.sizeInBytes = sizeInBytes;
    model.usage = usage;
  };
  publicAPI.write = (data) => {
    bufferSubData(model.device.getHandle(), model.handle, 0, data.buffer);
  };
  publicAPI.createAndWrite = (data, usage) => {
    model.handle = model.device.getHandle().createBuffer({
      size: data.byteLength,
      usage,
      mappedAtCreation: true,
      label: model.label
    });
    model.sizeInBytes = data.byteLength;
    model.usage = usage;
    new Uint8Array(model.handle.getMappedRange()).set(new Uint8Array(data.buffer));
    model.handle.unmap();
  };
  for (let i6 = 0; i6 < forwarded.length; i6++) {
    publicAPI[forwarded[i6]] = function() {
      return model.handle[forwarded[i6]](...arguments);
    };
  }
}
var DEFAULT_VALUES49 = {
  device: null,
  handle: null,
  sizeInBytes: 0,
  strideInBytes: 0,
  arrayInformation: null,
  usage: null,
  label: null,
  sourceTime: null
};
function extend50(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES49, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["handle", "sizeInBytes", "usage"]);
  macro.setGet(publicAPI, model, ["strideInBytes", "device", "arrayInformation", "label", "sourceTime"]);
  vtkWebGPUBuffer(publicAPI, model);
}
var newInstance51 = macro.newInstance(extend50);
var vtkWebGPUBuffer$1 = __spreadValues({
  newInstance: newInstance51,
  extend: extend50
}, Constants9);

// node_modules/@kitware/vtk.js/Rendering/Core/Property.js
var {
  Representation: Representation2,
  Interpolation: Interpolation2
} = PropertyConst;
function notImplemented2(method) {
  return () => macro.vtkErrorMacro(`vtkProperty::${method} - NOT IMPLEMENTED`);
}
function vtkProperty(publicAPI, model) {
  model.classHierarchy.push("vtkProperty");
  publicAPI.setColor = (r9, g2, b3) => {
    if (Array.isArray(r9)) {
      if (model.color[0] !== r9[0] || model.color[1] !== r9[1] || model.color[2] !== r9[2]) {
        model.color[0] = r9[0];
        model.color[1] = r9[1];
        model.color[2] = r9[2];
        publicAPI.modified();
      }
    } else if (model.color[0] !== r9 || model.color[1] !== g2 || model.color[2] !== b3) {
      model.color[0] = r9;
      model.color[1] = g2;
      model.color[2] = b3;
      publicAPI.modified();
    }
    publicAPI.setDiffuseColor(model.color);
    publicAPI.setAmbientColor(model.color);
    publicAPI.setSpecularColor(model.color);
  };
  publicAPI.computeCompositeColor = notImplemented2("ComputeCompositeColor");
  publicAPI.getColor = () => {
    let norm2 = 0;
    if (model.ambient + model.diffuse + model.specular > 0) {
      norm2 = 1 / (model.ambient + model.diffuse + model.specular);
    }
    for (let i6 = 0; i6 < 3; i6++) {
      model.color[i6] = norm2 * (model.ambient * model.ambientColor[i6] + model.diffuse * model.diffuseColor[i6] + model.specular * model.specularColor[i6]);
    }
    return [].concat(model.color);
  };
  publicAPI.setSpecularPower = (specularPower) => {
    const roughness = 1 / Math.max(1, specularPower);
    if (model.roughness !== roughness || model.specularPower !== specularPower) {
      model.specularPower = specularPower;
      model.roughness = roughness;
      publicAPI.modified();
    }
  };
  publicAPI.addShaderVariable = notImplemented2("AddShaderVariable");
  publicAPI.setInterpolationToFlat = () => publicAPI.setInterpolation(Interpolation2.FLAT);
  publicAPI.setInterpolationToGouraud = () => publicAPI.setInterpolation(Interpolation2.GOURAUD);
  publicAPI.setInterpolationToPhong = () => publicAPI.setInterpolation(Interpolation2.PHONG);
  publicAPI.getInterpolationAsString = () => macro.enumToString(Interpolation2, model.interpolation);
  publicAPI.setRepresentationToWireframe = () => publicAPI.setRepresentation(Representation2.WIREFRAME);
  publicAPI.setRepresentationToSurface = () => publicAPI.setRepresentation(Representation2.SURFACE);
  publicAPI.setRepresentationToPoints = () => publicAPI.setRepresentation(Representation2.POINTS);
  publicAPI.getRepresentationAsString = () => macro.enumToString(Representation2, model.representation);
}
var DEFAULT_VALUES50 = {
  color: [1, 1, 1],
  ambientColor: [1, 1, 1],
  diffuseColor: [1, 1, 1],
  specularColor: [1, 1, 1],
  edgeColor: [0, 0, 0],
  ambient: 0,
  diffuse: 1,
  metallic: 0,
  roughness: 0.6,
  normalStrength: 1,
  emission: 1,
  baseIOR: 1.45,
  specular: 0,
  specularPower: 1,
  opacity: 1,
  interpolation: Interpolation2.GOURAUD,
  representation: Representation2.SURFACE,
  edgeVisibility: false,
  backfaceCulling: false,
  frontfaceCulling: false,
  pointSize: 1,
  lineWidth: 1,
  lighting: true,
  shading: false,
  materialName: null
};
function extend51(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES50, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["lighting", "interpolation", "ambient", "diffuse", "metallic", "roughness", "normalStrength", "emission", "baseIOR", "specular", "specularPower", "opacity", "edgeVisibility", "lineWidth", "pointSize", "backfaceCulling", "frontfaceCulling", "representation", "diffuseTexture", "metallicTexture", "roughnessTexture", "normalTexture", "ambientOcclusionTexture", "emissionTexture"]);
  macro.setGetArray(publicAPI, model, ["ambientColor", "specularColor", "diffuseColor", "edgeColor"], 3);
  vtkProperty(publicAPI, model);
}
var newInstance52 = macro.newInstance(extend51, "vtkProperty");
var vtkProperty$1 = __spreadValues({
  newInstance: newInstance52,
  extend: extend51
}, PropertyConst);

// node_modules/@kitware/vtk.js/Rendering/WebGPU/IndexBuffer.js
var {
  Representation: Representation3
} = vtkProperty$1;
var {
  PrimitiveTypes: PrimitiveTypes2
} = Constants9;
var _LimitedMap = class {
  constructor() {
    this.keys = new Uint32Array(10);
    this.values = new Uint32Array(10);
    this.count = 0;
  }
  clear() {
    this.count = 0;
  }
  has(key) {
    for (let i6 = 0; i6 < this.count; i6++) {
      if (this.keys[i6] === key) {
        return true;
      }
    }
    return void 0;
  }
  get(key) {
    for (let i6 = 0; i6 < this.count; i6++) {
      if (this.keys[i6] === key) {
        return this.values[i6];
      }
    }
    return void 0;
  }
  set(key, value) {
    if (this.count < 9) {
      this.keys[this.count] = key;
      this.values[this.count++] = value;
    }
  }
};
function getPrimitiveName(primType) {
  switch (primType) {
    case PrimitiveTypes2.Points:
      return "points";
    case PrimitiveTypes2.Lines:
      return "lines";
    case PrimitiveTypes2.Triangles:
    case PrimitiveTypes2.TriangleEdges:
      return "polys";
    case PrimitiveTypes2.TriangleStripEdges:
    case PrimitiveTypes2.TriangleStrips:
      return "strips";
    default:
      return "";
  }
}
function _getOrAddFlatId(state, ptId, cellId) {
  let flatId = state.pointIdToFlatId[ptId];
  if (flatId < 0) {
    flatId = state.flatId;
    state.pointIdToFlatId[ptId] = flatId;
    state.flatIdToPointId[state.flatId] = ptId;
    state.flatIdToCellId[state.flatId] = cellId;
    state.flatId++;
  }
  return flatId;
}
function fillCell(ptIds, cellId, state) {
  const numPtIds = ptIds.length;
  for (let ptIdx = 0; ptIdx < numPtIds; ptIdx++) {
    let ptId2 = ptIds[ptIdx];
    if (state.cellProvokedMap.has(ptId2)) {
      state.ibo[state.iboId++] = state.cellProvokedMap.get(ptId2);
      for (let ptIdx2 = ptIdx + 1; ptIdx2 < ptIdx + numPtIds; ptIdx2++) {
        ptId2 = ptIds[ptIdx2 % numPtIds];
        const flatId2 = _getOrAddFlatId(state, ptId2, cellId);
        state.ibo[state.iboId++] = flatId2;
      }
      return;
    }
  }
  for (let ptIdx = 0; ptIdx < numPtIds; ptIdx++) {
    let ptId2 = ptIds[ptIdx];
    if (!state.provokedPointIds[ptId2]) {
      let flatId2 = _getOrAddFlatId(state, ptId2, cellId);
      state.provokedPointIds[ptId2] = 1;
      state.cellProvokedMap.set(ptId2, flatId2);
      state.flatIdToCellId[flatId2] = cellId;
      state.ibo[state.iboId++] = flatId2;
      for (let ptIdx2 = ptIdx + 1; ptIdx2 < ptIdx + numPtIds; ptIdx2++) {
        ptId2 = ptIds[ptIdx2 % numPtIds];
        flatId2 = _getOrAddFlatId(state, ptId2, cellId);
        state.ibo[state.iboId++] = flatId2;
      }
      return;
    }
  }
  let ptId = ptIds[0];
  let flatId = state.flatId;
  state.cellProvokedMap.set(ptId, flatId);
  state.flatIdToPointId[state.flatId] = ptId;
  state.flatIdToCellId[state.flatId] = cellId;
  state.flatId++;
  state.ibo[state.iboId++] = flatId;
  for (let ptIdx2 = 1; ptIdx2 < numPtIds; ptIdx2++) {
    ptId = ptIds[ptIdx2];
    flatId = _getOrAddFlatId(state, ptId, cellId);
    state.ibo[state.iboId++] = flatId;
  }
}
function countCell(ptIds, cellId, state) {
  const numPtIds = ptIds.length;
  state.iboSize += numPtIds;
  for (let ptIdx = 0; ptIdx < numPtIds; ptIdx++) {
    const ptId = ptIds[ptIdx];
    if (state.cellProvokedMap.has(ptId)) {
      return;
    }
  }
  for (let ptIdx = 0; ptIdx < numPtIds; ptIdx++) {
    const ptId = ptIds[ptIdx];
    if (!state.provokedPointIds[ptId]) {
      state.provokedPointIds[ptId] = 1;
      state.cellProvokedMap.set(ptId, 1);
      return;
    }
  }
  state.cellProvokedMap.set(ptIds[0], 1);
  state.extraPoints++;
}
var processCell;
var _single = new Uint32Array(1);
var _double = new Uint32Array(2);
var _triple = new Uint32Array(3);
var _indexCellBuilders = {
  // easy, every input point becomes an output point
  anythingToPoints(numPoints, cellPts, offset3, cellId, state) {
    for (let i6 = 0; i6 < numPoints; ++i6) {
      _single[0] = cellPts[offset3 + i6];
      processCell(_single, cellId, state);
    }
  },
  linesToWireframe(numPoints, cellPts, offset3, cellId, state) {
    for (let i6 = 0; i6 < numPoints - 1; ++i6) {
      _double[0] = cellPts[offset3 + i6];
      _double[1] = cellPts[offset3 + i6 + 1];
      processCell(_double, cellId, state);
    }
  },
  polysToWireframe(numPoints, cellPts, offset3, cellId, state) {
    if (numPoints > 2) {
      for (let i6 = 0; i6 < numPoints; ++i6) {
        _double[0] = cellPts[offset3 + i6];
        _double[1] = cellPts[offset3 + (i6 + 1) % numPoints];
        processCell(_double, cellId, state);
      }
    }
  },
  stripsToWireframe(numPoints, cellPts, offset3, cellId, state) {
    if (numPoints > 2) {
      for (let i6 = 0; i6 < numPoints - 1; ++i6) {
        _double[0] = cellPts[offset3 + i6];
        _double[1] = cellPts[offset3 + i6 + 1];
        processCell(_double, cellId, state);
      }
      for (let i6 = 0; i6 < numPoints - 2; i6++) {
        _double[0] = cellPts[offset3 + i6];
        _double[1] = cellPts[offset3 + i6 + 2];
        processCell(_double, cellId, state);
      }
    }
  },
  polysToSurface(npts, cellPts, offset3, cellId, state) {
    for (let i6 = 0; i6 < npts - 2; i6++) {
      _triple[0] = cellPts[offset3];
      _triple[1] = cellPts[offset3 + i6 + 1];
      _triple[2] = cellPts[offset3 + i6 + 2];
      processCell(_triple, cellId, state);
    }
  },
  stripsToSurface(npts, cellPts, offset3, cellId, state) {
    for (let i6 = 0; i6 < npts - 2; i6++) {
      _triple[0] = cellPts[offset3 + i6];
      _triple[1] = cellPts[offset3 + i6 + 1 + i6 % 2];
      _triple[2] = cellPts[offset3 + i6 + 1 + (i6 + 1) % 2];
      processCell(_triple, cellId, state);
    }
  }
};
function vtkWebGPUIndexBuffer(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUIndexBuffer");
  publicAPI.buildIndexBuffer = (req) => {
    const cellArray = req.cells;
    const primitiveType = req.primitiveType;
    const representation = req.representation;
    const cellOffset = req.cellOffset;
    const array = cellArray.getData();
    const cellArraySize = array.length;
    const inRepName = getPrimitiveName(primitiveType);
    const numPts = req.numberOfPoints;
    const state = {
      provokedPointIds: new Uint8Array(numPts),
      // size is good
      extraPoints: 0,
      iboSize: 0,
      flatId: 0,
      iboId: 0,
      cellProvokedMap: new _LimitedMap()
    };
    let func = null;
    if (representation === Representation3.POINTS || primitiveType === PrimitiveTypes2.Points) {
      func = _indexCellBuilders.anythingToPoints;
    } else if (representation === Representation3.WIREFRAME || primitiveType === PrimitiveTypes2.Lines) {
      func = _indexCellBuilders[`${inRepName}ToWireframe`];
    } else {
      func = _indexCellBuilders[`${inRepName}ToSurface`];
    }
    processCell = countCell;
    let cellId = cellOffset || 0;
    for (let cellArrayIndex = 0; cellArrayIndex < cellArraySize; ) {
      state.cellProvokedMap.clear();
      func(array[cellArrayIndex], array, cellArrayIndex + 1, cellId, state);
      cellArrayIndex += array[cellArrayIndex] + 1;
      cellId++;
    }
    if (numPts <= 65535) {
      state.flatIdToPointId = new Uint16Array(numPts + state.extraPoints);
    } else {
      state.flatIdToPointId = new Uint32Array(numPts + state.extraPoints);
    }
    if (numPts + state.extraPoints < 36863) {
      state.pointIdToFlatId = new Int16Array(numPts);
    } else {
      state.pointIdToFlatId = new Int32Array(numPts);
    }
    if (numPts + state.extraPoints <= 65535) {
      state.ibo = new Uint16Array(state.iboSize);
      req.format = "uint16";
    } else {
      state.ibo = new Uint32Array(state.iboSize);
      req.format = "uint32";
    }
    if (cellId <= 65535) {
      state.flatIdToCellId = new Uint16Array(numPts + state.extraPoints);
    } else {
      state.flatIdToCellId = new Uint32Array(numPts + state.extraPoints);
    }
    state.pointIdToFlatId.fill(-1);
    state.provokedPointIds.fill(0);
    processCell = fillCell;
    cellId = cellOffset || 0;
    for (let cellArrayIndex = 0; cellArrayIndex < cellArraySize; ) {
      state.cellProvokedMap.clear();
      func(array[cellArrayIndex], array, cellArrayIndex + 1, cellId, state);
      cellArrayIndex += array[cellArrayIndex] + 1;
      cellId++;
    }
    delete state.provokedPointIds;
    delete state.pointIdToFlatId;
    req.nativeArray = state.ibo;
    model.flatIdToPointId = state.flatIdToPointId;
    model.flatIdToCellId = state.flatIdToCellId;
    model.flatSize = state.flatId;
    model.indexCount = state.iboId;
  };
}
var DEFAULT_VALUES51 = {
  flatIdToPointId: null,
  flatIdToCellId: null,
  flatSize: 0,
  indexCount: 0
};
function extend52(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES51, initialValues);
  vtkWebGPUBuffer$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["flatIdToPointId", "flatIdToCellId", "flatSize", "indexCount"]);
  vtkWebGPUIndexBuffer(publicAPI, model);
}
var newInstance53 = macro.newInstance(extend52);
var vtkWebGPUIndexBuffer$1 = __spreadValues({
  newInstance: newInstance53,
  extend: extend52
}, Constants9);

// node_modules/@kitware/vtk.js/Rendering/WebGPU/BufferManager.js
var {
  BufferUsage: BufferUsage2
} = Constants9;
var {
  vtkErrorMacro: vtkErrorMacro19
} = macro$1;
var {
  VtkDataTypes: VtkDataTypes3
} = vtkDataArray$1;
var STATIC9 = {};
function _getFormatForDataArray(dataArray) {
  let format;
  switch (dataArray.getDataType()) {
    case VtkDataTypes3.UNSIGNED_CHAR:
      format = "uint8";
      break;
    case VtkDataTypes3.FLOAT:
      format = "float32";
      break;
    case VtkDataTypes3.UNSIGNED_INT:
      format = "uint32";
      break;
    case VtkDataTypes3.INT:
      format = "sint32";
      break;
    case VtkDataTypes3.DOUBLE:
      format = "float32";
      break;
    case VtkDataTypes3.UNSIGNED_SHORT:
      format = "uint16";
      break;
    case VtkDataTypes3.SHORT:
      format = "sin16";
      break;
    default:
      format = "float32";
      break;
  }
  switch (dataArray.getNumberOfComponents()) {
    case 2:
      format += "x2";
      break;
    case 3:
      if (!format.includes("32")) {
        vtkErrorMacro19(`unsupported x3 type for ${format}`);
      }
      format += "x3";
      break;
    case 4:
      format += "x4";
      break;
  }
  return format;
}
function packArray(indexBuffer, inArrayData, numComp, outputType, options) {
  const result = {};
  const flatSize = indexBuffer.getFlatSize();
  if (!flatSize) {
    return result;
  }
  let shift3 = [0, 0, 0, 0];
  if (options.shift) {
    if (options.shift.length) {
      shift3 = options.shift;
    } else {
      shift3.fill(options.shift);
    }
  }
  let scale7 = [1, 1, 1, 1];
  if (options.scale) {
    if (options.scale.length) {
      scale7 = options.scale;
    } else {
      scale7.fill(options.scale);
    }
  }
  const packExtra = Object.prototype.hasOwnProperty.call(options, "packExtra") ? options.packExtra : false;
  let addAPoint;
  let vboidx = 0;
  const stride = numComp + (packExtra ? 1 : 0);
  const packedVBO = newTypedArray(outputType, flatSize * stride);
  let flatIdMap = indexBuffer.getFlatIdToPointId();
  if (options.cellData) {
    flatIdMap = indexBuffer.getFlatIdToCellId();
  }
  if (numComp === 1) {
    addAPoint = function addAPointFunc(i6) {
      packedVBO[vboidx++] = scale7[0] * inArrayData[i6] + shift3[0];
    };
  } else if (numComp === 2) {
    addAPoint = function addAPointFunc(i6) {
      packedVBO[vboidx++] = scale7[0] * inArrayData[i6] + shift3[0];
      packedVBO[vboidx++] = scale7[1] * inArrayData[i6 + 1] + shift3[1];
    };
  } else if (numComp === 3 && !packExtra) {
    addAPoint = function addAPointFunc(i6) {
      packedVBO[vboidx++] = scale7[0] * inArrayData[i6] + shift3[0];
      packedVBO[vboidx++] = scale7[1] * inArrayData[i6 + 1] + shift3[1];
      packedVBO[vboidx++] = scale7[2] * inArrayData[i6 + 2] + shift3[2];
    };
  } else if (numComp === 3 && packExtra) {
    addAPoint = function addAPointFunc(i6) {
      packedVBO[vboidx++] = scale7[0] * inArrayData[i6] + shift3[0];
      packedVBO[vboidx++] = scale7[1] * inArrayData[i6 + 1] + shift3[1];
      packedVBO[vboidx++] = scale7[2] * inArrayData[i6 + 2] + shift3[2];
      packedVBO[vboidx++] = scale7[3] * 1 + shift3[3];
    };
  } else if (numComp === 4) {
    addAPoint = function addAPointFunc(i6) {
      packedVBO[vboidx++] = scale7[0] * inArrayData[i6] + shift3[0];
      packedVBO[vboidx++] = scale7[1] * inArrayData[i6 + 1] + shift3[1];
      packedVBO[vboidx++] = scale7[2] * inArrayData[i6 + 2] + shift3[2];
      packedVBO[vboidx++] = scale7[3] * inArrayData[i6 + 3] + shift3[3];
    };
  }
  for (let index2 = 0; index2 < flatSize; index2++) {
    const inArrayId = numComp * flatIdMap[index2];
    addAPoint(inArrayId);
  }
  result.nativeArray = packedVBO;
  return result;
}
function getNormal(pointData, i0, i1, i22) {
  const v1 = [pointData[i22 * 3] - pointData[i1 * 3], pointData[i22 * 3 + 1] - pointData[i1 * 3 + 1], pointData[i22 * 3 + 2] - pointData[i1 * 3 + 2]];
  const v2 = [pointData[i0 * 3] - pointData[i1 * 3], pointData[i0 * 3 + 1] - pointData[i1 * 3 + 1], pointData[i0 * 3 + 2] - pointData[i1 * 3 + 2]];
  const result = [];
  cross3(v1, v2, result);
  normalize4(result);
  return result;
}
function generateNormals(cellArray, pointArray) {
  const pointData = pointArray.getData();
  const cellArrayData = cellArray.getData();
  if (!cellArrayData || !pointData) {
    return null;
  }
  const packedVBO = new Int8Array(cellArray.getNumberOfCells() * 4);
  const size3 = cellArrayData.length;
  let vboidx = 0;
  for (let index2 = 0; index2 < size3; ) {
    const normal = getNormal(pointData, cellArrayData[index2 + 1], cellArrayData[index2 + 2], cellArrayData[index2 + 3]);
    packedVBO[vboidx++] = 127 * normal[0];
    packedVBO[vboidx++] = 127 * normal[1];
    packedVBO[vboidx++] = 127 * normal[2];
    packedVBO[vboidx++] = 127;
    index2 += cellArrayData[index2] + 1;
  }
  return packedVBO;
}
function vtkWebGPUBufferManager(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUBufferManager");
  function _createBuffer(req) {
    if (req.dataArray && !req.nativeArray) {
      req.nativeArray = req.dataArray.getData();
    }
    let buffer;
    let gpuUsage;
    if (req.usage === BufferUsage2.Index) {
      buffer = vtkWebGPUIndexBuffer$1.newInstance({
        label: req.label
      });
      buffer.setDevice(model.device);
      gpuUsage = GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST;
      buffer.buildIndexBuffer(req);
      buffer.createAndWrite(req.nativeArray, gpuUsage);
      buffer.setArrayInformation([{
        format: req.format
      }]);
    }
    if (!buffer) {
      buffer = vtkWebGPUBuffer$1.newInstance({
        label: req.label
      });
      buffer.setDevice(model.device);
    }
    if (req.usage === BufferUsage2.UniformArray) {
      gpuUsage = GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST;
      buffer.createAndWrite(req.nativeArray, gpuUsage);
    }
    if (req.usage === BufferUsage2.Storage) {
      gpuUsage = GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST;
      buffer.createAndWrite(req.nativeArray, gpuUsage);
    }
    if (req.usage === BufferUsage2.Texture) {
      gpuUsage = GPUBufferUsage.COPY_SRC;
      buffer.createAndWrite(req.nativeArray, gpuUsage);
    }
    if (req.usage === BufferUsage2.PointArray) {
      gpuUsage = GPUBufferUsage.VERTEX;
      const arrayType2 = vtkWebGPUTypes.getNativeTypeFromBufferFormat(req.format);
      const result = packArray(req.indexBuffer, req.dataArray.getData(), req.dataArray.getNumberOfComponents(), arrayType2, {
        packExtra: req.packExtra,
        shift: req.shift,
        scale: req.scale,
        cellData: req.cellData,
        cellOffset: req.cellOffset
      });
      buffer.createAndWrite(result.nativeArray, gpuUsage);
      buffer.setStrideInBytes(vtkWebGPUTypes.getByteStrideFromBufferFormat(req.format));
      buffer.setArrayInformation([{
        offset: 0,
        format: req.format,
        interpolation: req.cellData ? "flat" : "perspective"
      }]);
    }
    if (req.usage === BufferUsage2.NormalsFromPoints) {
      gpuUsage = GPUBufferUsage.VERTEX;
      const arrayType2 = vtkWebGPUTypes.getNativeTypeFromBufferFormat(req.format);
      const normals = generateNormals(req.cells, req.dataArray);
      const result = packArray(req.indexBuffer, normals, 4, arrayType2, {
        cellData: true
      });
      buffer.createAndWrite(result.nativeArray, gpuUsage);
      buffer.setStrideInBytes(vtkWebGPUTypes.getByteStrideFromBufferFormat(req.format));
      buffer.setArrayInformation([{
        offset: 0,
        format: req.format,
        interpolation: "flat"
      }]);
    }
    if (req.usage === BufferUsage2.RawVertex) {
      gpuUsage = GPUBufferUsage.VERTEX;
      buffer.createAndWrite(req.nativeArray, gpuUsage);
      buffer.setStrideInBytes(vtkWebGPUTypes.getByteStrideFromBufferFormat(req.format));
      buffer.setArrayInformation([{
        offset: 0,
        format: req.format
      }]);
    }
    buffer.setSourceTime(req.time);
    return buffer;
  }
  publicAPI.hasBuffer = (hash) => model.device.hasCachedObject(hash);
  publicAPI.getBuffer = (req) => {
    if (req.hash) {
      return model.device.getCachedObject(req.hash, _createBuffer, req);
    }
    return _createBuffer(req);
  };
  publicAPI.getBufferForPointArray = (dataArray, indexBuffer) => {
    const format = _getFormatForDataArray(dataArray);
    const buffRequest = {
      hash: `${dataArray.getMTime()}I${indexBuffer.getMTime()}${format}`,
      usage: BufferUsage2.PointArray,
      format,
      dataArray,
      indexBuffer
    };
    return publicAPI.getBuffer(buffRequest);
  };
  publicAPI.getFullScreenQuadBuffer = () => {
    if (model.fullScreenQuadBuffer) {
      return model.fullScreenQuadBuffer;
    }
    model.fullScreenQuadBuffer = vtkWebGPUBuffer$1.newInstance();
    model.fullScreenQuadBuffer.setDevice(model.device);
    const array = new Float32Array([-1, -1, 0, 1, -1, 0, 1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0]);
    model.fullScreenQuadBuffer.createAndWrite(array, GPUBufferUsage.VERTEX);
    model.fullScreenQuadBuffer.setStrideInBytes(12);
    model.fullScreenQuadBuffer.setArrayInformation([{
      offset: 0,
      format: "float32x3"
    }]);
    return model.fullScreenQuadBuffer;
  };
}
var DEFAULT_VALUES52 = {
  device: null,
  fullScreenQuadBuffer: null
};
function extend53(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES52, initialValues);
  obj(publicAPI, model);
  setGet(publicAPI, model, ["device"]);
  vtkWebGPUBufferManager(publicAPI, model);
}
var newInstance54 = newInstance(extend53);
var vtkWebGPUBufferManager$1 = __spreadValues(__spreadValues({
  newInstance: newInstance54,
  extend: extend53
}, STATIC9), Constants9);

// node_modules/@kitware/vtk.js/Rendering/WebGPU/StorageBuffer.js
var {
  BufferUsage: BufferUsage3
} = vtkWebGPUBufferManager$1;
var {
  vtkErrorMacro: vtkErrorMacro20
} = macro;
function vtkWebGPUStorageBuffer(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUStorageBuffer");
  publicAPI.addEntry = (name, type) => {
    if (model._bufferEntryNames.has(name)) {
      vtkErrorMacro20(`entry named ${name} already exists`);
      return;
    }
    model._bufferEntryNames.set(name, model.bufferEntries.length);
    const sizeInBytes = vtkWebGPUTypes.getByteStrideFromShaderFormat(type);
    model.bufferEntries.push({
      name,
      type,
      sizeInBytes,
      offset: model.sizeInBytes,
      nativeType: vtkWebGPUTypes.getNativeTypeFromShaderFormat(type)
    });
    model.sizeInBytes += sizeInBytes;
  };
  publicAPI.send = (device) => {
    if (!model._buffer) {
      const req = {
        nativeArray: model.Float32Array,
        usage: BufferUsage3.Storage,
        label: model.label
      };
      model._buffer = device.getBufferManager().getBuffer(req);
      model.bindGroupTime.modified();
      model._sendTime.modified();
      return;
    }
    device.getHandle().queue.writeBuffer(model._buffer.getHandle(), 0, model.arrayBuffer, 0, model.sizeInBytes * model.numberOfInstances);
    model._sendTime.modified();
  };
  publicAPI.createView = (type) => {
    if (type in model === false) {
      if (!model.arrayBuffer) {
        model.arrayBuffer = new ArrayBuffer(model.sizeInBytes * model.numberOfInstances);
      }
      model[type] = macro.newTypedArray(type, model.arrayBuffer);
    }
  };
  publicAPI.setValue = (name, instance, val) => {
    const idx = model._bufferEntryNames.get(name);
    if (idx === void 0) {
      vtkErrorMacro20(`entry named ${name} not found in UBO`);
      return;
    }
    const entry = model.bufferEntries[idx];
    publicAPI.createView(entry.nativeType);
    const view = model[entry.nativeType];
    view[(entry.offset + instance * model.sizeInBytes) / view.BYTES_PER_ELEMENT] = val;
  };
  publicAPI.setArray = (name, instance, arr) => {
    const idx = model._bufferEntryNames.get(name);
    if (idx === void 0) {
      vtkErrorMacro20(`entry named ${name} not found in UBO`);
      return;
    }
    const entry = model.bufferEntries[idx];
    publicAPI.createView(entry.nativeType);
    const view = model[entry.nativeType];
    const ioffset = (entry.offset + instance * model.sizeInBytes) / view.BYTES_PER_ELEMENT;
    for (let i6 = 0; i6 < arr.length; i6++) {
      view[ioffset + i6] = arr[i6];
    }
  };
  publicAPI.setAllInstancesFromArray = (name, arr) => {
    const idx = model._bufferEntryNames.get(name);
    if (idx === void 0) {
      vtkErrorMacro20(`entry named ${name} not found in UBO`);
      return;
    }
    const entry = model.bufferEntries[idx];
    publicAPI.createView(entry.nativeType);
    const view = model[entry.nativeType];
    const numComponents = arr.length / model.numberOfInstances;
    for (let inst = 0; inst < model.numberOfInstances; inst++) {
      const ioffset = (entry.offset + inst * model.sizeInBytes) / view.BYTES_PER_ELEMENT;
      for (let i6 = 0; i6 < numComponents; i6++) {
        view[ioffset + i6] = arr[inst * numComponents + i6];
      }
    }
  };
  publicAPI.setAllInstancesFromArrayColorToFloat = (name, arr) => {
    const idx = model._bufferEntryNames.get(name);
    if (idx === void 0) {
      vtkErrorMacro20(`entry named ${name} not found in UBO`);
      return;
    }
    const entry = model.bufferEntries[idx];
    publicAPI.createView(entry.nativeType);
    const view = model[entry.nativeType];
    const numComponents = arr.length / model.numberOfInstances;
    for (let inst = 0; inst < model.numberOfInstances; inst++) {
      const ioffset = (entry.offset + inst * model.sizeInBytes) / view.BYTES_PER_ELEMENT;
      for (let i6 = 0; i6 < numComponents; i6++) {
        view[ioffset + i6] = arr[inst * numComponents + i6] / 255;
      }
    }
  };
  publicAPI.setAllInstancesFromArray3x3To4x4 = (name, arr) => {
    const idx = model._bufferEntryNames.get(name);
    if (idx === void 0) {
      vtkErrorMacro20(`entry named ${name} not found in UBO`);
      return;
    }
    const entry = model.bufferEntries[idx];
    publicAPI.createView(entry.nativeType);
    const view = model[entry.nativeType];
    const numComponents = 9;
    for (let inst = 0; inst < model.numberOfInstances; inst++) {
      const ioffset = (entry.offset + inst * model.sizeInBytes) / view.BYTES_PER_ELEMENT;
      for (let j2 = 0; j2 < 3; j2++) {
        for (let i6 = 0; i6 < 3; i6++) {
          view[ioffset + j2 * 4 + i6] = arr[inst * numComponents + j2 * 3 + i6];
        }
      }
    }
  };
  publicAPI.getSendTime = () => model._sendTime.getMTime();
  publicAPI.getShaderCode = (binding, group) => {
    const lines = [`struct ${model.label}StructEntry
{`];
    for (let i6 = 0; i6 < model.bufferEntries.length; i6++) {
      const entry = model.bufferEntries[i6];
      lines.push(`  ${entry.name}: ${entry.type},`);
    }
    lines.push(`
};
struct ${model.label}Struct
{
  values: array<${model.label}StructEntry>,
};
@binding(${binding}) @group(${group}) var<storage, read> ${model.label}: ${model.label}Struct;
`);
    return lines.join("\n");
  };
  publicAPI.getBindGroupEntry = () => {
    const foo = {
      resource: {
        buffer: model._buffer.getHandle()
      }
    };
    return foo;
  };
  publicAPI.clearData = () => {
    model.numberOfInstances = 0;
    model.sizeInBytes = 0;
    model.bufferEntries = [];
    model._bufferEntryNames = /* @__PURE__ */ new Map();
    model._buffer = null;
    delete model.arrayBuffer;
    delete model.Float32Array;
  };
}
var DEFAULT_VALUES53 = {
  bufferEntries: null,
  bufferEntryNames: null,
  sizeInBytes: 0,
  label: null,
  numberOfInstances: 1
};
function extend54(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES53, initialValues);
  macro.obj(publicAPI, model);
  model._bufferEntryNames = /* @__PURE__ */ new Map();
  model.bufferEntries = [];
  model._sendTime = {};
  macro.obj(model._sendTime, {
    mtime: 0
  });
  model.bindGroupTime = {};
  macro.obj(model.bindGroupTime, {
    mtime: 0
  });
  model.bindGroupLayoutEntry = model.bindGroupLayoutEntry || {
    buffer: {
      type: "read-only-storage"
    }
  };
  macro.get(publicAPI, model, ["bindGroupTime"]);
  macro.setGet(publicAPI, model, ["device", "bindGroupLayoutEntry", "label", "numberOfInstances", "sizeInBytes"]);
  vtkWebGPUStorageBuffer(publicAPI, model);
}
var newInstance55 = macro.newInstance(extend54, "vtkWebGPUStorageBuffer");
var vtkWebGPUStorageBuffer$1 = {
  newInstance: newInstance55,
  extend: extend54
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/UniformBuffer.js
var {
  BufferUsage: BufferUsage4
} = vtkWebGPUBufferManager$1;
var {
  vtkErrorMacro: vtkErrorMacro21
} = macro;
function vtkWebGPUUniformBuffer(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUUniformBuffer");
  publicAPI.addEntry = (name, type) => {
    if (model._bufferEntryNames.has(name)) {
      vtkErrorMacro21(`entry named ${name} already exists`);
      return;
    }
    model.sortDirty = true;
    model._bufferEntryNames.set(name, model.bufferEntries.length);
    model.bufferEntries.push({
      name,
      type,
      sizeInBytes: vtkWebGPUTypes.getByteStrideFromShaderFormat(type),
      offset: -1,
      nativeType: vtkWebGPUTypes.getNativeTypeFromShaderFormat(type),
      packed: false
    });
  };
  publicAPI.sortBufferEntries = () => {
    if (!model.sortDirty) {
      return;
    }
    let currOffset = 0;
    const newEntries = [];
    let maxAlignment = 4;
    for (let i6 = 0; i6 < model.bufferEntries.length; i6++) {
      const entry = model.bufferEntries[i6];
      if (entry.sizeInBytes % 16 === 0) {
        maxAlignment = Math.max(16, maxAlignment);
      }
      if (entry.sizeInBytes % 8 === 0) {
        maxAlignment = Math.max(8, maxAlignment);
      }
    }
    for (let i6 = 0; i6 < model.bufferEntries.length; i6++) {
      const entry = model.bufferEntries[i6];
      if (entry.packed === false && entry.sizeInBytes % 16 === 0) {
        entry.packed = true;
        entry.offset = currOffset;
        newEntries.push(entry);
        currOffset += entry.sizeInBytes;
      }
    }
    for (let i6 = 0; i6 < model.bufferEntries.length; i6++) {
      const entry = model.bufferEntries[i6];
      if (entry.packed === false && entry.sizeInBytes === 12) {
        for (let i22 = 0; i22 < model.bufferEntries.length; i22++) {
          const entry2 = model.bufferEntries[i22];
          if (entry2.packed === false && entry2.sizeInBytes === 4) {
            entry.packed = true;
            entry.offset = currOffset;
            newEntries.push(entry);
            currOffset += entry.sizeInBytes;
            entry2.packed = true;
            entry2.offset = currOffset;
            newEntries.push(entry2);
            currOffset += entry2.sizeInBytes;
            break;
          }
        }
      }
    }
    for (let i6 = 0; i6 < model.bufferEntries.length; i6++) {
      const entry = model.bufferEntries[i6];
      if (!entry.packed && entry.sizeInBytes % 8 === 0) {
        for (let i22 = i6 + 1; i22 < model.bufferEntries.length; i22++) {
          const entry2 = model.bufferEntries[i22];
          if (!entry2.packed && entry2.sizeInBytes % 8 === 0) {
            entry.packed = true;
            entry.offset = currOffset;
            newEntries.push(entry);
            currOffset += entry.sizeInBytes;
            entry2.packed = true;
            entry2.offset = currOffset;
            newEntries.push(entry2);
            currOffset += entry2.sizeInBytes;
            break;
          }
        }
      }
    }
    for (let i6 = 0; i6 < model.bufferEntries.length; i6++) {
      const entry = model.bufferEntries[i6];
      if (!entry.packed && entry.sizeInBytes % 8 === 0) {
        let found = false;
        for (let i22 = 0; !found && i22 < model.bufferEntries.length; i22++) {
          const entry2 = model.bufferEntries[i22];
          if (!entry2.packed && entry2.sizeInBytes === 4) {
            for (let i32 = i22 + 1; i32 < model.bufferEntries.length; i32++) {
              const entry3 = model.bufferEntries[i32];
              if (!entry3.packed && entry3.sizeInBytes === 4) {
                entry.packed = true;
                entry.offset = currOffset;
                newEntries.push(entry);
                currOffset += entry.sizeInBytes;
                entry2.packed = true;
                entry2.offset = currOffset;
                newEntries.push(entry2);
                currOffset += entry2.sizeInBytes;
                entry3.packed = true;
                entry3.offset = currOffset;
                newEntries.push(entry3);
                currOffset += entry3.sizeInBytes;
                found = true;
                break;
              }
            }
          }
        }
      }
    }
    for (let i6 = 0; i6 < model.bufferEntries.length; i6++) {
      const entry = model.bufferEntries[i6];
      if (!entry.packed && entry.sizeInBytes > 4) {
        entry.packed = true;
        entry.offset = currOffset;
        newEntries.push(entry);
        currOffset += entry.sizeInBytes;
      }
    }
    for (let i6 = 0; i6 < model.bufferEntries.length; i6++) {
      const entry = model.bufferEntries[i6];
      if (!entry.packed) {
        entry.packed = true;
        entry.offset = currOffset;
        newEntries.push(entry);
        currOffset += entry.sizeInBytes;
      }
    }
    model.bufferEntries = newEntries;
    model._bufferEntryNames.clear();
    for (let i6 = 0; i6 < model.bufferEntries.length; i6++) {
      model._bufferEntryNames.set(model.bufferEntries[i6].name, i6);
    }
    model.sizeInBytes = currOffset;
    model.sizeInBytes = maxAlignment * Math.ceil(model.sizeInBytes / maxAlignment);
    model.sortDirty = false;
  };
  publicAPI.sendIfNeeded = (device) => {
    if (!model.UBO) {
      const req = {
        nativeArray: model.Float32Array,
        usage: BufferUsage4.UniformArray,
        label: model.label
      };
      model.UBO = device.getBufferManager().getBuffer(req);
      model.bindGroupTime.modified();
      model.sendDirty = false;
    }
    if (model.sendDirty) {
      device.getHandle().queue.writeBuffer(model.UBO.getHandle(), 0, model.arrayBuffer, 0, model.sizeInBytes);
      model.sendDirty = false;
    }
    model.sendTime.modified();
  };
  publicAPI.createView = (type) => {
    if (type in model === false) {
      if (!model.arrayBuffer) {
        model.arrayBuffer = new ArrayBuffer(model.sizeInBytes);
      }
      model[type] = macro.newTypedArray(type, model.arrayBuffer);
    }
  };
  publicAPI.setValue = (name, val) => {
    publicAPI.sortBufferEntries();
    const idx = model._bufferEntryNames.get(name);
    if (idx === void 0) {
      vtkErrorMacro21(`entry named ${name} not found in UBO`);
      return;
    }
    const entry = model.bufferEntries[idx];
    publicAPI.createView(entry.nativeType);
    const view = model[entry.nativeType];
    if (entry.lastValue !== val) {
      view[entry.offset / view.BYTES_PER_ELEMENT] = val;
      model.sendDirty = true;
    }
    entry.lastValue = val;
  };
  publicAPI.setArray = (name, arr) => {
    publicAPI.sortBufferEntries();
    const idx = model._bufferEntryNames.get(name);
    if (idx === void 0) {
      vtkErrorMacro21(`entry named ${name} not found in UBO`);
      return;
    }
    const entry = model.bufferEntries[idx];
    publicAPI.createView(entry.nativeType);
    const view = model[entry.nativeType];
    let changed = false;
    for (let i6 = 0; i6 < arr.length; i6++) {
      if (!entry.lastValue || entry.lastValue[i6] !== arr[i6]) {
        view[entry.offset / view.BYTES_PER_ELEMENT + i6] = arr[i6];
        changed = true;
      }
    }
    if (changed) {
      model.sendDirty = true;
      entry.lastValue = [...arr];
    }
  };
  publicAPI.getBindGroupEntry = () => {
    const foo = {
      resource: {
        buffer: model.UBO.getHandle()
      }
    };
    return foo;
  };
  publicAPI.getSendTime = () => model.sendTime.getMTime();
  publicAPI.getShaderCode = (binding, group) => {
    publicAPI.sortBufferEntries();
    const lines = [`struct ${model.label}Struct
{`];
    for (let i6 = 0; i6 < model.bufferEntries.length; i6++) {
      const entry = model.bufferEntries[i6];
      lines.push(`  ${entry.name}: ${entry.type},`);
    }
    lines.push(`};
@binding(${binding}) @group(${group}) var<uniform> ${model.label}: ${model.label}Struct;`);
    return lines.join("\n");
  };
}
var DEFAULT_VALUES54 = {
  bufferEntries: null,
  bufferEntryNames: null,
  sizeInBytes: 0,
  label: null,
  bindGroupLayoutEntry: null,
  bindGroupEntry: null
};
function extend55(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES54, initialValues);
  macro.obj(publicAPI, model);
  model._bufferEntryNames = /* @__PURE__ */ new Map();
  model.bufferEntries = [];
  model.bindGroupLayoutEntry = model.bindGroupLayoutEntry || {
    buffer: {
      type: "uniform"
    }
  };
  model.sendTime = {};
  macro.obj(model.sendTime, {
    mtime: 0
  });
  model.bindGroupTime = {};
  macro.obj(model.bindGroupTime, {
    mtime: 0
  });
  model.sendDirty = true;
  model.sortDirty = true;
  macro.get(publicAPI, model, ["binding", "bindGroupTime"]);
  macro.setGet(publicAPI, model, ["bindGroupLayoutEntry", "device", "label", "sizeInBytes"]);
  vtkWebGPUUniformBuffer(publicAPI, model);
}
var newInstance56 = macro.newInstance(extend55, "vtkWebGPUUniformBuffer");
var vtkWebGPUUniformBuffer$1 = {
  newInstance: newInstance56,
  extend: extend55
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/Renderer.js
var {
  vtkDebugMacro: vtkDebugMacro5
} = macro$1;
var clearFragColorTemplate = `
//VTK::Renderer::Dec

//VTK::Mapper::Dec

//VTK::TCoord::Dec

//VTK::RenderEncoder::Dec

//VTK::IOStructs::Dec

@fragment
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output: fragmentOutput;

  var computedColor: vec4<f32> = mapperUBO.BackgroundColor;

  //VTK::RenderEncoder::Impl
  return output;
}
`;
var clearFragTextureTemplate = `
fn vecToRectCoord(dir: vec3<f32>) -> vec2<f32> {
  var tau: f32 = 6.28318530718;
  var pi: f32 = 3.14159265359;
  var out: vec2<f32> = vec2<f32>(0.0);

  out.x = atan2(dir.z, dir.x) / tau;
  out.x += 0.5;

  var phix: f32 = length(vec2(dir.x, dir.z));
  out.y = atan2(dir.y, phix) / pi + 0.5;

  return out;
}

//VTK::Renderer::Dec

//VTK::Mapper::Dec

//VTK::TCoord::Dec

//VTK::RenderEncoder::Dec

//VTK::IOStructs::Dec

@fragment
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output: fragmentOutput;

  var tcoord: vec4<f32> = vec4<f32>(input.vertexVC.xy, -1, 1);
  var V: vec4<f32> = normalize(mapperUBO.FSQMatrix * tcoord); // vec2<f32>((input.tcoordVS.x - 0.5) * 2, -(input.tcoordVS.y - 0.5) * 2);
  // textureSampleLevel gets rid of some ugly artifacts
  var background = textureSampleLevel(EnvironmentTexture, EnvironmentTextureSampler, vecToRectCoord(V.xyz), 0.0);
  var computedColor: vec4<f32> = vec4<f32>(background.rgb, 1);

  //VTK::RenderEncoder::Impl
  return output;
}
`;
var _fsqClearMat4 = new Float64Array(16);
var _tNormalMat4 = new Float64Array(16);
function getLightTypeIndex(light) {
  if (light.getPositional()) {
    if (light.getConeAngle() >= 90) {
      return 0;
    }
    return 2;
  }
  return 1;
}
function vtkWebGPURenderer(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPURenderer");
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      if (!model.renderable) {
        return;
      }
      model.camera = model.renderable.getActiveCamera();
      publicAPI.updateLights();
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.camera);
      publicAPI.addMissingNodes(model.renderable.getViewPropsWithNestedProps());
      publicAPI.removeUnusedNodes();
      model.webgpuCamera = publicAPI.getViewNodeFor(model.camera);
      publicAPI.updateStabilizedMatrix();
    }
  };
  publicAPI.updateStabilizedMatrix = () => {
    const clipRange = model.camera.getClippingRange();
    const pos = model.camera.getPositionByReference();
    const dop = model.camera.getDirectionOfProjectionByReference();
    const center = [];
    const offset3 = [];
    vec3_exports.scale(offset3, dop, 0.5 * (clipRange[0] + clipRange[1]));
    vec3_exports.add(center, pos, offset3);
    vec3_exports.sub(offset3, center, model.stabilizedCenter);
    const length4 = vec3_exports.len(offset3);
    if (length4 / (clipRange[1] - clipRange[0]) > model.recenterThreshold) {
      model.stabilizedCenter = center;
      model.stabilizedTime.modified();
    }
  };
  publicAPI.updateLights = () => {
    let count = 0;
    const lights = model.renderable.getLightsByReference();
    for (let index2 = 0; index2 < lights.length; ++index2) {
      if (lights[index2].getSwitch() > 0) {
        count++;
      }
    }
    if (!count) {
      vtkDebugMacro5("No lights are on, creating one.");
      model.renderable.createLight();
    }
    return count;
  };
  publicAPI.updateUBO = () => {
    var _a9;
    const utime = model.UBO.getSendTime();
    if (model._parent.getMTime() > utime || publicAPI.getMTime() > utime || model.camera.getMTime() > utime || model.renderable.getMTime() > utime) {
      const keyMats = model.webgpuCamera.getKeyMatrices(publicAPI);
      model.UBO.setArray("WCVCMatrix", keyMats.wcvc);
      model.UBO.setArray("SCPCMatrix", keyMats.scpc);
      model.UBO.setArray("PCSCMatrix", keyMats.pcsc);
      model.UBO.setArray("SCVCMatrix", keyMats.scvc);
      model.UBO.setArray("VCPCMatrix", keyMats.vcpc);
      model.UBO.setArray("WCVCNormals", keyMats.normalMatrix);
      model.UBO.setValue("LightCount", model.renderable.getLights().length);
      model.UBO.setValue("MaxEnvironmentMipLevel", (_a9 = model.renderable.getEnvironmentTexture()) == null ? void 0 : _a9.getMipLevel());
      model.UBO.setValue("BackgroundDiffuseStrength", model.renderable.getEnvironmentTextureDiffuseStrength());
      model.UBO.setValue("BackgroundSpecularStrength", model.renderable.getEnvironmentTextureSpecularStrength());
      const tsize = publicAPI.getYInvertedTiledSizeAndOrigin();
      model.UBO.setArray("viewportSize", [tsize.usize, tsize.vsize]);
      model.UBO.setValue("cameraParallel", model.camera.getParallelProjection());
      const device = model._parent.getDevice();
      model.UBO.sendIfNeeded(device);
    }
  };
  publicAPI.updateSSBO = () => {
    const lights = model.renderable.getLights();
    const keyMats = model.webgpuCamera.getKeyMatrices(publicAPI);
    let lightTimeString = `${model.renderable.getMTime()}`;
    for (let i6 = 0; i6 < lights.length; i6++) {
      lightTimeString += lights[i6].getMTime();
    }
    if (lightTimeString !== model.lightTimeString) {
      const lightPosArray = new Float32Array(lights.length * 4);
      const lightDirArray = new Float32Array(lights.length * 4);
      const lightColorArray = new Float32Array(lights.length * 4);
      const lightTypeArray = new Float32Array(lights.length * 4);
      for (let i6 = 0; i6 < lights.length; i6++) {
        const offset3 = i6 * 4;
        const viewCoordinatePosition = lights[i6].getPosition();
        vec3_exports.transformMat4(viewCoordinatePosition, viewCoordinatePosition, keyMats.wcvc);
        lightPosArray[offset3] = viewCoordinatePosition[0];
        lightPosArray[offset3 + 1] = viewCoordinatePosition[1];
        lightPosArray[offset3 + 2] = viewCoordinatePosition[2];
        lightPosArray[offset3 + 3] = 0;
        lightDirArray[offset3] = -lights[i6].getDirection()[0];
        lightDirArray[offset3 + 1] = -lights[i6].getDirection()[1];
        lightDirArray[offset3 + 2] = -lights[i6].getDirection()[2];
        lightDirArray[offset3 + 3] = 0;
        lightColorArray[offset3] = lights[i6].getColor()[0];
        lightColorArray[offset3 + 1] = lights[i6].getColor()[1];
        lightColorArray[offset3 + 2] = lights[i6].getColor()[2];
        lightColorArray[offset3 + 3] = lights[i6].getIntensity() * 5;
        lightTypeArray[offset3] = getLightTypeIndex(lights[i6]);
        lightTypeArray[offset3 + 1] = Math.cos(radiansFromDegrees(lights[i6].getConeAngle()));
        lightTypeArray[offset3 + 2] = Math.cos(radiansFromDegrees(lights[i6].getConeAngle() + lights[i6].getConeFalloff()));
        lightTypeArray[offset3 + 3] = 0;
      }
      model.SSBO.clearData();
      model.SSBO.setNumberOfInstances(lights.length);
      model.SSBO.addEntry("LightPos", "vec4<f32>");
      model.SSBO.addEntry("LightDir", "vec4<f32>");
      model.SSBO.addEntry("LightColor", "vec4<f32>");
      model.SSBO.addEntry("LightData", "vec4<f32>");
      model.SSBO.setAllInstancesFromArray("LightPos", lightPosArray);
      model.SSBO.setAllInstancesFromArray("LightDir", lightDirArray);
      model.SSBO.setAllInstancesFromArray("LightColor", lightColorArray);
      model.SSBO.setAllInstancesFromArray("LightData", lightTypeArray);
      const device = model._parent.getDevice();
      model.SSBO.send(device);
    }
    model.lightTimeString = lightTimeString;
  };
  publicAPI.scissorAndViewport = (encoder2) => {
    const tsize = publicAPI.getYInvertedTiledSizeAndOrigin();
    encoder2.getHandle().setViewport(tsize.lowerLeftU, tsize.lowerLeftV, tsize.usize, tsize.vsize, 0, 1);
    encoder2.getHandle().setScissorRect(tsize.lowerLeftU, tsize.lowerLeftV, tsize.usize, tsize.vsize);
  };
  publicAPI.bindUBO = (renderEncoder) => {
    renderEncoder.activateBindGroup(model.bindGroup);
  };
  publicAPI.opaquePass = (prepass) => {
    if (prepass) {
      model.renderEncoder.begin(model._parent.getCommandEncoder());
      publicAPI.updateUBO();
      publicAPI.updateSSBO();
    } else {
      publicAPI.scissorAndViewport(model.renderEncoder);
      publicAPI.clear();
      model.renderEncoder.end();
    }
  };
  publicAPI.clear = () => {
    var _a9;
    if (model.renderable.getTransparent() || model.suppressClear) {
      return;
    }
    const device = model._parent.getDevice();
    if (!model.clearFSQ) {
      model.clearFSQ = vtkWebGPUFullScreenQuad$1.newInstance();
      model.clearFSQ.setDevice(device);
      model.clearFSQ.setPipelineHash("clearfsq");
      model.clearFSQ.setFragmentShaderTemplate(clearFragColorTemplate);
      const ubo = vtkWebGPUUniformBuffer$1.newInstance({
        label: "mapperUBO"
      });
      ubo.addEntry("FSQMatrix", "mat4x4<f32>");
      ubo.addEntry("BackgroundColor", "vec4<f32>");
      model.clearFSQ.setUBO(ubo);
      model.backgroundTex = model.renderable.getEnvironmentTexture();
    }
    if (model.clearFSQ.getPipelineHash() !== "clearfsqwithtexture" && model.renderable.getUseEnvironmentTextureAsBackground() && ((_a9 = model.backgroundTex) == null ? void 0 : _a9.getImageLoaded())) {
      model.clearFSQ.setFragmentShaderTemplate(clearFragTextureTemplate);
      const ubo = vtkWebGPUUniformBuffer$1.newInstance({
        label: "mapperUBO"
      });
      ubo.addEntry("FSQMatrix", "mat4x4<f32>");
      ubo.addEntry("BackgroundColor", "vec4<f32>");
      model.clearFSQ.setUBO(ubo);
      const environmentTextureHash = device.getTextureManager().getTextureForVTKTexture(model.backgroundTex);
      if (environmentTextureHash.getReady()) {
        const tview = environmentTextureHash.createView(`EnvironmentTexture`);
        model.clearFSQ.setTextureViews([tview]);
        model.backgroundTexLoaded = true;
        const interpolate = model.backgroundTex.getInterpolate() ? "linear" : "nearest";
        tview.addSampler(device, {
          addressModeU: "repeat",
          addressModeV: "clamp-to-edge",
          addressModeW: "repeat",
          minFilter: interpolate,
          magFilter: interpolate,
          mipmapFilter: "linear"
        });
      }
      model.clearFSQ.setPipelineHash("clearfsqwithtexture");
    } else if (model.clearFSQ.getPipelineHash() === "clearfsqwithtexture" && !model.renderable.getUseEnvironmentTextureAsBackground()) {
      model.clearFSQ = vtkWebGPUFullScreenQuad$1.newInstance();
      model.clearFSQ.setDevice(device);
      model.clearFSQ.setPipelineHash("clearfsq");
      model.clearFSQ.setFragmentShaderTemplate(clearFragColorTemplate);
      const ubo = vtkWebGPUUniformBuffer$1.newInstance({
        label: "mapperUBO"
      });
      ubo.addEntry("FSQMatrix", "mat4x4<f32>");
      ubo.addEntry("BackgroundColor", "vec4<f32>");
      model.clearFSQ.setUBO(ubo);
    }
    const keyMats = model.webgpuCamera.getKeyMatrices(publicAPI);
    const background = model.renderable.getBackgroundByReference();
    model.clearFSQ.getUBO().setArray("BackgroundColor", background);
    mat4_exports.transpose(_tNormalMat4, keyMats.normalMatrix);
    mat4_exports.mul(_fsqClearMat4, keyMats.scvc, keyMats.pcsc);
    mat4_exports.mul(_fsqClearMat4, _tNormalMat4, _fsqClearMat4);
    model.clearFSQ.getUBO().setArray("FSQMatrix", _fsqClearMat4);
    model.clearFSQ.getUBO().sendIfNeeded(device);
    model.clearFSQ.prepareAndDraw(model.renderEncoder);
  };
  publicAPI.translucentPass = (prepass) => {
    if (prepass) {
      model.renderEncoder.begin(model._parent.getCommandEncoder());
    } else {
      publicAPI.scissorAndViewport(model.renderEncoder);
      model.renderEncoder.end();
    }
  };
  publicAPI.volumeDepthRangePass = (prepass) => {
    if (prepass) {
      model.renderEncoder.begin(model._parent.getCommandEncoder());
    } else {
      publicAPI.scissorAndViewport(model.renderEncoder);
      model.renderEncoder.end();
    }
  };
  publicAPI.getAspectRatio = () => {
    const size3 = model._parent.getSizeByReference();
    const viewport = model.renderable.getViewportByReference();
    return size3[0] * (viewport[2] - viewport[0]) / ((viewport[3] - viewport[1]) * size3[1]);
  };
  publicAPI.convertToOpenGLDepth = (val) => model.webgpuCamera.convertToOpenGLDepth(val);
  publicAPI.getYInvertedTiledSizeAndOrigin = () => {
    const res = publicAPI.getTiledSizeAndOrigin();
    const size3 = model._parent.getSizeByReference();
    res.lowerLeftV = size3[1] - res.vsize - res.lowerLeftV;
    return res;
  };
  publicAPI.getTiledSizeAndOrigin = () => {
    const vport = model.renderable.getViewportByReference();
    const tileViewPort = [0, 0, 1, 1];
    const vpu = vport[0] - tileViewPort[0];
    const vpv = vport[1] - tileViewPort[1];
    const ndvp = model._parent.normalizedDisplayToDisplay(vpu, vpv);
    const lowerLeftU = Math.round(ndvp[0]);
    const lowerLeftV = Math.round(ndvp[1]);
    const vpu2 = vport[2] - tileViewPort[0];
    const vpv2 = vport[3] - tileViewPort[1];
    const ndvp2 = model._parent.normalizedDisplayToDisplay(vpu2, vpv2);
    let usize = Math.round(ndvp2[0]) - lowerLeftU;
    let vsize = Math.round(ndvp2[1]) - lowerLeftV;
    if (usize < 0) {
      usize = 0;
    }
    if (vsize < 0) {
      vsize = 0;
    }
    return {
      usize,
      vsize,
      lowerLeftU,
      lowerLeftV
    };
  };
  publicAPI.getPropFromID = (id) => {
    for (let i6 = 0; i6 < model.children.length; i6++) {
      const res = model.children[i6].getPropID ? model.children[i6].getPropID() : -1;
      if (res === id) {
        return model.children[i6];
      }
    }
    return null;
  };
  publicAPI.getStabilizedTime = () => model.stabilizedTime.getMTime();
  publicAPI.releaseGraphicsResources = () => {
    if (model.selector !== null) {
      model.selector.releaseGraphicsResources();
    }
  };
}
var DEFAULT_VALUES55 = {
  bindGroup: null,
  selector: null,
  renderEncoder: null,
  recenterThreshold: 20,
  suppressClear: false,
  stabilizedCenter: [0, 0, 0]
};
function extend56(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES55, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.UBO = vtkWebGPUUniformBuffer$1.newInstance({
    label: "rendererUBO"
  });
  model.UBO.addEntry("WCVCMatrix", "mat4x4<f32>");
  model.UBO.addEntry("SCPCMatrix", "mat4x4<f32>");
  model.UBO.addEntry("PCSCMatrix", "mat4x4<f32>");
  model.UBO.addEntry("SCVCMatrix", "mat4x4<f32>");
  model.UBO.addEntry("VCPCMatrix", "mat4x4<f32>");
  model.UBO.addEntry("WCVCNormals", "mat4x4<f32>");
  model.UBO.addEntry("viewportSize", "vec2<f32>");
  model.UBO.addEntry("LightCount", "i32");
  model.UBO.addEntry("MaxEnvironmentMipLevel", "f32");
  model.UBO.addEntry("BackgroundDiffuseStrength", "f32");
  model.UBO.addEntry("BackgroundSpecularStrength", "f32");
  model.UBO.addEntry("cameraParallel", "u32");
  model.SSBO = vtkWebGPUStorageBuffer$1.newInstance({
    label: "rendererLightSSBO"
  });
  model.lightTimeString = "";
  model.bindGroup = vtkWebGPUBindGroup$1.newInstance({
    label: "rendererBG"
  });
  model.bindGroup.setBindables([model.UBO, model.SSBO]);
  model.tmpMat4 = mat4_exports.identity(new Float64Array(16));
  model.stabilizedTime = {};
  obj(model.stabilizedTime, {
    mtime: 0
  });
  get(publicAPI, model, ["bindGroup", "stabilizedTime"]);
  getArray(publicAPI, model, ["stabilizedCenter"]);
  setGet(publicAPI, model, ["renderEncoder", "selector", "suppressClear", "UBO"]);
  vtkWebGPURenderer(publicAPI, model);
}
var newInstance57 = newInstance(extend56, "vtkWebGPURenderer");
registerOverride2("vtkRenderer", newInstance57);

// node_modules/@kitware/vtk.js/Rendering/WebGPU/Sampler.js
function vtkWebGPUSampler(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUSampler");
  publicAPI.create = function(device) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    model.device = device;
    model.options.addressModeU = options.addressModeU ? options.addressModeU : "clamp-to-edge";
    model.options.addressModeV = options.addressModeV ? options.addressModeV : "clamp-to-edge";
    model.options.addressModeW = options.addressModeW ? options.addressModeW : "clamp-to-edge";
    model.options.magFilter = options.magFilter ? options.magFilter : "nearest";
    model.options.minFilter = options.minFilter ? options.minFilter : "nearest";
    model.options.mipmapFilter = options.mipmapFilter ? options.mipmapFilter : "nearest";
    model.options.label = model.label;
    model.handle = model.device.getHandle().createSampler(model.options);
    model.bindGroupTime.modified();
  };
  publicAPI.getShaderCode = (binding, group) => {
    const result = `@binding(${binding}) @group(${group}) var ${model.label}: sampler;`;
    return result;
  };
  publicAPI.getBindGroupEntry = () => {
    const foo = {
      resource: model.handle
    };
    return foo;
  };
}
var DEFAULT_VALUES56 = {
  device: null,
  handle: null,
  label: null,
  options: null
};
function extend57(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES56, initialValues);
  macro.obj(publicAPI, model);
  model.options = {};
  model.bindGroupLayoutEntry = {
    /* eslint-disable no-undef */
    visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
    /* eslint-enable no-undef */
    sampler: {
      // type: 'filtering',
    }
  };
  model.bindGroupTime = {};
  macro.obj(model.bindGroupTime, {
    mtime: 0
  });
  macro.get(publicAPI, model, ["bindGroupTime", "handle", "options"]);
  macro.setGet(publicAPI, model, ["bindGroupLayoutEntry", "device", "label"]);
  vtkWebGPUSampler(publicAPI, model);
}
var newInstance58 = macro.newInstance(extend57);
var vtkWebGPUSampler$1 = {
  newInstance: newInstance58,
  extend: extend57
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/ImageMapper.js
var {
  SlicingMode: SlicingMode3
} = Constants8;
var imgFragTemplate = `
//VTK::Renderer::Dec

//VTK::Mapper::Dec

//VTK::TCoord::Dec

//VTK::Image::Dec

//VTK::RenderEncoder::Dec

//VTK::IOStructs::Dec

@fragment
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output: fragmentOutput;

  //VTK::Image::Sample

  // var computedColor: vec4<f32> = vec4<f32>(1.0,0.7, 0.5, 1.0);

//VTK::RenderEncoder::Impl

  return output;
}
`;
function computeFnToString5(property, fn, numberOfComponents) {
  const pwfun = fn.apply(property);
  if (pwfun) {
    const iComps = property.getIndependentComponents();
    return `${property.getMTime()}-${iComps}-${numberOfComponents}`;
  }
  return "0";
}
var tmpMat4 = new Float64Array(16);
var tmp2Mat4 = new Float64Array(16);
var tmp3Mat4 = new Float64Array(16);
var ptsArray1 = new Float64Array(4);
var ptsArray2 = new Float64Array(4);
function vtkWebGPUImageMapper(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUImageMapper");
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      model.WebGPUImageSlice = publicAPI.getFirstAncestorOfType("vtkWebGPUImageSlice");
      model.WebGPURenderer = model.WebGPUImageSlice.getFirstAncestorOfType("vtkWebGPURenderer");
      model.WebGPURenderWindow = model.WebGPURenderer.getParent();
      model.device = model.WebGPURenderWindow.getDevice();
      const ren = model.WebGPURenderer.getRenderable();
      if (model.renderable.getSliceAtFocalPoint()) {
        model.renderable.setSliceFromCamera(ren.getActiveCamera());
      }
    }
  };
  publicAPI.translucentPass = (prepass) => {
    if (prepass) {
      publicAPI.render();
    }
  };
  publicAPI.opaquePass = (prepass) => {
    if (prepass) {
      publicAPI.render();
    }
  };
  publicAPI.render = () => {
    model.renderable.update();
    model.currentInput = model.renderable.getInputData();
    publicAPI.prepareToDraw(model.WebGPURenderer.getRenderEncoder());
    model.renderEncoder.registerDrawCallback(model.pipeline, publicAPI.draw);
  };
  publicAPI.computePipelineHash = () => {
    const ext = model.currentInput.getExtent();
    if (ext[0] === ext[1] || ext[2] === ext[3] || ext[4] === ext[5]) {
      model.dimensions = 2;
      model.pipelineHash = "img2";
    } else {
      model.dimensions = 3;
      model.pipelineHash = "img3";
    }
  };
  publicAPI.updateUBO = () => {
    const utime = model.UBO.getSendTime();
    const actor = model.WebGPUImageSlice.getRenderable();
    const volMapr = actor.getMapper();
    if (publicAPI.getMTime() > utime || model.renderable.getMTime() > utime || actor.getProperty().getMTime() > utime) {
      const image2 = volMapr.getInputData();
      const center = model.WebGPURenderer.getStabilizedCenterByReference();
      mat4_exports.identity(tmpMat4);
      mat4_exports.translate(tmpMat4, tmpMat4, center);
      const mcwcmat = actor.getMatrix();
      mat4_exports.transpose(tmp2Mat4, mcwcmat);
      mat4_exports.invert(tmp2Mat4, tmp2Mat4);
      mat4_exports.multiply(tmpMat4, tmp2Mat4, tmpMat4);
      const modelToIndex = image2.getWorldToIndex();
      mat4_exports.multiply(tmpMat4, modelToIndex, tmpMat4);
      mat4_exports.invert(tmp3Mat4, tmpMat4);
      mat4_exports.fromTranslation(tmp2Mat4, [0.5, 0.5, 0.5]);
      mat4_exports.multiply(tmpMat4, tmp2Mat4, tmpMat4);
      const dims = image2.getDimensions();
      mat4_exports.identity(tmp2Mat4);
      mat4_exports.scale(tmp2Mat4, tmp2Mat4, [1 / dims[0], 1 / dims[1], 1 / dims[2]]);
      mat4_exports.multiply(tmpMat4, tmp2Mat4, tmpMat4);
      model.UBO.setArray("SCTCMatrix", tmpMat4);
      const ext = model.currentInput.getExtent();
      const {
        ijkMode
      } = model.renderable.getClosestIJKAxis();
      let nSlice = model.renderable.getSlice();
      if (ijkMode !== model.renderable.getSlicingMode()) {
        nSlice = model.renderable.getSliceAtPosition(nSlice);
      }
      let axis0 = 2;
      let axis1 = 0;
      let axis2 = 1;
      if (ijkMode === SlicingMode3.I) {
        axis0 = 0;
        axis1 = 1;
        axis2 = 2;
      } else if (ijkMode === SlicingMode3.J) {
        axis0 = 1;
        axis1 = 2;
        axis2 = 0;
      }
      ptsArray1[axis0] = nSlice;
      ptsArray1[axis1] = ext[axis1 * 2] - 0.5;
      ptsArray1[axis2] = ext[axis2 * 2] - 0.5;
      ptsArray1[3] = 1;
      vec4_exports.transformMat4(ptsArray1, ptsArray1, tmp3Mat4);
      model.UBO.setArray("Origin", ptsArray1);
      ptsArray2[axis0] = nSlice;
      ptsArray2[axis1] = ext[axis1 * 2 + 1] + 0.5;
      ptsArray2[axis2] = ext[axis2 * 2] - 0.5;
      ptsArray2[3] = 1;
      vec4_exports.transformMat4(ptsArray2, ptsArray2, tmp3Mat4);
      vec4_exports.subtract(ptsArray2, ptsArray2, ptsArray1);
      ptsArray2[3] = 1;
      model.UBO.setArray("Axis1", ptsArray2);
      ptsArray2[axis0] = nSlice;
      ptsArray2[axis1] = ext[axis1 * 2] - 0.5;
      ptsArray2[axis2] = ext[axis2 * 2 + 1] + 0.5;
      ptsArray2[3] = 1;
      vec4_exports.transformMat4(ptsArray2, ptsArray2, tmp3Mat4);
      vec4_exports.subtract(ptsArray2, ptsArray2, ptsArray1);
      ptsArray2[3] = 1;
      model.UBO.setArray("Axis2", ptsArray2);
      const cScale = [1, 1, 1, 1];
      const cShift = [0, 0, 0, 0];
      const tView = model.textureViews[0];
      const tScale = tView.getTexture().getScale();
      const numComp = tView.getTexture().getNumberOfComponents();
      for (let i6 = 0; i6 < numComp; i6++) {
        let cw = actor.getProperty().getColorWindow();
        let cl = actor.getProperty().getColorLevel();
        const target = 0;
        const cfun = actor.getProperty().getRGBTransferFunction(target);
        if (cfun) {
          const cRange = cfun.getRange();
          cw = cRange[1] - cRange[0];
          cl = 0.5 * (cRange[1] + cRange[0]);
        }
        cScale[i6] = tScale / cw;
        cShift[i6] = -cl / cw + 0.5;
      }
      model.UBO.setArray("cScale", cScale);
      model.UBO.setArray("cShift", cShift);
      model.UBO.sendIfNeeded(model.device);
    }
  };
  publicAPI.updateLUTImage = () => {
    const actorProperty = model.WebGPUImageSlice.getRenderable().getProperty();
    const tView = publicAPI.getTextureViews()[0];
    tView.getTexture().getNumberOfComponents();
    const numIComps = 1;
    const cfunToString = computeFnToString5(actorProperty, actorProperty.getRGBTransferFunction, numIComps);
    if (model.colorTextureString !== cfunToString) {
      model.numRows = numIComps;
      const colorArray = new Uint8ClampedArray(model.numRows * 2 * model.rowLength * 4);
      let cfun = actorProperty.getRGBTransferFunction();
      if (cfun) {
        const tmpTable = new Float32Array(model.rowLength * 3);
        for (let c6 = 0; c6 < numIComps; c6++) {
          cfun = actorProperty.getRGBTransferFunction(c6);
          const cRange = cfun.getRange();
          cfun.getTable(cRange[0], cRange[1], model.rowLength, tmpTable, 1);
          {
            for (let i6 = 0; i6 < model.rowLength; i6++) {
              const idx = c6 * model.rowLength * 8 + i6 * 4;
              colorArray[idx] = 255 * tmpTable[i6 * 3];
              colorArray[idx + 1] = 255 * tmpTable[i6 * 3 + 1];
              colorArray[idx + 2] = 255 * tmpTable[i6 * 3 + 2];
              colorArray[idx + 3] = 255;
              for (let j2 = 0; j2 < 4; j2++) {
                colorArray[idx + model.rowLength * 4 + j2] = colorArray[idx + j2];
              }
            }
          }
        }
      } else {
        for (let i6 = 0; i6 < model.rowLength; ++i6) {
          const grey = 255 * i6 / (model.rowLength - 1);
          colorArray[i6 * 4] = grey;
          colorArray[i6 * 4 + 1] = grey;
          colorArray[i6 * 4 + 2] = grey;
          colorArray[i6 * 4 + 3] = 255;
          for (let j2 = 0; j2 < 4; j2++) {
            colorArray[i6 * 4 + model.rowLength * 4 + j2] = colorArray[i6 * 4 + j2];
          }
        }
      }
      {
        const treq = {
          nativeArray: colorArray,
          width: model.rowLength,
          height: model.numRows * 2,
          depth: 1,
          format: "rgba8unorm"
        };
        const newTex = model.device.getTextureManager().getTexture(treq);
        const tview = newTex.createView("tfunTexture");
        model.textureViews[1] = tview;
      }
      model.colorTextureString = cfunToString;
    }
  };
  const superClassUpdateBuffers = publicAPI.updateBuffers;
  publicAPI.updateBuffers = () => {
    superClassUpdateBuffers();
    const newTex = model.device.getTextureManager().getTextureForImageData(model.currentInput);
    const tViews = model.textureViews;
    if (!tViews[0] || tViews[0].getTexture() !== newTex) {
      const tview = newTex.createView("imgTexture");
      tViews[0] = tview;
    }
    publicAPI.updateLUTImage();
    publicAPI.updateUBO();
    const actorProperty = model.WebGPUImageSlice.getRenderable().getProperty();
    const iType = actorProperty.getInterpolationType() === InterpolationType.NEAREST ? "nearest" : "linear";
    if (!model.clampSampler || iType !== model.clampSampler.getOptions().minFilter) {
      model.clampSampler = vtkWebGPUSampler$1.newInstance({
        label: "clampSampler"
      });
      model.clampSampler.create(model.device, {
        minFilter: iType,
        magFilter: iType
      });
      model.additionalBindables = [model.clampSampler];
    }
  };
  const sr = publicAPI.getShaderReplacements();
  publicAPI.replaceShaderPosition = (hash, pipeline, vertexInput) => {
    const vDesc = pipeline.getShaderDescription("vertex");
    vDesc.addBuiltinOutput("vec4<f32>", "@builtin(position) Position");
    let code = vDesc.getCode();
    const lines = ["var pos: vec4<f32> = mapperUBO.Origin +", "   (vertexBC.x * 0.5 + 0.5) * mapperUBO.Axis1 + (vertexBC.y * 0.5 + 0.5) * mapperUBO.Axis2;", "pos.w = 1.0;"];
    if (model.dimensions === 2) {
      lines.push("var tcoord : vec2<f32> = (mapperUBO.SCTCMatrix * pos).xy;");
    } else {
      lines.push("var tcoord : vec3<f32> = (mapperUBO.SCTCMatrix * pos).xyz;");
    }
    lines.push("output.tcoordVS = tcoord;", "output.Position = rendererUBO.SCPCMatrix * pos;");
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Position::Impl", lines).result;
    vDesc.setCode(code);
  };
  sr.set("replaceShaderPosition", publicAPI.replaceShaderPosition);
  publicAPI.replaceShaderTCoord = (hash, pipeline, vertexInput) => {
    const vDesc = pipeline.getShaderDescription("vertex");
    if (model.dimensions === 2) {
      vDesc.addOutput("vec2<f32>", "tcoordVS");
    } else {
      vDesc.addOutput("vec3<f32>", "tcoordVS");
    }
  };
  sr.set("replaceShaderTCoord", publicAPI.replaceShaderTCoord);
  publicAPI.replaceShaderImage = (hash, pipeline, vertexInput) => {
    const fDesc = pipeline.getShaderDescription("fragment");
    let code = fDesc.getCode();
    if (model.dimensions === 3) {
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Image::Sample", [`    var computedColor: vec4<f32> =`, `      textureSampleLevel(imgTexture, clampSampler, input.tcoordVS, 0.0);`, `//VTK::Image::Sample`]).result;
    } else {
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Image::Sample", [`    var computedColor: vec4<f32> =`, `      textureSampleLevel(imgTexture, clampSampler, input.tcoordVS, 0.0);`, `//VTK::Image::Sample`]).result;
    }
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Image::Sample", [`    var coord: vec2<f32> =`, `      vec2<f32>(computedColor.r * mapperUBO.cScale.r + mapperUBO.cShift.r, 0.5);`, `    computedColor = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);`]).result;
    fDesc.setCode(code);
  };
  sr.set("replaceShaderImage", publicAPI.replaceShaderImage);
}
var DEFAULT_VALUES57 = {
  rowLength: 1024
};
function extend58(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES57, initialValues);
  vtkWebGPUFullScreenQuad$1.extend(publicAPI, model, initialValues);
  publicAPI.setFragmentShaderTemplate(imgFragTemplate);
  model.UBO = vtkWebGPUUniformBuffer$1.newInstance({
    label: "mapperUBO"
  });
  model.UBO.addEntry("SCTCMatrix", "mat4x4<f32>");
  model.UBO.addEntry("Origin", "vec4<f32>");
  model.UBO.addEntry("Axis2", "vec4<f32>");
  model.UBO.addEntry("Axis1", "vec4<f32>");
  model.UBO.addEntry("cScale", "vec4<f32>");
  model.UBO.addEntry("cShift", "vec4<f32>");
  model.lutBuildTime = {};
  obj(model.lutBuildTime, {
    mtime: 0
  });
  model.imagemat = mat4_exports.identity(new Float64Array(16));
  model.imagematinv = mat4_exports.identity(new Float64Array(16));
  model.VBOBuildTime = {};
  obj(model.VBOBuildTime);
  vtkWebGPUImageMapper(publicAPI, model);
}
var newInstance59 = newInstance(extend58, "vtkWebGPUImageMapper");
registerOverride2("vtkImageMapper", newInstance59);

// node_modules/@kitware/vtk.js/Rendering/WebGPU/ImageSlice.js
function vtkWebGPUImageSlice(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUImageSlice");
  publicAPI.buildPass = (prepass) => {
    if (!model.renderable || !model.renderable.getVisibility()) {
      return;
    }
    if (prepass) {
      if (!model.renderable) {
        return;
      }
      model.WebGPURenderer = publicAPI.getFirstAncestorOfType("vtkWebGPURenderer");
      model.WebGPURenderWindow = model.WebGPURenderer.getFirstAncestorOfType("vtkWebGPURenderWindow");
      if (model.propID === void 0) {
        model.propID = model.WebGPURenderWindow.getUniquePropID();
      }
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.renderable.getMapper());
      publicAPI.removeUnusedNodes();
    }
  };
  publicAPI.traverseOpaquePass = (renderPass) => {
    if (!model.renderable || !model.renderable.getNestedVisibility() || !model.renderable.getIsOpaque() || model.WebGPURenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.children.forEach((child) => {
      child.traverse(renderPass);
    });
    publicAPI.apply(renderPass, false);
  };
  publicAPI.traverseTranslucentPass = (renderPass) => {
    if (!model.renderable || !model.renderable.getNestedVisibility() || model.renderable.getIsOpaque() || model.WebGPURenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.children.forEach((child) => {
      child.traverse(renderPass);
    });
    publicAPI.apply(renderPass, false);
  };
  publicAPI.queryPass = (prepass, renderPass) => {
    if (prepass) {
      if (!model.renderable || !model.renderable.getVisibility()) {
        return;
      }
      if (model.renderable.getIsOpaque()) {
        renderPass.incrementOpaqueActorCount();
      } else {
        renderPass.incrementTranslucentActorCount();
      }
    }
  };
  publicAPI.getBufferShift = (wgpuRen) => {
    publicAPI.getKeyMatrices(wgpuRen);
    return model.bufferShift;
  };
  publicAPI.getKeyMatrices = (wgpuRen) => {
    if (Math.max(model.renderable.getMTime(), wgpuRen.getStabilizedTime()) > model.keyMatricesTime.getMTime()) {
      model.renderable.computeMatrix();
      const mcwc = model.renderable.getMatrix();
      const center = wgpuRen.getStabilizedCenterByReference();
      model.bufferShift[0] = mcwc[3] - center[0];
      model.bufferShift[1] = mcwc[7] - center[1];
      model.bufferShift[2] = mcwc[11] - center[2];
      mat4_exports.transpose(model.keyMatrices.bcwc, mcwc);
      if (model.renderable.getIsIdentity()) {
        mat4_exports.identity(model.keyMatrices.normalMatrix);
      } else {
        mat4_exports.copy(model.keyMatrices.normalMatrix, model.keyMatrices.bcwc);
        model.keyMatrices.normalMatrix[3] = 0;
        model.keyMatrices.normalMatrix[7] = 0;
        model.keyMatrices.normalMatrix[11] = 0;
        mat4_exports.invert(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);
        mat4_exports.transpose(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);
      }
      mat4_exports.translate(model.keyMatrices.bcwc, model.keyMatrices.bcwc, [-model.bufferShift[0], -model.bufferShift[1], -model.bufferShift[2]]);
      mat4_exports.translate(model.keyMatrices.bcsc, model.keyMatrices.bcwc, [-center[0], -center[1], -center[2]]);
      model.keyMatricesTime.modified();
    }
    return model.keyMatrices;
  };
}
var DEFAULT_VALUES58 = {
  bufferShift: void 0,
  keyMatrixTime: null,
  keyMatrices: null,
  propID: void 0
};
function extend59(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES58, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.keyMatricesTime = {};
  obj(model.keyMatricesTime, {
    mtime: 0
  });
  model.keyMatrices = {
    normalMatrix: new Float64Array(16),
    bcwc: new Float64Array(16),
    bcsc: new Float64Array(16)
  };
  model.keyMatrixTime = {};
  obj(model.keyMatrixTime, {
    mtime: 0
  });
  model.keyMatrices = {
    mcwc: mat4_exports.identity(new Float64Array(16))
  };
  model.bufferShift = [0, 0, 0, 0];
  get(publicAPI, model, ["propID", "keyMatricesTime"]);
  vtkWebGPUImageSlice(publicAPI, model);
}
var newInstance60 = newInstance(extend59, "vtkWebGPUImageSlice");
registerOverride2("vtkImageSlice", newInstance60);

// node_modules/@kitware/vtk.js/Rendering/WebGPU/Volume.js
function vtkWebGPUVolume(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUVolume");
  publicAPI.buildPass = (prepass) => {
    if (!model.renderable || !model.renderable.getVisibility()) {
      return;
    }
    if (prepass) {
      model.WebGPURenderer = publicAPI.getFirstAncestorOfType("vtkWebGPURenderer");
      model.WebGPURenderWindow = model.WebGPURenderer.getFirstAncestorOfType("vtkWebGPURenderWindow");
      if (model.propID === void 0) {
        model.propID = model.WebGPURenderWindow.getUniquePropID();
      }
      model.renderable.getMapper().update();
    }
  };
  publicAPI.queryPass = (prepass, renderPass) => {
    if (prepass) {
      if (!model.renderable || !model.renderable.getVisibility()) {
        return;
      }
      const bds = model.renderable.getMapper().getBounds();
      if (!bds || bds.length !== 6 || bds[0] > bds[1]) {
        return;
      }
      renderPass.addVolume(publicAPI);
    }
  };
  const idx = new Float64Array(3);
  const vout = new Float64Array(3);
  publicAPI.getBoundingCubePoints = (result, offset3) => {
    const input = model.renderable.getMapper().getInputData();
    if (!input) {
      return;
    }
    const extent = input.getExtent();
    const m3 = model.renderable.getMatrix();
    let count = 0;
    for (let iz = 4; iz < 6; iz++) {
      idx[2] = extent[iz];
      for (let iy = 2; iy < 4; iy++) {
        idx[1] = extent[iy];
        for (let ix = 0; ix < 2; ix++) {
          idx[0] = extent[ix];
          input.indexToWorld(idx, vout);
          let poffset = offset3 + count * 3;
          result[poffset++] = m3[0] * vout[0] + m3[1] * vout[1] + m3[2] * vout[2] + m3[3];
          result[poffset++] = m3[4] * vout[0] + m3[5] * vout[1] + m3[6] * vout[2] + m3[7];
          result[poffset++] = m3[8] * vout[0] + m3[9] * vout[1] + m3[10] * vout[2] + m3[11];
          count++;
        }
      }
    }
  };
  publicAPI.getKeyMatrices = (wgpuRen) => {
    if (Math.max(model.renderable.getMTime(), wgpuRen.getStabilizedTime()) > model.keyMatricesTime.getMTime()) {
      model.renderable.computeMatrix();
      const mcwc = model.renderable.getMatrix();
      const center = wgpuRen.getStabilizedCenterByReference();
      mat4_exports.transpose(model.keyMatrices.bcwc, mcwc);
      mat4_exports.translate(model.keyMatrices.bcsc, model.keyMatrices.bcwc, [-center[0], -center[1], -center[2]]);
      model.keyMatricesTime.modified();
    }
    return model.keyMatrices;
  };
}
var DEFAULT_VALUES59 = {
  propID: void 0,
  keyMatricesTime: null
};
function extend60(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES59, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.keyMatricesTime = {};
  macro.obj(model.keyMatricesTime, {
    mtime: 0
  });
  model.keyMatrices = {
    bcwc: new Float64Array(16),
    bcsc: new Float64Array(16)
  };
  macro.get(publicAPI, model, ["propID", "keyMatricesTime"]);
  vtkWebGPUVolume(publicAPI, model);
}
var newInstance61 = macro.newInstance(extend60, "vtkWebGPUVolume");
registerOverride2("vtkVolume", newInstance61);

// node_modules/@kitware/vtk.js/Rendering/WebGPU/PixelSpaceCallbackMapper.js
function vtkWebGPUPixelSpaceCallbackMapper(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUPixelSpaceCallbackMapper");
  publicAPI.opaquePass = (prepass, renderPass) => {
    model.WebGPURenderer = publicAPI.getFirstAncestorOfType("vtkWebGPURenderer");
    model.WebGPURenderWindow = model.WebGPURenderer.getParent();
    const aspectRatio = model.WebGPURenderer.getAspectRatio();
    const camera = model.WebGPURenderer ? model.WebGPURenderer.getRenderable().getActiveCamera() : null;
    const tsize = model.WebGPURenderer.getTiledSizeAndOrigin();
    const texels = null;
    if (model.renderable.getUseZValues()) ;
    model.renderable.invokeCallback(model.renderable.getInputData(), camera, aspectRatio, tsize, texels);
  };
}
var DEFAULT_VALUES60 = {};
function extend61(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES60, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  vtkWebGPUPixelSpaceCallbackMapper(publicAPI, model);
}
var newInstance62 = macro.newInstance(extend61, "vtkWebGPUPixelSpaceCallbackMapper");
registerOverride2("vtkPixelSpaceCallbackMapper", newInstance62);

// node_modules/@kitware/vtk.js/Rendering/Core/AbstractMapper.js
function vtkAbstractMapper(publicAPI, model) {
  model.classHierarchy.push("vtkAbstractMapper");
  publicAPI.update = () => {
    publicAPI.getInputData();
  };
  publicAPI.addClippingPlane = (plane) => {
    if (!plane.isA("vtkPlane")) {
      return false;
    }
    if (!model.clippingPlanes.includes(plane)) {
      model.clippingPlanes.push(plane);
      publicAPI.modified();
      return true;
    }
    return false;
  };
  publicAPI.getNumberOfClippingPlanes = () => model.clippingPlanes.length;
  publicAPI.removeAllClippingPlanes = () => {
    if (model.clippingPlanes.length === 0) {
      return false;
    }
    model.clippingPlanes.length = 0;
    publicAPI.modified();
    return true;
  };
  publicAPI.removeClippingPlane = (clippingPlane) => {
    const i6 = model.clippingPlanes.indexOf(clippingPlane);
    if (i6 === -1) {
      return false;
    }
    model.clippingPlanes.splice(i6, 1);
    publicAPI.modified();
    return true;
  };
  publicAPI.getClippingPlanes = () => model.clippingPlanes;
  publicAPI.setClippingPlanes = (planes) => {
    if (!planes) {
      return;
    }
    if (!Array.isArray(planes)) {
      publicAPI.addClippingPlane(planes);
    } else {
      const nbPlanes = planes.length;
      for (let i6 = 0; i6 < nbPlanes && i6 < 6; i6++) {
        publicAPI.addClippingPlane(planes[i6]);
      }
    }
  };
  publicAPI.getClippingPlaneInDataCoords = (propMatrix, i6, hnormal) => {
    const clipPlanes = model.clippingPlanes;
    const mat = propMatrix;
    if (clipPlanes) {
      const n9 = clipPlanes.length;
      if (i6 >= 0 && i6 < n9) {
        const plane = clipPlanes[i6];
        const normal = plane.getNormal();
        const origin2 = plane.getOrigin();
        const v1 = normal[0];
        const v2 = normal[1];
        const v3 = normal[2];
        const v4 = -(v1 * origin2[0] + v2 * origin2[1] + v3 * origin2[2]);
        hnormal[0] = v1 * mat[0] + v2 * mat[4] + v3 * mat[8] + v4 * mat[12];
        hnormal[1] = v1 * mat[1] + v2 * mat[5] + v3 * mat[9] + v4 * mat[13];
        hnormal[2] = v1 * mat[2] + v2 * mat[6] + v3 * mat[10] + v4 * mat[14];
        hnormal[3] = v1 * mat[3] + v2 * mat[7] + v3 * mat[11] + v4 * mat[15];
        return;
      }
    }
    macro.vtkErrorMacro(`Clipping plane index ${i6} is out of range.`);
  };
}
var DEFAULT_VALUES61 = {
  clippingPlanes: []
};
function extend62(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES61, initialValues);
  macro.obj(publicAPI, model);
  macro.algo(publicAPI, model, 1, 0);
  if (!model.clippingPlanes) {
    model.clippingPlanes = [];
  }
  vtkAbstractMapper(publicAPI, model);
}
var vtkAbstractMapper$1 = {
  extend: extend62
};

// node_modules/@kitware/vtk.js/Common/DataModel/BoundingBox.js
var INIT_BOUNDS2 = [
  Number.MAX_VALUE,
  -Number.MAX_VALUE,
  // X
  Number.MAX_VALUE,
  -Number.MAX_VALUE,
  // Y
  Number.MAX_VALUE,
  -Number.MAX_VALUE
  // Z
];
function equals7(a4, b3) {
  return a4[0] === b3[0] && a4[1] === b3[1] && a4[2] === b3[2] && a4[3] === b3[3] && a4[4] === b3[4] && a4[5] === b3[5];
}
function isValid(bounds) {
  return (bounds == null ? void 0 : bounds.length) >= 6 && bounds[0] <= bounds[1] && bounds[2] <= bounds[3] && bounds[4] <= bounds[5];
}
function setBounds(bounds, otherBounds) {
  bounds[0] = otherBounds[0];
  bounds[1] = otherBounds[1];
  bounds[2] = otherBounds[2];
  bounds[3] = otherBounds[3];
  bounds[4] = otherBounds[4];
  bounds[5] = otherBounds[5];
  return bounds;
}
function reset(bounds) {
  return setBounds(bounds, INIT_BOUNDS2);
}
function addPoint2(bounds, x2, y3, z3) {
  const [xMin, xMax, yMin, yMax, zMin, zMax] = bounds;
  bounds[0] = xMin < x2 ? xMin : x2;
  bounds[1] = xMax > x2 ? xMax : x2;
  bounds[2] = yMin < y3 ? yMin : y3;
  bounds[3] = yMax > y3 ? yMax : y3;
  bounds[4] = zMin < z3 ? zMin : z3;
  bounds[5] = zMax > z3 ? zMax : z3;
  return bounds;
}
function addPoints(bounds, points) {
  if (points.length === 0) {
    return bounds;
  }
  if (Array.isArray(points[0])) {
    for (let i6 = 0; i6 < points.length; ++i6) {
      addPoint2(bounds, ...points[i6]);
    }
  } else {
    for (let i6 = 0; i6 < points.length; i6 += 3) {
      addPoint2(bounds, ...points.slice(i6, i6 + 3));
    }
  }
  return bounds;
}
function addBounds(bounds, xMin, xMax, yMin, yMax, zMin, zMax) {
  const [_xMin, _xMax, _yMin, _yMax, _zMin, _zMax] = bounds;
  if (zMax === void 0) {
    bounds[0] = Math.min(xMin[0], _xMin);
    bounds[1] = Math.max(xMin[1], _xMax);
    bounds[2] = Math.min(xMin[2], _yMin);
    bounds[3] = Math.max(xMin[3], _yMax);
    bounds[4] = Math.min(xMin[4], _zMin);
    bounds[5] = Math.max(xMin[5], _zMax);
  } else {
    bounds[0] = Math.min(xMin, _xMin);
    bounds[1] = Math.max(xMax, _xMax);
    bounds[2] = Math.min(yMin, _yMin);
    bounds[3] = Math.max(yMax, _yMax);
    bounds[4] = Math.min(zMin, _zMin);
    bounds[5] = Math.max(zMax, _zMax);
  }
  return bounds;
}
function setMinPoint(bounds, x2, y3, z3) {
  const [xMin, xMax, yMin, yMax, zMin, zMax] = bounds;
  bounds[0] = x2;
  bounds[1] = x2 > xMax ? x2 : xMax;
  bounds[2] = y3;
  bounds[3] = y3 > yMax ? y3 : yMax;
  bounds[4] = z3;
  bounds[5] = z3 > zMax ? z3 : zMax;
  return xMin !== x2 || yMin !== y3 || zMin !== z3;
}
function setMaxPoint(bounds, x2, y3, z3) {
  const [xMin, xMax, yMin, yMax, zMin, zMax] = bounds;
  bounds[0] = x2 < xMin ? x2 : xMin;
  bounds[1] = x2;
  bounds[2] = y3 < yMin ? y3 : yMin;
  bounds[3] = y3;
  bounds[4] = z3 < zMin ? z3 : zMin;
  bounds[5] = z3;
  return xMax !== x2 || yMax !== y3 || zMax !== z3;
}
function inflate(bounds, delta) {
  bounds[0] -= delta;
  bounds[1] += delta;
  bounds[2] -= delta;
  bounds[3] += delta;
  bounds[4] -= delta;
  bounds[5] += delta;
  return bounds;
}
function scale6(bounds, sx, sy, sz) {
  if (!isValid(bounds)) {
    return false;
  }
  if (sx >= 0) {
    bounds[0] *= sx;
    bounds[1] *= sx;
  } else {
    bounds[0] = sx * bounds[1];
    bounds[1] = sx * bounds[0];
  }
  if (sy >= 0) {
    bounds[2] *= sy;
    bounds[3] *= sy;
  } else {
    bounds[2] = sy * bounds[3];
    bounds[3] = sy * bounds[2];
  }
  if (sz >= 0) {
    bounds[4] *= sz;
    bounds[5] *= sz;
  } else {
    bounds[4] = sz * bounds[5];
    bounds[5] = sz * bounds[4];
  }
  return true;
}
function getCenter(bounds) {
  return [0.5 * (bounds[0] + bounds[1]), 0.5 * (bounds[2] + bounds[3]), 0.5 * (bounds[4] + bounds[5])];
}
function scaleAboutCenter(bounds, sx, sy, sz) {
  if (!isValid(bounds)) {
    return false;
  }
  const center = getCenter(bounds);
  bounds[0] -= center[0];
  bounds[1] -= center[0];
  bounds[2] -= center[1];
  bounds[3] -= center[1];
  bounds[4] -= center[2];
  bounds[5] -= center[2];
  scale6(bounds, sx, sy, sz);
  bounds[0] += center[0];
  bounds[1] += center[0];
  bounds[2] += center[1];
  bounds[3] += center[1];
  bounds[4] += center[2];
  bounds[5] += center[2];
  return true;
}
function getLength2(bounds, index2) {
  return bounds[index2 * 2 + 1] - bounds[index2 * 2];
}
function getLengths(bounds) {
  return [getLength2(bounds, 0), getLength2(bounds, 1), getLength2(bounds, 2)];
}
function getXRange(bounds) {
  return bounds.slice(0, 2);
}
function getYRange(bounds) {
  return bounds.slice(2, 4);
}
function getZRange(bounds) {
  return bounds.slice(4, 6);
}
function getMaxLength(bounds) {
  const l5 = getLengths(bounds);
  if (l5[0] > l5[1]) {
    if (l5[0] > l5[2]) {
      return l5[0];
    }
    return l5[2];
  }
  if (l5[1] > l5[2]) {
    return l5[1];
  }
  return l5[2];
}
function getDiagonalLength(bounds) {
  if (isValid(bounds)) {
    const l5 = getLengths(bounds);
    return Math.sqrt(l5[0] * l5[0] + l5[1] * l5[1] + l5[2] * l5[2]);
  }
  return null;
}
function getMinPoint(bounds) {
  return [bounds[0], bounds[2], bounds[4]];
}
function getMaxPoint(bounds) {
  return [bounds[1], bounds[3], bounds[5]];
}
function oppositeSign(a4, b3) {
  return a4 <= 0 && b3 >= 0 || a4 >= 0 && b3 <= 0;
}
function getCorners2(bounds, corners) {
  let count = 0;
  for (let ix = 0; ix < 2; ix++) {
    for (let iy = 2; iy < 4; iy++) {
      for (let iz = 4; iz < 6; iz++) {
        corners[count++] = [bounds[ix], bounds[iy], bounds[iz]];
      }
    }
  }
  return corners;
}
function computeCornerPoints(bounds, point1, point2) {
  point1[0] = bounds[0];
  point1[1] = bounds[2];
  point1[2] = bounds[4];
  point2[0] = bounds[1];
  point2[1] = bounds[3];
  point2[2] = bounds[5];
  return point1;
}
function transformBounds(bounds, transform2) {
  let out = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
  const corners = getCorners2(bounds, []);
  for (let i6 = 0; i6 < corners.length; ++i6) {
    vec3_exports.transformMat4(corners[i6], corners[i6], transform2);
  }
  reset(out);
  return addPoints(out, corners);
}
function computeScale3(bounds) {
  let scale32 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  scale32[0] = 0.5 * (bounds[1] - bounds[0]);
  scale32[1] = 0.5 * (bounds[3] - bounds[2]);
  scale32[2] = 0.5 * (bounds[5] - bounds[4]);
  return scale32;
}
function computeLocalBounds(points, u5, v2, w2) {
  const bounds = [].concat(INIT_BOUNDS2);
  const pointsData = points.getData();
  for (let i6 = 0; i6 < pointsData.length; i6 += 3) {
    const point = [pointsData[i6], pointsData[i6 + 1], pointsData[i6 + 2]];
    const du = dot4(point, u5);
    bounds[0] = Math.min(du, bounds[0]);
    bounds[1] = Math.max(du, bounds[1]);
    const dv = dot4(point, v2);
    bounds[2] = Math.min(dv, bounds[2]);
    bounds[3] = Math.max(dv, bounds[3]);
    const dw = dot4(point, w2);
    bounds[4] = Math.min(dw, bounds[4]);
    bounds[5] = Math.max(dw, bounds[5]);
  }
  return bounds;
}
function intersectBox(bounds, origin2, dir, coord, tolerance) {
  let inside = true;
  const quadrant = [];
  let whichPlane = 0;
  const maxT = [];
  const candidatePlane = [0, 0, 0];
  const RIGHT = 0;
  const LEFT = 1;
  const MIDDLE = 2;
  for (let i6 = 0; i6 < 3; i6++) {
    if (origin2[i6] < bounds[2 * i6]) {
      quadrant[i6] = LEFT;
      candidatePlane[i6] = bounds[2 * i6];
      inside = false;
    } else if (origin2[i6] > bounds[2 * i6 + 1]) {
      quadrant[i6] = RIGHT;
      candidatePlane[i6] = bounds[2 * i6 + 1];
      inside = false;
    } else {
      quadrant[i6] = MIDDLE;
    }
  }
  if (inside) {
    coord[0] = origin2[0];
    coord[1] = origin2[1];
    coord[2] = origin2[2];
    tolerance[0] = 0;
    return 1;
  }
  for (let i6 = 0; i6 < 3; i6++) {
    if (quadrant[i6] !== MIDDLE && dir[i6] !== 0) {
      maxT[i6] = (candidatePlane[i6] - origin2[i6]) / dir[i6];
    } else {
      maxT[i6] = -1;
    }
  }
  for (let i6 = 0; i6 < 3; i6++) {
    if (maxT[whichPlane] < maxT[i6]) {
      whichPlane = i6;
    }
  }
  if (maxT[whichPlane] > 1 || maxT[whichPlane] < 0) {
    return 0;
  }
  tolerance[0] = maxT[whichPlane];
  for (let i6 = 0; i6 < 3; i6++) {
    if (whichPlane !== i6) {
      coord[i6] = origin2[i6] + maxT[whichPlane] * dir[i6];
      if (coord[i6] < bounds[2 * i6] || coord[i6] > bounds[2 * i6 + 1]) {
        return 0;
      }
    } else {
      coord[i6] = candidatePlane[i6];
    }
  }
  return 1;
}
function intersectPlane(bounds, origin2, normal) {
  const p3 = [];
  let d3 = 0;
  let sign = 1;
  let firstOne = 1;
  for (let z3 = 4; z3 <= 5; ++z3) {
    p3[2] = bounds[z3];
    for (let y3 = 2; y3 <= 3; ++y3) {
      p3[1] = bounds[y3];
      for (let x2 = 0; x2 <= 1; ++x2) {
        p3[0] = bounds[x2];
        d3 = vtkPlane$1.evaluate(normal, origin2, p3);
        if (firstOne) {
          sign = d3 >= 0 ? 1 : -1;
          firstOne = 0;
        }
        if (d3 === 0 || sign > 0 && d3 < 0 || sign < 0 && d3 > 0) {
          return 1;
        }
      }
    }
  }
  return 0;
}
function intersect(bounds, bBounds) {
  if (!(isValid(bounds) && isValid(bBounds))) {
    return false;
  }
  const newBounds = [0, 0, 0, 0, 0, 0];
  let intersection2;
  for (let i6 = 0; i6 < 3; i6++) {
    intersection2 = false;
    if (bBounds[i6 * 2] >= bounds[i6 * 2] && bBounds[i6 * 2] <= bounds[i6 * 2 + 1]) {
      intersection2 = true;
      newBounds[i6 * 2] = bBounds[i6 * 2];
    } else if (bounds[i6 * 2] >= bBounds[i6 * 2] && bounds[i6 * 2] <= bBounds[i6 * 2 + 1]) {
      intersection2 = true;
      newBounds[i6 * 2] = bounds[i6 * 2];
    }
    if (bBounds[i6 * 2 + 1] >= bounds[i6 * 2] && bBounds[i6 * 2 + 1] <= bounds[i6 * 2 + 1]) {
      intersection2 = true;
      newBounds[i6 * 2 + 1] = bBounds[2 * i6 + 1];
    } else if (bounds[i6 * 2 + 1] >= bBounds[i6 * 2] && bounds[i6 * 2 + 1] <= bBounds[i6 * 2 + 1]) {
      intersection2 = true;
      newBounds[i6 * 2 + 1] = bounds[i6 * 2 + 1];
    }
    if (!intersection2) {
      return false;
    }
  }
  bounds[0] = newBounds[0];
  bounds[1] = newBounds[1];
  bounds[2] = newBounds[2];
  bounds[3] = newBounds[3];
  bounds[4] = newBounds[4];
  bounds[5] = newBounds[5];
  return true;
}
function intersects(bounds, bBounds) {
  if (!(isValid(bounds) && isValid(bBounds))) {
    return false;
  }
  for (let i6 = 0; i6 < 3; i6++) {
    if (bBounds[i6 * 2] >= bounds[i6 * 2] && bBounds[i6 * 2] <= bounds[i6 * 2 + 1]) {
      continue;
    } else if (bounds[i6 * 2] >= bBounds[i6 * 2] && bounds[i6 * 2] <= bBounds[i6 * 2 + 1]) {
      continue;
    }
    if (bBounds[i6 * 2 + 1] >= bounds[i6 * 2] && bBounds[i6 * 2 + 1] <= bounds[i6 * 2 + 1]) {
      continue;
    } else if (bounds[i6 * 2 + 1] >= bBounds[i6 * 2] && bounds[i6 * 2 + 1] <= bBounds[i6 * 2 + 1]) {
      continue;
    }
    return false;
  }
  return true;
}
function containsPoint(bounds, x2, y3, z3) {
  if (x2 < bounds[0] || x2 > bounds[1]) {
    return false;
  }
  if (y3 < bounds[2] || y3 > bounds[3]) {
    return false;
  }
  if (z3 < bounds[4] || z3 > bounds[5]) {
    return false;
  }
  return true;
}
function contains(bounds, otherBounds) {
  if (!intersects(bounds, otherBounds)) {
    return false;
  }
  if (!containsPoint(bounds, ...getMinPoint(otherBounds))) {
    return false;
  }
  if (!containsPoint(bounds, ...getMaxPoint(otherBounds))) {
    return false;
  }
  return true;
}
function cutWithPlane(bounds, origin2, normal) {
  const index2 = [[0, 1, 2, 3, 4, 5, 6, 7], [0, 1, 4, 5, 2, 3, 6, 7], [0, 2, 4, 6, 1, 3, 5, 7]];
  const d3 = [0, 0, 0, 0, 0, 0, 0, 0];
  let idx = 0;
  for (let ix = 0; ix < 2; ix++) {
    for (let iy = 2; iy < 4; iy++) {
      for (let iz = 4; iz < 6; iz++) {
        const x2 = [bounds[ix], bounds[iy], bounds[iz]];
        d3[idx++] = vtkPlane$1.evaluate(normal, origin2, x2);
      }
    }
  }
  let dir = 2;
  while (dir--) {
    if (oppositeSign(d3[index2[dir][0]], d3[index2[dir][4]]) && oppositeSign(d3[index2[dir][1]], d3[index2[dir][5]]) && oppositeSign(d3[index2[dir][2]], d3[index2[dir][6]]) && oppositeSign(d3[index2[dir][3]], d3[index2[dir][7]])) {
      break;
    }
  }
  if (dir < 0) {
    return false;
  }
  const sign = Math.sign(normal[dir]);
  const size3 = Math.abs((bounds[dir * 2 + 1] - bounds[dir * 2]) * normal[dir]);
  let t9 = sign > 0 ? 1 : 0;
  for (let i6 = 0; i6 < 4; i6++) {
    if (size3 === 0) {
      continue;
    }
    const ti = Math.abs(d3[index2[dir][i6]]) / size3;
    if (sign > 0 && ti < t9) {
      t9 = ti;
    }
    if (sign < 0 && ti > t9) {
      t9 = ti;
    }
  }
  const bound = (1 - t9) * bounds[dir * 2] + t9 * bounds[dir * 2 + 1];
  if (sign > 0) {
    bounds[dir * 2] = bound;
  } else {
    bounds[dir * 2 + 1] = bound;
  }
  return true;
}
var BoundingBox = class {
  constructor(refBounds) {
    this.bounds = refBounds;
    if (!this.bounds) {
      this.bounds = new Float64Array(INIT_BOUNDS2);
    }
  }
  getBounds() {
    return this.bounds;
  }
  equals(otherBounds) {
    return equals7(this.bounds, otherBounds);
  }
  isValid() {
    return isValid(this.bounds);
  }
  setBounds(otherBounds) {
    return setBounds(this.bounds, otherBounds);
  }
  reset() {
    return reset(this.bounds);
  }
  addPoint() {
    for (var _len = arguments.length, xyz = new Array(_len), _key = 0; _key < _len; _key++) {
      xyz[_key] = arguments[_key];
    }
    return addPoint2(this.bounds, ...xyz);
  }
  addPoints(points) {
    return addPoints(this.bounds, points);
  }
  addBounds(xMin, xMax, yMin, yMax, zMin, zMax) {
    return addBounds(this.bounds, xMin, xMax, yMin, yMax, zMin, zMax);
  }
  setMinPoint(x2, y3, z3) {
    return setMinPoint(this.bounds, x2, y3, z3);
  }
  setMaxPoint(x2, y3, z3) {
    return setMaxPoint(this.bounds, x2, y3, z3);
  }
  inflate(delta) {
    return inflate(this.bounds, delta);
  }
  scale(sx, sy, sz) {
    return scale6(this.bounds, sx, sy, sz);
  }
  getCenter() {
    return getCenter(this.bounds);
  }
  getLength(index2) {
    return getLength2(this.bounds, index2);
  }
  getLengths() {
    return getLengths(this.bounds);
  }
  getMaxLength() {
    return getMaxLength(this.bounds);
  }
  getDiagonalLength() {
    return getDiagonalLength(this.bounds);
  }
  getMinPoint() {
    return getMinPoint(this.bounds);
  }
  getMaxPoint() {
    return getMaxPoint(this.bounds);
  }
  getXRange() {
    return getXRange(this.bounds);
  }
  getYRange() {
    return getYRange(this.bounds);
  }
  getZRange() {
    return getZRange(this.bounds);
  }
  getCorners(corners) {
    return getCorners2(this.bounds, corners);
  }
  computeCornerPoints(point1, point2) {
    return computeCornerPoints(this.bounds, point1, point2);
  }
  computeLocalBounds(u5, v2, w2) {
    return computeLocalBounds(this.bounds, u5, v2, w2);
  }
  transformBounds(transform2) {
    let out = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    return transformBounds(this.bounds, transform2, out);
  }
  computeScale3(scale32) {
    return computeScale3(this.bounds, scale32);
  }
  cutWithPlane(origin2, normal) {
    return cutWithPlane(this.bounds, origin2, normal);
  }
  intersectBox(origin2, dir, coord, tolerance) {
    return intersectBox(this.bounds, origin2, dir, coord, tolerance);
  }
  intersectPlane(origin2, normal) {
    return intersectPlane(this.bounds, origin2, normal);
  }
  intersect(otherBounds) {
    return intersect(this.bounds, otherBounds);
  }
  intersects(otherBounds) {
    return intersects(this.bounds, otherBounds);
  }
  containsPoint(x2, y3, z3) {
    return containsPoint(this.bounds, x2, y3, z3);
  }
  contains(otherBounds) {
    return intersects(this.bounds, otherBounds);
  }
};
function newInstance63(initialValues) {
  const bounds = initialValues && initialValues.bounds;
  return new BoundingBox(bounds);
}
var STATIC10 = {
  equals: equals7,
  isValid,
  setBounds,
  reset,
  addPoint: addPoint2,
  addPoints,
  addBounds,
  setMinPoint,
  setMaxPoint,
  inflate,
  scale: scale6,
  scaleAboutCenter,
  getCenter,
  getLength: getLength2,
  getLengths,
  getMaxLength,
  getDiagonalLength,
  getMinPoint,
  getMaxPoint,
  getXRange,
  getYRange,
  getZRange,
  getCorners: getCorners2,
  computeCornerPoints,
  computeLocalBounds,
  transformBounds,
  computeScale3,
  cutWithPlane,
  intersectBox,
  intersectPlane,
  intersect,
  intersects,
  containsPoint,
  contains,
  INIT_BOUNDS: INIT_BOUNDS2
};
var vtkBoundingBox = __spreadValues({
  newInstance: newInstance63
}, STATIC10);

// node_modules/@kitware/vtk.js/Rendering/Core/AbstractMapper3D.js
function vtkAbstractMapper3D(publicAPI, model) {
  publicAPI.getBounds = () => {
    macro.vtkErrorMacro(`vtkAbstractMapper3D.getBounds - NOT IMPLEMENTED`);
    return createUninitializedBounds();
  };
  publicAPI.getCenter = () => {
    var _a9;
    const bounds = publicAPI.getBounds();
    model.center = vtkBoundingBox.isValid(bounds) ? vtkBoundingBox.getCenter(bounds) : null;
    return (_a9 = model.center) == null ? void 0 : _a9.slice();
  };
  publicAPI.getLength = () => {
    const bounds = publicAPI.getBounds();
    return vtkBoundingBox.getDiagonalLength(bounds);
  };
}
var defaultValues2 = (initialValues) => __spreadValues({
  bounds: [...vtkBoundingBox.INIT_BOUNDS],
  center: [0, 0, 0],
  viewSpecificProperties: {}
}, initialValues);
function extend63(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, defaultValues2(initialValues));
  vtkAbstractMapper$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["viewSpecificProperties"]);
  vtkAbstractMapper3D(publicAPI, model);
}
var vtkAbstractMapper3D$1 = {
  extend: extend63
};

// node_modules/@kitware/vtk.js/Rendering/Core/AbstractImageMapper.js
function vtkAbstractImageMapper(publicAPI, model) {
  model.classHierarchy.push("vtkAbstractImageMapper");
  publicAPI.getIsOpaque = () => true;
  publicAPI.getCurrentImage = () => null;
  publicAPI.getBoundsForSlice = () => {
    macro.vtkErrorMacro("vtkAbstractImageMapper.getBoundsForSlice - NOT IMPLEMENTED");
    return createUninitializedBounds();
  };
}
var DEFAULT_VALUES62 = {
  slice: 0,
  customDisplayExtent: [0, 0, 0, 0, 0, 0],
  useCustomExtents: false,
  backgroundColor: [0, 0, 0, 1]
};
function extend64(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES62, initialValues);
  vtkAbstractMapper3D$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["slice", "useCustomExtents"]);
  macro.setGetArray(publicAPI, model, ["customDisplayExtent"], 6);
  macro.setGetArray(publicAPI, model, ["backgroundColor"], 4);
  vtkAbstractImageMapper(publicAPI, model);
}
var vtkAbstractImageMapper$1 = {
  extend: extend64
};

// node_modules/@kitware/vtk.js/Rendering/Core/AbstractImageMapper/helper.js
function doPicking(p1, p22, mapper) {
  const imageData = mapper.getCurrentImage();
  const extent = imageData.getExtent();
  const ijk = [extent[0], extent[2], extent[4]];
  const {
    ijkMode
  } = mapper.getClosestIJKAxis();
  let nSlice = mapper.isA("vtkImageArrayMapper") ? mapper.getSubSlice() : mapper.getSlice();
  if (ijkMode !== mapper.getSlicingMode()) {
    nSlice = mapper.getSliceAtPosition(nSlice);
  }
  ijk[ijkMode] += nSlice;
  const worldOrigin = [0, 0, 0];
  imageData.indexToWorld(ijk, worldOrigin);
  ijk[ijkMode] += 1;
  const worldNormal = [0, 0, 0];
  imageData.indexToWorld(ijk, worldNormal);
  worldNormal[0] -= worldOrigin[0];
  worldNormal[1] -= worldOrigin[1];
  worldNormal[2] -= worldOrigin[2];
  vec3_exports.normalize(worldNormal, worldNormal);
  const intersect2 = vtkPlane$1.intersectWithLine(p1, p22, worldOrigin, worldNormal);
  if (intersect2.intersection) {
    const point = intersect2.x;
    const absoluteIJK = [0, 0, 0];
    imageData.worldToIndex(point, absoluteIJK);
    return {
      t: intersect2.t,
      absoluteIJK
    };
  }
  return null;
}
function intersectWithLineForPointPicking(p1, p22, mapper) {
  const pickingData = doPicking(p1, p22, mapper);
  if (pickingData) {
    const imageData = mapper.getCurrentImage();
    const extent = imageData.getExtent();
    const ijk = [Math.round(pickingData.absoluteIJK[0]), Math.round(pickingData.absoluteIJK[1]), Math.round(pickingData.absoluteIJK[2])];
    if (ijk[0] < extent[0] || ijk[0] > extent[1] || ijk[1] < extent[2] || ijk[1] > extent[3] || ijk[2] < extent[4] || ijk[2] > extent[5]) {
      return null;
    }
    return {
      t: pickingData.t,
      ijk
    };
  }
  return null;
}
function intersectWithLineForCellPicking(p1, p22, mapper) {
  const pickingData = doPicking(p1, p22, mapper);
  if (pickingData) {
    const imageData = mapper.getCurrentImage();
    const extent = imageData.getExtent();
    const absIJK = pickingData.absoluteIJK;
    const ijk = [Math.floor(absIJK[0]), Math.floor(absIJK[1]), Math.floor(absIJK[2])];
    if (ijk[0] < extent[0] || ijk[0] > extent[1] - 1 || ijk[1] < extent[2] || ijk[1] > extent[3] - 1 || ijk[2] < extent[4] || // handle single-slice images
    ijk[2] > (extent[5] ? extent[5] - 1 : extent[5])) {
      return null;
    }
    const pCoords = [absIJK[0] - ijk[0], absIJK[1] - ijk[1], absIJK[2] - ijk[2]];
    return {
      t: pickingData.t,
      ijk,
      pCoords
    };
  }
  return null;
}

// node_modules/@kitware/vtk.js/Rendering/Core/Mapper/Static.js
var resolveCoincidentTopologyPolygonOffsetFaces = 1;
var resolveCoincidentTopology = 0;
var RESOLVE_COINCIDENT_TOPOLOGY_MODE = ["VTK_RESOLVE_OFF", "VTK_RESOLVE_POLYGON_OFFSET"];
function getResolveCoincidentTopologyPolygonOffsetFaces() {
  return resolveCoincidentTopologyPolygonOffsetFaces;
}
function setResolveCoincidentTopologyPolygonOffsetFaces(value) {
  resolveCoincidentTopologyPolygonOffsetFaces = value;
}
function getResolveCoincidentTopology() {
  return resolveCoincidentTopology;
}
function setResolveCoincidentTopology() {
  let mode = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
  resolveCoincidentTopology = mode;
}
function setResolveCoincidentTopologyToDefault() {
  setResolveCoincidentTopology(0);
}
function setResolveCoincidentTopologyToOff() {
  setResolveCoincidentTopology(0);
}
function setResolveCoincidentTopologyToPolygonOffset() {
  setResolveCoincidentTopology(1);
}
function getResolveCoincidentTopologyAsString() {
  return RESOLVE_COINCIDENT_TOPOLOGY_MODE[resolveCoincidentTopology];
}
var otherStaticMethods = {
  getResolveCoincidentTopologyAsString,
  getResolveCoincidentTopologyPolygonOffsetFaces,
  getResolveCoincidentTopology,
  setResolveCoincidentTopology,
  setResolveCoincidentTopologyPolygonOffsetFaces,
  setResolveCoincidentTopologyToDefault,
  setResolveCoincidentTopologyToOff,
  setResolveCoincidentTopologyToPolygonOffset
};

// node_modules/@kitware/vtk.js/Rendering/Core/Mapper/CoincidentTopologyHelper.js
function addCoincidentTopologyMethods(publicAPI, model, nameList) {
  nameList.forEach((item) => {
    publicAPI[`get${item.method}`] = () => model[item.key];
    publicAPI[`set${item.method}`] = (factor, offset3) => {
      model[item.key] = {
        factor,
        offset: offset3
      };
    };
  });
}
var CATEGORIES = ["Polygon", "Line", "Point"];
var staticOffsetModel = {
  Polygon: {
    factor: 2,
    offset: 0
  },
  Line: {
    factor: 1,
    offset: -1
  },
  Point: {
    factor: 0,
    offset: -2
  }
};
var staticOffsetAPI = {};
addCoincidentTopologyMethods(staticOffsetAPI, staticOffsetModel, CATEGORIES.map((key) => ({
  key,
  method: `ResolveCoincidentTopology${key}OffsetParameters`
})));
function implementCoincidentTopologyMethods(publicAPI, model) {
  if (model.resolveCoincidentTopology === void 0) {
    model.resolveCoincidentTopology = false;
  }
  macro.setGet(publicAPI, model, ["resolveCoincidentTopology"]);
  model.topologyOffset = {
    Polygon: {
      factor: 0,
      offset: 0
    },
    Line: {
      factor: 0,
      offset: 0
    },
    Point: {
      factor: 0,
      offset: 0
    }
  };
  Object.keys(otherStaticMethods).forEach((methodName) => {
    publicAPI[methodName] = otherStaticMethods[methodName];
  });
  Object.keys(staticOffsetAPI).forEach((methodName) => {
    publicAPI[methodName] = staticOffsetAPI[methodName];
  });
  addCoincidentTopologyMethods(publicAPI, model.topologyOffset, CATEGORIES.map((key) => ({
    key,
    method: `RelativeCoincidentTopology${key}OffsetParameters`
  })));
  publicAPI.getCoincidentTopologyPolygonOffsetParameters = () => {
    const globalValue = staticOffsetAPI.getResolveCoincidentTopologyPolygonOffsetParameters();
    const localValue = publicAPI.getRelativeCoincidentTopologyPolygonOffsetParameters();
    return {
      factor: globalValue.factor + localValue.factor,
      offset: globalValue.offset + localValue.offset
    };
  };
  publicAPI.getCoincidentTopologyLineOffsetParameters = () => {
    const globalValue = staticOffsetAPI.getResolveCoincidentTopologyLineOffsetParameters();
    const localValue = publicAPI.getRelativeCoincidentTopologyLineOffsetParameters();
    return {
      factor: globalValue.factor + localValue.factor,
      offset: globalValue.offset + localValue.offset
    };
  };
  publicAPI.getCoincidentTopologyPointOffsetParameter = () => {
    const globalValue = staticOffsetAPI.getResolveCoincidentTopologyPointOffsetParameters();
    const localValue = publicAPI.getRelativeCoincidentTopologyPointOffsetParameters();
    return {
      factor: globalValue.factor + localValue.factor,
      offset: globalValue.offset + localValue.offset
    };
  };
}
var CoincidentTopologyHelper = {
  implementCoincidentTopologyMethods,
  staticOffsetAPI,
  otherStaticMethods,
  CATEGORIES
};

// node_modules/@kitware/vtk.js/Rendering/Core/ImageMapper.js
var {
  staticOffsetAPI: staticOffsetAPI2,
  otherStaticMethods: otherStaticMethods2
} = CoincidentTopologyHelper;
var {
  SlicingMode: SlicingMode4
} = Constants8;
function vtkImageMapper(publicAPI, model) {
  model.classHierarchy.push("vtkImageMapper");
  publicAPI.getSliceAtPosition = (pos) => {
    const image2 = publicAPI.getCurrentImage();
    let pos3;
    if (pos.length === 3) {
      pos3 = pos;
    } else if (Number.isFinite(pos)) {
      const bds = image2.getBounds();
      switch (model.slicingMode) {
        case SlicingMode4.X:
          pos3 = [pos, (bds[3] + bds[2]) / 2, (bds[5] + bds[4]) / 2];
          break;
        case SlicingMode4.Y:
          pos3 = [(bds[1] + bds[0]) / 2, pos, (bds[5] + bds[4]) / 2];
          break;
        case SlicingMode4.Z:
          pos3 = [(bds[1] + bds[0]) / 2, (bds[3] + bds[2]) / 2, pos];
          break;
      }
    }
    const ijk = [0, 0, 0];
    image2.worldToIndex(pos3, ijk);
    const ex = image2.getExtent();
    const {
      ijkMode
    } = publicAPI.getClosestIJKAxis();
    let slice = 0;
    switch (ijkMode) {
      case SlicingMode4.I:
        slice = clampValue(ijk[0], ex[0], ex[1]);
        break;
      case SlicingMode4.J:
        slice = clampValue(ijk[1], ex[2], ex[3]);
        break;
      case SlicingMode4.K:
        slice = clampValue(ijk[2], ex[4], ex[5]);
        break;
      default:
        return 0;
    }
    return slice;
  };
  publicAPI.setSliceFromCamera = (cam) => {
    const fp = cam.getFocalPoint();
    switch (model.slicingMode) {
      case SlicingMode4.I:
      case SlicingMode4.J:
      case SlicingMode4.K:
        {
          const slice = publicAPI.getSliceAtPosition(fp);
          publicAPI.setSlice(slice);
        }
        break;
      case SlicingMode4.X:
        publicAPI.setSlice(fp[0]);
        break;
      case SlicingMode4.Y:
        publicAPI.setSlice(fp[1]);
        break;
      case SlicingMode4.Z:
        publicAPI.setSlice(fp[2]);
        break;
    }
  };
  publicAPI.setXSlice = (id) => {
    publicAPI.setSlicingMode(SlicingMode4.X);
    publicAPI.setSlice(id);
  };
  publicAPI.setYSlice = (id) => {
    publicAPI.setSlicingMode(SlicingMode4.Y);
    publicAPI.setSlice(id);
  };
  publicAPI.setZSlice = (id) => {
    publicAPI.setSlicingMode(SlicingMode4.Z);
    publicAPI.setSlice(id);
  };
  publicAPI.setISlice = (id) => {
    publicAPI.setSlicingMode(SlicingMode4.I);
    publicAPI.setSlice(id);
  };
  publicAPI.setJSlice = (id) => {
    publicAPI.setSlicingMode(SlicingMode4.J);
    publicAPI.setSlice(id);
  };
  publicAPI.setKSlice = (id) => {
    publicAPI.setSlicingMode(SlicingMode4.K);
    publicAPI.setSlice(id);
  };
  publicAPI.getSlicingModeNormal = () => {
    const out = [0, 0, 0];
    const mat32 = publicAPI.getCurrentImage().getDirection();
    switch (model.slicingMode) {
      case SlicingMode4.X:
        out[0] = 1;
        break;
      case SlicingMode4.Y:
        out[1] = 1;
        break;
      case SlicingMode4.Z:
        out[2] = 1;
        break;
      case SlicingMode4.I:
        multiply3x3_vect3(mat32, [1, 0, 0], out);
        break;
      case SlicingMode4.J:
        multiply3x3_vect3(mat32, [0, 1, 0], out);
        break;
      case SlicingMode4.K:
        multiply3x3_vect3(mat32, [0, 0, 1], out);
        break;
    }
    return out;
  };
  function computeClosestIJKAxis() {
    let xyzMode;
    switch (model.slicingMode) {
      case SlicingMode4.X:
        xyzMode = 0;
        break;
      case SlicingMode4.Y:
        xyzMode = 1;
        break;
      case SlicingMode4.Z:
        xyzMode = 2;
        break;
      default:
        model.closestIJKAxis = {
          ijkMode: model.slicingMode,
          flip: false
        };
        return;
    }
    const direction2 = publicAPI.getCurrentImage().getDirection();
    const newMatrix = getSparseOrthogonalMatrix(direction2);
    let ijkMode = 0;
    for (; ijkMode < 3; ++ijkMode) {
      if (newMatrix[xyzMode + 3 * ijkMode] !== 0) {
        break;
      }
    }
    const flip3 = newMatrix[xyzMode + 3 * ijkMode] < 0;
    model.closestIJKAxis = {
      ijkMode,
      flip: flip3
    };
  }
  publicAPI.setSlicingMode = (mode) => {
    if (model.slicingMode === mode) {
      return;
    }
    model.slicingMode = mode;
    if (publicAPI.getCurrentImage()) {
      computeClosestIJKAxis();
    }
    publicAPI.modified();
  };
  publicAPI.getClosestIJKAxis = () => {
    if ((model.closestIJKAxis === void 0 || model.closestIJKAxis.ijkMode === SlicingMode4.NONE) && publicAPI.getCurrentImage()) {
      computeClosestIJKAxis();
    }
    return model.closestIJKAxis;
  };
  publicAPI.getBounds = () => {
    const image2 = publicAPI.getCurrentImage();
    if (!image2) {
      return createUninitializedBounds();
    }
    if (!model.useCustomExtents) {
      return image2.getBounds();
    }
    const ex = model.customDisplayExtent.slice();
    const {
      ijkMode
    } = publicAPI.getClosestIJKAxis();
    let nSlice = model.slice;
    if (ijkMode !== model.slicingMode) {
      nSlice = publicAPI.getSliceAtPosition(model.slice);
    }
    switch (ijkMode) {
      case SlicingMode4.I:
        ex[0] = nSlice;
        ex[1] = nSlice;
        break;
      case SlicingMode4.J:
        ex[2] = nSlice;
        ex[3] = nSlice;
        break;
      case SlicingMode4.K:
        ex[4] = nSlice;
        ex[5] = nSlice;
        break;
    }
    return image2.extentToBounds(ex);
  };
  publicAPI.getBoundsForSlice = function() {
    let slice = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : model.slice;
    let halfThickness = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    const image2 = publicAPI.getCurrentImage();
    if (!image2) {
      return createUninitializedBounds();
    }
    const extent = image2.getSpatialExtent();
    const {
      ijkMode
    } = publicAPI.getClosestIJKAxis();
    let nSlice = slice;
    if (ijkMode !== model.slicingMode) {
      nSlice = publicAPI.getSliceAtPosition(slice);
    }
    switch (ijkMode) {
      case SlicingMode4.I:
        extent[0] = nSlice - halfThickness;
        extent[1] = nSlice + halfThickness;
        break;
      case SlicingMode4.J:
        extent[2] = nSlice - halfThickness;
        extent[3] = nSlice + halfThickness;
        break;
      case SlicingMode4.K:
        extent[4] = nSlice - halfThickness;
        extent[5] = nSlice + halfThickness;
        break;
    }
    return image2.extentToBounds(extent);
  };
  publicAPI.intersectWithLineForPointPicking = (p1, p22) => intersectWithLineForPointPicking(p1, p22, publicAPI);
  publicAPI.intersectWithLineForCellPicking = (p1, p22) => intersectWithLineForCellPicking(p1, p22, publicAPI);
  publicAPI.getCurrentImage = () => publicAPI.getInputData();
}
var DEFAULT_VALUES63 = {
  slicingMode: SlicingMode4.NONE,
  closestIJKAxis: {
    ijkMode: SlicingMode4.NONE,
    flip: false
  },
  renderToRectangle: false,
  sliceAtFocalPoint: false,
  preferSizeOverAccuracy: false
  // Whether to use halfFloat representation of float, when it is inaccurate
};
function extend65(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES63, initialValues);
  vtkAbstractImageMapper$1.extend(publicAPI, model, initialValues);
  macro.get(publicAPI, model, ["slicingMode"]);
  macro.setGet(publicAPI, model, ["closestIJKAxis", "renderToRectangle", "sliceAtFocalPoint", "preferSizeOverAccuracy"]);
  CoincidentTopologyHelper.implementCoincidentTopologyMethods(publicAPI, model);
  vtkImageMapper(publicAPI, model);
}
var newInstance64 = macro.newInstance(extend65, "vtkImageMapper");
var vtkImageMapper$1 = __spreadValues(__spreadValues(__spreadValues({
  newInstance: newInstance64,
  extend: extend65
}, staticOffsetAPI2), otherStaticMethods2), Constants8);

// node_modules/@kitware/vtk.js/Rendering/Core/Prop/Constants.js
var CoordinateSystem = {
  DISPLAY: 0,
  WORLD: 1
};
var Constants10 = {
  CoordinateSystem
};

// node_modules/@kitware/vtk.js/Rendering/Core/Prop.js
var {
  CoordinateSystem: CoordinateSystem2
} = Constants10;
function notImplemented3(method) {
  return () => macro.vtkErrorMacro(`vtkProp::${method} - NOT IMPLEMENTED`);
}
function vtkProp(publicAPI, model) {
  model.classHierarchy.push("vtkProp");
  publicAPI.getMTime = () => {
    let m1 = model.mtime;
    for (let index2 = 0; index2 < model.textures.length; ++index2) {
      const m22 = model.textures[index2].getMTime();
      if (m22 > m1) {
        m1 = m22;
      }
    }
    return m1;
  };
  publicAPI.processSelectorPixelBuffers = (selector, pixeloffsets) => {
  };
  publicAPI.getNestedProps = () => null;
  publicAPI.getActors = () => [];
  publicAPI.getActors2D = () => [];
  publicAPI.getVolumes = () => [];
  publicAPI.pick = notImplemented3("pick");
  publicAPI.hasKey = notImplemented3("hasKey");
  publicAPI.getNestedVisibility = () => model.visibility && (!model._parentProp || model._parentProp.getNestedVisibility());
  publicAPI.getNestedPickable = () => model.pickable && (!model._parentProp || model._parentProp.getNestedPickable());
  publicAPI.getNestedDragable = () => model.dragable && (!model._parentProp || model._parentProp.getNestedDragable());
  publicAPI.getRedrawMTime = () => model.mtime;
  publicAPI.setEstimatedRenderTime = (t9) => {
    model.estimatedRenderTime = t9;
    model.savedEstimatedRenderTime = t9;
  };
  publicAPI.restoreEstimatedRenderTime = () => {
    model.estimatedRenderTime = model.savedEstimatedRenderTime;
  };
  publicAPI.addEstimatedRenderTime = (t9) => {
    model.estimatedRenderTime += t9;
  };
  publicAPI.setAllocatedRenderTime = (t9) => {
    model.allocatedRenderTime = t9;
    model.savedEstimatedRenderTime = model.estimatedRenderTime;
    model.estimatedRenderTime = 0;
  };
  publicAPI.getSupportsSelection = () => false;
  publicAPI.getTextures = () => model.textures;
  publicAPI.hasTexture = (texture) => model.textures.indexOf(texture) !== -1;
  publicAPI.addTexture = (texture) => {
    if (texture && !publicAPI.hasTexture(texture)) {
      model.textures = model.textures.concat(texture);
      publicAPI.modified();
    }
  };
  publicAPI.removeTexture = (texture) => {
    const newTextureList = model.textures.filter((item) => item !== texture);
    if (model.textures.length !== newTextureList.length) {
      model.textures = newTextureList;
      publicAPI.modified();
    }
  };
  publicAPI.removeAllTextures = () => {
    model.textures = [];
    publicAPI.modified();
  };
  publicAPI.setCoordinateSystemToWorld = () => publicAPI.setCoordinateSystem(CoordinateSystem2.WORLD);
  publicAPI.setCoordinateSystemToDisplay = () => publicAPI.setCoordinateSystem(CoordinateSystem2.DISPLAY);
}
var DEFAULT_VALUES64 = {
  // _parentProp: null,
  allocatedRenderTime: 10,
  coordinateSystem: CoordinateSystem2.WORLD,
  dragable: true,
  estimatedRenderTime: 0,
  paths: null,
  pickable: true,
  renderTimeMultiplier: 1,
  savedEstimatedRenderTime: 0,
  textures: [],
  useBounds: true,
  visibility: true
};
function extend66(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES64, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["estimatedRenderTime", "allocatedRenderTime"]);
  macro.setGet(publicAPI, model, ["_parentProp", "coordinateSystem", "dragable", "pickable", "renderTimeMultiplier", "useBounds", "visibility"]);
  macro.moveToProtected(publicAPI, model, ["parentProp"]);
  vtkProp(publicAPI, model);
}
var newInstance65 = macro.newInstance(extend66, "vtkProp");
var vtkProp$1 = __spreadValues({
  newInstance: newInstance65,
  extend: extend66
}, Constants10);

// node_modules/@kitware/vtk.js/Rendering/Core/Prop3D.js
var VTK_EPSILON = 1e-6;
function vtkProp3D(publicAPI, model) {
  model.classHierarchy.push("vtkProp3D");
  publicAPI.addPosition = (deltaXYZ) => {
    model.position = model.position.map((value, index2) => value + deltaXYZ[index2]);
    publicAPI.modified();
  };
  publicAPI.getOrientationWXYZ = () => {
    const q = quat_exports.create();
    mat4_exports.getRotation(q, model.rotation);
    const oaxis = new Float64Array(3);
    const w2 = quat_exports.getAxisAngle(oaxis, q);
    return [degreesFromRadians(w2), oaxis[0], oaxis[1], oaxis[2]];
  };
  publicAPI.getOrientationQuaternion = function() {
    let out = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return mat4_exports.getRotation(out, model.rotation);
  };
  publicAPI.rotateX = (val) => {
    if (val === 0) {
      return;
    }
    mat4_exports.rotateX(model.rotation, model.rotation, radiansFromDegrees(val));
    publicAPI.modified();
  };
  publicAPI.rotateY = (val) => {
    if (val === 0) {
      return;
    }
    mat4_exports.rotateY(model.rotation, model.rotation, radiansFromDegrees(val));
    publicAPI.modified();
  };
  publicAPI.rotateZ = (val) => {
    if (val === 0) {
      return;
    }
    mat4_exports.rotateZ(model.rotation, model.rotation, radiansFromDegrees(val));
    publicAPI.modified();
  };
  publicAPI.rotateWXYZ = (degrees, x2, y3, z3) => {
    if (degrees === 0 || x2 === 0 && y3 === 0 && z3 === 0) {
      return;
    }
    const angle2 = radiansFromDegrees(degrees);
    const q = quat_exports.create();
    quat_exports.setAxisAngle(q, [x2, y3, z3], angle2);
    const quatMat = new Float64Array(16);
    mat4_exports.fromQuat(quatMat, q);
    mat4_exports.multiply(model.rotation, model.rotation, quatMat);
    publicAPI.modified();
  };
  publicAPI.rotateQuaternion = (orientationQuaternion) => {
    if (Math.abs(orientationQuaternion[3]) >= 1 - VTK_EPSILON) {
      return;
    }
    const oriQuatMat = mat4_exports.fromQuat(new Float64Array(16), orientationQuaternion);
    mat4_exports.multiply(model.rotation, model.rotation, oriQuatMat);
    publicAPI.modified();
  };
  publicAPI.setOrientation = (x2, y3, z3) => {
    if (x2 === model.orientation[0] && y3 === model.orientation[1] && z3 === model.orientation[2]) {
      return false;
    }
    model.orientation = [x2, y3, z3];
    mat4_exports.identity(model.rotation);
    publicAPI.rotateZ(z3);
    publicAPI.rotateX(x2);
    publicAPI.rotateY(y3);
    publicAPI.modified();
    return true;
  };
  publicAPI.setUserMatrix = (matrix) => {
    if (areMatricesEqual(model.userMatrix, matrix)) {
      return false;
    }
    mat4_exports.copy(model.userMatrix, matrix);
    publicAPI.modified();
    return true;
  };
  publicAPI.getMatrix = () => {
    publicAPI.computeMatrix();
    return model.matrix;
  };
  publicAPI.computeMatrix = () => {
    if (publicAPI.getMTime() > model.matrixMTime.getMTime()) {
      mat4_exports.identity(model.matrix);
      if (model.userMatrix) {
        mat4_exports.multiply(model.matrix, model.matrix, model.userMatrix);
      }
      mat4_exports.translate(model.matrix, model.matrix, model.origin);
      mat4_exports.translate(model.matrix, model.matrix, model.position);
      mat4_exports.multiply(model.matrix, model.matrix, model.rotation);
      mat4_exports.scale(model.matrix, model.matrix, model.scale);
      mat4_exports.translate(model.matrix, model.matrix, [-model.origin[0], -model.origin[1], -model.origin[2]]);
      mat4_exports.transpose(model.matrix, model.matrix);
      model.isIdentity = true;
      for (let i6 = 0; i6 < 4; ++i6) {
        for (let j2 = 0; j2 < 4; ++j2) {
          if ((i6 === j2 ? 1 : 0) !== model.matrix[i6 + j2 * 4]) {
            model.isIdentity = false;
          }
        }
      }
      model.matrixMTime.modified();
    }
  };
  publicAPI.getCenter = () => vtkBoundingBox.getCenter(model.bounds);
  publicAPI.getLength = () => vtkBoundingBox.getLength(model.bounds);
  publicAPI.getXRange = () => vtkBoundingBox.getXRange(model.bounds);
  publicAPI.getYRange = () => vtkBoundingBox.getYRange(model.bounds);
  publicAPI.getZRange = () => vtkBoundingBox.getZRange(model.bounds);
  publicAPI.getUserMatrix = () => model.userMatrix;
  function updateIdentityFlag() {
    publicAPI.computeMatrix();
  }
  publicAPI.onModified(updateIdentityFlag);
}
var DEFAULT_VALUES65 = {
  origin: [0, 0, 0],
  position: [0, 0, 0],
  orientation: [0, 0, 0],
  rotation: null,
  scale: [1, 1, 1],
  bounds: [1, -1, 1, -1, 1, -1],
  userMatrix: null,
  userMatrixMTime: null,
  cachedProp3D: null,
  isIdentity: true,
  matrixMTime: null
};
function extend67(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES65, initialValues);
  vtkProp$1.extend(publicAPI, model, initialValues);
  model.matrixMTime = {};
  macro.obj(model.matrixMTime);
  macro.get(publicAPI, model, ["bounds", "isIdentity"]);
  macro.getArray(publicAPI, model, ["orientation"]);
  macro.setGetArray(publicAPI, model, ["origin", "position", "scale"], 3);
  model.matrix = mat4_exports.identity(new Float64Array(16));
  model.rotation = mat4_exports.identity(new Float64Array(16));
  model.userMatrix = mat4_exports.identity(new Float64Array(16));
  model.transform = null;
  vtkProp3D(publicAPI, model);
}
var newInstance66 = macro.newInstance(extend67, "vtkProp3D");
var vtkProp3D$1 = {
  newInstance: newInstance66,
  extend: extend67
};

// node_modules/@kitware/vtk.js/Rendering/Core/ImageProperty.js
var {
  InterpolationType: InterpolationType3
} = Constants7;
var {
  vtkErrorMacro: vtkErrorMacro22
} = macro;
var VTK_MAX_VRCOMP = 4;
function vtkImageProperty(publicAPI, model) {
  model.classHierarchy.push("vtkImageProperty");
  publicAPI.getMTime = () => {
    let mTime = model.mtime;
    let time;
    for (let index2 = 0; index2 < VTK_MAX_VRCOMP; index2++) {
      if (model.componentData[index2].rGBTransferFunction) {
        time = model.componentData[index2].rGBTransferFunction.getMTime();
        mTime = mTime > time ? mTime : time;
      }
      if (model.componentData[index2].piecewiseFunction) {
        time = model.componentData[index2].piecewiseFunction.getMTime();
        mTime = mTime > time ? mTime : time;
      }
    }
    return mTime;
  };
  publicAPI.setRGBTransferFunction = function() {
    let index2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    let func = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    let idx = index2;
    let transferFunc = func;
    if (!Number.isInteger(index2)) {
      transferFunc = index2;
      idx = 0;
    }
    if (model.componentData[idx].rGBTransferFunction !== transferFunc) {
      model.componentData[idx].rGBTransferFunction = transferFunc;
      publicAPI.modified();
      return true;
    }
    return false;
  };
  publicAPI.getRGBTransferFunction = function() {
    let idx = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    return model.componentData[idx].rGBTransferFunction;
  };
  publicAPI.setPiecewiseFunction = function() {
    let index2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    let func = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    let idx = index2;
    let transferFunc = func;
    if (!Number.isInteger(index2)) {
      transferFunc = index2;
      idx = 0;
    }
    if (model.componentData[idx].piecewiseFunction !== transferFunc) {
      model.componentData[idx].piecewiseFunction = transferFunc;
      publicAPI.modified();
      return true;
    }
    return false;
  };
  publicAPI.getPiecewiseFunction = function() {
    let idx = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    return model.componentData[idx].piecewiseFunction;
  };
  publicAPI.setScalarOpacity = function() {
    let index2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    let func = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    let idx = index2;
    let transferFunc = func;
    if (!Number.isInteger(index2)) {
      transferFunc = index2;
      idx = 0;
    }
    return publicAPI.setPiecewiseFunction(idx, transferFunc);
  };
  publicAPI.getScalarOpacity = function() {
    let idx = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    return publicAPI.getPiecewiseFunction(idx);
  };
  publicAPI.setComponentWeight = function() {
    let index2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    let value = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    if (index2 < 0 || index2 >= VTK_MAX_VRCOMP) {
      vtkErrorMacro22("Invalid index");
      return false;
    }
    const val = Math.min(1, Math.max(0, value));
    if (model.componentData[index2].componentWeight !== val) {
      model.componentData[index2].componentWeight = val;
      publicAPI.modified();
      return true;
    }
    return false;
  };
  publicAPI.getComponentWeight = function() {
    let index2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    if (index2 < 0 || index2 >= VTK_MAX_VRCOMP) {
      vtkErrorMacro22("Invalid index");
      return 0;
    }
    return model.componentData[index2].componentWeight;
  };
  publicAPI.setInterpolationTypeToNearest = () => publicAPI.setInterpolationType(InterpolationType3.NEAREST);
  publicAPI.setInterpolationTypeToLinear = () => publicAPI.setInterpolationType(InterpolationType3.LINEAR);
  publicAPI.getInterpolationTypeAsString = () => macro.enumToString(InterpolationType3, model.interpolationType);
}
var DEFAULT_VALUES66 = {
  independentComponents: false,
  interpolationType: InterpolationType3.LINEAR,
  colorWindow: 255,
  colorLevel: 127.5,
  ambient: 1,
  diffuse: 0,
  opacity: 1,
  useLookupTableScalarRange: false,
  useLabelOutline: false,
  labelOutlineThickness: [1],
  labelOutlineOpacity: 1
};
function extend68(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES66, initialValues);
  macro.obj(publicAPI, model);
  if (!model.componentData) {
    model.componentData = [];
    for (let i6 = 0; i6 < VTK_MAX_VRCOMP; i6++) {
      model.componentData.push({
        rGBTransferFunction: null,
        piecewiseFunction: null,
        componentWeight: 1
      });
    }
  }
  macro.setGet(publicAPI, model, ["independentComponents", "interpolationType", "colorWindow", "colorLevel", "ambient", "diffuse", "opacity", "useLookupTableScalarRange", "useLabelOutline", "labelOutlineOpacity"]);
  macro.setGetArray(publicAPI, model, ["labelOutlineThickness"]);
  vtkImageProperty(publicAPI, model);
}
var newInstance67 = macro.newInstance(extend68, "vtkImageProperty");
var vtkImageProperty$1 = {
  newInstance: newInstance67,
  extend: extend68
};

// node_modules/@kitware/vtk.js/Rendering/Core/ImageSlice.js
var {
  vtkDebugMacro: vtkDebugMacro6
} = macro;
function vtkImageSlice(publicAPI, model) {
  model.classHierarchy.push("vtkImageSlice");
  publicAPI.getActors = () => publicAPI;
  publicAPI.getImages = () => publicAPI;
  publicAPI.getIsOpaque = () => {
    if (model.forceOpaque) {
      return true;
    }
    if (model.forceTranslucent) {
      return false;
    }
    if (!model.property) {
      publicAPI.getProperty();
    }
    let isOpaque = model.property.getOpacity() >= 1;
    isOpaque = isOpaque && (!model.mapper || model.mapper.getIsOpaque());
    return isOpaque;
  };
  publicAPI.hasTranslucentPolygonalGeometry = () => false;
  publicAPI.makeProperty = vtkImageProperty$1.newInstance;
  publicAPI.getProperty = () => {
    if (model.property === null) {
      model.property = publicAPI.makeProperty();
    }
    return model.property;
  };
  publicAPI.getBounds = () => {
    if (model.mapper === null) {
      return model.bounds;
    }
    const bds = model.mapper.getBounds();
    if (!bds || bds.length !== 6) {
      return bds;
    }
    if (bds[0] > bds[1]) {
      model.mapperBounds = bds.concat();
      model.bounds = [1, -1, 1, -1, 1, -1];
      model.boundsMTime.modified();
      return bds;
    }
    const zip = (rows) => rows[0].map((_2, c6) => rows.map((row) => row[c6]));
    if (!model.mapperBounds || !zip([bds, model.mapperBounds]).reduce((a4, b3) => a4 && b3[0] === b3[1], true) || publicAPI.getMTime() > model.boundsMTime.getMTime()) {
      vtkDebugMacro6("Recomputing bounds...");
      model.mapperBounds = bds.map((x2) => x2);
      publicAPI.computeMatrix();
      const tmp4 = new Float64Array(16);
      mat4_exports.transpose(tmp4, model.matrix);
      vtkBoundingBox.transformBounds(bds, tmp4, model.bounds);
      model.boundsMTime.modified();
    }
    return model.bounds;
  };
  publicAPI.getBoundsForSlice = (slice, thickness) => {
    const bds = model.mapper.getBoundsForSlice(slice, thickness);
    if (!vtkBoundingBox.isValid(bds)) {
      return bds;
    }
    publicAPI.computeMatrix();
    const tmp4 = new Float64Array(16);
    mat4_exports.transpose(tmp4, model.matrix);
    const newBounds = vtkBoundingBox.transformBounds(bds, tmp4);
    return newBounds;
  };
  publicAPI.getMinXBound = () => publicAPI.getBounds()[0];
  publicAPI.getMaxXBound = () => publicAPI.getBounds()[1];
  publicAPI.getMinYBound = () => publicAPI.getBounds()[2];
  publicAPI.getMaxYBound = () => publicAPI.getBounds()[3];
  publicAPI.getMinZBound = () => publicAPI.getBounds()[4];
  publicAPI.getMaxZBound = () => publicAPI.getBounds()[5];
  publicAPI.getMTime = () => {
    let mt = model.mtime;
    if (model.property !== null) {
      const time = model.property.getMTime();
      mt = time > mt ? time : mt;
    }
    return mt;
  };
  publicAPI.getRedrawMTime = () => {
    let mt = model.mtime;
    if (model.mapper !== null) {
      let time = model.mapper.getMTime();
      mt = time > mt ? time : mt;
      if (model.mapper.getInput() !== null) {
        model.mapper.getInputAlgorithm().update();
        time = model.mapper.getInput().getMTime();
        mt = time > mt ? time : mt;
      }
    }
    if (model.property !== null) {
      let time = model.property.getMTime();
      mt = time > mt ? time : mt;
      if (model.property.getRGBTransferFunction() !== null) {
        time = model.property.getRGBTransferFunction().getMTime();
        mt = time > mt ? time : mt;
      }
    }
    return mt;
  };
  publicAPI.getSupportsSelection = () => model.mapper ? model.mapper.getSupportsSelection() : false;
}
var DEFAULT_VALUES67 = {
  mapper: null,
  property: null,
  bounds: [...vtkBoundingBox.INIT_BOUNDS]
};
function extend69(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES67, initialValues);
  vtkProp3D$1.extend(publicAPI, model, initialValues);
  model.boundsMTime = {};
  macro.obj(model.boundsMTime);
  macro.set(publicAPI, model, ["property"]);
  macro.setGet(publicAPI, model, ["mapper"]);
  macro.getArray(publicAPI, model, ["bounds"], 6);
  vtkImageSlice(publicAPI, model);
}
var newInstance68 = macro.newInstance(extend69, "vtkImageSlice");
var vtkImageSlice$1 = {
  newInstance: newInstance68,
  extend: extend69
};

// node_modules/@kitware/vtk.js/Common/DataModel/StructuredData/Constants.js
var StructuredType = {
  UNCHANGED: 0,
  SINGLE_POINT: 1,
  X_LINE: 2,
  Y_LINE: 3,
  Z_LINE: 4,
  XY_PLANE: 5,
  YZ_PLANE: 6,
  XZ_PLANE: 7,
  XYZ_GRID: 8,
  EMPTY: 9
};
var Constants11 = {
  StructuredType
};

// node_modules/@kitware/vtk.js/Common/DataModel/StructuredData.js
var {
  StructuredType: StructuredType2
} = Constants11;
function getDataDescriptionFromExtent(inExt) {
  let dataDim = 0;
  for (let i6 = 0; i6 < 3; ++i6) {
    if (inExt[i6 * 2] < inExt[i6 * 2 + 1]) {
      dataDim++;
    }
  }
  if (inExt[0] > inExt[1] || inExt[2] > inExt[3] || inExt[4] > inExt[5]) {
    return StructuredType2.EMPTY;
  }
  if (dataDim === 3) {
    return StructuredType2.XYZ_GRID;
  }
  if (dataDim === 2) {
    if (inExt[0] === inExt[1]) {
      return StructuredType2.YZ_PLANE;
    }
    if (inExt[2] === inExt[3]) {
      return StructuredType2.XZ_PLANE;
    }
    return StructuredType2.XY_PLANE;
  }
  if (dataDim === 1) {
    if (inExt[0] < inExt[1]) {
      return StructuredType2.X_LINE;
    }
    if (inExt[2] < inExt[3]) {
      return StructuredType2.Y_LINE;
    }
    return StructuredType2.Z_LINE;
  }
  return StructuredType2.SINGLE_POINT;
}
var vtkStructuredData = __spreadValues({
  getDataDescriptionFromExtent
}, Constants11);

// node_modules/@kitware/vtk.js/Common/DataModel/ImageData.js
var {
  vtkErrorMacro: vtkErrorMacro23
} = macro;
function vtkImageData(publicAPI, model) {
  model.classHierarchy.push("vtkImageData");
  publicAPI.setExtent = function() {
    if (model.deleted) {
      vtkErrorMacro23("instance deleted - cannot call any method");
      return false;
    }
    for (var _len = arguments.length, inExtent = new Array(_len), _key = 0; _key < _len; _key++) {
      inExtent[_key] = arguments[_key];
    }
    const extentArray = inExtent.length === 1 ? inExtent[0] : inExtent;
    if (extentArray.length !== 6) {
      return false;
    }
    const changeDetected = model.extent.some((item, index2) => item !== extentArray[index2]);
    if (changeDetected) {
      model.extent = extentArray.slice();
      model.dataDescription = vtkStructuredData.getDataDescriptionFromExtent(model.extent);
      publicAPI.modified();
    }
    return changeDetected;
  };
  publicAPI.setDimensions = function() {
    let i6;
    let j2;
    let k2;
    if (model.deleted) {
      vtkErrorMacro23("instance deleted - cannot call any method");
      return;
    }
    if (arguments.length === 1) {
      const array = arguments.length <= 0 ? void 0 : arguments[0];
      i6 = array[0];
      j2 = array[1];
      k2 = array[2];
    } else if (arguments.length === 3) {
      i6 = arguments.length <= 0 ? void 0 : arguments[0];
      j2 = arguments.length <= 1 ? void 0 : arguments[1];
      k2 = arguments.length <= 2 ? void 0 : arguments[2];
    } else {
      vtkErrorMacro23("Bad dimension specification");
      return;
    }
    publicAPI.setExtent(0, i6 - 1, 0, j2 - 1, 0, k2 - 1);
  };
  publicAPI.getDimensions = () => [model.extent[1] - model.extent[0] + 1, model.extent[3] - model.extent[2] + 1, model.extent[5] - model.extent[4] + 1];
  publicAPI.getNumberOfCells = () => {
    const dims = publicAPI.getDimensions();
    let nCells = 1;
    for (let i6 = 0; i6 < 3; i6++) {
      if (dims[i6] === 0) {
        return 0;
      }
      if (dims[i6] > 1) {
        nCells *= dims[i6] - 1;
      }
    }
    return nCells;
  };
  publicAPI.getNumberOfPoints = () => {
    const dims = publicAPI.getDimensions();
    return dims[0] * dims[1] * dims[2];
  };
  publicAPI.getPoint = (index2) => {
    const dims = publicAPI.getDimensions();
    if (dims[0] === 0 || dims[1] === 0 || dims[2] === 0) {
      vtkErrorMacro23("Requesting a point from an empty image.");
      return null;
    }
    const ijk = new Float64Array(3);
    switch (model.dataDescription) {
      case StructuredType.EMPTY:
        return null;
      case StructuredType.SINGLE_POINT:
        break;
      case StructuredType.X_LINE:
        ijk[0] = index2;
        break;
      case StructuredType.Y_LINE:
        ijk[1] = index2;
        break;
      case StructuredType.Z_LINE:
        ijk[2] = index2;
        break;
      case StructuredType.XY_PLANE:
        ijk[0] = index2 % dims[0];
        ijk[1] = index2 / dims[0];
        break;
      case StructuredType.YZ_PLANE:
        ijk[1] = index2 % dims[1];
        ijk[2] = index2 / dims[1];
        break;
      case StructuredType.XZ_PLANE:
        ijk[0] = index2 % dims[0];
        ijk[2] = index2 / dims[0];
        break;
      case StructuredType.XYZ_GRID:
        ijk[0] = index2 % dims[0];
        ijk[1] = index2 / dims[0] % dims[1];
        ijk[2] = index2 / (dims[0] * dims[1]);
        break;
      default:
        vtkErrorMacro23("Invalid dataDescription");
        break;
    }
    const coords = [0, 0, 0];
    publicAPI.indexToWorld(ijk, coords);
    return coords;
  };
  publicAPI.getBounds = () => publicAPI.extentToBounds(publicAPI.getSpatialExtent());
  publicAPI.extentToBounds = (ex) => vtkBoundingBox.transformBounds(ex, model.indexToWorld);
  publicAPI.getSpatialExtent = () => vtkBoundingBox.inflate([...model.extent], 0.5);
  publicAPI.computeTransforms = () => {
    mat4_exports.fromTranslation(model.indexToWorld, model.origin);
    model.indexToWorld[0] = model.direction[0];
    model.indexToWorld[1] = model.direction[1];
    model.indexToWorld[2] = model.direction[2];
    model.indexToWorld[4] = model.direction[3];
    model.indexToWorld[5] = model.direction[4];
    model.indexToWorld[6] = model.direction[5];
    model.indexToWorld[8] = model.direction[6];
    model.indexToWorld[9] = model.direction[7];
    model.indexToWorld[10] = model.direction[8];
    mat4_exports.scale(model.indexToWorld, model.indexToWorld, model.spacing);
    mat4_exports.invert(model.worldToIndex, model.indexToWorld);
  };
  publicAPI.indexToWorld = function(ain) {
    let aout = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    vec3_exports.transformMat4(aout, ain, model.indexToWorld);
    return aout;
  };
  publicAPI.indexToWorldVec3 = publicAPI.indexToWorld;
  publicAPI.worldToIndex = function(ain) {
    let aout = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    vec3_exports.transformMat4(aout, ain, model.worldToIndex);
    return aout;
  };
  publicAPI.worldToIndexVec3 = publicAPI.worldToIndex;
  publicAPI.indexToWorldBounds = function(bin) {
    let bout = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    return vtkBoundingBox.transformBounds(bin, model.indexToWorld, bout);
  };
  publicAPI.worldToIndexBounds = function(bin) {
    let bout = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    return vtkBoundingBox.transformBounds(bin, model.worldToIndex, bout);
  };
  publicAPI.onModified(publicAPI.computeTransforms);
  publicAPI.computeTransforms();
  publicAPI.getCenter = () => vtkBoundingBox.getCenter(publicAPI.getBounds());
  publicAPI.computeHistogram = function(worldBounds) {
    let voxelFunc = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    const bounds = [0, 0, 0, 0, 0, 0];
    publicAPI.worldToIndexBounds(worldBounds, bounds);
    const point1 = [0, 0, 0];
    const point2 = [0, 0, 0];
    vtkBoundingBox.computeCornerPoints(bounds, point1, point2);
    roundVector(point1, point1);
    roundVector(point2, point2);
    const dimensions = publicAPI.getDimensions();
    clampVector(point1, [0, 0, 0], [dimensions[0] - 1, dimensions[1] - 1, dimensions[2] - 1], point1);
    clampVector(point2, [0, 0, 0], [dimensions[0] - 1, dimensions[1] - 1, dimensions[2] - 1], point2);
    const yStride = dimensions[0];
    const zStride = dimensions[0] * dimensions[1];
    const pixels = publicAPI.getPointData().getScalars().getData();
    let maximum = -Infinity;
    let minimum = Infinity;
    let sumOfSquares = 0;
    let isum = 0;
    let inum = 0;
    for (let z3 = point1[2]; z3 <= point2[2]; z3++) {
      for (let y3 = point1[1]; y3 <= point2[1]; y3++) {
        let index2 = point1[0] + y3 * yStride + z3 * zStride;
        for (let x2 = point1[0]; x2 <= point2[0]; x2++) {
          if (!voxelFunc || voxelFunc([x2, y3, z3], bounds)) {
            const pixel = pixels[index2];
            if (pixel > maximum) maximum = pixel;
            if (pixel < minimum) minimum = pixel;
            sumOfSquares += pixel * pixel;
            isum += pixel;
            inum += 1;
          }
          ++index2;
        }
      }
    }
    const average = inum > 0 ? isum / inum : 0;
    const variance = inum ? Math.abs(sumOfSquares / inum - average * average) : 0;
    const sigma = Math.sqrt(variance);
    return {
      minimum,
      maximum,
      average,
      variance,
      sigma,
      count: inum
    };
  };
  publicAPI.computeIncrements = function(extent) {
    let numberOfComponents = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    const increments = [];
    let incr = numberOfComponents;
    for (let idx = 0; idx < 3; ++idx) {
      increments[idx] = incr;
      incr *= extent[idx * 2 + 1] - extent[idx * 2] + 1;
    }
    return increments;
  };
  publicAPI.computeOffsetIndex = (_ref) => {
    let [i6, j2, k2] = _ref;
    const extent = publicAPI.getExtent();
    const numberOfComponents = publicAPI.getPointData().getScalars().getNumberOfComponents();
    const increments = publicAPI.computeIncrements(extent, numberOfComponents);
    return Math.floor((Math.round(i6) - extent[0]) * increments[0] + (Math.round(j2) - extent[2]) * increments[1] + (Math.round(k2) - extent[4]) * increments[2]);
  };
  publicAPI.getOffsetIndexFromWorld = (xyz) => {
    const extent = publicAPI.getExtent();
    const index2 = publicAPI.worldToIndex(xyz);
    for (let idx = 0; idx < 3; ++idx) {
      if (index2[idx] < extent[idx * 2] || index2[idx] > extent[idx * 2 + 1]) {
        vtkErrorMacro23(`GetScalarPointer: Pixel ${index2} is not in memory. Current extent = ${extent}`);
        return NaN;
      }
    }
    return publicAPI.computeOffsetIndex(index2);
  };
  publicAPI.getScalarValueFromWorld = function(xyz) {
    let comp = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    const numberOfComponents = publicAPI.getPointData().getScalars().getNumberOfComponents();
    if (comp < 0 || comp >= numberOfComponents) {
      vtkErrorMacro23(`GetScalarPointer: Scalar Component ${comp} is not within bounds. Current Scalar numberOfComponents: ${numberOfComponents}`);
      return NaN;
    }
    const offsetIndex = publicAPI.getOffsetIndexFromWorld(xyz);
    if (Number.isNaN(offsetIndex)) {
      return offsetIndex;
    }
    return publicAPI.getPointData().getScalars().getComponent(offsetIndex, comp);
  };
}
var DEFAULT_VALUES68 = {
  direction: null,
  // a mat3
  indexToWorld: null,
  // a mat4
  worldToIndex: null,
  // a mat4
  spacing: [1, 1, 1],
  origin: [0, 0, 0],
  extent: [0, -1, 0, -1, 0, -1],
  dataDescription: StructuredType.EMPTY
};
function extend70(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES68, initialValues);
  vtkDataSet$1.extend(publicAPI, model, initialValues);
  if (!model.direction) {
    model.direction = mat3_exports.identity(new Float64Array(9));
  } else if (Array.isArray(model.direction)) {
    model.direction = new Float64Array(model.direction.slice(0, 9));
  }
  model.indexToWorld = new Float64Array(16);
  model.worldToIndex = new Float64Array(16);
  macro.get(publicAPI, model, ["indexToWorld", "worldToIndex"]);
  macro.setGetArray(publicAPI, model, ["origin", "spacing"], 3);
  macro.setGetArray(publicAPI, model, ["direction"], 9);
  macro.getArray(publicAPI, model, ["extent"], 6);
  vtkImageData(publicAPI, model);
}
var newInstance69 = macro.newInstance(extend70, "vtkImageData");
var vtkImageData$1 = {
  newInstance: newInstance69,
  extend: extend70
};

// node_modules/@kitware/vtk.js/Common/DataModel/ITKHelper.js
var {
  vtkErrorMacro: vtkErrorMacro24
} = macro;
var ITKJSPixelTypes = {
  Unknown: 0,
  Scalar: 1,
  RGB: 2,
  RGBA: 3,
  Offset: 4,
  Vector: 5,
  Point: 6,
  CovariantVector: 7,
  SymmetricSecondRankTensor: 8,
  DiffusionTensor3D: 9,
  Complex: 10,
  FixedArray: 11,
  Array: 12,
  Matrix: 13,
  VariableLengthVector: 14,
  VariableSizeMatrix: 15
};
var ITKWASMPixelTypes = {
  Unknown: "Unknown",
  Scalar: "Scalar",
  RGB: "RGB",
  RGBA: "RGBA",
  Offset: "Offset",
  Vector: "Vector",
  Point: "Point",
  CovariantVector: "CovariantVector",
  SymmetricSecondRankTensor: "SymmetricSecondRankTensor",
  DiffusionTensor3D: "DiffusionTensor3D",
  Complex: "Complex",
  FixedArray: "FixedArray",
  Array: "Array",
  Matrix: "Matrix",
  VariableLengthVector: "VariableLengthVector",
  VariableSizeMatrix: "VariableSizeMatrix"
};
var vtkArrayTypeToItkComponentType = /* @__PURE__ */ new Map([["Uint8Array", "uint8"], ["Int8Array", "int8"], ["Uint16Array", "uint16"], ["Int16Array", "int16"], ["Uint32Array", "uint32"], ["Int32Array", "int32"], ["Float32Array", "float32"], ["Float64Array", "float64"]]);
var itkComponentTypeToVtkArrayType = /* @__PURE__ */ new Map([["uint8", "Uint8Array"], ["int8", "Int8Array"], ["uint16", "Uint16Array"], ["int16", "Int16Array"], ["uint32", "Uint32Array"], ["int32", "Int32Array"], ["float32", "Float32Array"], ["float64", "Float64Array"]]);
function convertItkToVtkImage(itkImage) {
  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const vtkImage = {
    origin: [0, 0, 0],
    spacing: [1, 1, 1]
  };
  const dimensions = [1, 1, 1];
  const direction2 = [1, 0, 0, 0, 1, 0, 0, 0, 1];
  const isITKWasm = itkImage.direction.data === void 0;
  const ITKPixelTypes = isITKWasm ? ITKWASMPixelTypes : ITKJSPixelTypes;
  for (let idx = 0; idx < itkImage.imageType.dimension; ++idx) {
    vtkImage.origin[idx] = itkImage.origin[idx];
    vtkImage.spacing[idx] = itkImage.spacing[idx];
    dimensions[idx] = itkImage.size[idx];
    for (let col = 0; col < itkImage.imageType.dimension; ++col) {
      if (isITKWasm) {
        direction2[col + idx * 3] = itkImage.direction[idx + col * itkImage.imageType.dimension];
      } else {
        direction2[col + idx * 3] = itkImage.direction.data[idx + col * itkImage.imageType.dimension];
      }
    }
  }
  const imageData = vtkImageData$1.newInstance(vtkImage);
  const pointData = vtkDataArray$1.newInstance({
    name: options.scalarArrayName || "Scalars",
    values: itkImage.data,
    numberOfComponents: itkImage.imageType.components
  });
  imageData.setDirection(direction2);
  imageData.setDimensions(...dimensions);
  imageData.getPointData().setScalars(pointData);
  switch (isITKWasm ? ITKPixelTypes[itkImage.imageType.pixelType] : itkImage.imageType.pixelType) {
    case ITKPixelTypes.Scalar:
      break;
    case ITKPixelTypes.RGB:
      break;
    case ITKPixelTypes.RGBA:
      break;
    case ITKPixelTypes.Offset:
      break;
    case ITKPixelTypes.Vector:
      if (itkImage.imageType.dimension === 3 && itkImage.imageType.components === 3) {
        imageData.getPointData().setVectors(pointData);
      }
      break;
    case ITKPixelTypes.Point:
      break;
    case ITKPixelTypes.CovariantVector:
      if (itkImage.imageType.dimension === 3 && itkImage.imageType.components === 3) {
        imageData.getPointData().setVectors(pointData);
      }
      break;
    case ITKPixelTypes.SymmetricSecondRankTensor:
      if (itkImage.imageType.dimension === 3 && itkImage.imageType.components === 6) {
        imageData.getPointData().setTensors(pointData);
      }
      break;
    case ITKPixelTypes.DiffusionTensor3D:
      if (itkImage.imageType.dimension === 3 && itkImage.imageType.components === 6) {
        imageData.getPointData().setTensors(pointData);
      }
      break;
    case ITKPixelTypes.Complex:
      break;
    case ITKPixelTypes.FixedArray:
      break;
    case ITKPixelTypes.Array:
      break;
    case ITKPixelTypes.Matrix:
      break;
    case ITKPixelTypes.VariableLengthVector:
      break;
    case ITKPixelTypes.VariableSizeMatrix:
      break;
    default:
      vtkErrorMacro24(`Cannot handle unexpected itk-wasm pixel type ${itkImage.imageType.pixelType}`);
      return null;
  }
  return imageData;
}
function convertVtkToItkImage(vtkImage) {
  let copyData = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  const dimension2 = 3;
  const itkImage = {
    imageType: {
      dimension: dimension2,
      pixelType: ITKWASMPixelTypes.Scalar,
      componentType: "",
      components: 1
    },
    name: "vtkImageData",
    origin: vtkImage.getOrigin(),
    spacing: vtkImage.getSpacing(),
    direction: new Float64Array(9),
    size: vtkImage.getDimensions()
  };
  const direction2 = vtkImage.getDirection();
  for (let idx = 0; idx < dimension2; ++idx) {
    for (let idy = 0; idy < dimension2; ++idy) {
      itkImage.direction[idx + idy * dimension2] = direction2[idy + idx * dimension2];
    }
  }
  const pointData = vtkImage.getPointData();
  let vtkArray;
  if (pointData.getTensors() !== null) {
    itkImage.imageType.pixelType = ITKWASMPixelTypes.DiffusionTensor3D;
    vtkArray = pointData.getTensors();
  } else if (pointData.getVectors() != null) {
    itkImage.imageType.pixelType = ITKWASMPixelTypes.Vector;
    vtkArray = pointData.getVectors();
  } else {
    vtkArray = pointData.getScalars();
  }
  itkImage.imageType.componentType = vtkArrayTypeToItkComponentType.get(vtkArray.getDataType());
  if (copyData) {
    itkImage.data = vtkArray.getData().slice(0);
  } else {
    itkImage.data = vtkArray.getData();
  }
  return itkImage;
}
function convertItkToVtkPolyData(itkPolyData) {
  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const pointDataArrays = [];
  if (itkPolyData.pointData.length) {
    pointDataArrays.push({
      data: {
        vtkClass: "vtkDataArray",
        name: options.pointDataName || "PointData",
        numberOfComponents: itkPolyData.polyDataType.pointPixelComponents,
        size: itkPolyData.pointData.length,
        dataType: itkComponentTypeToVtkArrayType.get(itkPolyData.polyDataType.pointPixelComponentType),
        buffer: itkPolyData.pointData.buffer,
        values: itkPolyData.pointData
      }
    });
  }
  const cellDataArrays = [];
  if (itkPolyData.cellData.length) {
    cellDataArrays.push({
      data: {
        vtkClass: "vtkDataArray",
        name: options.cellDataName || "CellData",
        numberOfComponents: itkPolyData.polyDataType.pointPixelComponents,
        size: itkPolyData.cellData.length,
        dataType: itkComponentTypeToVtkArrayType.get(itkPolyData.polyDataType.pointPixelComponentType),
        buffer: itkPolyData.cellData.buffer,
        values: itkPolyData.cellData
      }
    });
  }
  const vtkPolyDataModel = {
    points: {
      vtkClass: "vtkPoints",
      name: "_points",
      numberOfComponents: 3,
      size: itkPolyData.points.length,
      dataType: "Float32Array",
      buffer: itkPolyData.points.buffer,
      values: itkPolyData.points
    },
    verts: {
      vtkClass: "vtkCellArray",
      name: "_verts",
      numberOfComponents: 1,
      size: itkPolyData.verticesBufferSize,
      dataType: "Uint32Array",
      buffer: itkPolyData.vertices.buffer,
      values: itkPolyData.vertices
    },
    lines: {
      vtkClass: "vtkCellArray",
      name: "_lines",
      numberOfComponents: 1,
      size: itkPolyData.linesBufferSize,
      dataType: "Uint32Array",
      buffer: itkPolyData.lines.buffer,
      values: itkPolyData.lines
    },
    polys: {
      vtkClass: "vtkCellArray",
      name: "_polys",
      numberOfComponents: 1,
      size: itkPolyData.polygonsBufferSize,
      dataType: "Uint32Array",
      buffer: itkPolyData.polygons.buffer,
      values: itkPolyData.polygons
    },
    strips: {
      vtkClass: "vtkCellArray",
      name: "_strips",
      numberOfComponents: 1,
      size: itkPolyData.triangleStripsBufferSize,
      dataType: "Uint32Array",
      buffer: itkPolyData.triangleStrips.buffer,
      values: itkPolyData.triangleStrips
    },
    pointData: {
      vtkClass: "vtkDataSetAttributes",
      activeGlobalIds: -1,
      activeNormals: -1,
      activePedigreeIds: -1,
      activeScalars: -1,
      activeTCoords: -1,
      activeTensors: -1,
      activeVectors: -1,
      copyFieldFlags: [],
      doCopyAllOff: false,
      doCopyAllOn: true,
      arrays: pointDataArrays
    },
    cellData: {
      vtkClass: "vtkDataSetAttributes",
      activeGlobalIds: -1,
      activeNormals: -1,
      activePedigreeIds: -1,
      activeScalars: -1,
      activeTCoords: -1,
      activeTensors: -1,
      activeVectors: -1,
      copyFieldFlags: [],
      doCopyAllOff: false,
      doCopyAllOn: true,
      arrays: cellDataArrays
    }
  };
  const polyData = vtkPolyData$1.newInstance(vtkPolyDataModel);
  const pd = polyData.getPointData();
  const cd = polyData.getCellData();
  if (itkPolyData.pointData.length) {
    switch (ITKWASMPixelTypes[itkPolyData.polyDataType.pointPixelType]) {
      case ITKWASMPixelTypes.Scalar:
        pd.setScalars(pd.getArrayByIndex(0));
        break;
      case ITKWASMPixelTypes.RGB:
        break;
      case ITKWASMPixelTypes.RGBA:
        break;
      case ITKWASMPixelTypes.Offset:
        break;
      case ITKWASMPixelTypes.Vector:
        if (itkPolyData.polyDataType.pointPixelComponents === 3) {
          pd.setVectors(pd.getArrayByIndex(0));
        }
        break;
      case ITKWASMPixelTypes.Point:
        break;
      case ITKWASMPixelTypes.CovariantVector:
        if (itkPolyData.polyDataType.pointPixelComponents === 3) {
          pd.setVectors(pd.getArrayByIndex(0));
        }
        break;
      case ITKWASMPixelTypes.SymmetricSecondRankTensor:
        if (itkPolyData.polyDataType.pointPixelComponents === 6) {
          pd.setTensors(pd.getArrayByIndex(0));
        }
        break;
      case ITKWASMPixelTypes.DiffusionTensor3D:
        if (itkPolyData.polyDataType.pointPixelComponents === 6) {
          pd.setTensors(pd.getArrayByIndex(0));
        }
        break;
      case ITKWASMPixelTypes.Complex:
        break;
      case ITKWASMPixelTypes.FixedArray:
        break;
      case ITKWASMPixelTypes.Array:
        break;
      case ITKWASMPixelTypes.Matrix:
        break;
      case ITKWASMPixelTypes.VariableLengthVector:
        break;
      case ITKWASMPixelTypes.VariableSizeMatrix:
        break;
      default:
        vtkErrorMacro24(`Cannot handle unexpected itk-wasm pixel type ${itkPolyData.polyDataType.pointPixelType}`);
        return null;
    }
  }
  if (itkPolyData.cellData.length) {
    switch (ITKWASMPixelTypes[itkPolyData.polyDataType.cellPixelType]) {
      case ITKWASMPixelTypes.Scalar:
        cd.setScalars(cd.getArrayByIndex(0));
        break;
      case ITKWASMPixelTypes.RGB:
        break;
      case ITKWASMPixelTypes.RGBA:
        break;
      case ITKWASMPixelTypes.Offset:
        break;
      case ITKWASMPixelTypes.Vector:
        if (itkPolyData.polyDataType.pointPixelComponents === 3) {
          cd.setVectors(cd.getArrayByIndex(0));
        }
        break;
      case ITKWASMPixelTypes.Point:
        break;
      case ITKWASMPixelTypes.CovariantVector:
        if (itkPolyData.polyDataType.pointPixelComponents === 3) {
          cd.setVectors(cd.getArrayByIndex(0));
        }
        break;
      case ITKWASMPixelTypes.SymmetricSecondRankTensor:
        if (itkPolyData.polyDataType.pointPixelComponents === 6) {
          cd.setTensors(cd.getArrayByIndex(0));
        }
        break;
      case ITKWASMPixelTypes.DiffusionTensor3D:
        if (itkPolyData.polyDataType.pointPixelComponents === 6) {
          cd.setTensors(cd.getArrayByIndex(0));
        }
        break;
      case ITKWASMPixelTypes.Complex:
        break;
      case ITKWASMPixelTypes.FixedArray:
        break;
      case ITKWASMPixelTypes.Array:
        break;
      case ITKWASMPixelTypes.Matrix:
        break;
      case ITKWASMPixelTypes.VariableLengthVector:
        break;
      case ITKWASMPixelTypes.VariableSizeMatrix:
        break;
      default:
        vtkErrorMacro24(`Cannot handle unexpected itk-wasm pixel type ${itkPolyData.polyDataType.pointPixelType}`);
        return null;
    }
  }
  return polyData;
}
function convertVtkToItkPolyData(polyData) {
  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const itkPolyData = {
    polyDataType: {
      pointPixelComponentType: "float32",
      pointPixelComponents: 1,
      pointPixelType: "Scalar",
      cellPixelComponentType: "float32",
      cellPixelComponents: 1,
      cellPixelType: "Scalar"
    },
    numberOfPoints: polyData.getNumberOfPoints(),
    points: polyData.getPoints().getData(),
    verticesBufferSize: polyData.getVerts().getNumberOfValues(),
    vertices: polyData.getVerts().getData(),
    linesBufferSize: polyData.getLines().getNumberOfValues(),
    lines: polyData.getLines().getData(),
    polygonsBufferSize: polyData.getPolys().getNumberOfValues(),
    polygons: polyData.getPolys().getData(),
    triangleStripsBufferSize: polyData.getStrips().getNumberOfValues(),
    triangleStrips: polyData.getStrips().getData(),
    numberOfPointPixels: 0,
    pointData: new Float32Array(),
    numberOfCellPixels: 0,
    cellData: new Float32Array()
  };
  const pd = polyData.getPointData();
  if (pd.getNumberOfArrays()) {
    const pdArray = options.pointDataName ? pd.getArrayByName(options.pointDataName) : pd.getArrayByIndex(0);
    itkPolyData.numberOfPointPixels = pdArray.getNumberOfTuples();
    itkPolyData.pointData = pdArray.getData();
    itkPolyData.polyDataType.pointPixelComponentType = vtkArrayTypeToItkComponentType.get(pdArray.getDataType());
    itkPolyData.polyDataType.cellPixelComponentType = itkPolyData.polyDataType.pointPixelComponentType;
    itkPolyData.polyDataType.pointPixelComponents = pdArray.getNumberOfComponents();
    itkPolyData.polyDataType.cellPixelComponents = itkPolyData.polyDataType.pointPixelComponents;
    if (pd.getTensors() === pdArray) {
      itkPolyData.polyDataType.pointPixelType = ITKWASMPixelTypes.SymmetricSecondRankTensor;
    } else if (pd.getVectors() === pdArray) {
      itkPolyData.polyDataType.pointPixelType = ITKWASMPixelTypes.Vector;
    }
    itkPolyData.polyDataType.cellPixelType = itkPolyData.polyDataType.pointPixelType;
  }
  const cd = polyData.getCellData();
  if (cd.getNumberOfArrays()) {
    const cdArray = options.cellDataName ? pd.getArrayByName(options.cellDataName) : pd.getArrayByIndex(0);
    itkPolyData.numberOfCellPixels = cdArray.getNumberOfTuples();
    itkPolyData.cellData = cdArray.getData();
    itkPolyData.polyDataType.cellPixelComponentType = vtkArrayTypeToItkComponentType.get(cdArray.getDataType());
    itkPolyData.polyDataType.cellPixelComponents = cdArray.getNumberOfComponents();
    if (cd.getTensors() === cdArray) {
      itkPolyData.polyDataType.cellPixelType = ITKWASMPixelTypes.SymmetricSecondRankTensor;
    } else if (cd.getVectors() === cdArray) {
      itkPolyData.polyDataType.cellPixelType = ITKWASMPixelTypes.Vector;
    } else {
      itkPolyData.polyDataType.cellPixelType = ITKWASMPixelTypes.Scalar;
    }
  }
  return itkPolyData;
}
var ITKHelper = {
  convertItkToVtkImage,
  convertVtkToItkImage,
  convertItkToVtkPolyData,
  convertVtkToItkPolyData
};

// node_modules/@kitware/vtk.js/Rendering/Core/Camera.js
var {
  vtkDebugMacro: vtkDebugMacro7
} = macro;
function vtkCamera(publicAPI, model) {
  model.classHierarchy.push("vtkCamera");
  const origin2 = new Float64Array(3);
  const dopbasis = new Float64Array([0, 0, -1]);
  const upbasis = new Float64Array([0, 1, 0]);
  const tmpMatrix = mat4_exports.identity(new Float64Array(16));
  const tmpMatrix2 = mat4_exports.identity(new Float64Array(16));
  const tmpvec1 = new Float64Array(3);
  const tmpvec2 = new Float64Array(3);
  const tmpvec3 = new Float64Array(3);
  const rotateMatrix = mat4_exports.identity(new Float64Array(16));
  const trans = mat4_exports.identity(new Float64Array(16));
  const newPosition = new Float64Array(3);
  const newFocalPoint = new Float64Array(3);
  function computeViewPlaneNormal() {
    model.viewPlaneNormal[0] = -model.directionOfProjection[0];
    model.viewPlaneNormal[1] = -model.directionOfProjection[1];
    model.viewPlaneNormal[2] = -model.directionOfProjection[2];
  }
  publicAPI.orthogonalizeViewUp = () => {
    const vt = publicAPI.getViewMatrix();
    model.viewUp[0] = vt[4];
    model.viewUp[1] = vt[5];
    model.viewUp[2] = vt[6];
    publicAPI.modified();
  };
  publicAPI.setPosition = (x2, y3, z3) => {
    if (x2 === model.position[0] && y3 === model.position[1] && z3 === model.position[2]) {
      return;
    }
    model.position[0] = x2;
    model.position[1] = y3;
    model.position[2] = z3;
    publicAPI.computeDistance();
    publicAPI.modified();
  };
  publicAPI.setFocalPoint = (x2, y3, z3) => {
    if (x2 === model.focalPoint[0] && y3 === model.focalPoint[1] && z3 === model.focalPoint[2]) {
      return;
    }
    model.focalPoint[0] = x2;
    model.focalPoint[1] = y3;
    model.focalPoint[2] = z3;
    publicAPI.computeDistance();
    publicAPI.modified();
  };
  publicAPI.setDistance = (d3) => {
    if (model.distance === d3) {
      return;
    }
    model.distance = d3;
    if (model.distance < 1e-20) {
      model.distance = 1e-20;
      vtkDebugMacro7("Distance is set to minimum.");
    }
    const vec = model.directionOfProjection;
    model.focalPoint[0] = model.position[0] + vec[0] * model.distance;
    model.focalPoint[1] = model.position[1] + vec[1] * model.distance;
    model.focalPoint[2] = model.position[2] + vec[2] * model.distance;
    publicAPI.modified();
  };
  publicAPI.computeDistance = () => {
    const dx = model.focalPoint[0] - model.position[0];
    const dy = model.focalPoint[1] - model.position[1];
    const dz = model.focalPoint[2] - model.position[2];
    model.distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
    if (model.distance < 1e-20) {
      model.distance = 1e-20;
      vtkDebugMacro7("Distance is set to minimum.");
      const vec = model.directionOfProjection;
      model.focalPoint[0] = model.position[0] + vec[0] * model.distance;
      model.focalPoint[1] = model.position[1] + vec[1] * model.distance;
      model.focalPoint[2] = model.position[2] + vec[2] * model.distance;
    }
    model.directionOfProjection[0] = dx / model.distance;
    model.directionOfProjection[1] = dy / model.distance;
    model.directionOfProjection[2] = dz / model.distance;
    computeViewPlaneNormal();
  };
  publicAPI.dolly = (amount) => {
    if (amount <= 0) {
      return;
    }
    const d3 = model.distance / amount;
    publicAPI.setPosition(model.focalPoint[0] - d3 * model.directionOfProjection[0], model.focalPoint[1] - d3 * model.directionOfProjection[1], model.focalPoint[2] - d3 * model.directionOfProjection[2]);
  };
  publicAPI.roll = (angle2) => {
    const eye = model.position;
    const at = model.focalPoint;
    const up = model.viewUp;
    const viewUpVec4 = new Float64Array([up[0], up[1], up[2], 0]);
    mat4_exports.identity(rotateMatrix);
    const viewDir = new Float64Array([at[0] - eye[0], at[1] - eye[1], at[2] - eye[2]]);
    mat4_exports.rotate(rotateMatrix, rotateMatrix, radiansFromDegrees(angle2), viewDir);
    vec4_exports.transformMat4(viewUpVec4, viewUpVec4, rotateMatrix);
    model.viewUp[0] = viewUpVec4[0];
    model.viewUp[1] = viewUpVec4[1];
    model.viewUp[2] = viewUpVec4[2];
    publicAPI.modified();
  };
  publicAPI.azimuth = (angle2) => {
    const fp = model.focalPoint;
    mat4_exports.identity(trans);
    mat4_exports.translate(trans, trans, fp);
    mat4_exports.rotate(trans, trans, radiansFromDegrees(angle2), model.viewUp);
    mat4_exports.translate(trans, trans, [-fp[0], -fp[1], -fp[2]]);
    vec3_exports.transformMat4(newPosition, model.position, trans);
    publicAPI.setPosition(newPosition[0], newPosition[1], newPosition[2]);
  };
  publicAPI.yaw = (angle2) => {
    const position = model.position;
    mat4_exports.identity(trans);
    mat4_exports.translate(trans, trans, position);
    mat4_exports.rotate(trans, trans, radiansFromDegrees(angle2), model.viewUp);
    mat4_exports.translate(trans, trans, [-position[0], -position[1], -position[2]]);
    vec3_exports.transformMat4(newFocalPoint, model.focalPoint, trans);
    publicAPI.setFocalPoint(newFocalPoint[0], newFocalPoint[1], newFocalPoint[2]);
  };
  publicAPI.elevation = (angle2) => {
    const fp = model.focalPoint;
    const vt = publicAPI.getViewMatrix();
    const axis2 = [-vt[0], -vt[1], -vt[2]];
    mat4_exports.identity(trans);
    mat4_exports.translate(trans, trans, fp);
    mat4_exports.rotate(trans, trans, radiansFromDegrees(angle2), axis2);
    mat4_exports.translate(trans, trans, [-fp[0], -fp[1], -fp[2]]);
    vec3_exports.transformMat4(newPosition, model.position, trans);
    publicAPI.setPosition(newPosition[0], newPosition[1], newPosition[2]);
  };
  publicAPI.pitch = (angle2) => {
    const position = model.position;
    const vt = publicAPI.getViewMatrix();
    const axis2 = [vt[0], vt[1], vt[2]];
    mat4_exports.identity(trans);
    mat4_exports.translate(trans, trans, position);
    mat4_exports.rotate(trans, trans, radiansFromDegrees(angle2), axis2);
    mat4_exports.translate(trans, trans, [-position[0], -position[1], -position[2]]);
    vec3_exports.transformMat4(newFocalPoint, model.focalPoint, trans);
    publicAPI.setFocalPoint(...newFocalPoint);
  };
  publicAPI.zoom = (factor) => {
    if (factor <= 0) {
      return;
    }
    if (model.parallelProjection) {
      model.parallelScale /= factor;
    } else {
      model.viewAngle /= factor;
    }
    publicAPI.modified();
  };
  publicAPI.translate = (x2, y3, z3) => {
    const offset3 = [x2, y3, z3];
    add6(model.position, offset3, model.position);
    add6(model.focalPoint, offset3, model.focalPoint);
    publicAPI.computeDistance();
    publicAPI.modified();
  };
  publicAPI.applyTransform = (transformMat43) => {
    const vuOld = [...model.viewUp, 1];
    const posNew = [];
    const fpNew = [];
    const vuNew = [];
    vuOld[0] += model.position[0];
    vuOld[1] += model.position[1];
    vuOld[2] += model.position[2];
    vec4_exports.transformMat4(posNew, [...model.position, 1], transformMat43);
    vec4_exports.transformMat4(fpNew, [...model.focalPoint, 1], transformMat43);
    vec4_exports.transformMat4(vuNew, vuOld, transformMat43);
    vuNew[0] -= posNew[0];
    vuNew[1] -= posNew[1];
    vuNew[2] -= posNew[2];
    publicAPI.setPosition(...posNew.slice(0, 3));
    publicAPI.setFocalPoint(...fpNew.slice(0, 3));
    publicAPI.setViewUp(...vuNew.slice(0, 3));
  };
  publicAPI.getThickness = () => model.clippingRange[1] - model.clippingRange[0];
  publicAPI.setThickness = (thickness) => {
    let t9 = thickness;
    if (t9 < 1e-20) {
      t9 = 1e-20;
      vtkDebugMacro7("Thickness is set to minimum.");
    }
    publicAPI.setClippingRange(model.clippingRange[0], model.clippingRange[0] + t9);
  };
  publicAPI.setThicknessFromFocalPoint = (thickness) => {
    let t9 = thickness;
    if (t9 < 1e-20) {
      t9 = 1e-20;
      vtkDebugMacro7("Thickness is set to minimum.");
    }
    publicAPI.setClippingRange(model.distance - t9 / 2, model.distance + t9 / 2);
  };
  publicAPI.setRoll = (angle2) => {
  };
  publicAPI.getRoll = () => {
  };
  publicAPI.setObliqueAngles = (alpha, beta) => {
  };
  publicAPI.getOrientation = () => {
  };
  publicAPI.getOrientationWXYZ = () => {
  };
  publicAPI.getFrustumPlanes = (aspect) => {
  };
  publicAPI.getCameraLightTransformMatrix = (matrix) => {
    mat4_exports.copy(matrix, model.cameraLightTransform);
    return matrix;
  };
  publicAPI.computeCameraLightTransform = () => {
    mat4_exports.copy(tmpMatrix, publicAPI.getViewMatrix());
    mat4_exports.invert(tmpMatrix, tmpMatrix);
    mat4_exports.fromScaling(tmpMatrix2, [model.distance, model.distance, model.distance]);
    mat4_exports.multiply(tmpMatrix, tmpMatrix, tmpMatrix2);
    mat4_exports.identity(model.cameraLightTransform);
    mat4_exports.translate(model.cameraLightTransform, tmpMatrix, [0, 0, -1]);
  };
  publicAPI.deepCopy = (sourceCamera) => {
  };
  publicAPI.physicalOrientationToWorldDirection = (ori) => {
    const oriq = quat_exports.fromValues(ori[0], ori[1], ori[2], ori[3]);
    const coriq = quat_exports.create();
    const qdir = quat_exports.fromValues(0, 0, 1, 0);
    quat_exports.conjugate(coriq, oriq);
    quat_exports.multiply(qdir, oriq, qdir);
    quat_exports.multiply(qdir, qdir, coriq);
    return [qdir[0], qdir[1], qdir[2]];
  };
  publicAPI.getPhysicalToWorldMatrix = (result) => {
    publicAPI.getWorldToPhysicalMatrix(result);
    mat4_exports.invert(result, result);
  };
  publicAPI.getWorldToPhysicalMatrix = (result) => {
    mat4_exports.identity(result);
    const physVRight = [3];
    cross3(model.physicalViewNorth, model.physicalViewUp, physVRight);
    result[0] = physVRight[0];
    result[1] = physVRight[1];
    result[2] = physVRight[2];
    result[4] = model.physicalViewUp[0];
    result[5] = model.physicalViewUp[1];
    result[6] = model.physicalViewUp[2];
    result[8] = -model.physicalViewNorth[0];
    result[9] = -model.physicalViewNorth[1];
    result[10] = -model.physicalViewNorth[2];
    mat4_exports.transpose(result, result);
    vec3_exports.set(tmpvec1, 1 / model.physicalScale, 1 / model.physicalScale, 1 / model.physicalScale);
    mat4_exports.scale(result, result, tmpvec1);
    mat4_exports.translate(result, result, model.physicalTranslation);
  };
  publicAPI.computeViewParametersFromViewMatrix = (vmat) => {
    mat4_exports.invert(tmpMatrix, vmat);
    vec3_exports.transformMat4(tmpvec1, origin2, tmpMatrix);
    publicAPI.computeDistance();
    const oldDist = model.distance;
    publicAPI.setPosition(tmpvec1[0], tmpvec1[1], tmpvec1[2]);
    vec3_exports.transformMat4(tmpvec2, dopbasis, tmpMatrix);
    vec3_exports.subtract(tmpvec2, tmpvec2, tmpvec1);
    vec3_exports.normalize(tmpvec2, tmpvec2);
    publicAPI.setDirectionOfProjection(tmpvec2[0], tmpvec2[1], tmpvec2[2]);
    vec3_exports.transformMat4(tmpvec3, upbasis, tmpMatrix);
    vec3_exports.subtract(tmpvec3, tmpvec3, tmpvec1);
    vec3_exports.normalize(tmpvec3, tmpvec3);
    publicAPI.setViewUp(tmpvec3[0], tmpvec3[1], tmpvec3[2]);
    publicAPI.setDistance(oldDist);
  };
  publicAPI.computeViewParametersFromPhysicalMatrix = (mat) => {
    publicAPI.getWorldToPhysicalMatrix(tmpMatrix);
    mat4_exports.multiply(tmpMatrix, mat, tmpMatrix);
    publicAPI.computeViewParametersFromViewMatrix(tmpMatrix);
  };
  publicAPI.setViewMatrix = (mat) => {
    model.viewMatrix = mat;
    if (model.viewMatrix) {
      mat4_exports.copy(tmpMatrix, model.viewMatrix);
      publicAPI.computeViewParametersFromViewMatrix(tmpMatrix);
      mat4_exports.transpose(model.viewMatrix, model.viewMatrix);
    }
  };
  publicAPI.getViewMatrix = () => {
    if (model.viewMatrix) {
      return model.viewMatrix;
    }
    mat4_exports.lookAt(
      tmpMatrix,
      model.position,
      // eye
      model.focalPoint,
      // at
      model.viewUp
      // up
    );
    mat4_exports.transpose(tmpMatrix, tmpMatrix);
    const result = new Float64Array(16);
    mat4_exports.copy(result, tmpMatrix);
    return result;
  };
  publicAPI.setProjectionMatrix = (mat) => {
    model.projectionMatrix = mat;
  };
  publicAPI.getProjectionMatrix = (aspect, nearz, farz) => {
    const result = new Float64Array(16);
    mat4_exports.identity(result);
    if (model.projectionMatrix) {
      const scale7 = 1 / model.physicalScale;
      vec3_exports.set(tmpvec1, scale7, scale7, scale7);
      mat4_exports.copy(result, model.projectionMatrix);
      mat4_exports.scale(result, result, tmpvec1);
      mat4_exports.transpose(result, result);
      return result;
    }
    mat4_exports.identity(tmpMatrix);
    const cWidth = model.clippingRange[1] - model.clippingRange[0];
    const cRange = [model.clippingRange[0] + (nearz + 1) * cWidth / 2, model.clippingRange[0] + (farz + 1) * cWidth / 2];
    if (model.parallelProjection) {
      const width = model.parallelScale * aspect;
      const height = model.parallelScale;
      const xmin = (model.windowCenter[0] - 1) * width;
      const xmax = (model.windowCenter[0] + 1) * width;
      const ymin = (model.windowCenter[1] - 1) * height;
      const ymax = (model.windowCenter[1] + 1) * height;
      mat4_exports.ortho(tmpMatrix, xmin, xmax, ymin, ymax, cRange[0], cRange[1]);
      mat4_exports.transpose(tmpMatrix, tmpMatrix);
    } else if (model.useOffAxisProjection) {
      throw new Error("Off-Axis projection is not supported at this time");
    } else {
      const tmp = Math.tan(radiansFromDegrees(model.viewAngle) / 2);
      let width;
      let height;
      if (model.useHorizontalViewAngle === true) {
        width = model.clippingRange[0] * tmp;
        height = model.clippingRange[0] * tmp / aspect;
      } else {
        width = model.clippingRange[0] * tmp * aspect;
        height = model.clippingRange[0] * tmp;
      }
      const xmin = (model.windowCenter[0] - 1) * width;
      const xmax = (model.windowCenter[0] + 1) * width;
      const ymin = (model.windowCenter[1] - 1) * height;
      const ymax = (model.windowCenter[1] + 1) * height;
      const znear = cRange[0];
      const zfar = cRange[1];
      tmpMatrix[0] = 2 * znear / (xmax - xmin);
      tmpMatrix[5] = 2 * znear / (ymax - ymin);
      tmpMatrix[2] = (xmin + xmax) / (xmax - xmin);
      tmpMatrix[6] = (ymin + ymax) / (ymax - ymin);
      tmpMatrix[10] = -(znear + zfar) / (zfar - znear);
      tmpMatrix[14] = -1;
      tmpMatrix[11] = -2 * znear * zfar / (zfar - znear);
      tmpMatrix[15] = 0;
    }
    mat4_exports.copy(result, tmpMatrix);
    return result;
  };
  publicAPI.getCompositeProjectionMatrix = (aspect, nearz, farz) => {
    const vMat = publicAPI.getViewMatrix();
    const pMat = publicAPI.getProjectionMatrix(aspect, nearz, farz);
    mat4_exports.multiply(pMat, vMat, pMat);
    return pMat;
  };
  publicAPI.setDirectionOfProjection = (x2, y3, z3) => {
    if (model.directionOfProjection[0] === x2 && model.directionOfProjection[1] === y3 && model.directionOfProjection[2] === z3) {
      return;
    }
    model.directionOfProjection[0] = x2;
    model.directionOfProjection[1] = y3;
    model.directionOfProjection[2] = z3;
    const vec = model.directionOfProjection;
    model.focalPoint[0] = model.position[0] + vec[0] * model.distance;
    model.focalPoint[1] = model.position[1] + vec[1] * model.distance;
    model.focalPoint[2] = model.position[2] + vec[2] * model.distance;
    computeViewPlaneNormal();
  };
  publicAPI.setDeviceAngles = (alpha, beta, gamma, screen) => {
    const physVRight = [3];
    cross3(model.physicalViewNorth, model.physicalViewUp, physVRight);
    const rotmat = mat4_exports.identity(new Float64Array(16));
    mat4_exports.rotate(rotmat, rotmat, radiansFromDegrees(alpha), model.physicalViewUp);
    mat4_exports.rotate(rotmat, rotmat, radiansFromDegrees(beta), physVRight);
    mat4_exports.rotate(rotmat, rotmat, radiansFromDegrees(gamma), model.physicalViewNorth);
    mat4_exports.rotate(rotmat, rotmat, radiansFromDegrees(-screen), model.physicalViewUp);
    const dop = new Float64Array([-model.physicalViewUp[0], -model.physicalViewUp[1], -model.physicalViewUp[2]]);
    const vup = new Float64Array(model.physicalViewNorth);
    vec3_exports.transformMat4(dop, dop, rotmat);
    vec3_exports.transformMat4(vup, vup, rotmat);
    publicAPI.setDirectionOfProjection(dop[0], dop[1], dop[2]);
    publicAPI.setViewUp(vup[0], vup[1], vup[2]);
    publicAPI.modified();
  };
  publicAPI.setOrientationWXYZ = (degrees, x2, y3, z3) => {
    const quatMat = mat4_exports.identity(new Float64Array(16));
    if (degrees !== 0 && (x2 !== 0 || y3 !== 0 || z3 !== 0)) {
      const angle2 = radiansFromDegrees(degrees);
      const q = quat_exports.create();
      quat_exports.setAxisAngle(q, [x2, y3, z3], angle2);
      mat4_exports.fromQuat(quatMat, q);
    }
    const newdop = new Float64Array(3);
    vec3_exports.transformMat4(newdop, [0, 0, -1], quatMat);
    const newvup = new Float64Array(3);
    vec3_exports.transformMat4(newvup, [0, 1, 0], quatMat);
    publicAPI.setDirectionOfProjection(...newdop);
    publicAPI.setViewUp(...newvup);
    publicAPI.modified();
  };
  publicAPI.computeClippingRange = (bounds) => {
    let vn = null;
    let position = null;
    vn = model.viewPlaneNormal;
    position = model.position;
    const a4 = -vn[0];
    const b3 = -vn[1];
    const c6 = -vn[2];
    const d3 = -(a4 * position[0] + b3 * position[1] + c6 * position[2]);
    const range = [a4 * bounds[0] + b3 * bounds[2] + c6 * bounds[4] + d3, 1e-18];
    for (let k2 = 0; k2 < 2; k2++) {
      for (let j2 = 0; j2 < 2; j2++) {
        for (let i6 = 0; i6 < 2; i6++) {
          const dist3 = a4 * bounds[i6] + b3 * bounds[2 + j2] + c6 * bounds[4 + k2] + d3;
          range[0] = dist3 < range[0] ? dist3 : range[0];
          range[1] = dist3 > range[1] ? dist3 : range[1];
        }
      }
    }
    return range;
  };
}
var DEFAULT_VALUES69 = {
  position: [0, 0, 1],
  focalPoint: [0, 0, 0],
  viewUp: [0, 1, 0],
  directionOfProjection: [0, 0, -1],
  parallelProjection: false,
  useHorizontalViewAngle: false,
  viewAngle: 30,
  parallelScale: 1,
  clippingRange: [0.01, 1000.01],
  windowCenter: [0, 0],
  viewPlaneNormal: [0, 0, 1],
  useOffAxisProjection: false,
  screenBottomLeft: [-0.5, -0.5, -0.5],
  screenBottomRight: [0.5, -0.5, -0.5],
  screenTopRight: [0.5, 0.5, -0.5],
  freezeFocalPoint: false,
  projectionMatrix: null,
  viewMatrix: null,
  cameraLightTransform: mat4_exports.create(),
  // used for world to physical transformations
  physicalTranslation: [0, 0, 0],
  physicalScale: 1,
  physicalViewUp: [0, 1, 0],
  physicalViewNorth: [0, 0, -1]
};
function extend71(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES69, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["distance"]);
  macro.setGet(publicAPI, model, ["parallelProjection", "useHorizontalViewAngle", "viewAngle", "parallelScale", "useOffAxisProjection", "freezeFocalPoint", "physicalScale"]);
  macro.getArray(publicAPI, model, ["directionOfProjection", "viewPlaneNormal", "position", "focalPoint"]);
  macro.setGetArray(publicAPI, model, ["clippingRange", "windowCenter"], 2);
  macro.setGetArray(publicAPI, model, ["viewUp", "screenBottomLeft", "screenBottomRight", "screenTopRight", "physicalTranslation", "physicalViewUp", "physicalViewNorth"], 3);
  vtkCamera(publicAPI, model);
}
var newInstance70 = macro.newInstance(extend71, "vtkCamera");
var vtkCamera$1 = {
  newInstance: newInstance70,
  extend: extend71
};

// node_modules/@kitware/vtk.js/Rendering/Core/Light.js
var LIGHT_TYPES = ["HeadLight", "CameraLight", "SceneLight"];
function vtkLight(publicAPI, model) {
  model.classHierarchy.push("vtkLight");
  const tmpVec = new Float64Array(3);
  publicAPI.getTransformedPosition = () => {
    if (model.transformMatrix) {
      vec3_exports.transformMat4(tmpVec, model.position, model.transformMatrix);
    } else {
      vec3_exports.set(tmpVec, model.position[0], model.position[1], model.position[2]);
    }
    return tmpVec;
  };
  publicAPI.getTransformedFocalPoint = () => {
    if (model.transformMatrix) {
      vec3_exports.transformMat4(tmpVec, model.focalPoint, model.transformMatrix);
    } else {
      vec3_exports.set(tmpVec, model.focalPoint[0], model.focalPoint[1], model.focalPoint[2]);
    }
    return tmpVec;
  };
  publicAPI.getDirection = () => {
    if (model.directionMTime < model.mtime) {
      vec3_exports.sub(model.direction, model.focalPoint, model.position);
      normalize4(model.direction);
      model.directionMTime = model.mtime;
    }
    return model.direction;
  };
  publicAPI.setDirection = (directionVector) => {
    const newFocalPoint = new Float64Array(3);
    vec3_exports.sub(newFocalPoint, model.position, directionVector);
    model.focalPoint = newFocalPoint;
  };
  publicAPI.setDirectionAngle = (elevation, azimuth) => {
    const elevationRadians = radiansFromDegrees(elevation);
    const azimuthRadians = radiansFromDegrees(azimuth);
    publicAPI.setPosition(Math.cos(elevationRadians) * Math.sin(azimuthRadians), Math.sin(elevationRadians), Math.cos(elevationRadians) * Math.cos(azimuthRadians));
    publicAPI.setFocalPoint(0, 0, 0);
    publicAPI.setPositional(0);
  };
  publicAPI.setLightTypeToHeadLight = () => {
    publicAPI.setLightType("HeadLight");
  };
  publicAPI.setLightTypeToCameraLight = () => {
    publicAPI.setLightType("CameraLight");
  };
  publicAPI.setLightTypeToSceneLight = () => {
    publicAPI.setTransformMatrix(null);
    publicAPI.setLightType("SceneLight");
  };
  publicAPI.lightTypeIsHeadLight = () => model.lightType === "HeadLight";
  publicAPI.lightTypeIsSceneLight = () => model.lightType === "SceneLight";
  publicAPI.lightTypeIsCameraLight = () => model.lightType === "CameraLight";
}
var DEFAULT_VALUES70 = {
  switch: true,
  intensity: 1,
  color: [1, 1, 1],
  position: [0, 0, 1],
  focalPoint: [0, 0, 0],
  positional: false,
  exponent: 1,
  coneAngle: 30,
  coneFalloff: 5,
  attenuationValues: [1, 0, 0],
  transformMatrix: null,
  lightType: "SceneLight",
  shadowAttenuation: 1,
  direction: [0, 0, 0],
  directionMTime: 0
};
function extend72(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES70, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["intensity", "switch", "positional", "exponent", "coneAngle", "coneFalloff", "transformMatrix", "lightType", "shadowAttenuation", "attenuationValues"]);
  macro.setGetArray(publicAPI, model, ["color", "position", "focalPoint", "attenuationValues"], 3);
  vtkLight(publicAPI, model);
}
var newInstance71 = macro.newInstance(extend72, "vtkLight");
var vtkLight$1 = {
  newInstance: newInstance71,
  extend: extend72,
  LIGHT_TYPES
};

// node_modules/@kitware/vtk.js/Rendering/Core/Viewport.js
var {
  vtkErrorMacro: vtkErrorMacro25
} = macro;
function notImplemented4(method) {
  return () => vtkErrorMacro25(`vtkViewport::${method} - NOT IMPLEMENTED`);
}
function vtkViewport(publicAPI, model) {
  model.classHierarchy.push("vtkViewport");
  publicAPI.getViewProps = () => model.props;
  publicAPI.hasViewProp = (prop) => model.props.includes(prop);
  publicAPI.addViewProp = (prop) => {
    if (prop && !publicAPI.hasViewProp(prop)) {
      model.props.push(prop);
    }
  };
  publicAPI.removeViewProp = (prop) => {
    const newPropList = model.props.filter((item) => item !== prop);
    if (model.props.length !== newPropList.length) {
      model.props = newPropList;
    }
  };
  publicAPI.removeAllViewProps = () => {
    model.props = [];
  };
  function gatherProps(prop) {
    let allProps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    allProps.push(prop);
    const children = prop.getNestedProps();
    if (children && children.length) {
      for (let i6 = 0; i6 < children.length; i6++) {
        gatherProps(children[i6], allProps);
      }
    }
    return allProps;
  }
  publicAPI.getViewPropsWithNestedProps = () => {
    const allPropsArray = [];
    for (let i6 = 0; i6 < model.props.length; i6++) {
      gatherProps(model.props[i6], allPropsArray);
    }
    return allPropsArray;
  };
  publicAPI.addActor2D = publicAPI.addViewProp;
  publicAPI.removeActor2D = (prop) => {
    publicAPI.removeViewProp(prop);
  };
  publicAPI.getActors2D = () => {
    model.actors2D = [];
    model.props.forEach((prop) => {
      model.actors2D = model.actors2D.concat(prop.getActors2D());
    });
    return model.actors2D;
  };
  publicAPI.displayToView = () => vtkErrorMacro25("call displayToView on your view instead");
  publicAPI.viewToDisplay = () => vtkErrorMacro25("callviewtodisplay on your view instead");
  publicAPI.getSize = () => vtkErrorMacro25("call getSize on your View instead");
  publicAPI.normalizedDisplayToProjection = (x2, y3, z3) => {
    const nvp = publicAPI.normalizedDisplayToNormalizedViewport(x2, y3, z3);
    return publicAPI.normalizedViewportToProjection(nvp[0], nvp[1], nvp[2]);
  };
  publicAPI.normalizedDisplayToNormalizedViewport = (x2, y3, z3) => {
    const scale7 = [model.viewport[2] - model.viewport[0], model.viewport[3] - model.viewport[1]];
    return [(x2 - model.viewport[0]) / scale7[0], (y3 - model.viewport[1]) / scale7[1], z3];
  };
  publicAPI.normalizedViewportToProjection = (x2, y3, z3) => [x2 * 2 - 1, y3 * 2 - 1, z3 * 2 - 1];
  publicAPI.projectionToNormalizedDisplay = (x2, y3, z3) => {
    const nvp = publicAPI.projectionToNormalizedViewport(x2, y3, z3);
    return publicAPI.normalizedViewportToNormalizedDisplay(nvp[0], nvp[1], nvp[2]);
  };
  publicAPI.normalizedViewportToNormalizedDisplay = (x2, y3, z3) => {
    const scale7 = [model.viewport[2] - model.viewport[0], model.viewport[3] - model.viewport[1]];
    return [x2 * scale7[0] + model.viewport[0], y3 * scale7[1] + model.viewport[1], z3];
  };
  publicAPI.projectionToNormalizedViewport = (x2, y3, z3) => [(x2 + 1) * 0.5, (y3 + 1) * 0.5, (z3 + 1) * 0.5];
  publicAPI.PickPropFrom = notImplemented4("PickPropFrom");
}
var DEFAULT_VALUES71 = {
  // _vtkWindow: null,
  background: [0, 0, 0],
  background2: [0.2, 0.2, 0.2],
  gradientBackground: false,
  viewport: [0, 0, 1, 1],
  aspect: [1, 1],
  pixelAspect: [1, 1],
  props: [],
  actors2D: []
};
function extend73(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES71, initialValues);
  macro.obj(publicAPI, model);
  macro.event(publicAPI, model, "event");
  macro.setGetArray(publicAPI, model, ["viewport"], 4);
  macro.setGetArray(publicAPI, model, ["background", "background2"], 3);
  vtkViewport(publicAPI, model);
}
var newInstance72 = macro.newInstance(extend73, "vtkViewport");
var vtkViewport$1 = {
  newInstance: newInstance72,
  extend: extend73
};

// node_modules/@kitware/vtk.js/Rendering/Core/Renderer.js
var {
  vtkDebugMacro: vtkDebugMacro8,
  vtkErrorMacro: vtkErrorMacro26,
  vtkWarningMacro: vtkWarningMacro8
} = macro$1;
function notImplemented5(method) {
  return () => vtkErrorMacro26(`vtkRenderer::${method} - NOT IMPLEMENTED`);
}
function vtkRenderer(publicAPI, model) {
  model.classHierarchy.push("vtkRenderer");
  const COMPUTE_VISIBLE_PROP_BOUNDS_EVENT = {
    type: "ComputeVisiblePropBoundsEvent",
    renderer: publicAPI
  };
  const RESET_CAMERA_CLIPPING_RANGE_EVENT = {
    type: "ResetCameraClippingRangeEvent",
    renderer: publicAPI
  };
  const RESET_CAMERA_EVENT = {
    type: "ResetCameraEvent",
    renderer: publicAPI
  };
  publicAPI.updateCamera = () => {
    if (!model.activeCamera) {
      vtkDebugMacro8("No cameras are on, creating one.");
      publicAPI.getActiveCameraAndResetIfCreated();
    }
    model.activeCamera.render(publicAPI);
    return true;
  };
  publicAPI.updateLightsGeometryToFollowCamera = () => {
    const camera = publicAPI.getActiveCameraAndResetIfCreated();
    model.lights.forEach((light) => {
      if (light.lightTypeIsSceneLight()) ;
      else if (light.lightTypeIsHeadLight()) {
        light.setPositionFrom(camera.getPositionByReference());
        light.setFocalPointFrom(camera.getFocalPointByReference());
        light.modified(camera.getMTime());
      } else if (light.lightTypeIsCameraLight()) {
        light.setTransformMatrix(camera.getCameraLightTransformMatrix(mat4_exports.create()));
      } else {
        vtkErrorMacro26("light has unknown light type", light.get());
      }
    });
  };
  publicAPI.updateLightGeometry = () => {
    if (model.lightFollowCamera) {
      return publicAPI.updateLightsGeometryToFollowCamera();
    }
    return true;
  };
  publicAPI.allocateTime = notImplemented5("allocateTime");
  publicAPI.updateGeometry = notImplemented5("updateGeometry");
  publicAPI.getVTKWindow = () => model._renderWindow;
  publicAPI.setLayer = (layer) => {
    vtkDebugMacro8(publicAPI.getClassName(), publicAPI, "setting Layer to ", layer);
    if (model.layer !== layer) {
      model.layer = layer;
      publicAPI.modified();
    }
    publicAPI.setPreserveColorBuffer(!!layer);
  };
  publicAPI.setActiveCamera = (camera) => {
    if (model.activeCamera === camera) {
      return false;
    }
    model.activeCamera = camera;
    publicAPI.modified();
    publicAPI.invokeEvent({
      type: "ActiveCameraEvent",
      camera
    });
    return true;
  };
  publicAPI.makeCamera = () => {
    const camera = vtkCamera$1.newInstance();
    publicAPI.invokeEvent({
      type: "CreateCameraEvent",
      camera
    });
    return camera;
  };
  publicAPI.getActiveCamera = () => {
    if (!model.activeCamera) {
      model.activeCamera = publicAPI.makeCamera();
    }
    return model.activeCamera;
  };
  publicAPI.getActiveCameraAndResetIfCreated = () => {
    if (!model.activeCamera) {
      publicAPI.getActiveCamera();
      publicAPI.resetCamera();
    }
    return model.activeCamera;
  };
  publicAPI.getActors = () => {
    model.actors = [];
    model.props.forEach((prop) => {
      model.actors = model.actors.concat(prop.getActors());
    });
    return model.actors;
  };
  publicAPI.addActor = publicAPI.addViewProp;
  publicAPI.removeActor = (actor) => {
    model.actors = model.actors.filter((a4) => a4 !== actor);
    publicAPI.removeViewProp(actor);
    publicAPI.modified();
  };
  publicAPI.removeAllActors = () => {
    const actors = publicAPI.getActors();
    actors.forEach((actor) => {
      publicAPI.removeViewProp(actor);
    });
    model.actors = [];
    publicAPI.modified();
  };
  publicAPI.getVolumes = () => {
    model.volumes = [];
    model.props.forEach((prop) => {
      model.volumes = model.volumes.concat(prop.getVolumes());
    });
    return model.volumes;
  };
  publicAPI.addVolume = publicAPI.addViewProp;
  publicAPI.removeVolume = (volume) => {
    model.volumes = model.volumes.filter((v2) => v2 !== volume);
    publicAPI.removeViewProp(volume);
    publicAPI.modified();
  };
  publicAPI.removeAllVolumes = () => {
    const volumes = publicAPI.getVolumes();
    volumes.forEach((volume) => {
      publicAPI.removeViewProp(volume);
    });
    model.volumes = [];
    publicAPI.modified();
  };
  publicAPI.hasLight = (light) => model.lights.includes(light);
  publicAPI.addLight = (light) => {
    if (light && !publicAPI.hasLight(light)) {
      model.lights.push(light);
      publicAPI.modified();
    }
  };
  publicAPI.removeLight = (light) => {
    model.lights = model.lights.filter((l5) => l5 !== light);
    publicAPI.modified();
  };
  publicAPI.removeAllLights = () => {
    model.lights = [];
    publicAPI.modified();
  };
  publicAPI.setLightCollection = (lights) => {
    model.lights = lights;
    publicAPI.modified();
  };
  publicAPI.makeLight = vtkLight$1.newInstance;
  publicAPI.createLight = () => {
    if (!model.automaticLightCreation) {
      return;
    }
    if (model._createdLight) {
      publicAPI.removeLight(model._createdLight);
      model._createdLight.delete();
      model._createdLight = null;
    }
    model._createdLight = publicAPI.makeLight();
    publicAPI.addLight(model._createdLight);
    model._createdLight.setLightTypeToHeadLight();
    model._createdLight.setPosition(publicAPI.getActiveCamera().getPosition());
    model._createdLight.setFocalPoint(publicAPI.getActiveCamera().getFocalPoint());
  };
  publicAPI.normalizedDisplayToWorld = (x2, y3, z3, aspect) => {
    let vpd = publicAPI.normalizedDisplayToProjection(x2, y3, z3);
    vpd = publicAPI.projectionToView(vpd[0], vpd[1], vpd[2], aspect);
    return publicAPI.viewToWorld(vpd[0], vpd[1], vpd[2]);
  };
  publicAPI.worldToNormalizedDisplay = (x2, y3, z3, aspect) => {
    let vpd = publicAPI.worldToView(x2, y3, z3);
    vpd = publicAPI.viewToProjection(vpd[0], vpd[1], vpd[2], aspect);
    return publicAPI.projectionToNormalizedDisplay(vpd[0], vpd[1], vpd[2]);
  };
  publicAPI.viewToWorld = (x2, y3, z3) => {
    if (model.activeCamera === null) {
      vtkErrorMacro26("ViewToWorld: no active camera, cannot compute view to world, returning 0,0,0");
      return [0, 0, 0];
    }
    const matrix = model.activeCamera.getViewMatrix();
    mat4_exports.invert(matrix, matrix);
    mat4_exports.transpose(matrix, matrix);
    const result = new Float64Array([x2, y3, z3]);
    vec3_exports.transformMat4(result, result, matrix);
    return result;
  };
  publicAPI.projectionToView = (x2, y3, z3, aspect) => {
    if (model.activeCamera === null) {
      vtkErrorMacro26("ProjectionToView: no active camera, cannot compute projection to view, returning 0,0,0");
      return [0, 0, 0];
    }
    const matrix = model.activeCamera.getProjectionMatrix(aspect, -1, 1);
    mat4_exports.invert(matrix, matrix);
    mat4_exports.transpose(matrix, matrix);
    const result = new Float64Array([x2, y3, z3]);
    vec3_exports.transformMat4(result, result, matrix);
    return result;
  };
  publicAPI.worldToView = (x2, y3, z3) => {
    if (model.activeCamera === null) {
      vtkErrorMacro26("WorldToView: no active camera, cannot compute view to world, returning 0,0,0");
      return [0, 0, 0];
    }
    const matrix = model.activeCamera.getViewMatrix();
    mat4_exports.transpose(matrix, matrix);
    const result = new Float64Array([x2, y3, z3]);
    vec3_exports.transformMat4(result, result, matrix);
    return result;
  };
  publicAPI.viewToProjection = (x2, y3, z3, aspect) => {
    if (model.activeCamera === null) {
      vtkErrorMacro26("ViewToProjection: no active camera, cannot compute view to projection, returning 0,0,0");
      return [0, 0, 0];
    }
    const matrix = model.activeCamera.getProjectionMatrix(aspect, -1, 1);
    mat4_exports.transpose(matrix, matrix);
    const result = new Float64Array([x2, y3, z3]);
    vec3_exports.transformMat4(result, result, matrix);
    return result;
  };
  publicAPI.computeVisiblePropBounds = () => {
    model.allBounds[0] = vtkBoundingBox.INIT_BOUNDS[0];
    model.allBounds[1] = vtkBoundingBox.INIT_BOUNDS[1];
    model.allBounds[2] = vtkBoundingBox.INIT_BOUNDS[2];
    model.allBounds[3] = vtkBoundingBox.INIT_BOUNDS[3];
    model.allBounds[4] = vtkBoundingBox.INIT_BOUNDS[4];
    model.allBounds[5] = vtkBoundingBox.INIT_BOUNDS[5];
    let nothingVisible = true;
    publicAPI.invokeEvent(COMPUTE_VISIBLE_PROP_BOUNDS_EVENT);
    for (let index2 = 0; index2 < model.props.length; ++index2) {
      const prop = model.props[index2];
      if (prop.getVisibility() && prop.getUseBounds()) {
        const bounds = prop.getBounds();
        if (bounds && areBoundsInitialized(bounds)) {
          nothingVisible = false;
          if (bounds[0] < model.allBounds[0]) {
            model.allBounds[0] = bounds[0];
          }
          if (bounds[1] > model.allBounds[1]) {
            model.allBounds[1] = bounds[1];
          }
          if (bounds[2] < model.allBounds[2]) {
            model.allBounds[2] = bounds[2];
          }
          if (bounds[3] > model.allBounds[3]) {
            model.allBounds[3] = bounds[3];
          }
          if (bounds[4] < model.allBounds[4]) {
            model.allBounds[4] = bounds[4];
          }
          if (bounds[5] > model.allBounds[5]) {
            model.allBounds[5] = bounds[5];
          }
        }
      }
    }
    if (nothingVisible) {
      uninitializeBounds(model.allBounds);
      vtkDebugMacro8("Can't compute bounds, no 3D props are visible");
    }
    return model.allBounds;
  };
  publicAPI.resetCamera = function() {
    let bounds = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    const boundsToUse = bounds || publicAPI.computeVisiblePropBounds();
    const center = [0, 0, 0];
    if (!areBoundsInitialized(boundsToUse)) {
      vtkDebugMacro8("Cannot reset camera!");
      return false;
    }
    let vn = null;
    if (publicAPI.getActiveCamera()) {
      vn = model.activeCamera.getViewPlaneNormal();
    } else {
      vtkErrorMacro26("Trying to reset non-existent camera");
      return false;
    }
    model.activeCamera.setViewAngle(30);
    center[0] = (boundsToUse[0] + boundsToUse[1]) / 2;
    center[1] = (boundsToUse[2] + boundsToUse[3]) / 2;
    center[2] = (boundsToUse[4] + boundsToUse[5]) / 2;
    let w1 = boundsToUse[1] - boundsToUse[0];
    let w2 = boundsToUse[3] - boundsToUse[2];
    let w3 = boundsToUse[5] - boundsToUse[4];
    w1 *= w1;
    w2 *= w2;
    w3 *= w3;
    let radius = w1 + w2 + w3;
    radius = radius === 0 ? 1 : radius;
    radius = Math.sqrt(radius) * 0.5;
    const angle2 = radiansFromDegrees(model.activeCamera.getViewAngle());
    const parallelScale = radius;
    const distance3 = radius / Math.sin(angle2 * 0.5);
    const vup = model.activeCamera.getViewUp();
    if (Math.abs(dot4(vup, vn)) > 0.999) {
      vtkWarningMacro8("Resetting view-up since view plane normal is parallel");
      model.activeCamera.setViewUp(-vup[2], vup[0], vup[1]);
    }
    model.activeCamera.setFocalPoint(center[0], center[1], center[2]);
    model.activeCamera.setPosition(center[0] + distance3 * vn[0], center[1] + distance3 * vn[1], center[2] + distance3 * vn[2]);
    publicAPI.resetCameraClippingRange(boundsToUse);
    model.activeCamera.setParallelScale(parallelScale);
    model.activeCamera.setPhysicalScale(radius);
    model.activeCamera.setPhysicalTranslation(-center[0], -center[1], -center[2]);
    publicAPI.invokeEvent(RESET_CAMERA_EVENT);
    return true;
  };
  publicAPI.resetCameraClippingRange = function() {
    let bounds = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    const boundsToUse = bounds || publicAPI.computeVisiblePropBounds();
    if (!areBoundsInitialized(boundsToUse)) {
      vtkDebugMacro8("Cannot reset camera clipping range!");
      return false;
    }
    publicAPI.getActiveCameraAndResetIfCreated();
    if (!model.activeCamera) {
      vtkErrorMacro26("Trying to reset clipping range of non-existent camera");
      return false;
    }
    const range = model.activeCamera.computeClippingRange(boundsToUse);
    let minGap = 0;
    if (model.activeCamera.getParallelProjection()) {
      minGap = 0.2 * model.activeCamera.getParallelScale();
    } else {
      const angle2 = radiansFromDegrees(model.activeCamera.getViewAngle());
      minGap = 0.2 * Math.tan(angle2 / 2) * range[1];
    }
    if (range[1] - range[0] < minGap) {
      minGap = minGap - range[1] + range[0];
      range[1] += minGap / 2;
      range[0] -= minGap / 2;
    }
    if (range[0] < 0) {
      range[0] = 0;
    }
    range[0] = 0.99 * range[0] - (range[1] - range[0]) * model.clippingRangeExpansion;
    range[1] = 1.01 * range[1] + (range[1] - range[0]) * model.clippingRangeExpansion;
    range[0] = range[0] >= range[1] ? 0.01 * range[1] : range[0];
    if (!model.nearClippingPlaneTolerance) {
      model.nearClippingPlaneTolerance = 0.01;
    }
    if (range[0] < model.nearClippingPlaneTolerance * range[1]) {
      range[0] = model.nearClippingPlaneTolerance * range[1];
    }
    model.activeCamera.setClippingRange(range[0], range[1]);
    publicAPI.invokeEvent(RESET_CAMERA_CLIPPING_RANGE_EVENT);
    return false;
  };
  publicAPI.setRenderWindow = (renderWindow) => {
    if (renderWindow !== model._renderWindow) {
      model._vtkWindow = renderWindow;
      model._renderWindow = renderWindow;
    }
  };
  publicAPI.visibleActorCount = () => model.props.filter((prop) => prop.getVisibility()).length;
  publicAPI.visibleVolumeCount = publicAPI.visibleActorCount;
  publicAPI.getMTime = () => {
    let m1 = model.mtime;
    const m22 = model.activeCamera ? model.activeCamera.getMTime() : 0;
    if (m22 > m1) {
      m1 = m22;
    }
    const m3 = model._createdLight ? model._createdLight.getMTime() : 0;
    if (m3 > m1) {
      m1 = m3;
    }
    return m1;
  };
  publicAPI.getTransparent = () => !!model.preserveColorBuffer;
  publicAPI.isActiveCameraCreated = () => !!model.activeCamera;
}
var DEFAULT_VALUES72 = {
  pickedProp: null,
  activeCamera: null,
  allBounds: [],
  ambient: [1, 1, 1],
  allocatedRenderTime: 100,
  timeFactor: 1,
  automaticLightCreation: true,
  twoSidedLighting: true,
  lastRenderTimeInSeconds: -1,
  renderWindow: null,
  lights: [],
  actors: [],
  volumes: [],
  lightFollowCamera: true,
  numberOfPropsRendered: 0,
  propArray: null,
  pathArray: null,
  layer: 0,
  preserveColorBuffer: false,
  preserveDepthBuffer: false,
  computeVisiblePropBounds: createUninitializedBounds(),
  interactive: true,
  nearClippingPlaneTolerance: 0,
  clippingRangeExpansion: 0.05,
  erase: true,
  draw: true,
  useShadows: false,
  useDepthPeeling: false,
  occlusionRatio: 0,
  maximumNumberOfPeels: 4,
  selector: null,
  delegate: null,
  texturedBackground: false,
  backgroundTexture: null,
  environmentTexture: null,
  environmentTextureDiffuseStrength: 1,
  environmentTextureSpecularStrength: 1,
  useEnvironmentTextureAsBackground: false,
  pass: 0
};
function extend74(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES72, initialValues);
  vtkViewport$1.extend(publicAPI, model, initialValues);
  if (!model.background) model.background = [0, 0, 0, 1];
  while (model.background.length < 3) model.background.push(0);
  if (model.background.length === 3) model.background.push(1);
  get(publicAPI, model, ["_renderWindow", "allocatedRenderTime", "timeFactor", "lastRenderTimeInSeconds", "numberOfPropsRendered", "lastRenderingUsedDepthPeeling", "selector"]);
  setGet(publicAPI, model, ["twoSidedLighting", "lightFollowCamera", "automaticLightCreation", "erase", "draw", "nearClippingPlaneTolerance", "clippingRangeExpansion", "backingStore", "interactive", "layer", "preserveColorBuffer", "preserveDepthBuffer", "useDepthPeeling", "occlusionRatio", "maximumNumberOfPeels", "delegate", "backgroundTexture", "texturedBackground", "environmentTexture", "environmentTextureDiffuseStrength", "environmentTextureSpecularStrength", "useEnvironmentTextureAsBackground", "useShadows", "pass"]);
  getArray(publicAPI, model, ["actors", "volumes", "lights"]);
  setGetArray(publicAPI, model, ["background"], 4, 1);
  moveToProtected(publicAPI, model, ["renderWindow"]);
  vtkRenderer(publicAPI, model);
}
var newInstance73 = newInstance(extend74, "vtkRenderer");
var vtkRenderer$1 = {
  newInstance: newInstance73,
  extend: extend74
};

// node_modules/@kitware/vtk.js/Rendering/Core/RenderWindow.js
var DEFAULT_VIEW_API = "WebGL";
var VIEW_CONSTRUCTORS = /* @__PURE__ */ Object.create(null);
function registerViewConstructor(name, constructor) {
  VIEW_CONSTRUCTORS[name] = constructor;
}
function listViewAPIs() {
  return Object.keys(VIEW_CONSTRUCTORS);
}
function newAPISpecificView(name) {
  let initialValues = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return VIEW_CONSTRUCTORS[name] && VIEW_CONSTRUCTORS[name](initialValues);
}
function vtkRenderWindow(publicAPI, model) {
  model.classHierarchy.push("vtkRenderWindow");
  publicAPI.addRenderer = (renderer) => {
    if (publicAPI.hasRenderer(renderer)) {
      return;
    }
    renderer.setRenderWindow(publicAPI);
    model.renderers.push(renderer);
    publicAPI.modified();
  };
  publicAPI.removeRenderer = (renderer) => {
    model.renderers = model.renderers.filter((r9) => r9 !== renderer);
    publicAPI.modified();
  };
  publicAPI.hasRenderer = (ren) => model.renderers.indexOf(ren) !== -1;
  publicAPI.newAPISpecificView = function(name) {
    let initialValues = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return newAPISpecificView(name || model.defaultViewAPI, initialValues);
  };
  publicAPI.addView = (view) => {
    if (publicAPI.hasView(view)) {
      return;
    }
    view.setRenderable(publicAPI);
    model._views.push(view);
    publicAPI.modified();
  };
  publicAPI.removeView = (view) => {
    model._views = model._views.filter((r9) => r9 !== view);
    publicAPI.modified();
  };
  publicAPI.hasView = (view) => model._views.indexOf(view) !== -1;
  publicAPI.preRender = () => {
    model.renderers.forEach((ren) => {
      if (!ren.isActiveCameraCreated()) {
        ren.resetCamera();
      }
    });
  };
  publicAPI.render = () => {
    publicAPI.preRender();
    if (model.interactor) {
      model.interactor.render();
    } else {
      model._views.forEach((view) => view.traverseAllPasses());
    }
  };
  publicAPI.getStatistics = () => {
    const results = {
      propCount: 0,
      invisiblePropCount: 0,
      gpuMemoryMB: 0
    };
    model._views.forEach((v2) => {
      if (v2.getGraphicsMemoryInfo) results.gpuMemoryMB += v2.getGraphicsMemoryInfo() / 1e6;
    });
    model.renderers.forEach((ren) => {
      const props = ren.getViewProps();
      const gren = model._views[0].getViewNodeFor(ren);
      props.forEach((prop) => {
        if (prop.getVisibility()) {
          results.propCount += 1;
          const mpr = prop.getMapper && prop.getMapper();
          if (mpr && mpr.getPrimitiveCount) {
            const gmpr = gren.getViewNodeFor(mpr);
            if (gmpr) {
              if (gmpr.getAllocatedGPUMemoryInBytes) {
                results.gpuMemoryMB += gmpr.getAllocatedGPUMemoryInBytes() / 1e6;
              }
              const pcount = mpr.getPrimitiveCount();
              Object.keys(pcount).forEach((keyName) => {
                if (!results[keyName]) {
                  results[keyName] = 0;
                }
                results[keyName] += pcount[keyName];
              });
            }
          }
        } else {
          results.invisiblePropCount += 1;
        }
      });
    });
    results.str = Object.keys(results).map((keyName) => `${keyName}: ${results[keyName]}`).join("\n");
    return results;
  };
  publicAPI.captureImages = function() {
    let format = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "image/png";
    let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    macro.setImmediate(publicAPI.render);
    return model._views.map((view) => view.captureNextImage ? view.captureNextImage(format, opts) : void 0).filter((i6) => !!i6);
  };
  publicAPI.addRenderWindow = (child) => {
    if (model.childRenderWindows.includes(child)) {
      return false;
    }
    model.childRenderWindows.push(child);
    publicAPI.modified();
    return true;
  };
}
var DEFAULT_VALUES73 = {
  defaultViewAPI: DEFAULT_VIEW_API,
  renderers: [],
  views: [],
  interactor: null,
  neverRendered: true,
  numberOfLayers: 1,
  childRenderWindows: []
};
function extend75(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES73, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["interactor", "numberOfLayers", "_views", "defaultViewAPI"]);
  macro.get(publicAPI, model, ["neverRendered"]);
  macro.getArray(publicAPI, model, ["renderers", "childRenderWindows"]);
  macro.moveToProtected(publicAPI, model, ["views"]);
  macro.event(publicAPI, model, "completion");
  vtkRenderWindow(publicAPI, model);
}
var newInstance74 = macro.newInstance(extend75, "vtkRenderWindow");
var vtkRenderWindow$1 = {
  newInstance: newInstance74,
  extend: extend75,
  registerViewConstructor,
  listViewAPIs,
  newAPISpecificView
};

// node_modules/@kitware/vtk.js/Rendering/Core/RenderWindowInteractor/Constants.js
var Device = {
  Unknown: 0,
  LeftController: 1,
  RightController: 2
};
var Input = {
  Unknown: 0,
  Trigger: 1,
  TrackPad: 2,
  Grip: 3,
  Thumbstick: 4,
  A: 5,
  B: 6,
  ApplicationMenu: 7
  // Not exposed in WebXR API
};
var Axis = {
  Unknown: 0,
  TouchpadX: 1,
  TouchpadY: 2,
  ThumbstickX: 3,
  ThumbstickY: 4
};
var Constants12 = {
  Device,
  Input,
  Axis
};

// node_modules/@kitware/vtk.js/Rendering/Core/RenderWindowInteractor.js
var {
  Device: Device2,
  Input: Input2
} = Constants12;
var {
  vtkWarningMacro: vtkWarningMacro9,
  vtkErrorMacro: vtkErrorMacro27,
  normalizeWheel: normalizeWheel2,
  vtkOnceErrorMacro: vtkOnceErrorMacro2
} = macro;
var EMPTY_MOUSE_EVENT = {
  ctrlKey: false,
  altKey: false,
  shiftKey: false
};
var deviceInputMap = {
  "xr-standard": [Input2.Trigger, Input2.Grip, Input2.TrackPad, Input2.Thumbstick, Input2.A, Input2.B]
};
var handledEvents = ["StartAnimation", "Animation", "EndAnimation", "PointerEnter", "PointerLeave", "MouseEnter", "MouseLeave", "StartMouseMove", "MouseMove", "EndMouseMove", "LeftButtonPress", "LeftButtonRelease", "MiddleButtonPress", "MiddleButtonRelease", "RightButtonPress", "RightButtonRelease", "KeyPress", "KeyDown", "KeyUp", "StartMouseWheel", "MouseWheel", "EndMouseWheel", "StartPinch", "Pinch", "EndPinch", "StartPan", "Pan", "EndPan", "StartRotate", "Rotate", "EndRotate", "Button3D", "Move3D", "StartPointerLock", "EndPointerLock", "StartInteraction", "Interaction", "EndInteraction", "AnimationFrameRateUpdate"];
function preventDefault(event2) {
  if (event2.cancelable) {
    event2.preventDefault();
  }
}
function pointerCacheToPositions(cache2) {
  const positions = /* @__PURE__ */ Object.create(null);
  cache2.forEach((_ref) => {
    let {
      pointerId,
      position
    } = _ref;
    positions[pointerId] = position;
  });
  return positions;
}
function vtkRenderWindowInteractor(publicAPI, model) {
  model.classHierarchy.push("vtkRenderWindowInteractor");
  const superClass = __spreadValues({}, publicAPI);
  const animationRequesters = /* @__PURE__ */ new Set();
  const pointerCache = /* @__PURE__ */ new Map();
  let wheelCoefficient = 1;
  publicAPI.start = () => {
    if (!model.initialized) {
      publicAPI.initialize();
      if (!model.initialized) {
        return;
      }
    }
    publicAPI.startEventLoop();
  };
  publicAPI.setRenderWindow = (aren) => {
    vtkErrorMacro27("you want to call setView(view) instead of setRenderWindow on a vtk.js interactor");
  };
  publicAPI.setInteractorStyle = (style) => {
    if (model.interactorStyle !== style) {
      if (model.interactorStyle != null) {
        model.interactorStyle.setInteractor(null);
      }
      model.interactorStyle = style;
      if (model.interactorStyle != null) {
        if (model.interactorStyle.getInteractor() !== publicAPI) {
          model.interactorStyle.setInteractor(publicAPI);
        }
      }
    }
  };
  publicAPI.initialize = () => {
    model.initialized = true;
    publicAPI.enable();
    publicAPI.render();
  };
  publicAPI.enable = () => publicAPI.setEnabled(true);
  publicAPI.disable = () => publicAPI.setEnabled(false);
  publicAPI.startEventLoop = () => vtkWarningMacro9("empty event loop");
  function updateCurrentRenderer(x2, y3) {
    if (!model._forcedRenderer) {
      model.currentRenderer = publicAPI.findPokedRenderer(x2, y3);
    }
  }
  publicAPI.getCurrentRenderer = () => {
    if (model.currentRenderer) {
      return model.currentRenderer;
    }
    updateCurrentRenderer(0, 0);
    return model.currentRenderer;
  };
  function _getScreenEventPositionFor(source) {
    const canvas = model._view.getCanvas();
    const bounds = canvas.getBoundingClientRect();
    const scaleX = canvas.width / bounds.width;
    const scaleY = canvas.height / bounds.height;
    const position = {
      x: scaleX * (source.clientX - bounds.left),
      y: scaleY * (bounds.height - source.clientY + bounds.top),
      z: 0
    };
    if (pointerCache.size <= 1 || !model.currentRenderer) {
      updateCurrentRenderer(position.x, position.y);
    }
    return position;
  }
  const getScreenEventPositionFor = model._getScreenEventPositionFor || _getScreenEventPositionFor;
  function getModifierKeysFor(event2) {
    return {
      controlKey: event2.ctrlKey,
      altKey: event2.altKey,
      shiftKey: event2.shiftKey
    };
  }
  function getKeysFor(event2) {
    const modifierKeys = getModifierKeysFor(event2);
    const keys = __spreadValues({
      key: event2.key,
      keyCode: event2.charCode
    }, modifierKeys);
    return keys;
  }
  function getDeviceTypeFor(event2) {
    return event2.pointerType || "";
  }
  const _bindEvents = () => {
    if (model.container === null) {
      return;
    }
    const {
      container
    } = model;
    container.addEventListener("contextmenu", preventDefault);
    container.addEventListener("wheel", publicAPI.handleWheel);
    container.addEventListener("DOMMouseScroll", publicAPI.handleWheel);
    container.addEventListener("pointerenter", publicAPI.handlePointerEnter);
    container.addEventListener("pointerleave", publicAPI.handlePointerLeave);
    container.addEventListener("pointermove", publicAPI.handlePointerMove, {
      passive: false
    });
    container.addEventListener("pointerdown", publicAPI.handlePointerDown, {
      passive: false
    });
    container.addEventListener("pointerup", publicAPI.handlePointerUp);
    container.addEventListener("pointercancel", publicAPI.handlePointerCancel);
    document.addEventListener("keypress", publicAPI.handleKeyPress);
    document.addEventListener("keydown", publicAPI.handleKeyDown);
    document.addEventListener("keyup", publicAPI.handleKeyUp);
    document.addEventListener("pointerlockchange", publicAPI.handlePointerLockChange);
    container.style.touchAction = "none";
    container.style.userSelect = "none";
    container.style.webkitTapHighlightColor = "rgba(0,0,0,0)";
  };
  publicAPI.bindEvents = (container) => {
    if (container === null) {
      return;
    }
    const res = superClass.setContainer(container);
    if (res) {
      _bindEvents();
    }
  };
  const _unbindEvents = () => {
    clearTimeout(model.moveTimeoutID);
    clearTimeout(model.wheelTimeoutID);
    model.moveTimeoutID = 0;
    model.wheelTimeoutID = 0;
    wheelCoefficient = 1;
    const {
      container
    } = model;
    if (container) {
      container.removeEventListener("contextmenu", preventDefault);
      container.removeEventListener("wheel", publicAPI.handleWheel);
      container.removeEventListener("DOMMouseScroll", publicAPI.handleWheel);
      container.removeEventListener("pointerenter", publicAPI.handlePointerEnter);
      container.removeEventListener("pointerleave", publicAPI.handlePointerLeave);
      container.removeEventListener("pointermove", publicAPI.handlePointerMove, {
        passive: false
      });
      container.removeEventListener("pointerdown", publicAPI.handlePointerDown, {
        passive: false
      });
      container.removeEventListener("pointerup", publicAPI.handlePointerUp);
      container.removeEventListener("pointercancel", publicAPI.handlePointerCancel);
    }
    document.removeEventListener("keypress", publicAPI.handleKeyPress);
    document.removeEventListener("keydown", publicAPI.handleKeyDown);
    document.removeEventListener("keyup", publicAPI.handleKeyUp);
    document.removeEventListener("pointerlockchange", publicAPI.handlePointerLockChange);
    pointerCache.clear();
  };
  publicAPI.unbindEvents = () => {
    _unbindEvents();
    superClass.setContainer(null);
  };
  publicAPI.handleKeyPress = (event2) => {
    const data = getKeysFor(event2);
    publicAPI.keyPressEvent(data);
  };
  publicAPI.handleKeyDown = (event2) => {
    const data = getKeysFor(event2);
    publicAPI.keyDownEvent(data);
  };
  publicAPI.handleKeyUp = (event2) => {
    const data = getKeysFor(event2);
    publicAPI.keyUpEvent(data);
  };
  publicAPI.handlePointerEnter = (event2) => {
    const callData = __spreadProps(__spreadValues({}, getModifierKeysFor(event2)), {
      position: getScreenEventPositionFor(event2),
      deviceType: getDeviceTypeFor(event2)
    });
    publicAPI.pointerEnterEvent(callData);
    if (callData.deviceType === "mouse") {
      publicAPI.mouseEnterEvent(callData);
    }
  };
  publicAPI.handlePointerLeave = (event2) => {
    const callData = __spreadProps(__spreadValues({}, getModifierKeysFor(event2)), {
      position: getScreenEventPositionFor(event2),
      deviceType: getDeviceTypeFor(event2)
    });
    publicAPI.pointerLeaveEvent(callData);
    if (callData.deviceType === "mouse") {
      publicAPI.mouseLeaveEvent(callData);
    }
  };
  publicAPI.handlePointerDown = (event2) => {
    if (event2.button > 2 || publicAPI.isPointerLocked()) {
      return;
    }
    if (model.preventDefaultOnPointerDown) {
      preventDefault(event2);
    }
    if (event2.target.hasPointerCapture(event2.pointerId)) {
      event2.target.releasePointerCapture(event2.pointerId);
    }
    model.container.setPointerCapture(event2.pointerId);
    if (pointerCache.has(event2.pointerId)) {
      vtkWarningMacro9("[RenderWindowInteractor] duplicate pointerId detected");
    }
    pointerCache.set(event2.pointerId, {
      pointerId: event2.pointerId,
      position: getScreenEventPositionFor(event2)
    });
    switch (event2.pointerType) {
      case "pen":
      case "touch":
        publicAPI.handleTouchStart(event2);
        break;
      case "mouse":
      default:
        publicAPI.handleMouseDown(event2);
        break;
    }
  };
  publicAPI.handlePointerUp = (event2) => {
    if (pointerCache.has(event2.pointerId)) {
      if (model.preventDefaultOnPointerUp) {
        preventDefault(event2);
      }
      pointerCache.delete(event2.pointerId);
      model.container.releasePointerCapture(event2.pointerId);
      switch (event2.pointerType) {
        case "pen":
        case "touch":
          publicAPI.handleTouchEnd(event2);
          break;
        case "mouse":
        default:
          publicAPI.handleMouseUp(event2);
          break;
      }
    }
  };
  publicAPI.handlePointerCancel = (event2) => {
    if (pointerCache.has(event2.pointerId)) {
      pointerCache.delete(event2.pointerId);
      switch (event2.pointerType) {
        case "pen":
        case "touch":
          publicAPI.handleTouchEnd(event2);
          break;
        case "mouse":
        default:
          publicAPI.handleMouseUp(event2);
          break;
      }
    }
  };
  publicAPI.handlePointerMove = (event2) => {
    if (pointerCache.has(event2.pointerId)) {
      const pointer = pointerCache.get(event2.pointerId);
      pointer.position = getScreenEventPositionFor(event2);
    }
    switch (event2.pointerType) {
      case "pen":
      case "touch":
        publicAPI.handleTouchMove(event2);
        break;
      case "mouse":
      default:
        publicAPI.handleMouseMove(event2);
        break;
    }
  };
  publicAPI.handleMouseDown = (event2) => {
    const callData = __spreadProps(__spreadValues({}, getModifierKeysFor(event2)), {
      position: getScreenEventPositionFor(event2),
      deviceType: getDeviceTypeFor(event2)
    });
    switch (event2.button) {
      case 0:
        publicAPI.leftButtonPressEvent(callData);
        break;
      case 1:
        publicAPI.middleButtonPressEvent(callData);
        break;
      case 2:
        publicAPI.rightButtonPressEvent(callData);
        break;
      default:
        vtkErrorMacro27(`Unknown mouse button pressed: ${event2.button}`);
        break;
    }
  };
  publicAPI.requestPointerLock = () => {
    if (model.container) {
      model.container.requestPointerLock();
    }
  };
  publicAPI.exitPointerLock = () => {
    var _a9;
    return (_a9 = document.exitPointerLock) == null ? void 0 : _a9.call(document);
  };
  publicAPI.isPointerLocked = () => !!model.container && document.pointerLockElement === model.container;
  publicAPI.handlePointerLockChange = () => {
    if (publicAPI.isPointerLocked()) {
      publicAPI.startPointerLockEvent();
    } else {
      publicAPI.endPointerLockEvent();
    }
  };
  function forceRender() {
    if (model._view && model.enabled && model.enableRender) {
      model.inRender = true;
      model._view.traverseAllPasses();
      model.inRender = false;
    }
    publicAPI.invokeRenderEvent();
  }
  publicAPI.requestAnimation = (requestor) => {
    if (requestor === void 0) {
      vtkErrorMacro27(`undefined requester, can not start animating`);
      return;
    }
    if (animationRequesters.has(requestor)) {
      vtkWarningMacro9(`requester is already registered for animating`);
      return;
    }
    animationRequesters.add(requestor);
    if (!model.animationRequest && animationRequesters.size === 1 && !model.xrAnimation) {
      model._animationStartTime = Date.now();
      model._animationFrameCount = 0;
      model.animationRequest = requestAnimationFrame(publicAPI.handleAnimation);
      publicAPI.startAnimationEvent();
    }
  };
  publicAPI.extendAnimation = (duration) => {
    const newEnd = Date.now() + duration;
    model._animationExtendedEnd = Math.max(model._animationExtendedEnd, newEnd);
    if (!model.animationRequest && animationRequesters.size === 0 && !model.xrAnimation) {
      model._animationStartTime = Date.now();
      model._animationFrameCount = 0;
      model.animationRequest = requestAnimationFrame(publicAPI.handleAnimation);
      publicAPI.startAnimationEvent();
    }
  };
  publicAPI.isAnimating = () => model.xrAnimation || model.animationRequest !== null;
  publicAPI.cancelAnimation = function(requestor) {
    let skipWarning = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    if (!animationRequesters.has(requestor)) {
      if (!skipWarning) {
        const requestStr = requestor && requestor.getClassName ? requestor.getClassName() : requestor;
        vtkWarningMacro9(`${requestStr} did not request an animation`);
      }
      return;
    }
    animationRequesters.delete(requestor);
    if (model.animationRequest && animationRequesters.size === 0 && Date.now() > model._animationExtendedEnd) {
      cancelAnimationFrame(model.animationRequest);
      model.animationRequest = null;
      publicAPI.endAnimationEvent();
      publicAPI.render();
    }
  };
  publicAPI.switchToXRAnimation = () => {
    if (model.animationRequest) {
      cancelAnimationFrame(model.animationRequest);
      model.animationRequest = null;
    }
    model.xrAnimation = true;
  };
  publicAPI.returnFromXRAnimation = () => {
    model.xrAnimation = false;
    if (animationRequesters.size !== 0) {
      model.recentAnimationFrameRate = 10;
      model.animationRequest = requestAnimationFrame(publicAPI.handleAnimation);
    }
  };
  publicAPI.updateXRGamepads = (xrSession, xrFrame, xrRefSpace) => {
    xrSession.inputSources.forEach((inputSource) => {
      const gripPose = inputSource.gripSpace == null ? null : xrFrame.getPose(inputSource.gripSpace, xrRefSpace);
      const targetRayPose = inputSource.gripSpace == null ? null : xrFrame.getPose(inputSource.targetRaySpace, xrRefSpace);
      const gamepad = inputSource.gamepad;
      const hand = inputSource.handedness;
      if (!gamepad) {
        return;
      }
      if (!(gamepad.index in model.lastGamepadValues)) {
        model.lastGamepadValues[gamepad.index] = {
          left: {
            buttons: {}
          },
          right: {
            buttons: {}
          },
          none: {
            buttons: {}
          }
        };
      }
      for (let buttonIdx = 0; buttonIdx < gamepad.buttons.length; ++buttonIdx) {
        if (!(buttonIdx in model.lastGamepadValues[gamepad.index][hand].buttons)) {
          model.lastGamepadValues[gamepad.index][hand].buttons[buttonIdx] = false;
        }
        if (model.lastGamepadValues[gamepad.index][hand].buttons[buttonIdx] !== gamepad.buttons[buttonIdx].pressed && gripPose != null) {
          publicAPI.button3DEvent({
            gamepad,
            position: gripPose.transform.position,
            orientation: gripPose.transform.orientation,
            targetPosition: targetRayPose.transform.position,
            targetOrientation: targetRayPose.transform.orientation,
            pressed: gamepad.buttons[buttonIdx].pressed,
            device: inputSource.handedness === "left" ? Device2.LeftController : Device2.RightController,
            input: deviceInputMap[gamepad.mapping] && deviceInputMap[gamepad.mapping][buttonIdx] ? deviceInputMap[gamepad.mapping][buttonIdx] : Input2.Trigger
          });
          model.lastGamepadValues[gamepad.index][hand].buttons[buttonIdx] = gamepad.buttons[buttonIdx].pressed;
        }
        if (model.lastGamepadValues[gamepad.index][hand].buttons[buttonIdx] && gripPose != null) {
          publicAPI.move3DEvent({
            gamepad,
            position: gripPose.transform.position,
            orientation: gripPose.transform.orientation,
            targetPosition: targetRayPose.transform.position,
            targetOrientation: targetRayPose.transform.orientation,
            device: inputSource.handedness === "left" ? Device2.LeftController : Device2.RightController
          });
        }
      }
    });
  };
  publicAPI.handleMouseMove = (event2) => {
    const callData = __spreadProps(__spreadValues({}, getModifierKeysFor(event2)), {
      position: getScreenEventPositionFor(event2),
      deviceType: getDeviceTypeFor(event2)
    });
    if (model.moveTimeoutID === 0) {
      publicAPI.startMouseMoveEvent(callData);
    } else {
      publicAPI.mouseMoveEvent(callData);
      clearTimeout(model.moveTimeoutID);
    }
    model.moveTimeoutID = setTimeout(() => {
      publicAPI.endMouseMoveEvent();
      model.moveTimeoutID = 0;
    }, 200);
  };
  publicAPI.handleAnimation = () => {
    const currTime = Date.now();
    model._animationFrameCount++;
    if (currTime - model._animationStartTime > 1e3 && model._animationFrameCount > 1) {
      model.recentAnimationFrameRate = 1e3 * (model._animationFrameCount - 1) / (currTime - model._animationStartTime);
      model.lastFrameTime = 1 / model.recentAnimationFrameRate;
      publicAPI.animationFrameRateUpdateEvent();
      model._animationStartTime = currTime;
      model._animationFrameCount = 1;
    }
    publicAPI.animationEvent();
    forceRender();
    if (animationRequesters.size > 0 || Date.now() < model._animationExtendedEnd) {
      model.animationRequest = requestAnimationFrame(publicAPI.handleAnimation);
    } else {
      cancelAnimationFrame(model.animationRequest);
      model.animationRequest = null;
      publicAPI.endAnimationEvent();
      publicAPI.render();
    }
  };
  publicAPI.handleWheel = (event2) => {
    preventDefault(event2);
    const callData = __spreadProps(__spreadValues(__spreadValues({}, normalizeWheel2(event2)), getModifierKeysFor(event2)), {
      position: getScreenEventPositionFor(event2),
      deviceType: getDeviceTypeFor(event2)
    });
    if (model.wheelTimeoutID === 0) {
      if (Math.abs(callData.spinY) >= 0.3) {
        wheelCoefficient = Math.abs(callData.spinY);
      } else {
        wheelCoefficient = 1;
      }
    }
    callData.spinY /= wheelCoefficient;
    if (model.wheelTimeoutID === 0) {
      publicAPI.startMouseWheelEvent(callData);
      publicAPI.mouseWheelEvent(callData);
    } else {
      publicAPI.mouseWheelEvent(callData);
      clearTimeout(model.wheelTimeoutID);
    }
    if (model.mouseScrollDebounceByPass) {
      publicAPI.extendAnimation(600);
      publicAPI.endMouseWheelEvent();
      model.wheelTimeoutID = 0;
    } else {
      model.wheelTimeoutID = setTimeout(() => {
        publicAPI.extendAnimation(600);
        publicAPI.endMouseWheelEvent();
        model.wheelTimeoutID = 0;
      }, 200);
    }
  };
  publicAPI.handleMouseUp = (event2) => {
    const callData = __spreadProps(__spreadValues({}, getModifierKeysFor(event2)), {
      position: getScreenEventPositionFor(event2),
      deviceType: getDeviceTypeFor(event2)
    });
    switch (event2.button) {
      case 0:
        publicAPI.leftButtonReleaseEvent(callData);
        break;
      case 1:
        publicAPI.middleButtonReleaseEvent(callData);
        break;
      case 2:
        publicAPI.rightButtonReleaseEvent(callData);
        break;
      default:
        vtkErrorMacro27(`Unknown mouse button released: ${event2.button}`);
        break;
    }
  };
  publicAPI.handleTouchStart = (event2) => {
    const pointers = [...pointerCache.values()];
    if (model.recognizeGestures && pointers.length > 1) {
      const positions = pointerCacheToPositions(pointerCache);
      if (pointers.length === 2) {
        const callData = __spreadProps(__spreadValues({}, getModifierKeysFor(EMPTY_MOUSE_EVENT)), {
          position: pointers[0].position,
          deviceType: getDeviceTypeFor(event2)
        });
        publicAPI.leftButtonReleaseEvent(callData);
      }
      publicAPI.recognizeGesture("TouchStart", positions);
    } else if (pointers.length === 1) {
      const callData = __spreadProps(__spreadValues({}, getModifierKeysFor(EMPTY_MOUSE_EVENT)), {
        position: getScreenEventPositionFor(event2),
        deviceType: getDeviceTypeFor(event2)
      });
      publicAPI.leftButtonPressEvent(callData);
    }
  };
  publicAPI.handleTouchMove = (event2) => {
    const pointers = [...pointerCache.values()];
    if (model.recognizeGestures && pointers.length > 1) {
      const positions = pointerCacheToPositions(pointerCache);
      publicAPI.recognizeGesture("TouchMove", positions);
    } else if (pointers.length === 1) {
      const callData = __spreadProps(__spreadValues({}, getModifierKeysFor(EMPTY_MOUSE_EVENT)), {
        position: pointers[0].position,
        deviceType: getDeviceTypeFor(event2)
      });
      publicAPI.mouseMoveEvent(callData);
    }
  };
  publicAPI.handleTouchEnd = (event2) => {
    const pointers = [...pointerCache.values()];
    if (model.recognizeGestures) {
      if (pointers.length === 0) {
        const callData = __spreadProps(__spreadValues({}, getModifierKeysFor(EMPTY_MOUSE_EVENT)), {
          position: getScreenEventPositionFor(event2),
          deviceType: getDeviceTypeFor(event2)
        });
        publicAPI.leftButtonReleaseEvent(callData);
      } else if (pointers.length === 1) {
        const positions = pointerCacheToPositions(pointerCache);
        publicAPI.recognizeGesture("TouchEnd", positions);
        const callData = __spreadProps(__spreadValues({}, getModifierKeysFor(EMPTY_MOUSE_EVENT)), {
          position: pointers[0].position,
          deviceType: getDeviceTypeFor(event2)
        });
        publicAPI.leftButtonPressEvent(callData);
      } else {
        const positions = pointerCacheToPositions(pointerCache);
        publicAPI.recognizeGesture("TouchMove", positions);
      }
    } else if (pointers.length === 1) {
      const callData = __spreadProps(__spreadValues({}, getModifierKeysFor(EMPTY_MOUSE_EVENT)), {
        position: pointers[0].position,
        deviceType: getDeviceTypeFor(event2)
      });
      publicAPI.leftButtonReleaseEvent(callData);
    }
  };
  publicAPI.setView = (val) => {
    if (model._view === val) {
      return;
    }
    model._view = val;
    model._view.getRenderable().setInteractor(publicAPI);
    publicAPI.modified();
  };
  publicAPI.getFirstRenderer = () => {
    var _a9, _b2, _c;
    return (_c = (_b2 = (_a9 = model._view) == null ? void 0 : _a9.getRenderable()) == null ? void 0 : _b2.getRenderersByReference()) == null ? void 0 : _c[0];
  };
  publicAPI.findPokedRenderer = function() {
    var _a9, _b2;
    let x2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    let y3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    if (!model._view) {
      return null;
    }
    const rc = (_b2 = (_a9 = model._view) == null ? void 0 : _a9.getRenderable()) == null ? void 0 : _b2.getRenderers();
    if (!rc || rc.length === 0) {
      return null;
    }
    rc.sort((a4, b3) => a4.getLayer() - b3.getLayer());
    let interactiveren = null;
    let viewportren = null;
    let currentRenderer = null;
    let count = rc.length;
    while (count--) {
      const aren = rc[count];
      if (model._view.isInViewport(x2, y3, aren) && aren.getInteractive()) {
        currentRenderer = aren;
        break;
      }
      if (interactiveren === null && aren.getInteractive()) {
        interactiveren = aren;
      }
      if (viewportren === null && model._view.isInViewport(x2, y3, aren)) {
        viewportren = aren;
      }
    }
    if (currentRenderer === null) {
      currentRenderer = interactiveren;
    }
    if (currentRenderer === null) {
      currentRenderer = viewportren;
    }
    if (currentRenderer == null) {
      currentRenderer = rc[0];
    }
    return currentRenderer;
  };
  publicAPI.render = () => {
    if (!publicAPI.isAnimating() && !model.inRender) {
      forceRender();
    }
  };
  handledEvents.forEach((eventName) => {
    const lowerFirst = eventName.charAt(0).toLowerCase() + eventName.slice(1);
    publicAPI[`${lowerFirst}Event`] = (arg) => {
      if (!model.enabled) {
        return;
      }
      const renderer = publicAPI.getCurrentRenderer();
      if (!renderer) {
        vtkOnceErrorMacro2(`
          Can not forward events without a current renderer on the interactor.
        `);
        return;
      }
      const callData = __spreadValues({
        type: eventName,
        pokedRenderer: model.currentRenderer,
        firstRenderer: publicAPI.getFirstRenderer()
      }, arg);
      publicAPI[`invoke${eventName}`](callData);
    };
  });
  publicAPI.recognizeGesture = (event2, positions) => {
    if (Object.keys(positions).length > 2) {
      return;
    }
    if (!model.startingEventPositions) {
      model.startingEventPositions = {};
    }
    if (event2 === "TouchStart") {
      Object.keys(positions).forEach((key) => {
        model.startingEventPositions[key] = positions[key];
      });
      model.currentGesture = "Start";
      return;
    }
    if (event2 === "TouchEnd") {
      if (model.currentGesture === "Pinch") {
        publicAPI.render();
        publicAPI.endPinchEvent();
      }
      if (model.currentGesture === "Rotate") {
        publicAPI.render();
        publicAPI.endRotateEvent();
      }
      if (model.currentGesture === "Pan") {
        publicAPI.render();
        publicAPI.endPanEvent();
      }
      model.currentGesture = "Start";
      model.startingEventPositions = {};
      return;
    }
    let count = 0;
    const posVals = [];
    const startVals = [];
    Object.keys(positions).forEach((key) => {
      posVals[count] = positions[key];
      startVals[count] = model.startingEventPositions[key];
      count++;
    });
    const originalDistance = Math.sqrt((startVals[0].x - startVals[1].x) * (startVals[0].x - startVals[1].x) + (startVals[0].y - startVals[1].y) * (startVals[0].y - startVals[1].y));
    const newDistance = Math.sqrt((posVals[0].x - posVals[1].x) * (posVals[0].x - posVals[1].x) + (posVals[0].y - posVals[1].y) * (posVals[0].y - posVals[1].y));
    let originalAngle = degreesFromRadians(Math.atan2(startVals[1].y - startVals[0].y, startVals[1].x - startVals[0].x));
    let newAngle = degreesFromRadians(Math.atan2(posVals[1].y - posVals[0].y, posVals[1].x - posVals[0].x));
    let angleDeviation = newAngle - originalAngle;
    newAngle = newAngle + 180 >= 360 ? newAngle - 180 : newAngle + 180;
    originalAngle = originalAngle + 180 >= 360 ? originalAngle - 180 : originalAngle + 180;
    if (Math.abs(newAngle - originalAngle) < Math.abs(angleDeviation)) {
      angleDeviation = newAngle - originalAngle;
    }
    const trans = [];
    trans[0] = (posVals[0].x - startVals[0].x + posVals[1].x - startVals[1].x) / 2;
    trans[1] = (posVals[0].y - startVals[0].y + posVals[1].y - startVals[1].y) / 2;
    if (event2 === "TouchMove") {
      if (model.currentGesture === "Start") {
        let thresh = 0.01 * Math.sqrt(model.container.clientWidth * model.container.clientWidth + model.container.clientHeight * model.container.clientHeight);
        if (thresh < 15) {
          thresh = 15;
        }
        const pinchDistance = Math.abs(newDistance - originalDistance);
        const rotateDistance = newDistance * 3.1415926 * Math.abs(angleDeviation) / 360;
        const panDistance = Math.sqrt(trans[0] * trans[0] + trans[1] * trans[1]);
        if (pinchDistance > thresh && pinchDistance > rotateDistance && pinchDistance > panDistance) {
          model.currentGesture = "Pinch";
          const callData = {
            scale: 1,
            touches: positions
          };
          publicAPI.startPinchEvent(callData);
        } else if (rotateDistance > thresh && rotateDistance > panDistance) {
          model.currentGesture = "Rotate";
          const callData = {
            rotation: 0,
            touches: positions
          };
          publicAPI.startRotateEvent(callData);
        } else if (panDistance > thresh) {
          model.currentGesture = "Pan";
          const callData = {
            translation: [0, 0],
            touches: positions
          };
          publicAPI.startPanEvent(callData);
        }
      } else {
        if (model.currentGesture === "Rotate") {
          const callData = {
            rotation: angleDeviation,
            touches: positions
          };
          publicAPI.rotateEvent(callData);
        }
        if (model.currentGesture === "Pinch") {
          const callData = {
            scale: newDistance / originalDistance,
            touches: positions
          };
          publicAPI.pinchEvent(callData);
        }
        if (model.currentGesture === "Pan") {
          const callData = {
            translation: trans,
            touches: positions
          };
          publicAPI.panEvent(callData);
        }
      }
    }
  };
  publicAPI.handleVisibilityChange = () => {
    model._animationStartTime = Date.now();
    model._animationFrameCount = 0;
  };
  publicAPI.setCurrentRenderer = (r9) => {
    model._forcedRenderer = !!r9;
    model.currentRenderer = r9;
  };
  publicAPI.setContainer = (container) => {
    _unbindEvents();
    const res = superClass.setContainer(container != null ? container : null);
    if (res) {
      _bindEvents();
    }
    return res;
  };
  publicAPI.delete = () => {
    while (animationRequesters.size) {
      publicAPI.cancelAnimation(animationRequesters.values().next().value);
    }
    if (typeof document.hidden !== "undefined") {
      document.removeEventListener("visibilitychange", publicAPI.handleVisibilityChange);
    }
    if (model.container) {
      publicAPI.setContainer(null);
    }
    superClass.delete();
  };
  if (typeof document.hidden !== "undefined") {
    document.addEventListener("visibilitychange", publicAPI.handleVisibilityChange, false);
  }
}
var DEFAULT_VALUES74 = {
  renderWindow: null,
  interactorStyle: null,
  picker: null,
  pickingManager: null,
  initialized: false,
  enabled: false,
  enableRender: true,
  currentRenderer: null,
  lightFollowCamera: true,
  desiredUpdateRate: 30,
  stillUpdateRate: 2,
  container: null,
  // _view: null,
  recognizeGestures: true,
  currentGesture: "Start",
  animationRequest: null,
  lastFrameTime: 0.1,
  recentAnimationFrameRate: 10,
  wheelTimeoutID: 0,
  moveTimeoutID: 0,
  lastGamepadValues: {},
  preventDefaultOnPointerDown: false,
  preventDefaultOnPointerUp: false,
  mouseScrollDebounceByPass: false
};
function extend76(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES74, initialValues);
  macro.obj(publicAPI, model);
  model._animationExtendedEnd = 0;
  macro.event(publicAPI, model, "RenderEvent");
  handledEvents.forEach((eventName) => macro.event(publicAPI, model, eventName));
  macro.get(publicAPI, model, ["initialized", "interactorStyle", "lastFrameTime", "recentAnimationFrameRate", "_view"]);
  macro.setGet(publicAPI, model, ["container", "lightFollowCamera", "enabled", "enableRender", "recognizeGestures", "desiredUpdateRate", "stillUpdateRate", "picker", "preventDefaultOnPointerDown", "preventDefaultOnPointerUp", "mouseScrollDebounceByPass"]);
  macro.moveToProtected(publicAPI, model, ["view"]);
  vtkRenderWindowInteractor(publicAPI, model);
}
var newInstance75 = macro.newInstance(extend76, "vtkRenderWindowInteractor");
var vtkRenderWindowInteractor$1 = __spreadValues({
  newInstance: newInstance75,
  extend: extend76,
  handledEvents
}, Constants12);

// node_modules/@kitware/vtk.js/Rendering/Core/InteractorObserver.js
var {
  vtkErrorMacro: vtkErrorMacro28,
  VOID: VOID2
} = macro;
function computeWorldToDisplay(renderer, x2, y3, z3) {
  const view = renderer.getRenderWindow().getViews()[0];
  return view.worldToDisplay(x2, y3, z3, renderer);
}
function computeDisplayToWorld(renderer, x2, y3, z3) {
  const view = renderer.getRenderWindow().getViews()[0];
  return view.displayToWorld(x2, y3, z3, renderer);
}
var STATIC11 = {
  computeWorldToDisplay,
  computeDisplayToWorld
};
function vtkInteractorObserver(publicAPI, model) {
  model.classHierarchy.push("vtkInteractorObserver");
  const superClass = __spreadValues({}, publicAPI);
  function unsubscribeFromEvents() {
    while (model.subscribedEvents.length) {
      model.subscribedEvents.pop().unsubscribe();
    }
  }
  function subscribeToEvents() {
    vtkRenderWindowInteractor$1.handledEvents.forEach((eventName) => {
      if (publicAPI[`handle${eventName}`]) {
        model.subscribedEvents.push(model._interactor[`on${eventName}`]((callData) => {
          if (model.processEvents) {
            return publicAPI[`handle${eventName}`](callData);
          }
          return VOID2;
        }, model.priority));
      }
    });
  }
  publicAPI.setInteractor = (i6) => {
    if (i6 === model._interactor) {
      return;
    }
    unsubscribeFromEvents();
    model._interactor = i6;
    if (i6 && model.enabled) {
      subscribeToEvents();
    }
    publicAPI.modified();
  };
  publicAPI.setEnabled = (enable) => {
    if (enable === model.enabled) {
      return;
    }
    unsubscribeFromEvents();
    if (enable) {
      if (model._interactor) {
        subscribeToEvents();
      } else {
        vtkErrorMacro28(`
          The interactor must be set before subscribing to events
        `);
      }
    }
    model.enabled = enable;
    publicAPI.modified();
  };
  publicAPI.computeDisplayToWorld = (renderer, x2, y3, z3) => {
    if (!renderer) {
      return null;
    }
    return model._interactor.getView().displayToWorld(x2, y3, z3, renderer);
  };
  publicAPI.computeWorldToDisplay = (renderer, x2, y3, z3) => {
    if (!renderer) {
      return null;
    }
    return model._interactor.getView().worldToDisplay(x2, y3, z3, renderer);
  };
  publicAPI.setPriority = (priority) => {
    const modified = superClass.setPriority(priority);
    if (modified && model._interactor) {
      unsubscribeFromEvents();
      subscribeToEvents();
    }
  };
}
var DEFAULT_VALUES75 = {
  enabled: true,
  // _interactor: null,
  priority: 0,
  processEvents: true,
  subscribedEvents: []
};
function extend77(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES75, initialValues);
  macro.obj(publicAPI, model);
  macro.event(publicAPI, model, "InteractionEvent");
  macro.event(publicAPI, model, "StartInteractionEvent");
  macro.event(publicAPI, model, "EndInteractionEvent");
  macro.get(publicAPI, model, ["_interactor", "enabled"]);
  macro.setGet(publicAPI, model, ["priority", "processEvents"]);
  macro.moveToProtected(publicAPI, model, ["interactor"]);
  vtkInteractorObserver(publicAPI, model);
}
var newInstance76 = macro.newInstance(extend77, "vtkInteractorObserver");
var vtkInteractorObserver$1 = __spreadValues({
  newInstance: newInstance76,
  extend: extend77
}, STATIC11);

// node_modules/@kitware/vtk.js/Rendering/Core/InteractorStyle/Constants.js
var States = {
  IS_START: 0,
  IS_NONE: 0,
  IS_ROTATE: 1,
  IS_PAN: 2,
  IS_SPIN: 3,
  IS_DOLLY: 4,
  IS_CAMERA_POSE: 11,
  IS_WINDOW_LEVEL: 1024,
  IS_SLICE: 1025
};
var vtkInteractorStyleConstants = {
  States
};

// node_modules/@kitware/vtk.js/Rendering/Core/InteractorStyle.js
var {
  States: States2
} = vtkInteractorStyleConstants;
var stateNames = {
  Rotate: States2.IS_ROTATE,
  Pan: States2.IS_PAN,
  Spin: States2.IS_SPIN,
  Dolly: States2.IS_DOLLY,
  CameraPose: States2.IS_CAMERA_POSE,
  WindowLevel: States2.IS_WINDOW_LEVEL,
  Slice: States2.IS_SLICE
};
function vtkInteractorStyle(publicAPI, model) {
  model.classHierarchy.push("vtkInteractorStyle");
  Object.keys(stateNames).forEach((key) => {
    macro.event(publicAPI, model, `Start${key}Event`);
    publicAPI[`start${key}`] = () => {
      if (model.state !== States2.IS_NONE) {
        return;
      }
      model.state = stateNames[key];
      model._interactor.requestAnimation(publicAPI);
      publicAPI.invokeStartInteractionEvent({
        type: "StartInteractionEvent"
      });
      publicAPI[`invokeStart${key}Event`]({
        type: `Start${key}Event`
      });
    };
    macro.event(publicAPI, model, `End${key}Event`);
    publicAPI[`end${key}`] = () => {
      if (model.state !== stateNames[key]) {
        return;
      }
      model.state = States2.IS_NONE;
      model._interactor.cancelAnimation(publicAPI);
      publicAPI.invokeEndInteractionEvent({
        type: "EndInteractionEvent"
      });
      publicAPI[`invokeEnd${key}Event`]({
        type: `End${key}Event`
      });
      model._interactor.render();
    };
  });
  publicAPI.handleKeyPress = (callData) => {
    const rwi = model._interactor;
    let ac = null;
    switch (callData.key) {
      case "r":
      case "R":
        callData.pokedRenderer.resetCamera();
        rwi.render();
        break;
      case "w":
      case "W":
        ac = callData.pokedRenderer.getActors();
        ac.forEach((anActor) => {
          const prop = anActor.getProperty();
          if (prop.setRepresentationToWireframe) {
            prop.setRepresentationToWireframe();
          }
        });
        rwi.render();
        break;
      case "s":
      case "S":
        ac = callData.pokedRenderer.getActors();
        ac.forEach((anActor) => {
          const prop = anActor.getProperty();
          if (prop.setRepresentationToSurface) {
            prop.setRepresentationToSurface();
          }
        });
        rwi.render();
        break;
      case "v":
      case "V":
        ac = callData.pokedRenderer.getActors();
        ac.forEach((anActor) => {
          const prop = anActor.getProperty();
          if (prop.setRepresentationToPoints) {
            prop.setRepresentationToPoints();
          }
        });
        rwi.render();
        break;
    }
  };
}
var DEFAULT_VALUES76 = {
  state: States2.IS_NONE,
  handleObservers: 1,
  autoAdjustCameraClippingRange: 1
};
function extend78(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES76, initialValues);
  vtkInteractorObserver$1.extend(publicAPI, model, initialValues);
  vtkInteractorStyle(publicAPI, model);
}
var newInstance77 = macro.newInstance(extend78, "vtkInteractorStyle");
var vtkInteractorStyle$1 = __spreadValues({
  newInstance: newInstance77,
  extend: extend78
}, vtkInteractorStyleConstants);

// node_modules/@kitware/vtk.js/Interaction/Style/InteractorStyleTrackballCamera.js
var {
  States: States3
} = vtkInteractorStyleConstants;
function vtkInteractorStyleTrackballCamera(publicAPI, model) {
  model.classHierarchy.push("vtkInteractorStyleTrackballCamera");
  publicAPI.handleMouseMove = (callData) => {
    const pos = callData.position;
    const renderer = callData.pokedRenderer;
    switch (model.state) {
      case States3.IS_ROTATE:
        publicAPI.handleMouseRotate(renderer, pos);
        publicAPI.invokeInteractionEvent({
          type: "InteractionEvent"
        });
        break;
      case States3.IS_PAN:
        publicAPI.handleMousePan(renderer, pos);
        publicAPI.invokeInteractionEvent({
          type: "InteractionEvent"
        });
        break;
      case States3.IS_DOLLY:
        publicAPI.handleMouseDolly(renderer, pos);
        publicAPI.invokeInteractionEvent({
          type: "InteractionEvent"
        });
        break;
      case States3.IS_SPIN:
        publicAPI.handleMouseSpin(renderer, pos);
        publicAPI.invokeInteractionEvent({
          type: "InteractionEvent"
        });
        break;
    }
    model.previousPosition = pos;
  };
  publicAPI.handleButton3D = (ed) => {
    if (ed && ed.pressed && ed.device === Device.RightController && (ed.input === Input.Trigger || ed.input === Input.TrackPad)) {
      publicAPI.startCameraPose();
      return;
    }
    if (ed && !ed.pressed && ed.device === Device.RightController && (ed.input === Input.Trigger || ed.input === Input.TrackPad) && model.state === States3.IS_CAMERA_POSE) {
      publicAPI.endCameraPose();
    }
  };
  publicAPI.handleMove3D = (ed) => {
    switch (model.state) {
      case States3.IS_CAMERA_POSE:
        publicAPI.updateCameraPose(ed);
        break;
    }
  };
  publicAPI.updateCameraPose = (ed) => {
    const camera = ed.pokedRenderer.getActiveCamera();
    const oldTrans = camera.getPhysicalTranslation();
    const speed = 0.5;
    const pscale = speed * 0.05 * camera.getPhysicalScale();
    const dir = camera.physicalOrientationToWorldDirection([ed.orientation.x, ed.orientation.y, ed.orientation.z, ed.orientation.w]);
    camera.setPhysicalTranslation(oldTrans[0] + dir[0] * pscale, oldTrans[1] + dir[1] * pscale, oldTrans[2] + dir[2] * pscale);
  };
  publicAPI.handleLeftButtonPress = (callData) => {
    const pos = callData.position;
    model.previousPosition = pos;
    if (callData.shiftKey) {
      if (callData.controlKey || callData.altKey) {
        publicAPI.startDolly();
      } else {
        publicAPI.startPan();
      }
    } else {
      if (callData.controlKey || callData.altKey) {
        publicAPI.startSpin();
      } else {
        publicAPI.startRotate();
      }
    }
  };
  publicAPI.handleLeftButtonRelease = () => {
    switch (model.state) {
      case States3.IS_DOLLY:
        publicAPI.endDolly();
        break;
      case States3.IS_PAN:
        publicAPI.endPan();
        break;
      case States3.IS_SPIN:
        publicAPI.endSpin();
        break;
      case States3.IS_ROTATE:
        publicAPI.endRotate();
        break;
    }
  };
  publicAPI.handleStartMouseWheel = () => {
    publicAPI.startDolly();
  };
  publicAPI.handleEndMouseWheel = () => {
    publicAPI.endDolly();
  };
  publicAPI.handleStartPinch = (callData) => {
    model.previousScale = callData.scale;
    publicAPI.startDolly();
  };
  publicAPI.handleEndPinch = () => {
    publicAPI.endDolly();
  };
  publicAPI.handleStartRotate = (callData) => {
    model.previousRotation = callData.rotation;
    publicAPI.startRotate();
  };
  publicAPI.handleEndRotate = () => {
    publicAPI.endRotate();
  };
  publicAPI.handleStartPan = (callData) => {
    model.previousTranslation = callData.translation;
    publicAPI.startPan();
  };
  publicAPI.handleEndPan = () => {
    publicAPI.endPan();
  };
  publicAPI.handlePinch = (callData) => {
    publicAPI.dollyByFactor(callData.pokedRenderer, callData.scale / model.previousScale);
    model.previousScale = callData.scale;
  };
  publicAPI.handlePan = (callData) => {
    const camera = callData.pokedRenderer.getActiveCamera();
    let viewFocus = camera.getFocalPoint();
    viewFocus = publicAPI.computeWorldToDisplay(callData.pokedRenderer, viewFocus[0], viewFocus[1], viewFocus[2]);
    const focalDepth = viewFocus[2];
    const trans = callData.translation;
    const lastTrans = model.previousTranslation;
    const newPickPoint = publicAPI.computeDisplayToWorld(callData.pokedRenderer, viewFocus[0] + trans[0] - lastTrans[0], viewFocus[1] + trans[1] - lastTrans[1], focalDepth);
    const oldPickPoint = publicAPI.computeDisplayToWorld(callData.pokedRenderer, viewFocus[0], viewFocus[1], focalDepth);
    const motionVector = [];
    motionVector[0] = oldPickPoint[0] - newPickPoint[0];
    motionVector[1] = oldPickPoint[1] - newPickPoint[1];
    motionVector[2] = oldPickPoint[2] - newPickPoint[2];
    viewFocus = camera.getFocalPoint();
    const viewPoint = camera.getPosition();
    camera.setFocalPoint(motionVector[0] + viewFocus[0], motionVector[1] + viewFocus[1], motionVector[2] + viewFocus[2]);
    camera.setPosition(motionVector[0] + viewPoint[0], motionVector[1] + viewPoint[1], motionVector[2] + viewPoint[2]);
    if (model._interactor.getLightFollowCamera()) {
      callData.pokedRenderer.updateLightsGeometryToFollowCamera();
    }
    camera.orthogonalizeViewUp();
    model.previousTranslation = callData.translation;
  };
  publicAPI.handleRotate = (callData) => {
    const camera = callData.pokedRenderer.getActiveCamera();
    camera.roll(callData.rotation - model.previousRotation);
    camera.orthogonalizeViewUp();
    model.previousRotation = callData.rotation;
  };
  publicAPI.handleMouseRotate = (renderer, position) => {
    if (!model.previousPosition) {
      return;
    }
    const rwi = model._interactor;
    const dx = position.x - model.previousPosition.x;
    const dy = position.y - model.previousPosition.y;
    const size3 = rwi.getView().getViewportSize(renderer);
    let deltaElevation = -0.1;
    let deltaAzimuth = -0.1;
    if (size3[0] && size3[1]) {
      deltaElevation = -20 / size3[1];
      deltaAzimuth = -20 / size3[0];
    }
    const rxf = dx * deltaAzimuth * model.motionFactor;
    const ryf = dy * deltaElevation * model.motionFactor;
    const camera = renderer.getActiveCamera();
    if (!Number.isNaN(rxf) && !Number.isNaN(ryf)) {
      camera.azimuth(rxf);
      camera.elevation(ryf);
      camera.orthogonalizeViewUp();
    }
    if (model.autoAdjustCameraClippingRange) {
      renderer.resetCameraClippingRange();
    }
    if (rwi.getLightFollowCamera()) {
      renderer.updateLightsGeometryToFollowCamera();
    }
  };
  publicAPI.handleMouseSpin = (renderer, position) => {
    if (!model.previousPosition) {
      return;
    }
    const rwi = model._interactor;
    const camera = renderer.getActiveCamera();
    const center = rwi.getView().getViewportCenter(renderer);
    const oldAngle = degreesFromRadians(Math.atan2(model.previousPosition.y - center[1], model.previousPosition.x - center[0]));
    const newAngle = degreesFromRadians(Math.atan2(position.y - center[1], position.x - center[0])) - oldAngle;
    if (!Number.isNaN(newAngle)) {
      camera.roll(newAngle);
      camera.orthogonalizeViewUp();
    }
  };
  publicAPI.handleMousePan = (renderer, position) => {
    if (!model.previousPosition) {
      return;
    }
    const camera = renderer.getActiveCamera();
    let viewFocus = camera.getFocalPoint();
    viewFocus = publicAPI.computeWorldToDisplay(renderer, viewFocus[0], viewFocus[1], viewFocus[2]);
    const focalDepth = viewFocus[2];
    const newPickPoint = publicAPI.computeDisplayToWorld(renderer, position.x, position.y, focalDepth);
    const oldPickPoint = publicAPI.computeDisplayToWorld(renderer, model.previousPosition.x, model.previousPosition.y, focalDepth);
    const motionVector = [];
    motionVector[0] = oldPickPoint[0] - newPickPoint[0];
    motionVector[1] = oldPickPoint[1] - newPickPoint[1];
    motionVector[2] = oldPickPoint[2] - newPickPoint[2];
    viewFocus = camera.getFocalPoint();
    const viewPoint = camera.getPosition();
    camera.setFocalPoint(motionVector[0] + viewFocus[0], motionVector[1] + viewFocus[1], motionVector[2] + viewFocus[2]);
    camera.setPosition(motionVector[0] + viewPoint[0], motionVector[1] + viewPoint[1], motionVector[2] + viewPoint[2]);
    if (model._interactor.getLightFollowCamera()) {
      renderer.updateLightsGeometryToFollowCamera();
    }
  };
  publicAPI.handleMouseDolly = (renderer, position) => {
    if (!model.previousPosition) {
      return;
    }
    const dy = position.y - model.previousPosition.y;
    const rwi = model._interactor;
    const center = rwi.getView().getViewportCenter(renderer);
    const dyf = model.motionFactor * dy / center[1];
    publicAPI.dollyByFactor(renderer, __pow(1.1, dyf));
  };
  publicAPI.handleMouseWheel = (callData) => {
    const dyf = 1 - callData.spinY / model.zoomFactor;
    publicAPI.dollyByFactor(callData.pokedRenderer, dyf);
  };
  publicAPI.dollyByFactor = (renderer, factor) => {
    if (Number.isNaN(factor)) {
      return;
    }
    const camera = renderer.getActiveCamera();
    if (camera.getParallelProjection()) {
      camera.setParallelScale(camera.getParallelScale() / factor);
    } else {
      camera.dolly(factor);
      if (model.autoAdjustCameraClippingRange) {
        renderer.resetCameraClippingRange();
      }
    }
    if (model._interactor.getLightFollowCamera()) {
      renderer.updateLightsGeometryToFollowCamera();
    }
  };
}
var DEFAULT_VALUES77 = {
  motionFactor: 10,
  zoomFactor: 10
};
function extend79(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES77, initialValues);
  vtkInteractorStyle$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["motionFactor", "zoomFactor"]);
  vtkInteractorStyleTrackballCamera(publicAPI, model);
}
var newInstance78 = macro.newInstance(extend79, "vtkInteractorStyleTrackballCamera");
var vtkInteractorStyleTrackballCamera$1 = {
  newInstance: newInstance78,
  extend: extend79
};

// node_modules/@kitware/vtk.js/Common/Core/URLExtract.js
function identity5(i6) {
  return i6;
}
function toNativeType(str6) {
  if (str6 === null || str6 === "null") {
    return null;
  }
  if (str6 === "true") {
    return true;
  }
  if (str6 === "false") {
    return false;
  }
  if (str6 === void 0 || str6 === "undefined") {
    return void 0;
  }
  if (str6[0] === "[" && str6[str6.length - 1] === "]") {
    return str6.substring(1, str6.length - 1).split(",").map((s9) => toNativeType(s9.trim()));
  }
  if (str6 === "" || Number.isNaN(Number(str6))) {
    return str6;
  }
  return Number(str6);
}
function extractURLParameters() {
  let castToNativeType = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
  let query = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : window.location.search;
  const summary = {};
  const convert3 = castToNativeType ? toNativeType : identity5;
  const queryTokens = (query || "").replace(/#.*/, "").replace("?", "").split("&");
  queryTokens.forEach((token) => {
    const [key, value] = token.split("=").map((s9) => decodeURIComponent(s9));
    if (key) {
      summary[key] = value ? convert3(value) : true;
    }
  });
  return summary;
}
var vtkURLExtract = {
  toNativeType,
  extractURLParameters
};

// node_modules/@kitware/vtk.js/Rendering/Core/Actor.js
var {
  vtkDebugMacro: vtkDebugMacro9
} = macro;
function vtkActor(publicAPI, model) {
  model.classHierarchy.push("vtkActor");
  const superClass = __spreadValues({}, publicAPI);
  publicAPI.getActors = () => [publicAPI];
  publicAPI.getIsOpaque = () => {
    if (model.forceOpaque) {
      return true;
    }
    if (model.forceTranslucent) {
      return false;
    }
    if (!model.property) {
      publicAPI.getProperty();
    }
    let isOpaque = model.property.getOpacity() >= 1;
    isOpaque = isOpaque && (!model.texture || !model.texture.isTranslucent());
    isOpaque = isOpaque && (!model.mapper || model.mapper.getIsOpaque());
    return isOpaque;
  };
  publicAPI.hasTranslucentPolygonalGeometry = () => {
    if (model.mapper === null) {
      return false;
    }
    if (model.property === null) {
      publicAPI.setProperty(publicAPI.makeProperty());
    }
    return !publicAPI.getIsOpaque();
  };
  publicAPI.makeProperty = vtkProperty$1.newInstance;
  publicAPI.getProperty = () => {
    if (model.property === null) {
      model.property = publicAPI.makeProperty();
    }
    return model.property;
  };
  publicAPI.getBounds = () => {
    if (model.mapper === null) {
      return model.bounds;
    }
    const bds = model.mapper.getBounds();
    if (!bds || bds.length !== 6) {
      return bds;
    }
    if (bds[0] > bds[1]) {
      model.mapperBounds = bds.concat();
      model.bounds = [1, -1, 1, -1, 1, -1];
      model.boundsMTime.modified();
      return bds;
    }
    if (!model.mapperBounds || bds[0] !== model.mapperBounds[0] || bds[1] !== model.mapperBounds[1] || bds[2] !== model.mapperBounds[2] || bds[3] !== model.mapperBounds[3] || bds[4] !== model.mapperBounds[4] || bds[5] !== model.mapperBounds[5] || publicAPI.getMTime() > model.boundsMTime.getMTime()) {
      vtkDebugMacro9("Recomputing bounds...");
      model.mapperBounds = bds.concat();
      const bbox = [];
      vtkBoundingBox.getCorners(bds, bbox);
      publicAPI.computeMatrix();
      const tmp4 = new Float64Array(16);
      mat4_exports.transpose(tmp4, model.matrix);
      bbox.forEach((pt) => vec3_exports.transformMat4(pt, pt, tmp4));
      model.bounds[0] = model.bounds[2] = model.bounds[4] = Number.MAX_VALUE;
      model.bounds[1] = model.bounds[3] = model.bounds[5] = -Number.MAX_VALUE;
      model.bounds = model.bounds.map((d3, i6) => i6 % 2 === 0 ? bbox.reduce((a4, b3) => a4 > b3[i6 / 2] ? b3[i6 / 2] : a4, d3) : bbox.reduce((a4, b3) => a4 < b3[(i6 - 1) / 2] ? b3[(i6 - 1) / 2] : a4, d3));
      model.boundsMTime.modified();
    }
    return model.bounds;
  };
  publicAPI.getMTime = () => {
    let mt = superClass.getMTime();
    if (model.property !== null) {
      const time = model.property.getMTime();
      mt = time > mt ? time : mt;
    }
    if (model.backfaceProperty !== null) {
      const time = model.backfaceProperty.getMTime();
      mt = time > mt ? time : mt;
    }
    return mt;
  };
  publicAPI.getRedrawMTime = () => {
    let mt = model.mtime;
    if (model.mapper !== null) {
      let time = model.mapper.getMTime();
      mt = time > mt ? time : mt;
      if (model.mapper.getInput() !== null) {
        model.mapper.getInputAlgorithm().update();
        time = model.mapper.getInput().getMTime();
        mt = time > mt ? time : mt;
      }
    }
    return mt;
  };
  publicAPI.getSupportsSelection = () => model.mapper ? model.mapper.getSupportsSelection() : false;
  publicAPI.processSelectorPixelBuffers = (selector, pixelOffsets) => {
    if (model.mapper && model.mapper.processSelectorPixelBuffers) {
      model.mapper.processSelectorPixelBuffers(selector, pixelOffsets);
    }
  };
}
var DEFAULT_VALUES78 = {
  mapper: null,
  property: null,
  backfaceProperty: null,
  forceOpaque: false,
  forceTranslucent: false,
  bounds: [1, -1, 1, -1, 1, -1]
};
function extend80(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES78, initialValues);
  vtkProp3D$1.extend(publicAPI, model, initialValues);
  model.boundsMTime = {};
  macro.obj(model.boundsMTime);
  macro.set(publicAPI, model, ["property"]);
  macro.setGet(publicAPI, model, ["backfaceProperty", "forceOpaque", "forceTranslucent", "mapper"]);
  vtkActor(publicAPI, model);
}
var newInstance79 = macro.newInstance(extend80, "vtkActor");

// node_modules/@kitware/vtk.js/Common/Core/ScalarsToColors/Constants.js
var VectorMode = {
  MAGNITUDE: 0,
  COMPONENT: 1,
  RGBCOLORS: 2
};
var ScalarMappingTarget = {
  LUMINANCE: 1,
  LUMINANCE_ALPHA: 2,
  RGB: 3,
  RGBA: 4
};
var vtkScalarsToColors = {
  VectorMode,
  ScalarMappingTarget
};

// node_modules/@kitware/vtk.js/Rendering/Core/Mapper/Constants.js
var ColorMode = {
  DEFAULT: 0,
  MAP_SCALARS: 1,
  DIRECT_SCALARS: 2
};
var ScalarMode = {
  DEFAULT: 0,
  USE_POINT_DATA: 1,
  USE_CELL_DATA: 2,
  USE_POINT_FIELD_DATA: 3,
  USE_CELL_FIELD_DATA: 4,
  USE_FIELD_DATA: 5
};
var GetArray = {
  BY_ID: 0,
  BY_NAME: 1
};
var Constants13 = {
  ColorMode,
  GetArray,
  ScalarMode
};

// node_modules/@kitware/vtk.js/Common/Core/ScalarsToColors.js
var {
  ScalarMappingTarget: ScalarMappingTarget2,
  VectorMode: VectorMode2
} = vtkScalarsToColors;
var {
  VtkDataTypes: VtkDataTypes4
} = vtkDataArray$1;
var {
  ColorMode: ColorMode2
} = Constants13;
var {
  vtkErrorMacro: vtkErrorMacro29
} = macro;
function intColorToUChar(c6) {
  return c6;
}
function floatColorToUChar(c6) {
  return Math.floor(c6 * 255 + 0.5);
}
function vtkScalarsToColors2(publicAPI, model) {
  model.classHierarchy.push("vtkScalarsToColors");
  publicAPI.setVectorModeToMagnitude = () => publicAPI.setVectorMode(VectorMode2.MAGNITUDE);
  publicAPI.setVectorModeToComponent = () => publicAPI.setVectorMode(VectorMode2.COMPONENT);
  publicAPI.setVectorModeToRGBColors = () => publicAPI.setVectorMode(VectorMode2.RGBCOLORS);
  publicAPI.build = () => {
  };
  publicAPI.isOpaque = () => true;
  publicAPI.setAnnotations = (values, annotations) => {
    if (values && !annotations || !values && annotations) {
      return;
    }
    if (values && annotations && values.length !== annotations.length) {
      vtkErrorMacro29("Values and annotations do not have the same number of tuples so ignoring");
      return;
    }
    model.annotationArray = [];
    if (annotations && values) {
      const num = annotations.length;
      for (let i6 = 0; i6 < num; i6++) {
        model.annotationArray.push({
          value: values[i6],
          annotation: String(annotations[i6])
        });
      }
    }
    publicAPI.updateAnnotatedValueMap();
    publicAPI.modified();
  };
  publicAPI.setAnnotation = (value, annotation) => {
    let i6 = publicAPI.checkForAnnotatedValue(value);
    let modified = false;
    if (i6 >= 0) {
      if (model.annotationArray[i6].annotation !== annotation) {
        model.annotationArray[i6].annotation = annotation;
        modified = true;
      }
    } else {
      model.annotationArray.push({
        value,
        annotation
      });
      i6 = model.annotationArray.length - 1;
      modified = true;
    }
    if (modified) {
      publicAPI.updateAnnotatedValueMap();
      publicAPI.modified();
    }
    return i6;
  };
  publicAPI.getNumberOfAnnotatedValues = () => model.annotationArray.length;
  publicAPI.getAnnotatedValue = (idx) => {
    if (idx < 0 || idx >= model.annotationArray.length) {
      return null;
    }
    return model.annotationArray[idx].value;
  };
  publicAPI.getAnnotation = (idx) => {
    if (model.annotationArray[idx] === void 0) {
      return null;
    }
    return model.annotationArray[idx].annotation;
  };
  publicAPI.getAnnotatedValueIndex = (val) => model.annotationArray.length ? publicAPI.checkForAnnotatedValue(val) : -1;
  publicAPI.removeAnnotation = (value) => {
    const i6 = publicAPI.checkForAnnotatedValue(value);
    const needToRemove = i6 >= 0;
    if (needToRemove) {
      model.annotationArray.splice(i6, 1);
      publicAPI.updateAnnotatedValueMap();
      publicAPI.modified();
    }
    return needToRemove;
  };
  publicAPI.resetAnnotations = () => {
    model.annotationArray = [];
    model.annotatedValueMap = [];
    publicAPI.modified();
  };
  publicAPI.getAnnotationColor = (val, rgba) => {
    if (model.indexedLookup) {
      const i6 = publicAPI.getAnnotatedValueIndex(val);
      publicAPI.getIndexedColor(i6, rgba);
    } else {
      publicAPI.getColor(parseFloat(val), rgba);
      rgba[3] = 1;
    }
  };
  publicAPI.checkForAnnotatedValue = (value) => publicAPI.getAnnotatedValueIndexInternal(value);
  publicAPI.getAnnotatedValueIndexInternal = (value) => {
    if (model.annotatedValueMap[value] !== void 0) {
      const na = model.annotationArray.length;
      return model.annotatedValueMap[value] % na;
    }
    return -1;
  };
  publicAPI.getIndexedColor = (val, rgba) => {
    rgba[0] = 0;
    rgba[1] = 0;
    rgba[2] = 0;
    rgba[3] = 0;
  };
  publicAPI.updateAnnotatedValueMap = () => {
    model.annotatedValueMap = [];
    const na = model.annotationArray.length;
    for (let i6 = 0; i6 < na; i6++) {
      model.annotatedValueMap[model.annotationArray[i6].value] = i6;
    }
  };
  publicAPI.mapScalars = (scalars, colorMode, componentIn) => {
    const numberOfComponents = scalars.getNumberOfComponents();
    let newColors = null;
    if (colorMode === ColorMode2.DEFAULT && (scalars.getDataType() === VtkDataTypes4.UNSIGNED_CHAR || scalars.getDataType() === VtkDataTypes4.UNSIGNED_CHAR_CLAMPED) || colorMode === ColorMode2.DIRECT_SCALARS && scalars) {
      newColors = publicAPI.convertToRGBA(scalars, numberOfComponents, scalars.getNumberOfTuples());
    } else {
      const newscalars = {
        type: "vtkDataArray",
        name: "temp",
        numberOfComponents: 4,
        dataType: VtkDataTypes4.UNSIGNED_CHAR
      };
      const s9 = macro.newTypedArray(newscalars.dataType, 4 * scalars.getNumberOfTuples());
      newscalars.values = s9;
      newscalars.size = s9.length;
      newColors = vtkDataArray$1.newInstance(newscalars);
      let component = componentIn;
      if (component < 0 && numberOfComponents > 1) {
        publicAPI.mapVectorsThroughTable(scalars, newColors, ScalarMappingTarget2.RGBA, -1, -1);
      } else {
        if (component < 0) {
          component = 0;
        }
        if (component >= numberOfComponents) {
          component = numberOfComponents - 1;
        }
        publicAPI.mapScalarsThroughTable(scalars, newColors, ScalarMappingTarget2.RGBA, component);
      }
    }
    return newColors;
  };
  publicAPI.mapVectorsToMagnitude = (input, output, compsToUse) => {
    const length4 = input.getNumberOfTuples();
    const inIncr = input.getNumberOfComponents();
    const outputV = output.getData();
    const inputV = input.getData();
    for (let i6 = 0; i6 < length4; i6++) {
      let sum = 0;
      for (let j2 = 0; j2 < compsToUse; j2++) {
        sum += inputV[i6 * inIncr + j2] * inputV[i6 * inIncr + j2];
      }
      outputV[i6] = Math.sqrt(sum);
    }
  };
  publicAPI.mapVectorsThroughTable = (input, output, outputFormat, vectorComponentIn, vectorSizeIn) => {
    let vectorMode = publicAPI.getVectorMode();
    let vectorSize = vectorSizeIn;
    let vectorComponent = vectorComponentIn;
    const inComponents = input.getNumberOfComponents();
    if (vectorMode === VectorMode2.COMPONENT) {
      if (vectorComponent === -1) {
        vectorComponent = publicAPI.getVectorComponent();
      }
      if (vectorComponent < 0) {
        vectorComponent = 0;
      }
      if (vectorComponent >= inComponents) {
        vectorComponent = inComponents - 1;
      }
    } else {
      if (vectorSize === -1) {
        vectorSize = publicAPI.getVectorSize();
      }
      if (vectorSize <= 0) {
        vectorComponent = 0;
        vectorSize = inComponents;
      } else {
        if (vectorComponent < 0) {
          vectorComponent = 0;
        }
        if (vectorComponent >= inComponents) {
          vectorComponent = inComponents - 1;
        }
        if (vectorComponent + vectorSize > inComponents) {
          vectorSize = inComponents - vectorComponent;
        }
      }
      if (vectorMode === VectorMode2.MAGNITUDE && (inComponents === 1 || vectorSize === 1)) {
        vectorMode = VectorMode2.COMPONENT;
      }
    }
    let inputOffset = 0;
    if (vectorComponent > 0) {
      inputOffset = vectorComponent;
    }
    switch (vectorMode) {
      case VectorMode2.COMPONENT: {
        publicAPI.mapScalarsThroughTable(input, output, outputFormat, inputOffset);
        break;
      }
      case VectorMode2.RGBCOLORS: {
        break;
      }
      case VectorMode2.MAGNITUDE:
      default: {
        const magValues = vtkDataArray$1.newInstance({
          numberOfComponents: 1,
          values: new Float32Array(input.getNumberOfTuples())
        });
        publicAPI.mapVectorsToMagnitude(input, magValues, vectorSize);
        publicAPI.mapScalarsThroughTable(magValues, output, outputFormat, 0);
        break;
      }
    }
  };
  publicAPI.luminanceToRGBA = (newColors, colors, alpha, convtFun) => {
    const a4 = convtFun(alpha);
    const values = colors.getData();
    const newValues = newColors.getData();
    const size3 = values.length;
    const component = 0;
    const tuple = 1;
    let count = 0;
    for (let i6 = component; i6 < size3; i6 += tuple) {
      const l5 = convtFun(values[i6]);
      newValues[count * 4] = l5;
      newValues[count * 4 + 1] = l5;
      newValues[count * 4 + 2] = l5;
      newValues[count * 4 + 3] = a4;
      count++;
    }
  };
  publicAPI.luminanceAlphaToRGBA = (newColors, colors, alpha, convtFun) => {
    const values = colors.getData();
    const newValues = newColors.getData();
    const size3 = values.length;
    const component = 0;
    const tuple = 2;
    let count = 0;
    for (let i6 = component; i6 < size3; i6 += tuple) {
      const l5 = convtFun(values[i6]);
      newValues[count] = l5;
      newValues[count + 1] = l5;
      newValues[count + 2] = l5;
      newValues[count + 3] = convtFun(values[i6 + 1]) * alpha;
      count += 4;
    }
  };
  publicAPI.rGBToRGBA = (newColors, colors, alpha, convtFun) => {
    const a4 = floatColorToUChar(alpha);
    const values = colors.getData();
    const newValues = newColors.getData();
    const size3 = values.length;
    const component = 0;
    const tuple = 3;
    let count = 0;
    for (let i6 = component; i6 < size3; i6 += tuple) {
      newValues[count * 4] = convtFun(values[i6]);
      newValues[count * 4 + 1] = convtFun(values[i6 + 1]);
      newValues[count * 4 + 2] = convtFun(values[i6 + 2]);
      newValues[count * 4 + 3] = a4;
      count++;
    }
  };
  publicAPI.rGBAToRGBA = (newColors, colors, alpha, convtFun) => {
    const values = colors.getData();
    const newValues = newColors.getData();
    const size3 = values.length;
    const component = 0;
    const tuple = 4;
    let count = 0;
    for (let i6 = component; i6 < size3; i6 += tuple) {
      newValues[count * 4] = convtFun(values[i6]);
      newValues[count * 4 + 1] = convtFun(values[i6 + 1]);
      newValues[count * 4 + 2] = convtFun(values[i6 + 2]);
      newValues[count * 4 + 3] = convtFun(values[i6 + 3]) * alpha;
      count++;
    }
  };
  publicAPI.convertToRGBA = (colors, numComp, numTuples) => {
    let {
      alpha
    } = model;
    if (numComp === 4 && alpha >= 1 && colors.getDataType() === VtkDataTypes4.UNSIGNED_CHAR) {
      return colors;
    }
    const newColors = vtkDataArray$1.newInstance({
      numberOfComponents: 4,
      empty: true,
      size: 4 * numTuples,
      dataType: VtkDataTypes4.UNSIGNED_CHAR
    });
    if (numTuples <= 0) {
      return newColors;
    }
    alpha = alpha > 0 ? alpha : 0;
    alpha = alpha < 1 ? alpha : 1;
    let convtFun = intColorToUChar;
    if (colors.getDataType() === VtkDataTypes4.FLOAT || colors.getDataType() === VtkDataTypes4.DOUBLE) {
      convtFun = floatColorToUChar;
    }
    switch (numComp) {
      case 1:
        publicAPI.luminanceToRGBA(newColors, colors, alpha, convtFun);
        break;
      case 2:
        publicAPI.luminanceAlphaToRGBA(newColors, colors, convtFun);
        break;
      case 3:
        publicAPI.rGBToRGBA(newColors, colors, alpha, convtFun);
        break;
      case 4:
        publicAPI.rGBAToRGBA(newColors, colors, alpha, convtFun);
        break;
      default:
        vtkErrorMacro29("Cannot convert colors");
        return null;
    }
    return newColors;
  };
  publicAPI.usingLogScale = () => false;
  publicAPI.getNumberOfAvailableColors = () => 256 * 256 * 256;
  publicAPI.setRange = (min5, max5) => publicAPI.setMappingRange(min5, max5);
  publicAPI.getRange = () => publicAPI.getMappingRange();
  publicAPI.areScalarsOpaque = (scalars, colorMode, componentIn) => {
    if (!scalars) {
      return publicAPI.isOpaque();
    }
    const numberOfComponents = scalars.getNumberOfComponents();
    if (colorMode === ColorMode2.DEFAULT && scalars.getDataType() === VtkDataTypes4.UNSIGNED_CHAR || colorMode === ColorMode2.DIRECT_SCALARS) {
      if (numberOfComponents === 3 || numberOfComponents === 1) {
        return model.alpha >= 1;
      }
      const range = scalars.getRange(numberOfComponents - 1);
      return range[0] === 255;
    }
    return true;
  };
}
var DEFAULT_VALUES79 = {
  alpha: 1,
  vectorComponent: 0,
  vectorSize: -1,
  vectorMode: VectorMode2.COMPONENT,
  mappingRange: null,
  annotationArray: null,
  annotatedValueMap: null,
  indexedLookup: false
};
function extend81(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES79, initialValues);
  macro.obj(publicAPI, model);
  model.mappingRange = [0, 255];
  model.annotationArray = [];
  model.annotatedValueMap = [];
  macro.setGet(publicAPI, model, ["vectorSize", "vectorComponent", "vectorMode", "alpha", "indexedLookup"]);
  macro.setArray(publicAPI, model, ["mappingRange"], 2);
  macro.getArray(publicAPI, model, ["mappingRange"]);
  vtkScalarsToColors2(publicAPI, model);
}
var newInstance80 = macro.newInstance(extend81, "vtkScalarsToColors");
var vtkScalarsToColors$1 = __spreadValues({
  newInstance: newInstance80,
  extend: extend81
}, vtkScalarsToColors);

// node_modules/@kitware/vtk.js/Common/Core/LookupTable.js
var {
  vtkErrorMacro: vtkErrorMacro30
} = macro;
var BELOW_RANGE_COLOR_INDEX = 0;
var ABOVE_RANGE_COLOR_INDEX = 1;
var NAN_COLOR_INDEX = 2;
function vtkLookupTable(publicAPI, model) {
  model.classHierarchy.push("vtkLookupTable");
  publicAPI.isOpaque = () => {
    if (model.opaqueFlagBuildTime.getMTime() < publicAPI.getMTime()) {
      let opaque = true;
      if (model.nanColor[3] < 1) {
        opaque = 0;
      }
      if (model.useBelowRangeColor && model.belowRangeColor[3] < 1) {
        opaque = 0;
      }
      if (model.useAboveRangeColor && model.aboveRangeColor[3] < 1) {
        opaque = 0;
      }
      for (let i6 = 3; i6 < model.table.length && opaque; i6 += 4) {
        if (model.table[i6] < 255) {
          opaque = false;
        }
      }
      model.opaqueFlag = opaque;
      model.opaqueFlagBuildTime.modified();
    }
    return model.opaqueFlag;
  };
  publicAPI.usingLogScale = () => false;
  publicAPI.getNumberOfAvailableColors = () => model.table.length / 4;
  publicAPI.linearIndexLookup = (v2, p3) => {
    let dIndex = 0;
    const nv = Number(v2);
    if (nv < p3.range[0]) {
      dIndex = p3.maxIndex + BELOW_RANGE_COLOR_INDEX + 1.5;
    } else if (nv > p3.range[1]) {
      dIndex = p3.maxIndex + ABOVE_RANGE_COLOR_INDEX + 1.5;
    } else {
      dIndex = (nv + p3.shift) * p3.scale;
      dIndex = dIndex < p3.maxIndex ? dIndex : p3.maxIndex;
    }
    return Math.floor(dIndex);
  };
  publicAPI.linearLookup = (v2, table, p3) => {
    let index2 = 0;
    if (isNan(v2)) {
      index2 = Math.floor(p3.maxIndex + 1.5 + NAN_COLOR_INDEX);
    } else {
      index2 = publicAPI.linearIndexLookup(v2, p3);
    }
    const offset3 = 4 * index2;
    return table.slice(offset3, offset3 + 4);
  };
  publicAPI.indexedLookupFunction = (v2, table, p3) => {
    let index2 = publicAPI.getAnnotatedValueIndexInternal(v2);
    if (index2 === -1) {
      index2 = model.numberOfColors + NAN_COLOR_INDEX;
    }
    const offset3 = 4 * index2;
    return [table[offset3], table[offset3 + 1], table[offset3 + 2], table[offset3 + 3]];
  };
  publicAPI.lookupShiftAndScale = (range, p3) => {
    p3.shift = -range[0];
    p3.scale = Number.MAX_VALUE;
    if (range[1] > range[0]) {
      p3.scale = (p3.maxIndex + 1) / (range[1] - range[0]);
    }
  };
  publicAPI.mapScalarsThroughTable = (input, output, outFormat, inputOffset) => {
    let lookupFunc = publicAPI.linearLookup;
    if (model.indexedLookup) {
      lookupFunc = publicAPI.indexedLookupFunction;
    }
    const trange = publicAPI.getMappingRange();
    const p3 = {
      maxIndex: publicAPI.getNumberOfColors() - 1,
      range: trange,
      shift: 0,
      scale: 0
    };
    publicAPI.lookupShiftAndScale(trange, p3);
    const alpha = publicAPI.getAlpha();
    const length4 = input.getNumberOfTuples();
    const inIncr = input.getNumberOfComponents();
    const outputV = output.getData();
    const inputV = input.getData();
    if (alpha >= 1) {
      if (outFormat === ScalarMappingTarget.RGBA) {
        for (let i6 = 0; i6 < length4; i6++) {
          const cptr = lookupFunc(inputV[i6 * inIncr + inputOffset], model.table, p3);
          outputV[i6 * 4] = cptr[0];
          outputV[i6 * 4 + 1] = cptr[1];
          outputV[i6 * 4 + 2] = cptr[2];
          outputV[i6 * 4 + 3] = cptr[3];
        }
      }
    } else {
      if (outFormat === ScalarMappingTarget.RGBA) {
        for (let i6 = 0; i6 < length4; i6++) {
          const cptr = lookupFunc(inputV[i6 * inIncr + inputOffset], model.table, p3);
          outputV[i6 * 4] = cptr[0];
          outputV[i6 * 4 + 1] = cptr[1];
          outputV[i6 * 4 + 2] = cptr[2];
          outputV[i6 * 4 + 3] = Math.floor(cptr[3] * alpha + 0.5);
        }
      }
    }
  };
  publicAPI.forceBuild = () => {
    let hinc = 0;
    let sinc = 0;
    let vinc = 0;
    let ainc = 0;
    const maxIndex = model.numberOfColors - 1;
    if (maxIndex) {
      hinc = (model.hueRange[1] - model.hueRange[0]) / maxIndex;
      sinc = (model.saturationRange[1] - model.saturationRange[0]) / maxIndex;
      vinc = (model.valueRange[1] - model.valueRange[0]) / maxIndex;
      ainc = (model.alphaRange[1] - model.alphaRange[0]) / maxIndex;
    }
    model.table.length = 4 * maxIndex + 16;
    const hsv = [];
    const rgba = [];
    for (let i6 = 0; i6 <= maxIndex; i6++) {
      hsv[0] = model.hueRange[0] + i6 * hinc;
      hsv[1] = model.saturationRange[0] + i6 * sinc;
      hsv[2] = model.valueRange[0] + i6 * vinc;
      hsv2rgb(hsv, rgba);
      rgba[3] = model.alphaRange[0] + i6 * ainc;
      model.table[i6 * 4] = rgba[0] * 255 + 0.5;
      model.table[i6 * 4 + 1] = rgba[1] * 255 + 0.5;
      model.table[i6 * 4 + 2] = rgba[2] * 255 + 0.5;
      model.table[i6 * 4 + 3] = rgba[3] * 255 + 0.5;
    }
    publicAPI.buildSpecialColors();
    model.buildTime.modified();
  };
  publicAPI.setTable = (table) => {
    if (Array.isArray(table)) {
      const nbComponents = table[0].length;
      model.numberOfColors = table.length;
      const colorOffset = 4 - nbComponents;
      let offset3 = 0;
      for (let i6 = 0; i6 < model.numberOfColors; i6++) {
        model.table[i6 * 4] = 255;
        model.table[i6 * 4 + 1] = 255;
        model.table[i6 * 4 + 2] = 255;
        model.table[i6 * 4 + 3] = 255;
      }
      for (let i6 = 0; i6 < table.length; i6++) {
        const color = table[i6];
        for (let j2 = 0; j2 < nbComponents; j2++) {
          model.table[offset3++] = color[j2];
        }
        offset3 += colorOffset;
      }
      publicAPI.buildSpecialColors();
      model.insertTime.modified();
      publicAPI.modified();
      return true;
    }
    if (table.getNumberOfComponents() !== 4) {
      vtkErrorMacro30("Expected 4 components for RGBA colors");
      return false;
    }
    if (table.getDataType() !== VtkDataTypes.UNSIGNED_CHAR) {
      vtkErrorMacro30("Expected unsigned char values for RGBA colors");
      return false;
    }
    model.numberOfColors = table.getNumberOfTuples();
    const data = table.getData();
    model.table.length = data.length;
    for (let i6 = 0; i6 < data.length; i6++) {
      model.table[i6] = data[i6];
    }
    publicAPI.buildSpecialColors();
    model.insertTime.modified();
    publicAPI.modified();
    return true;
  };
  publicAPI.buildSpecialColors = () => {
    const {
      numberOfColors
    } = model;
    const tptr = model.table;
    let base = (numberOfColors + BELOW_RANGE_COLOR_INDEX) * 4;
    if (model.useBelowRangeColor || numberOfColors === 0) {
      tptr[base] = model.belowRangeColor[0] * 255 + 0.5;
      tptr[base + 1] = model.belowRangeColor[1] * 255 + 0.5;
      tptr[base + 2] = model.belowRangeColor[2] * 255 + 0.5;
      tptr[base + 3] = model.belowRangeColor[3] * 255 + 0.5;
    } else {
      tptr[base] = tptr[0];
      tptr[base + 1] = tptr[1];
      tptr[base + 2] = tptr[2];
      tptr[base + 3] = tptr[3];
    }
    base = (numberOfColors + ABOVE_RANGE_COLOR_INDEX) * 4;
    if (model.useAboveRangeColor || numberOfColors === 0) {
      tptr[base] = model.aboveRangeColor[0] * 255 + 0.5;
      tptr[base + 1] = model.aboveRangeColor[1] * 255 + 0.5;
      tptr[base + 2] = model.aboveRangeColor[2] * 255 + 0.5;
      tptr[base + 3] = model.aboveRangeColor[3] * 255 + 0.5;
    } else {
      tptr[base] = tptr[4 * (numberOfColors - 1) + 0];
      tptr[base + 1] = tptr[4 * (numberOfColors - 1) + 1];
      tptr[base + 2] = tptr[4 * (numberOfColors - 1) + 2];
      tptr[base + 3] = tptr[4 * (numberOfColors - 1) + 3];
    }
    base = (numberOfColors + NAN_COLOR_INDEX) * 4;
    tptr[base] = model.nanColor[0] * 255 + 0.5;
    tptr[base + 1] = model.nanColor[1] * 255 + 0.5;
    tptr[base + 2] = model.nanColor[2] * 255 + 0.5;
    tptr[base + 3] = model.nanColor[3] * 255 + 0.5;
  };
  publicAPI.build = () => {
    if (model.table.length < 1 || publicAPI.getMTime() > model.buildTime.getMTime() && model.insertTime.getMTime() <= model.buildTime.getMTime()) {
      publicAPI.forceBuild();
    }
  };
  if (model.table.length > 0) {
    publicAPI.buildSpecialColors();
    model.insertTime.modified();
  }
}
var DEFAULT_VALUES80 = {
  numberOfColors: 256,
  // table: null,
  hueRange: [0, 0.66667],
  saturationRange: [1, 1],
  valueRange: [1, 1],
  alphaRange: [1, 1],
  nanColor: [0.5, 0, 0, 1],
  belowRangeColor: [0, 0, 0, 1],
  aboveRangeColor: [1, 1, 1, 1],
  useAboveRangeColor: false,
  useBelowRangeColor: false,
  alpha: 1
  // buildTime: null,
  // opaqueFlagBuildTime: null,
  // insertTime: null,
};
function extend82(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES80, initialValues);
  vtkScalarsToColors$1.extend(publicAPI, model, initialValues);
  if (!model.table) {
    model.table = [];
  }
  model.buildTime = {};
  macro.obj(model.buildTime);
  model.opaqueFlagBuildTime = {};
  macro.obj(model.opaqueFlagBuildTime, {
    mtime: 0
  });
  model.insertTime = {};
  macro.obj(model.insertTime, {
    mtime: 0
  });
  macro.get(publicAPI, model, ["buildTime"]);
  macro.setGet(publicAPI, model, ["numberOfColors", "useAboveRangeColor", "useBelowRangeColor"]);
  macro.setArray(publicAPI, model, ["alphaRange", "hueRange", "saturationRange", "valueRange"], 2);
  macro.setArray(publicAPI, model, ["nanColor", "belowRangeColor", "aboveRangeColor"], 4);
  macro.getArray(publicAPI, model, ["hueRange", "saturationRange", "valueRange", "alphaRange", "nanColor", "belowRangeColor", "aboveRangeColor"]);
  vtkLookupTable(publicAPI, model);
}
var newInstance81 = macro.newInstance(extend82, "vtkLookupTable");
var vtkLookupTable$1 = {
  newInstance: newInstance81,
  extend: extend82
};

// node_modules/@kitware/vtk.js/Rendering/OpenGL/HardwareSelector/Constants.js
var PassTypes = {
  MIN_KNOWN_PASS: 0,
  ACTOR_PASS: 0,
  COMPOSITE_INDEX_PASS: 1,
  ID_LOW24: 2,
  ID_HIGH24: 3,
  MAX_KNOWN_PASS: 3
};
var Constants14 = {
  PassTypes
};

// node_modules/@kitware/vtk.js/Rendering/Core/Mapper.js
var {
  FieldAssociations: FieldAssociations2
} = vtkDataSet$1;
var {
  staticOffsetAPI: staticOffsetAPI3,
  otherStaticMethods: otherStaticMethods3
} = CoincidentTopologyHelper;
var {
  ColorMode: ColorMode3,
  ScalarMode: ScalarMode2,
  GetArray: GetArray2
} = Constants13;
var {
  VectorMode: VectorMode3
} = vtkScalarsToColors;
var {
  VtkDataTypes: VtkDataTypes5
} = vtkDataArray$1;
function notImplemented6(method) {
  return () => macro.vtkErrorMacro(`vtkMapper::${method} - NOT IMPLEMENTED`);
}
function vtkMapper(publicAPI, model) {
  model.classHierarchy.push("vtkMapper");
  publicAPI.getBounds = () => {
    const input = publicAPI.getInputData();
    if (!input) {
      model.bounds = createUninitializedBounds();
    } else {
      if (!model.static) {
        publicAPI.update();
      }
      model.bounds = input.getBounds();
    }
    return model.bounds;
  };
  publicAPI.setForceCompileOnly = (v2) => {
    model.forceCompileOnly = v2;
  };
  publicAPI.setSelectionWebGLIdsToVTKIds = (selectionWebGLIdsToVTKIds) => {
    model.selectionWebGLIdsToVTKIds = selectionWebGLIdsToVTKIds;
  };
  publicAPI.createDefaultLookupTable = () => {
    model.lookupTable = vtkLookupTable$1.newInstance();
  };
  publicAPI.getColorModeAsString = () => macro.enumToString(ColorMode3, model.colorMode);
  publicAPI.setColorModeToDefault = () => publicAPI.setColorMode(0);
  publicAPI.setColorModeToMapScalars = () => publicAPI.setColorMode(1);
  publicAPI.setColorModeToDirectScalars = () => publicAPI.setColorMode(2);
  publicAPI.getScalarModeAsString = () => macro.enumToString(ScalarMode2, model.scalarMode);
  publicAPI.setScalarModeToDefault = () => publicAPI.setScalarMode(0);
  publicAPI.setScalarModeToUsePointData = () => publicAPI.setScalarMode(1);
  publicAPI.setScalarModeToUseCellData = () => publicAPI.setScalarMode(2);
  publicAPI.setScalarModeToUsePointFieldData = () => publicAPI.setScalarMode(3);
  publicAPI.setScalarModeToUseCellFieldData = () => publicAPI.setScalarMode(4);
  publicAPI.setScalarModeToUseFieldData = () => publicAPI.setScalarMode(5);
  publicAPI.getAbstractScalars = (input, scalarMode, arrayAccessMode, arrayId, arrayName) => {
    if (!input || !model.scalarVisibility) {
      return {
        scalars: null,
        cellFLag: false
      };
    }
    let scalars = null;
    let cellFlag = false;
    if (scalarMode === ScalarMode2.DEFAULT) {
      scalars = input.getPointData().getScalars();
      if (!scalars) {
        scalars = input.getCellData().getScalars();
        cellFlag = true;
      }
    } else if (scalarMode === ScalarMode2.USE_POINT_DATA) {
      scalars = input.getPointData().getScalars();
    } else if (scalarMode === ScalarMode2.USE_CELL_DATA) {
      scalars = input.getCellData().getScalars();
      cellFlag = true;
    } else if (scalarMode === ScalarMode2.USE_POINT_FIELD_DATA) {
      const pd = input.getPointData();
      if (arrayAccessMode === GetArray2.BY_ID) {
        scalars = pd.getArrayByIndex(arrayId);
      } else {
        scalars = pd.getArrayByName(arrayName);
      }
    } else if (scalarMode === ScalarMode2.USE_CELL_FIELD_DATA) {
      const cd = input.getCellData();
      cellFlag = true;
      if (arrayAccessMode === GetArray2.BY_ID) {
        scalars = cd.getArrayByIndex(arrayId);
      } else {
        scalars = cd.getArrayByName(arrayName);
      }
    } else if (scalarMode === ScalarMode2.USE_FIELD_DATA) {
      const fd = input.getFieldData();
      if (arrayAccessMode === GetArray2.BY_ID) {
        scalars = fd.getArrayByIndex(arrayId);
      } else {
        scalars = fd.getArrayByName(arrayName);
      }
    }
    return {
      scalars,
      cellFlag
    };
  };
  publicAPI.mapScalars = (input, alpha) => {
    const scalars = publicAPI.getAbstractScalars(input, model.scalarMode, model.arrayAccessMode, model.arrayId, model.colorByArrayName).scalars;
    if (!scalars) {
      model.colorCoordinates = null;
      model.colorTextureMap = null;
      model.colorMapColors = null;
      return;
    }
    const toString3 = `${publicAPI.getMTime()}${scalars.getMTime()}${alpha}`;
    if (model.colorBuildString === toString3) return;
    if (!model.useLookupTableScalarRange) {
      publicAPI.getLookupTable().setRange(model.scalarRange[0], model.scalarRange[1]);
    }
    if (publicAPI.canUseTextureMapForColoring(input)) {
      publicAPI.mapScalarsToTexture(scalars, alpha);
    } else {
      model.colorCoordinates = null;
      model.colorTextureMap = null;
      const lut = publicAPI.getLookupTable();
      if (lut) {
        lut.build();
        model.colorMapColors = lut.mapScalars(scalars, model.colorMode, model.fieldDataTupleId);
      }
    }
    model.colorBuildString = `${publicAPI.getMTime()}${scalars.getMTime()}${alpha}`;
  };
  publicAPI.scalarToTextureCoordinate = (scalarValue, rangeMin, invRangeWidth) => {
    let texCoordS = 0.5;
    let texCoordT = 1;
    if (!isNan(scalarValue)) {
      texCoordT = 0.49;
      texCoordS = (scalarValue - rangeMin) * invRangeWidth;
      if (texCoordS > 1e3) {
        texCoordS = 1e3;
      } else if (texCoordS < -1e3) {
        texCoordS = -1e3;
      }
    }
    return {
      texCoordS,
      texCoordT
    };
  };
  publicAPI.createColorTextureCoordinates = (input, output, numScalars, numComps, component, range, tableRange, tableNumberOfColors, useLogScale) => {
    const scalarTexelWidth = (range[1] - range[0]) / tableNumberOfColors;
    const paddedRange = [];
    paddedRange[0] = range[0] - scalarTexelWidth;
    paddedRange[1] = range[1] + scalarTexelWidth;
    const invRangeWidth = 1 / (paddedRange[1] - paddedRange[0]);
    const outputV = output.getData();
    const inputV = input.getData();
    let count = 0;
    let outputCount = 0;
    if (component < 0 || component >= numComps) {
      for (let scalarIdx = 0; scalarIdx < numScalars; ++scalarIdx) {
        let sum = 0;
        for (let compIdx = 0; compIdx < numComps; ++compIdx) {
          sum += inputV[count] * inputV[count];
          count++;
        }
        let magnitude = Math.sqrt(sum);
        if (useLogScale) {
          magnitude = vtkLookupTable$1.applyLogScale(magnitude, tableRange, range);
        }
        const outputs = publicAPI.scalarToTextureCoordinate(magnitude, paddedRange[0], invRangeWidth);
        outputV[outputCount] = outputs.texCoordS;
        outputV[outputCount + 1] = outputs.texCoordT;
        outputCount += 2;
      }
    } else {
      count += component;
      for (let scalarIdx = 0; scalarIdx < numScalars; ++scalarIdx) {
        let inputValue = inputV[count];
        if (useLogScale) {
          inputValue = vtkLookupTable$1.applyLogScale(inputValue, tableRange, range);
        }
        const outputs = publicAPI.scalarToTextureCoordinate(inputValue, paddedRange[0], invRangeWidth);
        outputV[outputCount] = outputs.texCoordS;
        outputV[outputCount + 1] = outputs.texCoordT;
        outputCount += 2;
        count += numComps;
      }
    }
  };
  publicAPI.mapScalarsToTexture = (scalars, alpha) => {
    const range = model.lookupTable.getRange();
    const useLogScale = model.lookupTable.usingLogScale();
    if (useLogScale) {
      vtkLookupTable$1.getLogRange(range, range);
    }
    const origAlpha = model.lookupTable.getAlpha();
    model.colorMapColors = null;
    if (model.colorTextureMap == null || publicAPI.getMTime() > model.colorTextureMap.getMTime() || model.lookupTable.getMTime() > model.colorTextureMap.getMTime() || model.lookupTable.getAlpha() !== alpha) {
      model.lookupTable.setAlpha(alpha);
      model.colorTextureMap = null;
      model.lookupTable.build();
      let numberOfColors = model.lookupTable.getNumberOfAvailableColors();
      if (numberOfColors > 4094) {
        numberOfColors = 4094;
      }
      if (numberOfColors < 64) {
        numberOfColors = 64;
      }
      numberOfColors += 2;
      const k2 = (range[1] - range[0]) / (numberOfColors - 2);
      const newArray = new Float64Array(numberOfColors * 2);
      for (let i6 = 0; i6 < numberOfColors; ++i6) {
        newArray[i6] = range[0] + i6 * k2 - k2 / 2;
        if (useLogScale) {
          newArray[i6] = __pow(10, newArray[i6]);
        }
      }
      for (let i6 = 0; i6 < numberOfColors; ++i6) {
        newArray[i6 + numberOfColors] = NaN;
      }
      model.colorTextureMap = vtkImageData$1.newInstance();
      model.colorTextureMap.setExtent(0, numberOfColors - 1, 0, 1, 0, 0);
      const tmp = vtkDataArray$1.newInstance({
        numberOfComponents: 1,
        values: newArray
      });
      model.colorTextureMap.getPointData().setScalars(model.lookupTable.mapScalars(tmp, model.colorMode, 0));
      model.lookupTable.setAlpha(origAlpha);
    }
    if (!model.colorCoordinates || publicAPI.getMTime() > model.colorCoordinates.getMTime() || publicAPI.getInputData(0).getMTime() > model.colorCoordinates.getMTime() || model.lookupTable.getMTime() > model.colorCoordinates.getMTime()) {
      model.colorCoordinates = null;
      const numComps = scalars.getNumberOfComponents();
      const num = scalars.getNumberOfTuples();
      model.colorCoordinates = vtkDataArray$1.newInstance({
        numberOfComponents: 2,
        values: new Float32Array(num * 2)
      });
      let scalarComponent = model.lookupTable.getVectorComponent();
      if (model.lookupTable.getVectorMode() === VectorMode3.MAGNITUDE && scalars.getNumberOfComponents() > 1) {
        scalarComponent = -1;
      }
      publicAPI.createColorTextureCoordinates(scalars, model.colorCoordinates, num, numComps, scalarComponent, range, model.lookupTable.getRange(), model.colorTextureMap.getPointData().getScalars().getNumberOfTuples() / 2 - 2, useLogScale);
    }
  };
  publicAPI.getIsOpaque = () => {
    const input = publicAPI.getInputData();
    const gasResult = publicAPI.getAbstractScalars(input, model.scalarMode, model.arrayAccessMode, model.arrayId, model.colorByArrayName);
    const scalars = gasResult.scalars;
    if (!model.scalarVisibility || scalars == null) {
      return true;
    }
    const lut = publicAPI.getLookupTable();
    if (lut) {
      lut.build();
      return lut.areScalarsOpaque(scalars, model.colorMode, -1);
    }
    return true;
  };
  publicAPI.canUseTextureMapForColoring = (input) => {
    if (!model.interpolateScalarsBeforeMapping) {
      return false;
    }
    if (model.lookupTable && model.lookupTable.getIndexedLookup()) {
      return false;
    }
    const gasResult = publicAPI.getAbstractScalars(input, model.scalarMode, model.arrayAccessMode, model.arrayId, model.colorByArrayName);
    const scalars = gasResult.scalars;
    if (!scalars) {
      return false;
    }
    if (gasResult.cellFlag) {
      return false;
    }
    if (model.colorMode === ColorMode3.DEFAULT && scalars.getDataType() === VtkDataTypes5.UNSIGNED_CHAR || model.colorMode === ColorMode3.DIRECT_SCALARS) {
      return false;
    }
    return true;
  };
  publicAPI.clearColorArrays = () => {
    model.colorMapColors = null;
    model.colorCoordinates = null;
    model.colorTextureMap = null;
  };
  publicAPI.getLookupTable = () => {
    if (!model.lookupTable) {
      publicAPI.createDefaultLookupTable();
    }
    return model.lookupTable;
  };
  publicAPI.getMTime = () => {
    let mt = model.mtime;
    if (model.lookupTable !== null) {
      const time = model.lookupTable.getMTime();
      mt = time > mt ? time : mt;
    }
    return mt;
  };
  publicAPI.getPrimitiveCount = () => {
    const input = publicAPI.getInputData();
    const pcount = {
      points: input.getPoints().getNumberOfValues() / 3,
      verts: input.getVerts().getNumberOfValues() - input.getVerts().getNumberOfCells(),
      lines: input.getLines().getNumberOfValues() - 2 * input.getLines().getNumberOfCells(),
      triangles: input.getPolys().getNumberOfValues() - 3 * input.getPolys().getNumberOfCells()
    };
    return pcount;
  };
  publicAPI.acquireInvertibleLookupTable = notImplemented6("AcquireInvertibleLookupTable");
  publicAPI.valueToColor = notImplemented6("ValueToColor");
  publicAPI.colorToValue = notImplemented6("ColorToValue");
  publicAPI.useInvertibleColorFor = notImplemented6("UseInvertibleColorFor");
  publicAPI.clearInvertibleColor = notImplemented6("ClearInvertibleColor");
  publicAPI.processSelectorPixelBuffers = (selector, pixelOffsets) => {
    if (!selector || !model.selectionWebGLIdsToVTKIds || !model.populateSelectionSettings) {
      return;
    }
    const rawLowData = selector.getRawPixelBuffer(PassTypes.ID_LOW24);
    const rawHighData = selector.getRawPixelBuffer(PassTypes.ID_HIGH24);
    const currentPass = selector.getCurrentPass();
    const fieldAssociation = selector.getFieldAssociation();
    let idMap = null;
    if (fieldAssociation === FieldAssociations2.FIELD_ASSOCIATION_POINTS) {
      idMap = model.selectionWebGLIdsToVTKIds.points;
    } else if (fieldAssociation === FieldAssociations2.FIELD_ASSOCIATION_CELLS) {
      idMap = model.selectionWebGLIdsToVTKIds.cells;
    }
    if (!idMap) {
      return;
    }
    pixelOffsets.forEach((pos) => {
      if (currentPass === PassTypes.ID_LOW24) {
        let inValue = 0;
        if (rawHighData) {
          inValue += rawHighData[pos];
          inValue *= 256;
        }
        inValue += rawLowData[pos + 2];
        inValue *= 256;
        inValue += rawLowData[pos + 1];
        inValue *= 256;
        inValue += rawLowData[pos];
        const outValue = idMap[inValue];
        const lowData = selector.getPixelBuffer(PassTypes.ID_LOW24);
        lowData[pos] = outValue & 255;
        lowData[pos + 1] = (outValue & 65280) >> 8;
        lowData[pos + 2] = (outValue & 16711680) >> 16;
      } else if (currentPass === PassTypes.ID_HIGH24 && rawHighData) {
        let inValue = 0;
        inValue += rawHighData[pos];
        inValue *= 256;
        inValue += rawLowData[pos];
        inValue *= 256;
        inValue += rawLowData[pos + 1];
        inValue *= 256;
        inValue += rawLowData[pos + 2];
        const outValue = idMap[inValue];
        const highData = selector.getPixelBuffer(PassTypes.ID_HIGH24);
        highData[pos] = (outValue & 4278190080) >> 24;
      }
    });
  };
}
var DEFAULT_VALUES81 = {
  colorMapColors: null,
  // Same as this->Colors
  static: false,
  lookupTable: null,
  scalarVisibility: true,
  scalarRange: [0, 1],
  useLookupTableScalarRange: false,
  colorMode: 0,
  scalarMode: 0,
  arrayAccessMode: 1,
  // By_NAME
  renderTime: 0,
  colorByArrayName: null,
  fieldDataTupleId: -1,
  populateSelectionSettings: true,
  selectionWebGLIdsToVTKIds: null,
  interpolateScalarsBeforeMapping: false,
  colorCoordinates: null,
  colorTextureMap: null,
  forceCompileOnly: 0,
  useInvertibleColors: false,
  invertibleScalars: null,
  customShaderAttributes: []
};
function extend83(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES81, initialValues);
  vtkAbstractMapper3D$1.extend(publicAPI, model, initialValues);
  macro.get(publicAPI, model, ["colorCoordinates", "colorMapColors", "colorTextureMap", "selectionWebGLIdsToVTKIds"]);
  macro.setGet(publicAPI, model, [
    "colorByArrayName",
    "arrayAccessMode",
    "colorMode",
    "fieldDataTupleId",
    "interpolateScalarsBeforeMapping",
    "lookupTable",
    "populateSelectionSettings",
    "renderTime",
    "scalarMode",
    "scalarVisibility",
    "static",
    "useLookupTableScalarRange",
    "customShaderAttributes"
    // point data array names that will be transferred to the VBO
  ]);
  macro.setGetArray(publicAPI, model, ["scalarRange"], 2);
  CoincidentTopologyHelper.implementCoincidentTopologyMethods(publicAPI, model);
  vtkMapper(publicAPI, model);
}
var newInstance82 = macro.newInstance(extend83, "vtkMapper");
var vtkMapper$1 = __spreadValues(__spreadValues(__spreadValues({
  newInstance: newInstance82,
  extend: extend83
}, staticOffsetAPI3), otherStaticMethods3), Constants13);

// node_modules/@kitware/vtk.js/Rendering/SceneGraph/RenderPass.js
function vtkRenderPass(publicAPI, model) {
  model.classHierarchy.push("vtkRenderPass");
  publicAPI.getOperation = () => model.currentOperation;
  publicAPI.setCurrentOperation = (val) => {
    model.currentOperation = val;
    model.currentTraverseOperation = `traverse${macro.capitalize(model.currentOperation)}`;
  };
  publicAPI.getTraverseOperation = () => model.currentTraverseOperation;
  publicAPI.traverse = function(viewNode) {
    let parent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    if (model.deleted) {
      return;
    }
    model._currentParent = parent;
    model.preDelegateOperations.forEach((val) => {
      publicAPI.setCurrentOperation(val);
      viewNode.traverse(publicAPI);
    });
    model.delegates.forEach((val) => {
      val.traverse(viewNode, publicAPI);
    });
    model.postDelegateOperations.forEach((val) => {
      publicAPI.setCurrentOperation(val);
      viewNode.traverse(publicAPI);
    });
  };
}
var DEFAULT_VALUES82 = {
  delegates: [],
  currentOperation: null,
  preDelegateOperations: [],
  postDelegateOperations: [],
  currentParent: null
};
function extend84(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES82, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["currentOperation"]);
  macro.setGet(publicAPI, model, ["delegates", "_currentParent", "preDelegateOperations", "postDelegateOperations"]);
  macro.moveToProtected(publicAPI, model, ["currentParent"]);
  vtkRenderPass(publicAPI, model);
}
var newInstance83 = macro.newInstance(extend84, "vtkRenderPass");
var vtkRenderPass$1 = {
  newInstance: newInstance83,
  extend: extend84
};

// node_modules/@kitware/vtk.js/Rendering/OpenGL/OrderIndependentTranslucentPass.js
var {
  Representation: Representation4
} = vtkProperty$1;
var {
  vtkErrorMacro: vtkErrorMacro31
} = macro;
function translucentShaderReplacement(shaders) {
  const substituteRes = vtkShaderProgram$1.substitute(shaders.Fragment, "//VTK::RenderPassFragmentShader::Impl", `
      float weight = gl_FragData[0].a * pow(max(1.1 - gl_FragCoord.z, 0.0), 2.0);
      gl_FragData[0] = vec4(gl_FragData[0].rgb*weight, gl_FragData[0].a);
      gl_FragData[1].r = weight;
    `, false);
  shaders.Fragment = substituteRes.result;
}
var oitpFragTemplate = `//VTK::System::Dec

in vec2 tcoord;

uniform sampler2D translucentRTexture;
uniform sampler2D translucentRGBATexture;

// the output of this shader
//VTK::Output::Dec

void main()
{
  vec4 t1Color = texture(translucentRGBATexture, tcoord);
  float t2Color = texture(translucentRTexture, tcoord).r;
  gl_FragData[0] = vec4(t1Color.rgb/max(t2Color,0.01), 1.0 - t1Color.a);
}
`;
function vtkOpenGLOrderIndependentTranslucentPass(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLOrderIndependentTranslucentPass");
  publicAPI.createVertexBuffer = () => {
    const ptsArray = new Float32Array([-1, -1, -1, 1, -1, -1, -1, 1, -1, 1, 1, -1]);
    const tcoordArray = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]);
    const cellArray = new Uint16Array([4, 0, 1, 3, 2]);
    const points = vtkDataArray$1.newInstance({
      numberOfComponents: 3,
      values: ptsArray
    });
    points.setName("points");
    const tcoords = vtkDataArray$1.newInstance({
      numberOfComponents: 2,
      values: tcoordArray
    });
    tcoords.setName("tcoords");
    const cells = vtkDataArray$1.newInstance({
      numberOfComponents: 1,
      values: cellArray
    });
    model.tris.getCABO().createVBO(cells, "polys", Representation4.SURFACE, {
      points,
      tcoords,
      cellOffset: 0
    });
    model.VBOBuildTime.modified();
  };
  publicAPI.createFramebuffer = (viewNode) => {
    const size3 = viewNode.getSize();
    const gl = viewNode.getContext();
    model.framebuffer = vtkOpenGLFramebuffer.newInstance();
    model.framebuffer.setOpenGLRenderWindow(viewNode);
    model.framebuffer.create(...size3);
    model.framebuffer.saveCurrentBindingsAndBuffers();
    model.framebuffer.bind();
    model.translucentRGBATexture = vtkOpenGLTexture$1.newInstance();
    model.translucentRGBATexture.setInternalFormat(gl.RGBA16F);
    model.translucentRGBATexture.setFormat(gl.RGBA);
    model.translucentRGBATexture.setOpenGLDataType(gl.HALF_FLOAT);
    model.translucentRGBATexture.setOpenGLRenderWindow(viewNode);
    model.translucentRGBATexture.create2DFromRaw(size3[0], size3[1], 4, "Float32Array", null);
    model.translucentRTexture = vtkOpenGLTexture$1.newInstance();
    model.translucentRTexture.setInternalFormat(gl.R16F);
    model.translucentRTexture.setFormat(gl.RED);
    model.translucentRTexture.setOpenGLDataType(gl.HALF_FLOAT);
    model.translucentRTexture.setOpenGLRenderWindow(viewNode);
    model.translucentRTexture.create2DFromRaw(size3[0], size3[1], 1, "Float32Array", null);
    model.translucentZTexture = vtkOpenGLTexture$1.newInstance();
    model.translucentZTexture.setOpenGLRenderWindow(viewNode);
    model.translucentZTexture.createDepthFromRaw(size3[0], size3[1], "Float32Array", null);
    model.framebuffer.setColorBuffer(model.translucentRGBATexture, 0);
    model.framebuffer.setColorBuffer(model.translucentRTexture, 1);
    model.framebuffer.setDepthBuffer(model.translucentZTexture);
  };
  publicAPI.createCopyShader = (viewNode) => {
    model.copyShader = viewNode.getShaderCache().readyShaderProgramArray(["//VTK::System::Dec", "attribute vec4 vertexDC;", "attribute vec2 tcoordTC;", "varying vec2 tcoord;", "void main() { tcoord = tcoordTC; gl_Position = vertexDC; }"].join("\n"), oitpFragTemplate, "");
  };
  publicAPI.createVBO = (viewNode) => {
    const gl = viewNode.getContext();
    model.tris.setOpenGLRenderWindow(viewNode);
    publicAPI.createVertexBuffer();
    const program = model.copyShader;
    model.tris.getCABO().bind();
    if (!model.copyVAO.addAttributeArray(program, model.tris.getCABO(), "vertexDC", model.tris.getCABO().getVertexOffset(), model.tris.getCABO().getStride(), gl.FLOAT, 3, gl.FALSE)) {
      vtkErrorMacro31("Error setting vertexDC in copy shader VAO.");
    }
    if (!model.copyVAO.addAttributeArray(program, model.tris.getCABO(), "tcoordTC", model.tris.getCABO().getTCoordOffset(), model.tris.getCABO().getStride(), gl.FLOAT, 2, gl.FALSE)) {
      vtkErrorMacro31("Error setting vertexDC in copy shader VAO.");
    }
  };
  publicAPI.traverse = (viewNode, renNode, forwardPass) => {
    if (model.deleted) {
      return;
    }
    const size3 = viewNode.getSize();
    const gl = viewNode.getContext();
    model._supported = false;
    if (renNode.getSelector() || !gl || !viewNode.getWebgl2() || !gl.getExtension("EXT_color_buffer_half_float") && !gl.getExtension("EXT_color_buffer_float")) {
      publicAPI.setCurrentOperation("translucentPass");
      renNode.traverse(publicAPI);
      return;
    }
    model._supported = true;
    if (model.framebuffer === null) {
      publicAPI.createFramebuffer(viewNode);
    } else {
      const fbSize = model.framebuffer.getSize();
      if (fbSize === null || fbSize[0] !== size3[0] || fbSize[1] !== size3[1]) {
        model.framebuffer.releaseGraphicsResources();
        model.translucentRGBATexture.releaseGraphicsResources(viewNode);
        model.translucentRTexture.releaseGraphicsResources(viewNode);
        model.translucentZTexture.releaseGraphicsResources(viewNode);
        publicAPI.createFramebuffer(viewNode);
      } else {
        model.framebuffer.saveCurrentBindingsAndBuffers();
        model.framebuffer.bind();
      }
    }
    gl.drawBuffers([gl.COLOR_ATTACHMENT0]);
    gl.clearBufferfv(gl.COLOR, 0, [0, 0, 0, 0]);
    gl.clearBufferfv(gl.DEPTH, 0, [1]);
    gl.colorMask(false, false, false, false);
    if (forwardPass.getOpaqueActorCount() > 0) {
      forwardPass.setCurrentOperation("opaqueZBufferPass");
      renNode.traverse(forwardPass);
    }
    gl.colorMask(true, true, true, true);
    gl.drawBuffers([gl.COLOR_ATTACHMENT0, gl.COLOR_ATTACHMENT1]);
    gl.viewport(0, 0, size3[0], size3[1]);
    gl.scissor(0, 0, size3[0], size3[1]);
    gl.clearBufferfv(gl.COLOR, 0, [0, 0, 0, 1]);
    gl.clearBufferfv(gl.COLOR, 1, [0, 0, 0, 0]);
    gl.enable(gl.DEPTH_TEST);
    gl.enable(gl.BLEND);
    gl.blendFuncSeparate(gl.ONE, gl.ONE, gl.ZERO, gl.ONE_MINUS_SRC_ALPHA);
    publicAPI.setCurrentOperation("translucentPass");
    renNode.traverse(publicAPI);
    gl.drawBuffers([gl.NONE]);
    model.framebuffer.restorePreviousBindingsAndBuffers();
    if (model.copyShader === null) {
      publicAPI.createCopyShader(viewNode);
    } else {
      viewNode.getShaderCache().readyShaderProgram(model.copyShader);
    }
    if (!model.copyVAO) {
      model.copyVAO = vtkVertexArrayObject.newInstance();
      model.copyVAO.setOpenGLRenderWindow(viewNode);
    }
    model.copyVAO.bind();
    if (model.VBOBuildTime.getMTime() < publicAPI.getMTime()) {
      publicAPI.createVBO(viewNode);
    }
    gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
    gl.depthMask(false);
    gl.depthFunc(gl.ALWAYS);
    gl.viewport(0, 0, size3[0], size3[1]);
    gl.scissor(0, 0, size3[0], size3[1]);
    model.translucentRGBATexture.activate();
    model.copyShader.setUniformi("translucentRGBATexture", model.translucentRGBATexture.getTextureUnit());
    model.translucentRTexture.activate();
    model.copyShader.setUniformi("translucentRTexture", model.translucentRTexture.getTextureUnit());
    gl.drawArrays(gl.TRIANGLES, 0, model.tris.getCABO().getElementCount());
    gl.depthMask(true);
    gl.depthFunc(gl.LEQUAL);
    model.translucentRGBATexture.deactivate();
    model.translucentRTexture.deactivate();
    const ts = renNode.getTiledSizeAndOrigin();
    gl.scissor(ts.lowerLeftU, ts.lowerLeftV, ts.usize, ts.vsize);
    gl.viewport(ts.lowerLeftU, ts.lowerLeftV, ts.usize, ts.vsize);
  };
  publicAPI.getShaderReplacement = () => {
    if (model._supported) {
      return translucentShaderReplacement;
    }
    return null;
  };
  publicAPI.releaseGraphicsResources = (viewNode) => {
    if (model.framebuffer) {
      model.framebuffer.releaseGraphicsResources(viewNode);
      model.framebuffer = null;
    }
    if (model.translucentRGBATexture) {
      model.translucentRGBATexture.releaseGraphicsResources(viewNode);
      model.translucentRGBATexture = null;
    }
    if (model.translucentRTexture) {
      model.translucentRTexture.releaseGraphicsResources(viewNode);
      model.translucentRTexture = null;
    }
    if (model.translucentZTexture) {
      model.translucentZTexture.releaseGraphicsResources(viewNode);
      model.translucentZTexture = null;
    }
    if (model.copyVAO) {
      model.copyVAO.releaseGraphicsResources(viewNode);
      model.copyVAO = null;
    }
    if (model.copyShader) {
      model.copyShader.releaseGraphicsResources(viewNode);
      model.copyShader = null;
    }
    if (model.tris) {
      model.tris.releaseGraphicsResources(viewNode);
      model.tris = null;
    }
    publicAPI.modified();
  };
}
var DEFAULT_VALUES83 = {
  framebuffer: null,
  copyShader: null,
  tris: null
};
function extend85(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES83, initialValues);
  vtkRenderPass$1.extend(publicAPI, model, initialValues);
  model.VBOBuildTime = {};
  macro.obj(model.VBOBuildTime, {
    mtime: 0
  });
  model.tris = vtkHelper.newInstance();
  macro.get(publicAPI, model, ["framebuffer"]);
  vtkOpenGLOrderIndependentTranslucentPass(publicAPI, model);
}
var newInstance84 = macro.newInstance(extend85, "vtkOpenGLOrderIndependentTranslucentPass");
var vtkOpenGLOrderIndependentTranslucentPass$1 = {
  newInstance: newInstance84,
  extend: extend85
};

// node_modules/@kitware/vtk.js/Rendering/OpenGL/ForwardPass.js
function vtkForwardPass(publicAPI, model) {
  model.classHierarchy.push("vtkForwardPass");
  publicAPI.traverse = function(viewNode) {
    let parent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    if (model.deleted) {
      return;
    }
    model._currentParent = parent;
    publicAPI.setCurrentOperation("buildPass");
    viewNode.traverse(publicAPI);
    const numlayers = viewNode.getRenderable().getNumberOfLayers();
    const renderers = viewNode.getRenderable().getRenderersByReference();
    for (let i6 = 0; i6 < numlayers; i6++) {
      for (let index2 = 0; index2 < renderers.length; index2++) {
        const ren = renderers[index2];
        const renNode = viewNode.getViewNodeFor(ren);
        if (ren.getDraw() && ren.getLayer() === i6) {
          model.opaqueActorCount = 0;
          model.translucentActorCount = 0;
          model.volumeCount = 0;
          model.overlayActorCount = 0;
          publicAPI.setCurrentOperation("queryPass");
          renNode.traverse(publicAPI);
          if ((model.opaqueActorCount > 0 || model.translucentActorCount > 0) && model.volumeCount > 0 || model.depthRequested) {
            const size3 = viewNode.getFramebufferSize();
            if (model.framebuffer === null) {
              model.framebuffer = vtkOpenGLFramebuffer.newInstance();
            }
            model.framebuffer.setOpenGLRenderWindow(viewNode);
            model.framebuffer.saveCurrentBindingsAndBuffers();
            const fbSize = model.framebuffer.getSize();
            if (fbSize === null || fbSize[0] !== size3[0] || fbSize[1] !== size3[1]) {
              model.framebuffer.create(size3[0], size3[1]);
              model.framebuffer.populateFramebuffer();
            }
            model.framebuffer.bind();
            publicAPI.setCurrentOperation("zBufferPass");
            renNode.traverse(publicAPI);
            model.framebuffer.restorePreviousBindingsAndBuffers();
            model.depthRequested = false;
          }
          publicAPI.setCurrentOperation("cameraPass");
          renNode.traverse(publicAPI);
          if (model.opaqueActorCount > 0) {
            publicAPI.setCurrentOperation("opaquePass");
            renNode.traverse(publicAPI);
          }
          if (model.translucentActorCount > 0) {
            if (!model.translucentPass) {
              model.translucentPass = vtkOpenGLOrderIndependentTranslucentPass$1.newInstance();
            }
            model.translucentPass.traverse(viewNode, renNode, publicAPI);
          }
          if (model.volumeCount > 0) {
            publicAPI.setCurrentOperation("volumePass");
            renNode.traverse(publicAPI);
          }
          if (model.overlayActorCount > 0) {
            publicAPI.setCurrentOperation("overlayPass");
            renNode.traverse(publicAPI);
          }
        }
      }
    }
  };
  publicAPI.getZBufferTexture = () => {
    if (model.framebuffer) {
      return model.framebuffer.getColorTexture();
    }
    return null;
  };
  publicAPI.requestDepth = () => {
    model.depthRequested = true;
  };
  publicAPI.incrementOpaqueActorCount = () => model.opaqueActorCount++;
  publicAPI.incrementTranslucentActorCount = () => model.translucentActorCount++;
  publicAPI.incrementVolumeCount = () => model.volumeCount++;
  publicAPI.incrementOverlayActorCount = () => model.overlayActorCount++;
}
var DEFAULT_VALUES84 = {
  opaqueActorCount: 0,
  translucentActorCount: 0,
  volumeCount: 0,
  overlayActorCount: 0,
  framebuffer: null,
  depthRequested: false
};
function extend86(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES84, initialValues);
  vtkRenderPass$1.extend(publicAPI, model, initialValues);
  macro.get(publicAPI, model, ["framebuffer", "opaqueActorCount", "translucentActorCount", "volumeCount"]);
  vtkForwardPass(publicAPI, model);
}
var newInstance85 = macro.newInstance(extend86, "vtkForwardPass");
var vtkForwardPass$1 = {
  newInstance: newInstance85,
  extend: extend86
};

// node_modules/@kitware/vtk.js/Rendering/Core/HardwareSelector.js
var {
  FieldAssociations: FieldAssociations3
} = vtkDataSet$1;
function vtkHardwareSelector(publicAPI, model) {
  model.classHierarchy.push("vtkHardwareSelector");
  publicAPI.getSourceDataAsync = (renderer, fx1, fy1, fx2, fy2) => __async(this, null, function* () {
  });
  publicAPI.selectAsync = (renderer, fx1, fy1, fx2, fy2) => __async(this, null, function* () {
    const srcData = yield publicAPI.getSourceDataAsync(renderer, fx1, fy1, fx2, fy2);
    if (srcData) {
      return srcData.generateSelection(fx1, fy1, fx2, fy2);
    }
    return [];
  });
}
var DEFAULT_VALUES85 = {
  fieldAssociation: FieldAssociations3.FIELD_ASSOCIATION_CELLS,
  captureZValues: false
};
function extend87(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES85, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["fieldAssociation", "captureZValues"]);
  vtkHardwareSelector(publicAPI, model);
}
var newInstance86 = macro.newInstance(extend87, "vtkHardwareSelector");
var vtkHardwareSelector$1 = {
  newInstance: newInstance86,
  extend: extend87
};

// node_modules/@kitware/vtk.js/Common/DataModel/SelectionNode/Constants.js
var SelectionContent = {
  GLOBALIDS: 0,
  PEDIGREEIDS: 1,
  VALUES: 2,
  INDICES: 3,
  FRUSTUM: 4,
  LOCATIONS: 5,
  THRESHOLDS: 6,
  BLOCKS: 7,
  QUERY: 8
};
var SelectionField = {
  CELL: 0,
  POINT: 1,
  FIELD: 2,
  VERTEX: 3,
  EDGE: 4,
  ROW: 5
};
var Constants15 = {
  SelectionContent,
  SelectionField
};

// node_modules/@kitware/vtk.js/Common/DataModel/SelectionNode.js
function vtkSelectionNode(publicAPI, model) {
  model.classHierarchy.push("vtkSelectionNode");
  publicAPI.getBounds = () => model.points.getBounds();
}
var DEFAULT_VALUES86 = {
  contentType: -1,
  fieldType: -1,
  properties: null,
  selectionList: []
};
function extend88(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES86, initialValues);
  macro.obj(publicAPI, model);
  model.properties = {};
  macro.setGet(publicAPI, model, ["contentType", "fieldType", "properties", "selectionList"]);
  vtkSelectionNode(publicAPI, model);
}
var newInstance87 = macro.newInstance(extend88, "vtkSelectionNode");
var vtkSelectionNode$1 = __spreadValues({
  newInstance: newInstance87,
  extend: extend88
}, Constants15);

// node_modules/@kitware/vtk.js/Rendering/OpenGL/HardwareSelector.js
var {
  PassTypes: PassTypes2
} = Constants14;
var {
  SelectionContent: SelectionContent2,
  SelectionField: SelectionField2
} = vtkSelectionNode$1;
var {
  FieldAssociations: FieldAssociations4
} = vtkDataSet$1;
var {
  vtkErrorMacro: vtkErrorMacro32
} = macro;
var idOffset = 1;
function getInfoHash(info) {
  return `${info.propID} ${info.compositeID}`;
}
function getAlpha(xx, yy, pb, area) {
  if (!pb) {
    return 0;
  }
  const offset3 = (yy * (area[2] - area[0] + 1) + xx) * 4;
  return pb[offset3 + 3];
}
function convert(xx, yy, pb, area) {
  if (!pb) {
    return 0;
  }
  const offset3 = (yy * (area[2] - area[0] + 1) + xx) * 4;
  const r9 = pb[offset3];
  const g2 = pb[offset3 + 1];
  const b3 = pb[offset3 + 2];
  return (b3 * 256 + g2) * 256 + r9;
}
function getID(low24, high8) {
  let val = high8;
  val <<= 24;
  val |= low24;
  return val;
}
function getPixelInformationWithData(buffdata, inDisplayPosition, maxDistance, outSelectedPosition) {
  const maxDist = maxDistance < 0 ? 0 : maxDistance;
  if (maxDist === 0) {
    outSelectedPosition[0] = inDisplayPosition[0];
    outSelectedPosition[1] = inDisplayPosition[1];
    if (inDisplayPosition[0] < buffdata.area[0] || inDisplayPosition[0] > buffdata.area[2] || inDisplayPosition[1] < buffdata.area[1] || inDisplayPosition[1] > buffdata.area[3]) {
      return null;
    }
    const displayPosition = [inDisplayPosition[0] - buffdata.area[0], inDisplayPosition[1] - buffdata.area[1]];
    const actorid = convert(displayPosition[0], displayPosition[1], buffdata.pixBuffer[PassTypes2.ACTOR_PASS], buffdata.area);
    if (actorid <= 0 || actorid - idOffset >= buffdata.props.length) {
      return null;
    }
    const info2 = {};
    info2.valid = true;
    info2.propID = actorid - idOffset;
    info2.prop = buffdata.props[info2.propID];
    let compositeID = convert(displayPosition[0], displayPosition[1], buffdata.pixBuffer[PassTypes2.COMPOSITE_INDEX_PASS], buffdata.area);
    if (compositeID < 0 || compositeID > 16777215) {
      compositeID = 0;
    }
    info2.compositeID = compositeID - idOffset;
    if (buffdata.captureZValues) {
      const offset3 = (displayPosition[1] * (buffdata.area[2] - buffdata.area[0] + 1) + displayPosition[0]) * 4;
      info2.zValue = (256 * buffdata.zBuffer[offset3] + buffdata.zBuffer[offset3 + 1]) / 65535;
      info2.displayPosition = inDisplayPosition;
    }
    if (buffdata.pixBuffer[PassTypes2.ID_LOW24]) {
      if (getAlpha(displayPosition[0], displayPosition[1], buffdata.pixBuffer[PassTypes2.ID_LOW24], buffdata.area) === 0) {
        return info2;
      }
    }
    const low24 = convert(displayPosition[0], displayPosition[1], buffdata.pixBuffer[PassTypes2.ID_LOW24], buffdata.area);
    const high24 = convert(displayPosition[0], displayPosition[1], buffdata.pixBuffer[PassTypes2.ID_HIGH24], buffdata.area);
    info2.attributeID = getID(low24, high24);
    return info2;
  }
  const dispPos = [inDisplayPosition[0], inDisplayPosition[1]];
  const curPos = [0, 0];
  let info = getPixelInformationWithData(buffdata, inDisplayPosition, 0, outSelectedPosition);
  if (info && info.valid) {
    return info;
  }
  for (let dist3 = 1; dist3 < maxDist; ++dist3) {
    for (let y3 = dispPos[1] > dist3 ? dispPos[1] - dist3 : 0; y3 <= dispPos[1] + dist3; ++y3) {
      curPos[1] = y3;
      if (dispPos[0] >= dist3) {
        curPos[0] = dispPos[0] - dist3;
        info = getPixelInformationWithData(buffdata, curPos, 0, outSelectedPosition);
        if (info && info.valid) {
          return info;
        }
      }
      curPos[0] = dispPos[0] + dist3;
      info = getPixelInformationWithData(buffdata, curPos, 0, outSelectedPosition);
      if (info && info.valid) {
        return info;
      }
    }
    for (let x2 = dispPos[0] >= dist3 ? dispPos[0] - (dist3 - 1) : 0; x2 <= dispPos[0] + (dist3 - 1); ++x2) {
      curPos[0] = x2;
      if (dispPos[1] >= dist3) {
        curPos[1] = dispPos[1] - dist3;
        info = getPixelInformationWithData(buffdata, curPos, 0, outSelectedPosition);
        if (info && info.valid) {
          return info;
        }
      }
      curPos[1] = dispPos[1] + dist3;
      info = getPixelInformationWithData(buffdata, curPos, 0, outSelectedPosition);
      if (info && info.valid) {
        return info;
      }
    }
  }
  outSelectedPosition[0] = inDisplayPosition[0];
  outSelectedPosition[1] = inDisplayPosition[1];
  return null;
}
function convertSelection(fieldassociation, dataMap, captureZValues, renderer, openGLRenderWindow) {
  const sel = [];
  let count = 0;
  dataMap.forEach((value, key) => {
    const child = vtkSelectionNode$1.newInstance();
    child.setContentType(SelectionContent2.INDICES);
    switch (fieldassociation) {
      case FieldAssociations4.FIELD_ASSOCIATION_CELLS:
        child.setFieldType(SelectionField2.CELL);
        break;
      case FieldAssociations4.FIELD_ASSOCIATION_POINTS:
        child.setFieldType(SelectionField2.POINT);
        break;
      default:
        vtkErrorMacro32("Unknown field association");
    }
    child.getProperties().propID = value.info.propID;
    child.getProperties().prop = value.info.prop;
    child.getProperties().compositeID = value.info.compositeID;
    child.getProperties().attributeID = value.info.attributeID;
    child.getProperties().pixelCount = value.pixelCount;
    if (captureZValues) {
      child.getProperties().displayPosition = [value.info.displayPosition[0], value.info.displayPosition[1], value.info.zValue];
      child.getProperties().worldPosition = openGLRenderWindow.displayToWorld(value.info.displayPosition[0], value.info.displayPosition[1], value.info.zValue, renderer);
    }
    child.setSelectionList(value.attributeIDs);
    sel[count] = child;
    count++;
  });
  return sel;
}
function generateSelectionWithData(buffdata, fx1, fy1, fx2, fy2) {
  const x1 = Math.floor(fx1);
  const y1 = Math.floor(fy1);
  const x2 = Math.floor(fx2);
  const y22 = Math.floor(fy2);
  const dataMap = /* @__PURE__ */ new Map();
  const outSelectedPosition = [0, 0];
  for (let yy = y1; yy <= y22; yy++) {
    for (let xx = x1; xx <= x2; xx++) {
      const pos = [xx, yy];
      const info = getPixelInformationWithData(buffdata, pos, 0, outSelectedPosition);
      if (info && info.valid) {
        const hash = getInfoHash(info);
        if (!dataMap.has(hash)) {
          dataMap.set(hash, {
            info,
            pixelCount: 1,
            attributeIDs: [info.attributeID]
          });
        } else {
          const dmv = dataMap.get(hash);
          dmv.pixelCount++;
          if (buffdata.captureZValues) {
            if (info.zValue < dmv.info.zValue) {
              dmv.info = info;
            }
          }
          if (dmv.attributeIDs.indexOf(info.attributeID) === -1) {
            dmv.attributeIDs.push(info.attributeID);
          }
        }
      }
    }
  }
  return convertSelection(buffdata.fieldAssociation, dataMap, buffdata.captureZValues, buffdata.renderer, buffdata.openGLRenderWindow);
}
function vtkOpenGLHardwareSelector(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLHardwareSelector");
  publicAPI.releasePixBuffers = () => {
    model.rawPixBuffer = [];
    model.pixBuffer = [];
    model.zBuffer = null;
  };
  publicAPI.beginSelection = () => {
    model._openGLRenderer = model._openGLRenderWindow.getViewNodeFor(model._renderer);
    model.maxAttributeId = 0;
    const size3 = model._openGLRenderWindow.getSize();
    if (!model.framebuffer) {
      model.framebuffer = vtkOpenGLFramebuffer.newInstance();
      model.framebuffer.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.framebuffer.saveCurrentBindingsAndBuffers();
      model.framebuffer.create(size3[0], size3[1]);
      model.framebuffer.populateFramebuffer();
    } else {
      model.framebuffer.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.framebuffer.saveCurrentBindingsAndBuffers();
      const fbSize = model.framebuffer.getSize();
      if (!fbSize || fbSize[0] !== size3[0] || fbSize[1] !== size3[1]) {
        model.framebuffer.create(size3[0], size3[1]);
        model.framebuffer.populateFramebuffer();
      } else {
        model.framebuffer.bind();
      }
    }
    model._openGLRenderer.clear();
    model._openGLRenderer.setSelector(publicAPI);
    model.hitProps = {};
    model.propPixels = {};
    model.props = [];
    publicAPI.releasePixBuffers();
    if (model.fieldAssociation === FieldAssociations4.FIELD_ASSOCIATION_POINTS) {
      const gl = model._openGLRenderWindow.getContext();
      const originalBlending = gl.isEnabled(gl.BLEND);
      gl.disable(gl.BLEND);
      model._openGLRenderWindow.traverseAllPasses();
      if (originalBlending) {
        gl.enable(gl.BLEND);
      }
    }
  };
  publicAPI.endSelection = () => {
    model.hitProps = {};
    model._openGLRenderer.setSelector(null);
    model.framebuffer.restorePreviousBindingsAndBuffers();
  };
  publicAPI.preCapturePass = () => {
    const gl = model._openGLRenderWindow.getContext();
    model.originalBlending = gl.isEnabled(gl.BLEND);
    gl.disable(gl.BLEND);
  };
  publicAPI.postCapturePass = () => {
    const gl = model._openGLRenderWindow.getContext();
    if (model.originalBlending) {
      gl.enable(gl.BLEND);
    }
  };
  publicAPI.select = () => {
    let sel = null;
    if (publicAPI.captureBuffers()) {
      sel = publicAPI.generateSelection(model.area[0], model.area[1], model.area[2], model.area[3]);
      publicAPI.releasePixBuffers();
    }
    return sel;
  };
  publicAPI.getSourceDataAsync = (renderer, fx1, fy1, fx2, fy2) => __async(this, null, function* () {
    model._renderer = renderer;
    if (fx1 === void 0) {
      const size3 = model._openGLRenderWindow.getSize();
      publicAPI.setArea(0, 0, size3[0] - 1, size3[1] - 1);
    } else {
      publicAPI.setArea(fx1, fy1, fx2, fy2);
    }
    if (!publicAPI.captureBuffers()) {
      return false;
    }
    const result = {
      area: [...model.area],
      pixBuffer: [...model.pixBuffer],
      captureZValues: model.captureZValues,
      zBuffer: model.zBuffer,
      props: [...model.props],
      fieldAssociation: model.fieldAssociation,
      renderer,
      openGLRenderWindow: model._openGLRenderWindow
    };
    result.generateSelection = function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return generateSelectionWithData(result, ...args);
    };
    return result;
  });
  publicAPI.captureBuffers = () => {
    if (!model._renderer || !model._openGLRenderWindow) {
      vtkErrorMacro32("Renderer and view must be set before calling Select.");
      return false;
    }
    model._openGLRenderer = model._openGLRenderWindow.getViewNodeFor(model._renderer);
    model._openGLRenderWindow.getRenderable().preRender();
    publicAPI.invokeEvent({
      type: "StartEvent"
    });
    model.originalBackground = model._renderer.getBackgroundByReference();
    model._renderer.setBackground(0, 0, 0, 0);
    const rpasses = model._openGLRenderWindow.getRenderPasses();
    publicAPI.beginSelection();
    for (model.currentPass = PassTypes2.MIN_KNOWN_PASS; model.currentPass <= PassTypes2.MAX_KNOWN_PASS; model.currentPass++) {
      if (publicAPI.passRequired(model.currentPass)) {
        publicAPI.preCapturePass(model.currentPass);
        if (model.captureZValues && model.currentPass === PassTypes2.ACTOR_PASS && typeof rpasses[0].requestDepth === "function" && typeof rpasses[0].getFramebuffer === "function") {
          rpasses[0].requestDepth();
          model._openGLRenderWindow.traverseAllPasses();
        } else {
          model._openGLRenderWindow.traverseAllPasses();
        }
        publicAPI.postCapturePass(model.currentPass);
        publicAPI.savePixelBuffer(model.currentPass);
        publicAPI.processPixelBuffers();
      }
    }
    publicAPI.endSelection();
    model._renderer.setBackground(model.originalBackground);
    publicAPI.invokeEvent({
      type: "EndEvent"
    });
    return true;
  };
  publicAPI.processPixelBuffers = () => {
    model.props.forEach((prop, index2) => {
      if (publicAPI.isPropHit(index2)) {
        prop.processSelectorPixelBuffers(publicAPI, model.propPixels[index2]);
      }
    });
  };
  publicAPI.passRequired = (pass) => {
    if (pass === PassTypes2.ID_HIGH24) {
      if (model.fieldAssociation === FieldAssociations4.FIELD_ASSOCIATION_POINTS) {
        return model.maximumPointId > 16777215;
      }
      if (model.fieldAssociation === FieldAssociations4.FIELD_ASSOCIATION_CELLS) {
        return model.maximumCellId > 16777215;
      }
    }
    return true;
  };
  publicAPI.savePixelBuffer = (passNo) => {
    model.pixBuffer[passNo] = model._openGLRenderWindow.getPixelData(model.area[0], model.area[1], model.area[2], model.area[3]);
    if (!model.rawPixBuffer[passNo]) {
      const size3 = (model.area[2] - model.area[0] + 1) * (model.area[3] - model.area[1] + 1) * 4;
      model.rawPixBuffer[passNo] = new Uint8Array(size3);
      model.rawPixBuffer[passNo].set(model.pixBuffer[passNo]);
    }
    if (passNo === PassTypes2.ACTOR_PASS) {
      if (model.captureZValues) {
        const rpasses = model._openGLRenderWindow.getRenderPasses();
        if (typeof rpasses[0].requestDepth === "function" && typeof rpasses[0].getFramebuffer === "function") {
          const fb = rpasses[0].getFramebuffer();
          fb.saveCurrentBindingsAndBuffers();
          fb.bind();
          model.zBuffer = model._openGLRenderWindow.getPixelData(model.area[0], model.area[1], model.area[2], model.area[3]);
          fb.restorePreviousBindingsAndBuffers();
        }
      }
      publicAPI.buildPropHitList(model.rawPixBuffer[passNo]);
    }
  };
  publicAPI.buildPropHitList = (pixelbuffer) => {
    let offset3 = 0;
    for (let yy = 0; yy <= model.area[3] - model.area[1]; yy++) {
      for (let xx = 0; xx <= model.area[2] - model.area[0]; xx++) {
        let val = convert(xx, yy, pixelbuffer, model.area);
        if (val > 0) {
          val--;
          if (!(val in model.hitProps)) {
            model.hitProps[val] = true;
            model.propPixels[val] = [];
          }
          model.propPixels[val].push(offset3 * 4);
        }
        ++offset3;
      }
    }
  };
  publicAPI.renderProp = (prop) => {
    if (model.currentPass === PassTypes2.ACTOR_PASS) {
      publicAPI.setPropColorValueFromInt(model.props.length + idOffset);
      model.props.push(prop);
    }
  };
  publicAPI.renderCompositeIndex = (index2) => {
    if (model.currentPass === PassTypes2.COMPOSITE_INDEX_PASS) {
      publicAPI.setPropColorValueFromInt(index2 + idOffset);
    }
  };
  publicAPI.renderAttributeId = (attribid) => {
    if (attribid < 0) {
      return;
    }
    model.maxAttributeId = attribid > model.maxAttributeId ? attribid : model.maxAttributeId;
  };
  publicAPI.passTypeToString = (type) => macro.enumToString(PassTypes2, type);
  publicAPI.isPropHit = (id) => Boolean(model.hitProps[id]);
  publicAPI.setPropColorValueFromInt = (val) => {
    model.propColorValue[0] = val % 256 / 255;
    model.propColorValue[1] = Math.floor(val / 256) % 256 / 255;
    model.propColorValue[2] = Math.floor(val / 65536) % 256 / 255;
  };
  publicAPI.getPixelInformation = (inDisplayPosition, maxDistance, outSelectedPosition) => {
    const maxDist = maxDistance < 0 ? 0 : maxDistance;
    if (maxDist === 0) {
      outSelectedPosition[0] = inDisplayPosition[0];
      outSelectedPosition[1] = inDisplayPosition[1];
      if (inDisplayPosition[0] < model.area[0] || inDisplayPosition[0] > model.area[2] || inDisplayPosition[1] < model.area[1] || inDisplayPosition[1] > model.area[3]) {
        return null;
      }
      const displayPosition = [inDisplayPosition[0] - model.area[0], inDisplayPosition[1] - model.area[1]];
      const actorid = convert(displayPosition[0], displayPosition[1], model.pixBuffer[PassTypes2.ACTOR_PASS], model.area);
      if (actorid <= 0 || actorid - idOffset >= model.props.length) {
        return null;
      }
      const info2 = {};
      info2.valid = true;
      info2.propID = actorid - idOffset;
      info2.prop = model.props[info2.propID];
      let compositeID = convert(displayPosition[0], displayPosition[1], model.pixBuffer[PassTypes2.COMPOSITE_INDEX_PASS], model.area);
      if (compositeID < 0 || compositeID > 16777215) {
        compositeID = 0;
      }
      info2.compositeID = compositeID - idOffset;
      if (model.captureZValues) {
        const offset3 = (displayPosition[1] * (model.area[2] - model.area[0] + 1) + displayPosition[0]) * 4;
        info2.zValue = (256 * model.zBuffer[offset3] + model.zBuffer[offset3 + 1]) / 65535;
        info2.displayPosition = inDisplayPosition;
      }
      if (model.pixBuffer[PassTypes2.ID_LOW24]) {
        if (getAlpha(displayPosition[0], displayPosition[1], model.pixBuffer[PassTypes2.ID_LOW24], model.area) === 0) {
          return info2;
        }
      }
      const low24 = convert(displayPosition[0], displayPosition[1], model.pixBuffer[PassTypes2.ID_LOW24], model.area);
      const high24 = convert(displayPosition[0], displayPosition[1], model.pixBuffer[PassTypes2.ID_HIGH24], model.area);
      info2.attributeID = getID(low24, high24);
      return info2;
    }
    const dispPos = [inDisplayPosition[0], inDisplayPosition[1]];
    const curPos = [0, 0];
    let info = publicAPI.getPixelInformation(inDisplayPosition, 0, outSelectedPosition);
    if (info && info.valid) {
      return info;
    }
    for (let dist3 = 1; dist3 < maxDist; ++dist3) {
      for (let y3 = dispPos[1] > dist3 ? dispPos[1] - dist3 : 0; y3 <= dispPos[1] + dist3; ++y3) {
        curPos[1] = y3;
        if (dispPos[0] >= dist3) {
          curPos[0] = dispPos[0] - dist3;
          info = publicAPI.getPixelInformation(curPos, 0, outSelectedPosition);
          if (info && info.valid) {
            return info;
          }
        }
        curPos[0] = dispPos[0] + dist3;
        info = publicAPI.getPixelInformation(curPos, 0, outSelectedPosition);
        if (info && info.valid) {
          return info;
        }
      }
      for (let x2 = dispPos[0] >= dist3 ? dispPos[0] - (dist3 - 1) : 0; x2 <= dispPos[0] + (dist3 - 1); ++x2) {
        curPos[0] = x2;
        if (dispPos[1] >= dist3) {
          curPos[1] = dispPos[1] - dist3;
          info = publicAPI.getPixelInformation(curPos, 0, outSelectedPosition);
          if (info && info.valid) {
            return info;
          }
        }
        curPos[1] = dispPos[1] + dist3;
        info = publicAPI.getPixelInformation(curPos, 0, outSelectedPosition);
        if (info && info.valid) {
          return info;
        }
      }
    }
    outSelectedPosition[0] = inDisplayPosition[0];
    outSelectedPosition[1] = inDisplayPosition[1];
    return null;
  };
  publicAPI.generateSelection = (fx1, fy1, fx2, fy2) => {
    const x1 = Math.floor(fx1);
    const y1 = Math.floor(fy1);
    const x2 = Math.floor(fx2);
    const y22 = Math.floor(fy2);
    const dataMap = /* @__PURE__ */ new Map();
    const outSelectedPosition = [0, 0];
    for (let yy = y1; yy <= y22; yy++) {
      for (let xx = x1; xx <= x2; xx++) {
        const pos = [xx, yy];
        const info = publicAPI.getPixelInformation(pos, 0, outSelectedPosition);
        if (info && info.valid) {
          const hash = getInfoHash(info);
          if (!dataMap.has(hash)) {
            dataMap.set(hash, {
              info,
              pixelCount: 1,
              attributeIDs: [info.attributeID]
            });
          } else {
            const dmv = dataMap.get(hash);
            dmv.pixelCount++;
            if (model.captureZValues) {
              if (info.zValue < dmv.info.zValue) {
                dmv.info = info;
              }
            }
            if (dmv.attributeIDs.indexOf(info.attributeID) === -1) {
              dmv.attributeIDs.push(info.attributeID);
            }
          }
        }
      }
    }
    return convertSelection(model.fieldAssociation, dataMap, model.captureZValues, model._renderer, model._openGLRenderWindow);
  };
  publicAPI.getRawPixelBuffer = (passNo) => model.rawPixBuffer[passNo];
  publicAPI.getPixelBuffer = (passNo) => model.pixBuffer[passNo];
  publicAPI.attach = (w2, r9) => {
    model._openGLRenderWindow = w2;
    model._renderer = r9;
  };
  const superSetArea = publicAPI.setArea;
  publicAPI.setArea = function() {
    if (superSetArea(...arguments)) {
      model.area[0] = Math.floor(model.area[0]);
      model.area[1] = Math.floor(model.area[1]);
      model.area[2] = Math.floor(model.area[2]);
      model.area[3] = Math.floor(model.area[3]);
      return true;
    }
    return false;
  };
}
var DEFAULT_VALUES87 = {
  area: void 0,
  // _renderer: null,
  // _openGLRenderWindow: null,
  // _openGLRenderer: null,
  currentPass: -1,
  propColorValue: null,
  props: null,
  maximumPointId: 0,
  maximumCellId: 0,
  idOffset: 1
};
function extend89(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES87, initialValues);
  vtkHardwareSelector$1.extend(publicAPI, model, initialValues);
  model.propColorValue = [0, 0, 0];
  model.props = [];
  if (!model.area) {
    model.area = [0, 0, 0, 0];
  }
  macro.setGetArray(publicAPI, model, ["area"], 4);
  macro.setGet(publicAPI, model, ["_renderer", "currentPass", "_openGLRenderWindow", "maximumPointId", "maximumCellId"]);
  macro.setGetArray(publicAPI, model, ["propColorValue"], 3);
  macro.moveToProtected(publicAPI, model, ["renderer", "openGLRenderWindow"]);
  macro.event(publicAPI, model, "event");
  vtkOpenGLHardwareSelector(publicAPI, model);
}
var newInstance88 = macro.newInstance(extend89, "vtkOpenGLHardwareSelector");
var vtkHardwareSelector2 = __spreadValues({
  newInstance: newInstance88,
  extend: extend89
}, Constants14);

// node_modules/@kitware/vtk.js/Rendering/OpenGL/ShaderCache.js
var import_spark_md5 = __toESM(require_spark_md5());
var SET_GET_FIELDS = ["lastShaderProgramBound", "context", "_openGLRenderWindow"];
function vtkShaderCache(publicAPI, model) {
  model.classHierarchy.push("vtkShaderCache");
  publicAPI.replaceShaderValues = (VSSource, FSSource, GSSource) => {
    let nFSSource = FSSource;
    if (GSSource.length > 0) {
      nFSSource = vtkShaderProgram$1.substitute(nFSSource, "VSOut", "GSOut").result;
    }
    const gl2 = model._openGLRenderWindow.getWebgl2();
    let fragDepthString = "\n";
    let version = "#version 100\n";
    if (gl2) {
      version = "#version 300 es\n#define attribute in\n#define textureCube texture\n#define texture2D texture\n#define textureCubeLod textureLod\n#define texture2DLod textureLod\n";
    } else {
      model.context.getExtension("OES_standard_derivatives");
      if (model.context.getExtension("EXT_frag_depth")) {
        fragDepthString = "#extension GL_EXT_frag_depth : enable\n";
      }
      if (model.context.getExtension("EXT_shader_texture_lod")) {
        fragDepthString += "#extension GL_EXT_shader_texture_lod : enable\n#define textureCubeLod textureCubeLodEXT\n#define texture2DLod texture2DLodEXT";
      }
    }
    nFSSource = vtkShaderProgram$1.substitute(nFSSource, "//VTK::System::Dec", [`${version}
`, gl2 ? "" : "#extension GL_OES_standard_derivatives : enable\n", fragDepthString, "#ifdef GL_FRAGMENT_PRECISION_HIGH", "precision highp float;", "precision highp int;", "#else", "precision mediump float;", "precision mediump int;", "#endif"]).result;
    let nVSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::System::Dec", [`${version}
`, "#ifdef GL_FRAGMENT_PRECISION_HIGH", "precision highp float;", "precision highp int;", "#else", "precision mediump float;", "precision mediump int;", "#endif"]).result;
    if (gl2) {
      nVSSource = vtkShaderProgram$1.substitute(nVSSource, "varying", "out").result;
      nFSSource = vtkShaderProgram$1.substitute(nFSSource, "varying", "in").result;
      let shaderOutputs = "";
      let outputCount = 0;
      while (nFSSource.includes(`gl_FragData[${outputCount}]`)) {
        nFSSource = vtkShaderProgram$1.substitute(nFSSource, `gl_FragData\\[${outputCount}\\]`, `fragOutput${outputCount}`).result;
        shaderOutputs += `layout(location = ${outputCount}) out vec4 fragOutput${outputCount};
`;
        outputCount++;
      }
      nFSSource = vtkShaderProgram$1.substitute(nFSSource, "//VTK::Output::Dec", shaderOutputs).result;
    }
    const nGSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::System::Dec", version).result;
    return {
      VSSource: nVSSource,
      FSSource: nFSSource,
      GSSource: nGSSource
    };
  };
  publicAPI.readyShaderProgramArray = (vertexCode, fragmentCode, geometryCode) => {
    const data = publicAPI.replaceShaderValues(vertexCode, fragmentCode, geometryCode);
    const shaderProgram = publicAPI.getShaderProgram(data.VSSource, data.FSSource, data.GSSource);
    return publicAPI.readyShaderProgram(shaderProgram);
  };
  publicAPI.readyShaderProgram = (program) => {
    if (!program) {
      return null;
    }
    if (!program.getCompiled() && !program.compileShader()) {
      return null;
    }
    if (!publicAPI.bindShaderProgram(program)) {
      return null;
    }
    return program;
  };
  publicAPI.getShaderProgram = (vertexCode, fragmentCode, geometryCode) => {
    const hashInput = `${vertexCode}${fragmentCode}${geometryCode}`;
    const result = import_spark_md5.default.hash(hashInput);
    if (!(result in model.shaderPrograms)) {
      const sps = vtkShaderProgram$1.newInstance();
      sps.setContext(model.context);
      sps.getVertexShader().setSource(vertexCode);
      sps.getFragmentShader().setSource(fragmentCode);
      if (geometryCode) {
        sps.getGeometryShader().setSource(geometryCode);
      }
      sps.setMd5Hash(result);
      model.shaderPrograms[result] = sps;
      return sps;
    }
    return model.shaderPrograms[result];
  };
  publicAPI.releaseGraphicsResources = (win) => {
    publicAPI.releaseCurrentShaderProgram();
    Object.keys(model.shaderPrograms).map((key) => model.shaderPrograms[key]).forEach((sp) => sp.cleanup());
    model.shaderPrograms = {};
  };
  publicAPI.releaseCurrentShaderProgram = () => {
    if (model.lastShaderProgramBound) {
      model.lastShaderProgramBound.cleanup();
      model.lastShaderProgramBound = null;
    }
  };
  publicAPI.bindShaderProgram = (program) => {
    if (model.lastShaderProgramBound === program) {
      return 1;
    }
    if (model.lastShaderProgramBound) {
      model.lastShaderProgramBound.release();
    }
    program.bind();
    model.lastShaderProgramBound = program;
    return 1;
  };
}
var DEFAULT_VALUES88 = {
  lastShaderProgramBound: null,
  shaderPrograms: null,
  context: null
  // _openGLRenderWindow: null,
};
function extend90(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES88, initialValues);
  model.shaderPrograms = {};
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, SET_GET_FIELDS);
  macro.moveToProtected(publicAPI, model, ["openGLRenderWindow"]);
  vtkShaderCache(publicAPI, model);
}
var newInstance89 = macro.newInstance(extend90, "vtkShaderCache");
var vtkShaderCache$1 = {
  newInstance: newInstance89,
  extend: extend90
};

// node_modules/@kitware/vtk.js/Rendering/OpenGL/TextureUnitManager.js
var {
  vtkErrorMacro: vtkErrorMacro33
} = macro;
function vtkOpenGLTextureUnitManager(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLTextureUnitManager");
  publicAPI.deleteTable = () => {
    for (let i6 = 0; i6 < model.numberOfTextureUnits; ++i6) {
      if (model.textureUnits[i6] === true) {
        vtkErrorMacro33("some texture units  were not properly released");
      }
    }
    model.textureUnits = [];
    model.numberOfTextureUnits = 0;
  };
  publicAPI.setContext = (ctx) => {
    if (model.context !== ctx) {
      if (model.context !== 0) {
        publicAPI.deleteTable();
      }
      model.context = ctx;
      if (model.context) {
        model.numberOfTextureUnits = ctx.getParameter(ctx.MAX_TEXTURE_IMAGE_UNITS);
        for (let i6 = 0; i6 < model.numberOfTextureUnits; ++i6) {
          model.textureUnits[i6] = false;
        }
      }
      publicAPI.modified();
    }
  };
  publicAPI.allocate = () => {
    for (let i6 = 0; i6 < model.numberOfTextureUnits; i6++) {
      if (!publicAPI.isAllocated(i6)) {
        model.textureUnits[i6] = true;
        return i6;
      }
    }
    return -1;
  };
  publicAPI.allocateUnit = (unit) => {
    if (publicAPI.isAllocated(unit)) {
      return -1;
    }
    model.textureUnits[unit] = true;
    return unit;
  };
  publicAPI.isAllocated = (textureUnitId) => model.textureUnits[textureUnitId];
  publicAPI.free = (val) => {
    model.textureUnits[val] = false;
  };
  publicAPI.freeAll = () => {
    for (let i6 = 0; i6 < model.numberOfTextureUnits; ++i6) {
      model.textureUnits[i6] = false;
    }
  };
}
var DEFAULT_VALUES89 = {
  context: null,
  numberOfTextureUnits: 0,
  textureUnits: 0
};
function extend91(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES89, initialValues);
  macro.obj(publicAPI, model);
  model.textureUnits = [];
  macro.get(publicAPI, model, ["numberOfTextureUnits"]);
  macro.setGet(publicAPI, model, ["context"]);
  vtkOpenGLTextureUnitManager(publicAPI, model);
}
var newInstance90 = macro.newInstance(extend91, "vtkOpenGLTextureUnitManager");
var vtkTextureUnitManager = {
  newInstance: newInstance90,
  extend: extend91
};

// node_modules/@kitware/vtk.js/Rendering/SceneGraph/RenderWindowViewNode.js
function vtkRenderWindowViewNode(publicAPI, model) {
  model.classHierarchy.push("vtkRenderWindowViewNode");
  publicAPI.getViewNodeFactory = () => null;
  publicAPI.getAspectRatio = () => model.size[0] / model.size[1];
  publicAPI.getAspectRatioForRenderer = (renderer) => {
    const viewport = renderer.getViewportByReference();
    return model.size[0] * (viewport[2] - viewport[0]) / ((viewport[3] - viewport[1]) * model.size[1]);
  };
  publicAPI.isInViewport = (x2, y3, viewport) => {
    const vCoords = viewport.getViewportByReference();
    const size3 = publicAPI.getFramebufferSize();
    if (vCoords[0] * size3[0] <= x2 && vCoords[2] * size3[0] >= x2 && vCoords[1] * size3[1] <= y3 && vCoords[3] * size3[1] >= y3) {
      return true;
    }
    return false;
  };
  publicAPI.getViewportSize = (viewport) => {
    const vCoords = viewport.getViewportByReference();
    const size3 = publicAPI.getFramebufferSize();
    return [(vCoords[2] - vCoords[0]) * size3[0], (vCoords[3] - vCoords[1]) * size3[1]];
  };
  publicAPI.getViewportCenter = (viewport) => {
    const size3 = publicAPI.getViewportSize(viewport);
    return [size3[0] * 0.5, size3[1] * 0.5];
  };
  publicAPI.displayToNormalizedDisplay = (x2, y3, z3) => {
    const size3 = publicAPI.getFramebufferSize();
    return [x2 / size3[0], y3 / size3[1], z3];
  };
  publicAPI.normalizedDisplayToDisplay = (x2, y3, z3) => {
    const size3 = publicAPI.getFramebufferSize();
    return [x2 * size3[0], y3 * size3[1], z3];
  };
  publicAPI.worldToView = (x2, y3, z3, renderer) => renderer.worldToView(x2, y3, z3);
  publicAPI.viewToWorld = (x2, y3, z3, renderer) => renderer.viewToWorld(x2, y3, z3);
  publicAPI.worldToDisplay = (x2, y3, z3, renderer) => {
    const val = renderer.worldToView(x2, y3, z3);
    const dims = publicAPI.getViewportSize(renderer);
    const val2 = renderer.viewToProjection(val[0], val[1], val[2], dims[0] / dims[1]);
    const val3 = renderer.projectionToNormalizedDisplay(val2[0], val2[1], val2[2]);
    return publicAPI.normalizedDisplayToDisplay(val3[0], val3[1], val3[2]);
  };
  publicAPI.displayToWorld = (x2, y3, z3, renderer) => {
    const val = publicAPI.displayToNormalizedDisplay(x2, y3, z3);
    const val2 = renderer.normalizedDisplayToProjection(val[0], val[1], val[2]);
    const dims = publicAPI.getViewportSize(renderer);
    const val3 = renderer.projectionToView(val2[0], val2[1], val2[2], dims[0] / dims[1]);
    return renderer.viewToWorld(val3[0], val3[1], val3[2]);
  };
  publicAPI.normalizedDisplayToViewport = (x2, y3, z3, renderer) => {
    let vCoords = renderer.getViewportByReference();
    vCoords = publicAPI.normalizedDisplayToDisplay(vCoords[0], vCoords[1], 0);
    const coords = publicAPI.normalizedDisplayToDisplay(x2, y3, z3);
    return [coords[0] - vCoords[0] - 0.5, coords[1] - vCoords[1] - 0.5, z3];
  };
  publicAPI.viewportToNormalizedViewport = (x2, y3, z3, renderer) => {
    const size3 = publicAPI.getViewportSize(renderer);
    if (size3 && size3[0] !== 0 && size3[1] !== 0) {
      return [x2 / (size3[0] - 1), y3 / (size3[1] - 1), z3];
    }
    return [x2, y3, z3];
  };
  publicAPI.normalizedViewportToViewport = (x2, y3, z3, renderer) => {
    const size3 = publicAPI.getViewportSize(renderer);
    return [x2 * (size3[0] - 1), y3 * (size3[1] - 1), z3];
  };
  publicAPI.displayToLocalDisplay = (x2, y3, z3) => {
    const size3 = publicAPI.getFramebufferSize();
    return [x2, size3[1] - y3 - 1, z3];
  };
  publicAPI.viewportToNormalizedDisplay = (x2, y3, z3, renderer) => {
    let vCoords = renderer.getViewportByReference();
    vCoords = publicAPI.normalizedDisplayToDisplay(vCoords[0], vCoords[1], 0);
    const x22 = x2 + vCoords[0] + 0.5;
    const y22 = y3 + vCoords[1] + 0.5;
    return publicAPI.displayToNormalizedDisplay(x22, y22, z3);
  };
  publicAPI.getComputedDevicePixelRatio = () => model.size[0] / publicAPI.getContainerSize()[0];
  publicAPI.getContainerSize = () => {
    macro.vtkErrorMacro("not implemented");
  };
  publicAPI.getPixelData = (x1, y1, x2, y22) => {
    macro.vtkErrorMacro("not implemented");
  };
  publicAPI.createSelector = () => {
    macro.vtkErrorMacro("not implemented");
  };
}
var DEFAULT_VALUES90 = {
  size: void 0,
  selector: void 0
};
function extend92(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES90, initialValues);
  if (!model.size) {
    model.size = [300, 300];
  }
  macro.getArray(publicAPI, model, ["size"], 2);
  macro.get(publicAPI, model, ["selector"]);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  vtkRenderWindowViewNode(publicAPI, model);
}
var newInstance91 = macro.newInstance(extend92, "vtkRenderWindowViewNode");
var vtkRenderWindowViewNode$1 = {
  newInstance: newInstance91,
  extend: extend92
};

// node_modules/@kitware/vtk.js/Rendering/OpenGL/RenderWindow/ContextProxy.js
var GET_UNDERLYING_CONTEXT = "__getUnderlyingContext";
function createContextProxyHandler() {
  const cache2 = /* @__PURE__ */ new Map();
  const getParameterHandler = {
    apply(target, gl, args) {
      if (cache2.has(args[0])) {
        return cache2.get(args[0]);
      }
      return target.apply(gl, args);
    }
  };
  function cachedSetterHandler(key) {
    return {
      apply(target, gl, args) {
        cache2.set(key, args[0]);
        return target.apply(gl, args);
      }
    };
  }
  const propHandlers = /* @__PURE__ */ Object.create(null);
  propHandlers.getParameter = (gl, prop, receiver, propValue) => new Proxy(propValue.bind(gl), getParameterHandler);
  propHandlers.depthMask = (gl, prop, receiver, propValue) => new Proxy(propValue.bind(gl), cachedSetterHandler(gl.DEPTH_WRITEMASK));
  return {
    get(gl, prop, receiver) {
      if (prop === GET_UNDERLYING_CONTEXT) return () => gl;
      let value = Reflect.get(gl, prop, gl);
      if (value instanceof Function) {
        value = value.bind(gl);
      }
      const propHandler = propHandlers[prop];
      if (propHandler) {
        return propHandler(gl, prop, receiver, value);
      }
      return value;
    }
  };
}

// node_modules/@kitware/vtk.js/Rendering/OpenGL/RenderWindow.js
var {
  vtkDebugMacro: vtkDebugMacro10,
  vtkErrorMacro: vtkErrorMacro34
} = macro;
var SCREENSHOT_PLACEHOLDER = {
  position: "absolute",
  top: 0,
  left: 0,
  width: "100%",
  height: "100%"
};
var parentMethodsToProxy = ["activateTexture", "deactivateTexture", "disableCullFace", "enableCullFace", "get3DContext", "getActiveFramebuffer", "getContext", "getDefaultTextureByteSize", "getDefaultTextureInternalFormat", "getDefaultToWebgl2", "getGLInformations", "getGraphicsMemoryInfo", "getGraphicsResourceForObject", "getHardwareMaximumLineWidth", "getPixelData", "getShaderCache", "getTextureUnitForTexture", "getTextureUnitManager", "getWebgl2", "makeCurrent", "releaseGraphicsResources", "releaseGraphicsResourcesForObject", "restoreContext", "setActiveFramebuffer", "setContext", "setDefaultToWebgl2", "setGraphicsResourceForObject"];
function checkRenderTargetSupport(gl, format, type) {
  const framebuffer = gl.createFramebuffer();
  const texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texImage2D(gl.TEXTURE_2D, 0, format, 2, 2, 0, format, type, null);
  gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
  const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.bindTexture(gl.TEXTURE_2D, null);
  return status === gl.FRAMEBUFFER_COMPLETE;
}
var GL_CONTEXT_COUNT = 0;
var GL_CONTEXT_LISTENERS = [];
function createGLContext() {
  GL_CONTEXT_COUNT++;
  GL_CONTEXT_LISTENERS.forEach((cb) => cb(GL_CONTEXT_COUNT));
}
function deleteGLContext() {
  GL_CONTEXT_COUNT--;
  GL_CONTEXT_LISTENERS.forEach((cb) => cb(GL_CONTEXT_COUNT));
}
function _preventDefault(e13) {
  e13.preventDefault();
}
function vtkOpenGLRenderWindow(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLRenderWindow");
  let cachingContextHandler;
  function getCachingContextHandler() {
    if (!cachingContextHandler) {
      cachingContextHandler = createContextProxyHandler();
    }
    return cachingContextHandler;
  }
  publicAPI.getViewNodeFactory = () => model.myFactory;
  model.canvas.addEventListener("webglcontextlost", _preventDefault, false);
  model.canvas.addEventListener("webglcontextrestored", publicAPI.restoreContext, false);
  const previousSize = [0, 0];
  function updateWindow() {
    if (model.renderable) {
      if (model.size[0] !== previousSize[0] || model.size[1] !== previousSize[1]) {
        previousSize[0] = model.size[0];
        previousSize[1] = model.size[1];
        model.canvas.setAttribute("width", model.size[0]);
        model.canvas.setAttribute("height", model.size[1]);
      }
    }
    if (model.viewStream) {
      model.viewStream.setSize(model.size[0], model.size[1]);
    }
    model.canvas.style.display = model.useOffScreen ? "none" : "block";
    if (model.el) {
      model.el.style.cursor = model.cursorVisibility ? model.cursor : "none";
    }
    model.containerSize = null;
  }
  publicAPI.onModified(updateWindow);
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      if (!model.renderable) {
        return;
      }
      publicAPI.prepareNodes();
      publicAPI.addMissingNodes(model.renderable.getRenderersByReference());
      publicAPI.addMissingNodes(model.renderable.getChildRenderWindowsByReference());
      publicAPI.removeUnusedNodes();
      publicAPI.initialize();
      model.children.forEach((child) => {
        var _a9;
        (_a9 = child.setOpenGLRenderWindow) == null ? void 0 : _a9.call(child, publicAPI);
      });
    }
  };
  publicAPI.initialize = () => {
    if (!model.initialized) {
      model.rootOpenGLRenderWindow = publicAPI.getLastAncestorOfType("vtkOpenGLRenderWindow");
      if (model.rootOpenGLRenderWindow) {
        model.context2D = publicAPI.get2DContext();
      } else {
        model.context = publicAPI.get3DContext();
        publicAPI.resizeFromChildRenderWindows();
        if (model.context) {
          createGLContext();
        }
        model.textureUnitManager = vtkTextureUnitManager.newInstance();
        model.textureUnitManager.setContext(model.context);
        model.shaderCache.setContext(model.context);
        const gl = model.context;
        gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
        gl.depthFunc(gl.LEQUAL);
        gl.enable(gl.BLEND);
      }
      model.initialized = true;
    }
  };
  publicAPI.makeCurrent = () => {
    model.context.makeCurrent();
  };
  publicAPI.setContainer = (el) => {
    if (model.el && model.el !== el) {
      if (model.canvas.parentNode !== model.el) {
        vtkErrorMacro34("Error: canvas parent node does not match container");
      }
      model.el.removeChild(model.canvas);
      if (model.el.contains(model.bgImage)) {
        model.el.removeChild(model.bgImage);
      }
    }
    if (model.el !== el) {
      model.el = el;
      if (model.el) {
        model.el.appendChild(model.canvas);
        if (model.useBackgroundImage) {
          model.el.appendChild(model.bgImage);
        }
      }
      publicAPI.modified();
    }
  };
  publicAPI.getContainer = () => model.el;
  publicAPI.getContainerSize = () => {
    if (!model.containerSize && model.el) {
      const {
        width,
        height
      } = model.el.getBoundingClientRect();
      model.containerSize = [width, height];
    }
    return model.containerSize || model.size;
  };
  publicAPI.getFramebufferSize = () => {
    var _a9;
    const fbSize = (_a9 = model.activeFramebuffer) == null ? void 0 : _a9.getSize();
    return fbSize || model.size;
  };
  publicAPI.getPixelData = (x1, y1, x2, y22) => {
    const pixels = new Uint8Array((x2 - x1 + 1) * (y22 - y1 + 1) * 4);
    model.context.readPixels(x1, y1, x2 - x1 + 1, y22 - y1 + 1, model.context.RGBA, model.context.UNSIGNED_BYTE, pixels);
    return pixels;
  };
  publicAPI.get3DContext = function() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      preserveDrawingBuffer: false,
      depth: true,
      alpha: true,
      powerPreference: "high-performance"
    };
    let result = null;
    const webgl2Supported = typeof WebGL2RenderingContext !== "undefined";
    model.webgl2 = false;
    if (model.defaultToWebgl2 && webgl2Supported) {
      result = model.canvas.getContext("webgl2", options);
      if (result) {
        model.webgl2 = true;
        vtkDebugMacro10("using webgl2");
      }
    }
    if (!result) {
      vtkDebugMacro10("using webgl1");
      result = model.canvas.getContext("webgl", options) || model.canvas.getContext("experimental-webgl", options);
    }
    return new Proxy(result, getCachingContextHandler());
  };
  publicAPI.get2DContext = function() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return model.canvas.getContext("2d", options);
  };
  publicAPI.restoreContext = () => {
    const rp = vtkRenderPass$1.newInstance();
    rp.setCurrentOperation("Release");
    rp.traverse(publicAPI, null);
  };
  publicAPI.activateTexture = (texture) => {
    const result = model._textureResourceIds.get(texture);
    if (result !== void 0) {
      model.context.activeTexture(model.context.TEXTURE0 + result);
      return;
    }
    const activeUnit = publicAPI.getTextureUnitManager().allocate();
    if (activeUnit < 0) {
      vtkErrorMacro34("Hardware does not support the number of textures defined.");
      return;
    }
    model._textureResourceIds.set(texture, activeUnit);
    model.context.activeTexture(model.context.TEXTURE0 + activeUnit);
  };
  publicAPI.deactivateTexture = (texture) => {
    const result = model._textureResourceIds.get(texture);
    if (result !== void 0) {
      publicAPI.getTextureUnitManager().free(result);
      model._textureResourceIds.delete(texture);
    }
  };
  publicAPI.getTextureUnitForTexture = (texture) => {
    const result = model._textureResourceIds.get(texture);
    if (result !== void 0) {
      return result;
    }
    return -1;
  };
  publicAPI.getDefaultTextureByteSize = function(vtkType) {
    let oglNorm16Ext = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    let useHalfFloat = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    if (model.webgl2) {
      switch (vtkType) {
        case VtkDataTypes.CHAR:
        case VtkDataTypes.SIGNED_CHAR:
        case VtkDataTypes.UNSIGNED_CHAR:
          return 1;
        case oglNorm16Ext:
        case useHalfFloat:
        case VtkDataTypes.UNSIGNED_SHORT:
        case VtkDataTypes.SHORT:
        case VtkDataTypes.VOID:
          return 2;
        default:
          return 4;
      }
    }
    return 1;
  };
  publicAPI.getDefaultTextureInternalFormat = function(vtktype, numComps) {
    let oglNorm16Ext = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
    let useHalfFloat = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    if (model.webgl2) {
      switch (vtktype) {
        case VtkDataTypes.UNSIGNED_CHAR:
          switch (numComps) {
            case 1:
              return model.context.R8;
            case 2:
              return model.context.RG8;
            case 3:
              return model.context.RGB8;
            case 4:
            default:
              return model.context.RGBA8;
          }
        case (oglNorm16Ext && !useHalfFloat && VtkDataTypes.UNSIGNED_SHORT):
          switch (numComps) {
            case 1:
              return oglNorm16Ext.R16_EXT;
            case 2:
              return oglNorm16Ext.RG16_EXT;
            case 3:
              return oglNorm16Ext.RGB16_EXT;
            case 4:
            default:
              return oglNorm16Ext.RGBA16_EXT;
          }
        case (oglNorm16Ext && !useHalfFloat && VtkDataTypes.SHORT):
          switch (numComps) {
            case 1:
              return oglNorm16Ext.R16_SNORM_EXT;
            case 2:
              return oglNorm16Ext.RG16_SNORM_EXT;
            case 3:
              return oglNorm16Ext.RGB16_SNORM_EXT;
            case 4:
            default:
              return oglNorm16Ext.RGBA16_SNORM_EXT;
          }
        case VtkDataTypes.UNSIGNED_SHORT:
        case VtkDataTypes.SHORT:
        case VtkDataTypes.FLOAT:
        default:
          switch (numComps) {
            case 1:
              return useHalfFloat ? model.context.R16F : model.context.R32F;
            case 2:
              return useHalfFloat ? model.context.RG16F : model.context.RG32F;
            case 3:
              return useHalfFloat ? model.context.RGB16F : model.context.RGB32F;
            case 4:
            default:
              return useHalfFloat ? model.context.RGBA16F : model.context.RGBA32F;
          }
      }
    }
    switch (numComps) {
      case 1:
        return model.context.LUMINANCE;
      case 2:
        return model.context.LUMINANCE_ALPHA;
      case 3:
        return model.context.RGB;
      case 4:
      default:
        return model.context.RGBA;
    }
  };
  publicAPI.setBackgroundImage = (img) => {
    model.bgImage.src = img.src;
  };
  publicAPI.setUseBackgroundImage = (value) => {
    model.useBackgroundImage = value;
    if (model.useBackgroundImage && !model.el.contains(model.bgImage)) {
      model.el.appendChild(model.bgImage);
    } else if (!model.useBackgroundImage && model.el.contains(model.bgImage)) {
      model.el.removeChild(model.bgImage);
    }
  };
  function getCanvasDataURL() {
    let format = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : model.imageFormat;
    const temporaryCanvas = document.createElement("canvas");
    const temporaryContext = temporaryCanvas.getContext("2d");
    temporaryCanvas.width = model.canvas.width;
    temporaryCanvas.height = model.canvas.height;
    temporaryContext.drawImage(model.canvas, 0, 0);
    const mainBoundingClientRect = model.canvas.getBoundingClientRect();
    const renderWindow = model.renderable;
    const renderers = renderWindow.getRenderers();
    renderers.forEach((renderer) => {
      const viewProps = renderer.getViewProps();
      viewProps.forEach((viewProp) => {
        if (viewProp.getContainer) {
          const container = viewProp.getContainer();
          const canvasList = container.getElementsByTagName("canvas");
          for (let i6 = 0; i6 < canvasList.length; i6++) {
            const currentCanvas = canvasList[i6];
            const boundingClientRect = currentCanvas.getBoundingClientRect();
            const newXPosition = boundingClientRect.x - mainBoundingClientRect.x;
            const newYPosition = boundingClientRect.y - mainBoundingClientRect.y;
            temporaryContext.drawImage(currentCanvas, newXPosition, newYPosition);
          }
        }
      });
    });
    const screenshot = temporaryCanvas.toDataURL(format);
    temporaryCanvas.remove();
    publicAPI.invokeImageReady(screenshot);
  }
  publicAPI.captureNextImage = function() {
    let format = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "image/png";
    let {
      resetCamera = false,
      size: size3 = null,
      scale: scale7 = 1
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (model.deleted) {
      return null;
    }
    model.imageFormat = format;
    const previous = model.notifyStartCaptureImage;
    model.notifyStartCaptureImage = true;
    model._screenshot = {
      size: !!size3 || scale7 !== 1 ? size3 || model.size.map((val) => val * scale7) : null
    };
    return new Promise((resolve, reject) => {
      const subscription = publicAPI.onImageReady((imageURL) => {
        if (model._screenshot.size === null) {
          model.notifyStartCaptureImage = previous;
          subscription.unsubscribe();
          if (model._screenshot.placeHolder) {
            model.size = model._screenshot.originalSize;
            publicAPI.modified();
            if (model._screenshot.cameras) {
              model._screenshot.cameras.forEach((_ref) => {
                let {
                  restoreParamsFn,
                  arg
                } = _ref;
                return restoreParamsFn(arg);
              });
            }
            publicAPI.traverseAllPasses();
            model.el.removeChild(model._screenshot.placeHolder);
            model._screenshot.placeHolder.remove();
            model._screenshot = null;
          }
          resolve(imageURL);
        } else {
          const tmpImg = document.createElement("img");
          tmpImg.style = SCREENSHOT_PLACEHOLDER;
          tmpImg.src = imageURL;
          model._screenshot.placeHolder = model.el.appendChild(tmpImg);
          model.canvas.style.display = "none";
          model._screenshot.originalSize = model.size;
          model.size = model._screenshot.size;
          model._screenshot.size = null;
          publicAPI.modified();
          if (resetCamera) {
            const isUserResetCamera = resetCamera !== true;
            model._screenshot.cameras = model.renderable.getRenderers().map((renderer) => {
              const camera = renderer.getActiveCamera();
              const params = camera.get("focalPoint", "position", "parallelScale");
              return {
                resetCameraArgs: isUserResetCamera ? {
                  renderer
                } : void 0,
                resetCameraFn: isUserResetCamera ? resetCamera : renderer.resetCamera,
                restoreParamsFn: camera.set,
                // "clone" the params so we don't keep refs to properties
                arg: JSON.parse(JSON.stringify(params))
              };
            });
            model._screenshot.cameras.forEach((_ref2) => {
              let {
                resetCameraFn,
                resetCameraArgs
              } = _ref2;
              return resetCameraFn(resetCameraArgs);
            });
          }
          publicAPI.traverseAllPasses();
        }
      });
    });
  };
  let hardwareMaximumLineWidth;
  publicAPI.getHardwareMaximumLineWidth = () => {
    if (hardwareMaximumLineWidth != null) {
      return hardwareMaximumLineWidth;
    }
    const gl = publicAPI.get3DContext();
    const lineWidthRange = gl.getParameter(gl.ALIASED_LINE_WIDTH_RANGE);
    hardwareMaximumLineWidth = lineWidthRange[1];
    return lineWidthRange[1];
  };
  publicAPI.getGLInformations = () => {
    if (model._glInformation) {
      return model._glInformation;
    }
    const gl = publicAPI.get3DContext();
    const glTextureFloat = gl.getExtension("OES_texture_float");
    const glTextureHalfFloat = gl.getExtension("OES_texture_half_float");
    const glDebugRendererInfo = gl.getExtension("WEBGL_debug_renderer_info");
    const glDrawBuffers = gl.getExtension("WEBGL_draw_buffers");
    const glAnisotropic = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
    const params = [["Max Vertex Attributes", "MAX_VERTEX_ATTRIBS", gl.getParameter(gl.MAX_VERTEX_ATTRIBS)], ["Max Varying Vectors", "MAX_VARYING_VECTORS", gl.getParameter(gl.MAX_VARYING_VECTORS)], ["Max Vertex Uniform Vectors", "MAX_VERTEX_UNIFORM_VECTORS", gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS)], ["Max Fragment Uniform Vectors", "MAX_FRAGMENT_UNIFORM_VECTORS", gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS)], ["Max Fragment Texture Image Units", "MAX_TEXTURE_IMAGE_UNITS", gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS)], ["Max Vertex Texture Image Units", "MAX_VERTEX_TEXTURE_IMAGE_UNITS", gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS)], ["Max Combined Texture Image Units", "MAX_COMBINED_TEXTURE_IMAGE_UNITS", gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS)], ["Max 2D Texture Size", "MAX_TEXTURE_SIZE", gl.getParameter(gl.MAX_TEXTURE_SIZE)], ["Max Cube Texture Size", "MAX_CUBE_MAP_TEXTURE_SIZE", gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE)], ["Max Texture Anisotropy", "MAX_TEXTURE_MAX_ANISOTROPY_EXT", glAnisotropic && gl.getParameter(glAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)], ["Point Size Range", "ALIASED_POINT_SIZE_RANGE", gl.getParameter(gl.ALIASED_POINT_SIZE_RANGE).join(" - ")], ["Line Width Range", "ALIASED_LINE_WIDTH_RANGE", gl.getParameter(gl.ALIASED_LINE_WIDTH_RANGE).join(" - ")], ["Max Viewport Dimensions", "MAX_VIEWPORT_DIMS", gl.getParameter(gl.MAX_VIEWPORT_DIMS).join(" - ")], ["Max Renderbuffer Size", "MAX_RENDERBUFFER_SIZE", gl.getParameter(gl.MAX_RENDERBUFFER_SIZE)], ["Framebuffer Red Bits", "RED_BITS", gl.getParameter(gl.RED_BITS)], ["Framebuffer Green Bits", "GREEN_BITS", gl.getParameter(gl.GREEN_BITS)], ["Framebuffer Blue Bits", "BLUE_BITS", gl.getParameter(gl.BLUE_BITS)], ["Framebuffer Alpha Bits", "ALPHA_BITS", gl.getParameter(gl.ALPHA_BITS)], ["Framebuffer Depth Bits", "DEPTH_BITS", gl.getParameter(gl.DEPTH_BITS)], ["Framebuffer Stencil Bits", "STENCIL_BITS", gl.getParameter(gl.STENCIL_BITS)], ["Framebuffer Subpixel Bits", "SUBPIXEL_BITS", gl.getParameter(gl.SUBPIXEL_BITS)], ["MSAA Samples", "SAMPLES", gl.getParameter(gl.SAMPLES)], ["MSAA Sample Buffers", "SAMPLE_BUFFERS", gl.getParameter(gl.SAMPLE_BUFFERS)], ["Supported Formats for UByte Render Targets     ", "UNSIGNED_BYTE RENDER TARGET FORMATS", [glTextureFloat && checkRenderTargetSupport(gl, gl.RGBA, gl.UNSIGNED_BYTE) ? "RGBA" : "", glTextureFloat && checkRenderTargetSupport(gl, gl.RGB, gl.UNSIGNED_BYTE) ? "RGB" : "", glTextureFloat && checkRenderTargetSupport(gl, gl.LUMINANCE, gl.UNSIGNED_BYTE) ? "LUMINANCE" : "", glTextureFloat && checkRenderTargetSupport(gl, gl.ALPHA, gl.UNSIGNED_BYTE) ? "ALPHA" : "", glTextureFloat && checkRenderTargetSupport(gl, gl.LUMINANCE_ALPHA, gl.UNSIGNED_BYTE) ? "LUMINANCE_ALPHA" : ""].join(" ")], ["Supported Formats for Half Float Render Targets", "HALF FLOAT RENDER TARGET FORMATS", [glTextureHalfFloat && checkRenderTargetSupport(gl, gl.RGBA, glTextureHalfFloat.HALF_FLOAT_OES) ? "RGBA" : "", glTextureHalfFloat && checkRenderTargetSupport(gl, gl.RGB, glTextureHalfFloat.HALF_FLOAT_OES) ? "RGB" : "", glTextureHalfFloat && checkRenderTargetSupport(gl, gl.LUMINANCE, glTextureHalfFloat.HALF_FLOAT_OES) ? "LUMINANCE" : "", glTextureHalfFloat && checkRenderTargetSupport(gl, gl.ALPHA, glTextureHalfFloat.HALF_FLOAT_OES) ? "ALPHA" : "", glTextureHalfFloat && checkRenderTargetSupport(gl, gl.LUMINANCE_ALPHA, glTextureHalfFloat.HALF_FLOAT_OES) ? "LUMINANCE_ALPHA" : ""].join(" ")], ["Supported Formats for Full Float Render Targets", "FLOAT RENDER TARGET FORMATS", [glTextureFloat && checkRenderTargetSupport(gl, gl.RGBA, gl.FLOAT) ? "RGBA" : "", glTextureFloat && checkRenderTargetSupport(gl, gl.RGB, gl.FLOAT) ? "RGB" : "", glTextureFloat && checkRenderTargetSupport(gl, gl.LUMINANCE, gl.FLOAT) ? "LUMINANCE" : "", glTextureFloat && checkRenderTargetSupport(gl, gl.ALPHA, gl.FLOAT) ? "ALPHA" : "", glTextureFloat && checkRenderTargetSupport(gl, gl.LUMINANCE_ALPHA, gl.FLOAT) ? "LUMINANCE_ALPHA" : ""].join(" ")], ["Max Multiple Render Targets Buffers", "MAX_DRAW_BUFFERS_WEBGL", glDrawBuffers ? gl.getParameter(glDrawBuffers.MAX_DRAW_BUFFERS_WEBGL) : 0], ["High Float Precision in Vertex Shader", "HIGH_FLOAT VERTEX_SHADER", [gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).rangeMax, "</sup>)"].join("")], ["Medium Float Precision in Vertex Shader", "MEDIUM_FLOAT VERTEX_SHADER", [gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).rangeMax, "</sup>)"].join("")], ["Low Float Precision in Vertex Shader", "LOW_FLOAT VERTEX_SHADER", [gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.LOW_FLOAT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.LOW_FLOAT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.LOW_FLOAT).rangeMax, "</sup>)"].join("")], ["High Float Precision in Fragment Shader", "HIGH_FLOAT FRAGMENT_SHADER", [gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).rangeMax, "</sup>)"].join("")], ["Medium Float Precision in Fragment Shader", "MEDIUM_FLOAT FRAGMENT_SHADER", [gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).rangeMax, "</sup>)"].join("")], ["Low Float Precision in Fragment Shader", "LOW_FLOAT FRAGMENT_SHADER", [gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_FLOAT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_FLOAT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_FLOAT).rangeMax, "</sup>)"].join("")], ["High Int Precision in Vertex Shader", "HIGH_INT VERTEX_SHADER", [gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_INT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_INT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_INT).rangeMax, "</sup>)"].join("")], ["Medium Int Precision in Vertex Shader", "MEDIUM_INT VERTEX_SHADER", [gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_INT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_INT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_INT).rangeMax, "</sup>)"].join("")], ["Low Int Precision in Vertex Shader", "LOW_INT VERTEX_SHADER", [gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.LOW_INT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.LOW_INT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.LOW_INT).rangeMax, "</sup>)"].join("")], ["High Int Precision in Fragment Shader", "HIGH_INT FRAGMENT_SHADER", [gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_INT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_INT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_INT).rangeMax, "</sup>)"].join("")], ["Medium Int Precision in Fragment Shader", "MEDIUM_INT FRAGMENT_SHADER", [gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_INT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_INT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_INT).rangeMax, "</sup>)"].join("")], ["Low Int Precision in Fragment Shader", "LOW_INT FRAGMENT_SHADER", [gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_INT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_INT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_INT).rangeMax, "</sup>)"].join("")], ["Supported Extensions", "EXTENSIONS", gl.getSupportedExtensions().join("<br/>					    ")], ["WebGL Renderer", "RENDERER", gl.getParameter(gl.RENDERER)], ["WebGL Vendor", "VENDOR", gl.getParameter(gl.VENDOR)], ["WebGL Version", "VERSION", gl.getParameter(gl.VERSION)], ["Shading Language Version", "SHADING_LANGUAGE_VERSION", gl.getParameter(gl.SHADING_LANGUAGE_VERSION)], ["Unmasked Renderer", "UNMASKED_RENDERER", glDebugRendererInfo && gl.getParameter(glDebugRendererInfo.UNMASKED_RENDERER_WEBGL)], ["Unmasked Vendor", "UNMASKED_VENDOR", glDebugRendererInfo && gl.getParameter(glDebugRendererInfo.UNMASKED_VENDOR_WEBGL)], ["WebGL Version", "WEBGL_VERSION", model.webgl2 ? 2 : 1]];
    const result = {};
    while (params.length) {
      const [label, key, value] = params.pop();
      if (key) {
        result[key] = {
          label,
          value
        };
      }
    }
    model._glInformation = result;
    return result;
  };
  publicAPI.traverseAllPasses = () => {
    var _a9;
    if (model.renderPasses) {
      for (let index2 = 0; index2 < model.renderPasses.length; ++index2) {
        model.renderPasses[index2].traverse(publicAPI, null);
      }
    }
    if (model.notifyStartCaptureImage) {
      getCanvasDataURL();
    }
    publicAPI.copyParentContent();
    const childrenRW = model.renderable.getChildRenderWindowsByReference();
    for (let i6 = 0; i6 < childrenRW.length; ++i6) {
      (_a9 = publicAPI.getViewNodeFor(childrenRW[i6])) == null ? void 0 : _a9.traverseAllPasses();
    }
  };
  publicAPI.copyParentContent = () => {
    const rootParent = model.rootOpenGLRenderWindow;
    if (!rootParent || !model.context2D) {
      return;
    }
    const parentCanvas = rootParent.getCanvas();
    const selfCanvas = model.canvas;
    model.context2D.drawImage(
      parentCanvas,
      0,
      parentCanvas.height - selfCanvas.height,
      // source y axis is inverted
      selfCanvas.width,
      selfCanvas.height,
      0,
      0,
      selfCanvas.width,
      selfCanvas.height
    );
  };
  publicAPI.resizeFromChildRenderWindows = () => {
    var _a9;
    const childrenRW = model.renderable.getChildRenderWindowsByReference();
    if (childrenRW.length > 0) {
      const maxSize = [0, 0];
      for (let i6 = 0; i6 < childrenRW.length; ++i6) {
        const childSize = (_a9 = publicAPI.getViewNodeFor(childrenRW[i6])) == null ? void 0 : _a9.getSize();
        if (childSize) {
          maxSize[0] = childSize[0] > maxSize[0] ? childSize[0] : maxSize[0];
          maxSize[1] = childSize[1] > maxSize[1] ? childSize[1] : maxSize[1];
        }
      }
      publicAPI.setSize(...maxSize);
    }
  };
  publicAPI.disableCullFace = () => {
    if (model.cullFaceEnabled) {
      model.context.disable(model.context.CULL_FACE);
      model.cullFaceEnabled = false;
    }
  };
  publicAPI.enableCullFace = () => {
    if (!model.cullFaceEnabled) {
      model.context.enable(model.context.CULL_FACE);
      model.cullFaceEnabled = true;
    }
  };
  publicAPI.setViewStream = (stream) => {
    if (model.viewStream === stream) {
      return false;
    }
    if (model.subscription) {
      model.subscription.unsubscribe();
      model.subscription = null;
    }
    model.viewStream = stream;
    if (model.viewStream) {
      const mainRenderer = model.renderable.getRenderers()[0];
      mainRenderer.getBackgroundByReference()[3] = 0;
      publicAPI.setUseBackgroundImage(true);
      model.subscription = model.viewStream.onImageReady((e13) => publicAPI.setBackgroundImage(e13.image));
      model.viewStream.setSize(model.size[0], model.size[1]);
      model.viewStream.invalidateCache();
      model.viewStream.render();
      publicAPI.modified();
    }
    return true;
  };
  publicAPI.createSelector = () => {
    const ret = vtkHardwareSelector2.newInstance();
    ret.setOpenGLRenderWindow(publicAPI);
    return ret;
  };
  function clearEvents() {
    model.canvas.removeEventListener("webglcontextlost", _preventDefault);
    model.canvas.removeEventListener("webglcontextrestored", publicAPI.restoreContext);
  }
  publicAPI.delete = macro.chain(() => {
    if (model.context) {
      deleteGLContext();
    }
  }, clearEvents, publicAPI.delete, publicAPI.setViewStream);
  publicAPI.setActiveFramebuffer = (newActiveFramebuffer) => {
    model.activeFramebuffer = newActiveFramebuffer;
  };
  const superSetSize = publicAPI.setSize;
  publicAPI.setSize = (width, height) => {
    const modified = superSetSize(width, height);
    if (modified) {
      publicAPI.invokeWindowResizeEvent({
        width,
        height
      });
    }
    return modified;
  };
  publicAPI.getGraphicsResourceForObject = (vtkObj) => {
    if (!vtkObj) {
      return null;
    }
    const vtko = model._graphicsResources.get(vtkObj);
    const vtkh = model._graphicsResourceHash.get(vtkObj);
    return {
      vtkObj: vtko,
      hash: vtkh
    };
  };
  publicAPI.setGraphicsResourceForObject = (vtkObj, gObj, hash) => {
    if (!vtkObj) {
      return;
    }
    model._graphicsResources.set(vtkObj, gObj);
    model._graphicsResourceHash.set(vtkObj, hash);
  };
  publicAPI.getGraphicsMemoryInfo = () => {
    let memUsed = 0;
    model._graphicsResources.forEach((gObj, vtkObj) => {
      memUsed += gObj.getAllocatedGPUMemoryInBytes();
    });
    return memUsed;
  };
  publicAPI.releaseGraphicsResourcesForObject = (vtkObj) => {
    var _a9;
    if (!vtkObj) {
      return false;
    }
    (_a9 = model._graphicsResources.get(vtkObj)) == null ? void 0 : _a9.releaseGraphicsResources(publicAPI);
    return model._graphicsResources.delete(vtkObj) && model._graphicsResourceHash.delete(vtkObj);
  };
  publicAPI.releaseGraphicsResources = () => {
    if (model.shaderCache !== null) {
      model.shaderCache.releaseGraphicsResources(publicAPI);
    }
    model._graphicsResources.forEach((gObj, vtkObj) => {
      gObj.releaseGraphicsResources(publicAPI);
    });
    model._graphicsResources.clear();
    model._graphicsResourceHash.clear();
    if (model.textureUnitManager !== null) {
      model.textureUnitManager.freeAll();
    }
    model.renderable.getRenderersByReference().forEach((ren) => {
      const glRen = publicAPI.getViewNodeFor(ren);
      glRen == null ? void 0 : glRen.releaseGraphicsResources();
    });
  };
  const publicAPIBeforeProxy = __spreadValues({}, publicAPI);
  parentMethodsToProxy.forEach((methodName) => {
    publicAPI[methodName] = function() {
      if (model.rootOpenGLRenderWindow) {
        return model.rootOpenGLRenderWindow[methodName](...arguments);
      }
      return publicAPIBeforeProxy[methodName](...arguments);
    };
  });
}
var DEFAULT_VALUES91 = {
  cullFaceEnabled: false,
  shaderCache: null,
  initialized: false,
  context: null,
  context2D: null,
  canvas: null,
  cursorVisibility: true,
  cursor: "pointer",
  textureUnitManager: null,
  textureResourceIds: null,
  containerSize: null,
  renderPasses: [],
  notifyStartCaptureImage: false,
  webgl2: false,
  defaultToWebgl2: true,
  // attempt webgl2 on by default
  activeFramebuffer: null,
  imageFormat: "image/png",
  useOffScreen: false,
  useBackgroundImage: false
};
function extend93(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES91, initialValues);
  vtkRenderWindowViewNode$1.extend(publicAPI, model, initialValues);
  if (!model.canvas) {
    model.canvas = document.createElement("canvas");
    model.canvas.style.width = "100%";
  }
  if (!model.selector) {
    model.selector = vtkHardwareSelector2.newInstance();
    model.selector.setOpenGLRenderWindow(publicAPI);
  }
  model.bgImage = new Image();
  model.bgImage.style.position = "absolute";
  model.bgImage.style.left = "0";
  model.bgImage.style.top = "0";
  model.bgImage.style.width = "100%";
  model.bgImage.style.height = "100%";
  model.bgImage.style.zIndex = "-1";
  model._textureResourceIds = /* @__PURE__ */ new Map();
  model._graphicsResources = /* @__PURE__ */ new Map();
  model._graphicsResourceHash = /* @__PURE__ */ new Map();
  model._glInformation = null;
  model.myFactory = vtkViewNodeFactory2.newInstance();
  model.shaderCache = vtkShaderCache$1.newInstance();
  model.shaderCache.setOpenGLRenderWindow(publicAPI);
  model.renderPasses[0] = vtkForwardPass$1.newInstance();
  macro.get(publicAPI, model, ["shaderCache", "textureUnitManager", "webgl2", "useBackgroundImage", "activeFramebuffer", "rootOpenGLRenderWindow"]);
  macro.setGet(publicAPI, model, ["initialized", "context", "context2D", "canvas", "renderPasses", "notifyStartCaptureImage", "defaultToWebgl2", "cursor", "useOffScreen"]);
  macro.setGetArray(publicAPI, model, ["size"], 2);
  macro.event(publicAPI, model, "imageReady");
  macro.event(publicAPI, model, "windowResizeEvent");
  vtkOpenGLRenderWindow(publicAPI, model);
}
var newInstance92 = macro.newInstance(extend93, "vtkOpenGLRenderWindow");
registerViewConstructor("WebGL", newInstance92);
registerOverride("vtkRenderWindow", newInstance92);

// node_modules/@kitware/vtk.js/Rendering/WebGPU/RenderEncoder.js
var forwarded2 = ["setBindGroup", "setIndexBuffer", "setVertexBuffer", "draw", "drawIndexed"];
function vtkWebGPURenderEncoder(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPURenderEncoder");
  publicAPI.begin = (encoder2) => {
    model.drawCallbacks = [];
    model.handle = encoder2.beginRenderPass(model.description);
    if (model.label) {
      model.handle.pushDebugGroup(model.label);
    }
  };
  publicAPI.end = () => {
    for (let i6 = 0; i6 < model.drawCallbacks.length; i6++) {
      const pStruct = model.drawCallbacks[i6];
      const pl = pStruct.pipeline;
      publicAPI.setPipeline(pl);
      for (let cb = 0; cb < pStruct.callbacks.length; cb++) {
        pStruct.callbacks[cb](publicAPI);
      }
    }
    if (model.label) {
      model.handle.popDebugGroup();
    }
    model.handle.end();
    model.boundPipeline = null;
  };
  publicAPI.setPipeline = (pl) => {
    var _a9, _b2;
    if (model.boundPipeline === pl) {
      return;
    }
    model.handle.setPipeline(pl.getHandle());
    const pd = pl.getPipelineDescription();
    if (model.colorTextureViews.length !== pd.fragment.targets.length) {
      console.log(`mismatched attachment counts on pipeline ${pd.fragment.targets.length} while encoder has ${model.colorTextureViews.length}`);
      console.trace();
    } else {
      for (let i6 = 0; i6 < model.colorTextureViews.length; i6++) {
        const fmt = (_a9 = model.colorTextureViews[i6].getTexture()) == null ? void 0 : _a9.getFormat();
        if (fmt && fmt !== pd.fragment.targets[i6].format) {
          console.log(`mismatched attachments for attachment ${i6} on pipeline ${pd.fragment.targets[i6].format} while encoder has ${fmt}`);
          console.trace();
        }
      }
    }
    if (!model.depthTextureView !== !("depthStencil" in pd)) {
      console.log("mismatched depth attachments");
      console.trace();
    } else if (model.depthTextureView) {
      const dfmt = (_b2 = model.depthTextureView.getTexture()) == null ? void 0 : _b2.getFormat();
      if (dfmt && dfmt !== pd.depthStencil.format) {
        console.log(`mismatched depth attachments on pipeline ${pd.depthStencil.format} while encoder has ${dfmt}`);
        console.trace();
      }
    }
    model.boundPipeline = pl;
  };
  publicAPI.replaceShaderCode = (pipeline) => {
    model.replaceShaderCodeFunction(pipeline);
  };
  publicAPI.setColorTextureView = (idx, view) => {
    if (model.colorTextureViews[idx] === view) {
      return;
    }
    model.colorTextureViews[idx] = view;
  };
  publicAPI.activateBindGroup = (bg) => {
    const device = model.boundPipeline.getDevice();
    const midx = model.boundPipeline.getBindGroupLayoutCount(bg.getLabel());
    model.handle.setBindGroup(midx, bg.getBindGroup(device));
    const bgl1 = device.getBindGroupLayoutDescription(bg.getBindGroupLayout(device));
    const bgl2 = device.getBindGroupLayoutDescription(model.boundPipeline.getBindGroupLayout(midx));
    if (bgl1 !== bgl2) {
      console.log(`renderEncoder ${model.pipelineHash} mismatched bind group layouts bind group has
${bgl1}
 versus pipeline
${bgl2}
`);
      console.trace();
    }
  };
  publicAPI.attachTextureViews = () => {
    for (let i6 = 0; i6 < model.colorTextureViews.length; i6++) {
      if (!model.description.colorAttachments[i6]) {
        model.description.colorAttachments[i6] = {
          view: model.colorTextureViews[i6].getHandle()
        };
      } else {
        model.description.colorAttachments[i6].view = model.colorTextureViews[i6].getHandle();
      }
    }
    if (model.depthTextureView) {
      model.description.depthStencilAttachment.view = model.depthTextureView.getHandle();
    }
  };
  publicAPI.registerDrawCallback = (pipeline, cb) => {
    for (let i6 = 0; i6 < model.drawCallbacks.length; i6++) {
      if (model.drawCallbacks[i6].pipeline === pipeline) {
        model.drawCallbacks[i6].callbacks.push(cb);
        return;
      }
    }
    model.drawCallbacks.push({
      pipeline,
      callbacks: [cb]
    });
  };
  for (let i6 = 0; i6 < forwarded2.length; i6++) {
    publicAPI[forwarded2[i6]] = function() {
      return model.handle[forwarded2[i6]](...arguments);
    };
  }
}
var DEFAULT_VALUES92 = {
  description: null,
  handle: null,
  boundPipeline: null,
  pipelineHash: null,
  pipelineSettings: null,
  replaceShaderCodeFunction: null,
  depthTextureView: null,
  label: null
};
function extend94(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES92, initialValues);
  obj(publicAPI, model);
  model.description = {
    colorAttachments: [{
      view: void 0,
      loadOp: "load",
      storeOp: "store"
    }],
    depthStencilAttachment: {
      view: void 0,
      depthLoadOp: "clear",
      depthClearValue: 0,
      depthStoreOp: "store"
    }
  };
  model.replaceShaderCodeFunction = (pipeline) => {
    const fDesc = pipeline.getShaderDescription("fragment");
    fDesc.addOutput("vec4<f32>", "outColor");
    let code = fDesc.getCode();
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::RenderEncoder::Impl", ["output.outColor = computedColor;"]).result;
    fDesc.setCode(code);
  };
  model.pipelineSettings = {
    primitive: {
      cullMode: "none"
    },
    depthStencil: {
      depthWriteEnabled: true,
      depthCompare: "greater-equal",
      format: "depth32float"
    },
    fragment: {
      targets: [{
        format: "rgba16float",
        blend: {
          color: {
            srcFactor: "src-alpha",
            dstFactor: "one-minus-src-alpha"
          },
          alpha: {
            srcfactor: "one",
            dstFactor: "one-minus-src-alpha"
          }
        }
      }]
    }
  };
  model.colorTextureViews = [];
  get(publicAPI, model, ["boundPipeline", "colorTextureViews"]);
  setGet(publicAPI, model, ["depthTextureView", "description", "handle", "label", "pipelineHash", "pipelineSettings", "replaceShaderCodeFunction"]);
  vtkWebGPURenderEncoder(publicAPI, model);
}
var newInstance93 = newInstance(extend94, "vtkWebGPURenderEncoder");
var vtkWebGPURenderEncoder$1 = {
  newInstance: newInstance93,
  extend: extend94
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/TextureView.js
function vtkWebGPUTextureView(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUTextureView");
  publicAPI.create = (texture, options) => {
    model.texture = texture;
    model.options = options;
    model.options.dimension = model.options.dimension || "2d";
    model.options.label = model.label;
    model.textureHandle = texture.getHandle();
    model.handle = model.textureHandle.createView(model.options);
    model.bindGroupLayoutEntry.texture.viewDimension = model.options.dimension;
    const tDetails = vtkWebGPUTypes.getDetailsFromTextureFormat(model.texture.getFormat());
    model.bindGroupLayoutEntry.texture.sampleType = tDetails.sampleType;
  };
  publicAPI.createFromTextureHandle = (textureHandle, options) => {
    model.texture = null;
    model.options = options;
    model.options.dimension = model.options.dimension || "2d";
    model.options.label = model.label;
    model.textureHandle = textureHandle;
    model.handle = model.textureHandle.createView(model.options);
    model.bindGroupLayoutEntry.texture.viewDimension = model.options.dimension;
    const tDetails = vtkWebGPUTypes.getDetailsFromTextureFormat(options.format);
    model.bindGroupLayoutEntry.texture.sampleType = tDetails.sampleType;
    model.bindGroupTime.modified();
  };
  publicAPI.getBindGroupEntry = () => {
    const foo = {
      resource: publicAPI.getHandle()
    };
    return foo;
  };
  publicAPI.getShaderCode = (binding, group) => {
    let ttype = "f32";
    if (model.bindGroupLayoutEntry.texture.sampleType === "sint") {
      ttype = "i32";
    } else if (model.bindGroupLayoutEntry.texture.sampleType === "uint") {
      ttype = "u32";
    }
    let result = `@binding(${binding}) @group(${group}) var ${model.label}: texture_${model.options.dimension}<${ttype}>;`;
    if (model.bindGroupLayoutEntry.texture.sampleType === "depth") {
      result = `@binding(${binding}) @group(${group}) var ${model.label}: texture_depth_${model.options.dimension};`;
    }
    return result;
  };
  publicAPI.addSampler = (device, options) => {
    const newSamp = vtkWebGPUSampler$1.newInstance({
      label: `${model.label}Sampler`
    });
    newSamp.create(device, options);
    publicAPI.setSampler(newSamp);
  };
  publicAPI.getBindGroupTime = () => {
    if (model.texture && model.texture.getHandle() !== model.textureHandle) {
      model.textureHandle = model.texture.getHandle();
      model.handle = model.textureHandle.createView(model.options);
      model.bindGroupTime.modified();
    }
    return model.bindGroupTime;
  };
  publicAPI.getHandle = () => {
    if (model.texture && model.texture.getHandle() !== model.textureHandle) {
      model.textureHandle = model.texture.getHandle();
      model.handle = model.textureHandle.createView(model.options);
      model.bindGroupTime.modified();
    }
    return model.handle;
  };
}
var DEFAULT_VALUES93 = {
  texture: null,
  handle: null,
  sampler: null,
  label: null
};
function extend95(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES93, initialValues);
  macro.obj(publicAPI, model);
  model.bindGroupLayoutEntry = {
    /* eslint-disable no-undef */
    visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
    /* eslint-enable no-undef */
    texture: {
      sampleType: "float",
      viewDimension: "2d"
      // multisampled: false,
    }
  };
  model.bindGroupTime = {};
  macro.obj(model.bindGroupTime, {
    mtime: 0
  });
  macro.get(publicAPI, model, ["bindGroupTime", "texture"]);
  macro.setGet(publicAPI, model, ["bindGroupLayoutEntry", "label", "sampler"]);
  vtkWebGPUTextureView(publicAPI, model);
}
var newInstance94 = macro.newInstance(extend95);
var vtkWebGPUTextureView$1 = {
  newInstance: newInstance94,
  extend: extend95
};

// node_modules/@kitware/vtk.js/Rendering/Core/Texture.js
function vtkTexture(publicAPI, model) {
  model.classHierarchy.push("vtkTexture");
  publicAPI.imageLoaded = () => {
    model.image.removeEventListener("load", publicAPI.imageLoaded);
    model.imageLoaded = true;
    publicAPI.modified();
  };
  publicAPI.setJsImageData = (imageData) => {
    if (model.jsImageData === imageData) {
      return;
    }
    if (imageData !== null) {
      publicAPI.setInputData(null);
      publicAPI.setInputConnection(null);
      model.image = null;
      model.canvas = null;
    }
    model.jsImageData = imageData;
    model.imageLoaded = true;
    publicAPI.modified();
  };
  publicAPI.setCanvas = (canvas) => {
    if (model.canvas === canvas) {
      return;
    }
    if (canvas !== null) {
      publicAPI.setInputData(null);
      publicAPI.setInputConnection(null);
      model.image = null;
      model.jsImageData = null;
    }
    model.canvas = canvas;
    publicAPI.modified();
  };
  publicAPI.setImage = (image2) => {
    if (model.image === image2) {
      return;
    }
    if (image2 !== null) {
      publicAPI.setInputData(null);
      publicAPI.setInputConnection(null);
      model.canvas = null;
      model.jsImageData = null;
    }
    model.image = image2;
    model.imageLoaded = false;
    if (image2.complete) {
      publicAPI.imageLoaded();
    } else {
      image2.addEventListener("load", publicAPI.imageLoaded);
    }
    publicAPI.modified();
  };
  publicAPI.getDimensionality = () => {
    let width = 0;
    let height = 0;
    let depth = 1;
    if (publicAPI.getInputData()) {
      const data = publicAPI.getInputData();
      width = data.getDimensions()[0];
      height = data.getDimensions()[1];
      depth = data.getDimensions()[2];
    }
    if (model.jsImageData) {
      width = model.jsImageData.width;
      height = model.jsImageData.height;
    }
    if (model.canvas) {
      width = model.canvas.width;
      height = model.canvas.height;
    }
    if (model.image) {
      width = model.image.width;
      height = model.image.height;
    }
    const dimensionality = (width > 1) + (height > 1) + (depth > 1);
    return dimensionality;
  };
  publicAPI.getInputAsJsImageData = () => {
    if (!model.imageLoaded || publicAPI.getInputData()) return null;
    if (model.jsImageData) {
      return model.jsImageData();
    }
    if (model.canvas) {
      const context = model.canvas.getContext("2d");
      const imageData = context.getImageData(0, 0, model.canvas.width, model.canvas.height);
      return imageData;
    }
    if (model.image) {
      const canvas = document.createElement("canvas");
      canvas.width = model.image.width;
      canvas.height = model.image.height;
      const context = canvas.getContext("2d");
      context.translate(0, canvas.height);
      context.scale(1, -1);
      context.drawImage(model.image, 0, 0, model.image.width, model.image.height);
      const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
      return imageData;
    }
    return null;
  };
}
var generateMipmaps = (nativeArray, width, height, level) => {
  const g3m = [1, 2, 1];
  const g3w = 4;
  const kernel = g3m;
  const kernelWeight = g3w;
  const hs = nativeArray.length / (width * height);
  let currentWidth = width;
  let currentHeight = height;
  let imageData = nativeArray;
  const maps = [imageData];
  for (let i6 = 0; i6 < level; i6++) {
    const oldData = [...imageData];
    currentWidth /= 2;
    currentHeight /= 2;
    imageData = new Uint8ClampedArray(currentWidth * currentHeight * hs);
    const vs = hs * currentWidth;
    let shift3 = 0;
    for (let p3 = 0; p3 < imageData.length; p3 += hs) {
      if (p3 % vs === 0) {
        shift3 += 2 * hs * currentWidth;
      }
      for (let c6 = 0; c6 < hs; c6++) {
        let sample = oldData[shift3 + c6];
        sample += oldData[shift3 + hs + c6];
        sample += oldData[shift3 - 2 * vs + c6];
        sample += oldData[shift3 - 2 * vs + hs + c6];
        sample /= 4;
        imageData[p3 + c6] = sample;
      }
      shift3 += 2 * hs;
    }
    let dataCopy = [...imageData];
    for (let p3 = 0; p3 < imageData.length; p3 += hs) {
      for (let c6 = 0; c6 < hs; c6++) {
        let x2 = -(kernel.length - 1) / 2;
        let kw = kernelWeight;
        let value = 0;
        for (let k2 = 0; k2 < kernel.length; k2++) {
          let index2 = p3 + c6 + x2 * hs;
          const lineShift = index2 % vs - (p3 + c6) % vs;
          if (lineShift > hs) index2 += vs;
          if (lineShift < -hs) index2 -= vs;
          if (dataCopy[index2]) {
            value += dataCopy[index2] * kernel[k2];
          } else {
            kw -= kernel[k2];
          }
          x2 += 1;
        }
        imageData[p3 + c6] = value / kw;
      }
    }
    dataCopy = [...imageData];
    for (let p3 = 0; p3 < imageData.length; p3 += hs) {
      for (let c6 = 0; c6 < hs; c6++) {
        let x2 = -(kernel.length - 1) / 2;
        let kw = kernelWeight;
        let value = 0;
        for (let k2 = 0; k2 < kernel.length; k2++) {
          const index2 = p3 + c6 + x2 * vs;
          if (dataCopy[index2]) {
            value += dataCopy[index2] * kernel[k2];
          } else {
            kw -= kernel[k2];
          }
          x2 += 1;
        }
        imageData[p3 + c6] = value / kw;
      }
    }
    maps.push(imageData);
  }
  return maps;
};
var DEFAULT_VALUES94 = {
  image: null,
  canvas: null,
  jsImageData: null,
  imageLoaded: false,
  repeat: false,
  interpolate: false,
  edgeClamp: false,
  mipLevel: 0,
  resizable: false
  // must be set at construction time if the texture can be resizable
};
function extend96(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES94, initialValues);
  macro.obj(publicAPI, model);
  macro.algo(publicAPI, model, 6, 0);
  macro.get(publicAPI, model, ["canvas", "image", "jsImageData", "imageLoaded", "resizable"]);
  macro.setGet(publicAPI, model, ["repeat", "edgeClamp", "interpolate", "mipLevel"]);
  vtkTexture(publicAPI, model);
}
var newInstance95 = macro.newInstance(extend96, "vtkTexture");
var STATIC12 = {
  generateMipmaps
};
var vtkTexture$1 = __spreadValues({
  newInstance: newInstance95,
  extend: extend96
}, STATIC12);

// node_modules/@kitware/vtk.js/Rendering/WebGPU/Texture.js
var {
  BufferUsage: BufferUsage5
} = vtkWebGPUBufferManager$1;
function vtkWebGPUTexture(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUTexture");
  publicAPI.create = (device, options) => {
    model.device = device;
    model.width = options.width;
    model.height = options.height;
    model.depth = options.depth ? options.depth : 1;
    const dimension2 = model.depth === 1 ? "2d" : "3d";
    model.format = options.format ? options.format : "rgba8unorm";
    model.mipLevel = options.mipLevel ? options.mipLevel : 0;
    model.usage = options.usage ? options.usage : GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;
    model.handle = model.device.getHandle().createTexture({
      size: [model.width, model.height, model.depth],
      format: model.format,
      // 'rgba8unorm',
      usage: model.usage,
      label: model.label,
      dimension: dimension2,
      mipLevelCount: model.mipLevel + 1
    });
  };
  publicAPI.assignFromHandle = (device, handle, options) => {
    model.device = device;
    model.handle = handle;
    model.width = options.width;
    model.height = options.height;
    model.depth = options.depth ? options.depth : 1;
    model.format = options.format ? options.format : "rgba8unorm";
    model.usage = options.usage ? options.usage : GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;
  };
  publicAPI.writeImageData = (req) => {
    let nativeArray = [];
    if (req.canvas) {
      model.device.getHandle().queue.copyExternalImageToTexture({
        source: req.canvas,
        flipY: req.flip
      }, {
        texture: model.handle,
        premultipliedAlpha: true
      }, [model.width, model.height, model.depth]);
      model.ready = true;
      return;
    }
    if (req.jsImageData && !req.nativeArray) {
      req.width = req.jsImageData.width;
      req.height = req.jsImageData.height;
      req.depth = 1;
      req.format = "rgba8unorm";
      req.flip = true;
      req.nativeArray = req.jsImageData.data;
    }
    const tDetails = vtkWebGPUTypes.getDetailsFromTextureFormat(model.format);
    let bufferBytesPerRow = model.width * tDetails.stride;
    const fixAll = (arr, height, depth) => {
      const inWidthInBytes = arr.length / (height * depth) * arr.BYTES_PER_ELEMENT;
      const halfFloat = tDetails.elementSize === 2 && tDetails.sampleType === "float";
      if (halfFloat || inWidthInBytes % 256) {
        const inArray = arr;
        const inWidth = inWidthInBytes / inArray.BYTES_PER_ELEMENT;
        const outBytesPerElement = tDetails.elementSize;
        const outWidthInBytes = 256 * Math.floor((inWidth * outBytesPerElement + 255) / 256);
        const outWidth = outWidthInBytes / outBytesPerElement;
        const outArray = macro.newTypedArray(halfFloat ? "Uint16Array" : inArray.constructor.name, outWidth * height * depth);
        for (let v2 = 0; v2 < height * depth; v2++) {
          if (halfFloat) {
            for (let i6 = 0; i6 < inWidth; i6++) {
              outArray[v2 * outWidth + i6] = HalfFloat.toHalf(inArray[v2 * inWidth + i6]);
            }
          } else {
            outArray.set(inArray.subarray(v2 * inWidth, (v2 + 1) * inWidth), v2 * outWidth);
          }
        }
        return [outArray, outWidthInBytes];
      }
      return [arr, inWidthInBytes];
    };
    if (req.nativeArray) {
      nativeArray = req.nativeArray;
    }
    if (req.image) {
      const canvas = document.createElement("canvas");
      canvas.width = req.image.width;
      canvas.height = req.image.height;
      const ctx = canvas.getContext("2d");
      ctx.translate(0, canvas.height);
      ctx.scale(1, -1);
      ctx.drawImage(req.image, 0, 0, req.image.width, req.image.height, 0, 0, canvas.width, canvas.height);
      const imageData = ctx.getImageData(0, 0, req.image.width, req.image.height);
      nativeArray = imageData.data;
    }
    const cmdEnc = model.device.createCommandEncoder();
    if (publicAPI.getDimensionality() !== 3) {
      const mips = vtkTexture$1.generateMipmaps(nativeArray, model.width, model.height, model.mipLevel);
      let currentWidth = model.width;
      let currentHeight = model.height;
      for (let m3 = 0; m3 <= model.mipLevel; m3++) {
        const fix = fixAll(mips[m3], currentHeight, 1);
        bufferBytesPerRow = fix[1];
        const buffRequest = {
          dataArray: req.dataArray ? req.dataArray : null,
          nativeArray: fix[0],
          /* eslint-disable no-undef */
          usage: BufferUsage5.Texture
          /* eslint-enable no-undef */
        };
        const buff = model.device.getBufferManager().getBuffer(buffRequest);
        cmdEnc.copyBufferToTexture({
          buffer: buff.getHandle(),
          offset: 0,
          bytesPerRow: bufferBytesPerRow,
          rowsPerImage: currentHeight
        }, {
          texture: model.handle,
          mipLevel: m3
        }, [currentWidth, currentHeight, 1]);
        currentWidth /= 2;
        currentHeight /= 2;
      }
      model.device.submitCommandEncoder(cmdEnc);
      model.ready = true;
    } else {
      const fix = fixAll(nativeArray, model.height, model.depth);
      bufferBytesPerRow = fix[1];
      const buffRequest = {
        dataArray: req.dataArray ? req.dataArray : null,
        /* eslint-disable no-undef */
        usage: BufferUsage5.Texture
        /* eslint-enable no-undef */
      };
      buffRequest.nativeArray = fix[0];
      const buff = model.device.getBufferManager().getBuffer(buffRequest);
      cmdEnc.copyBufferToTexture({
        buffer: buff.getHandle(),
        offset: 0,
        bytesPerRow: bufferBytesPerRow,
        rowsPerImage: model.height
      }, {
        texture: model.handle
      }, [model.width, model.height, model.depth]);
      model.device.submitCommandEncoder(cmdEnc);
      model.ready = true;
    }
  };
  publicAPI.getScale = () => {
    const tDetails = vtkWebGPUTypes.getDetailsFromTextureFormat(model.format);
    const halfFloat = tDetails.elementSize === 2 && tDetails.sampleType === "float";
    return halfFloat ? 1 : 255;
  };
  publicAPI.getNumberOfComponents = () => {
    const tDetails = vtkWebGPUTypes.getDetailsFromTextureFormat(model.format);
    return tDetails.numComponents;
  };
  publicAPI.getDimensionality = () => {
    let dims = 0;
    if (model.width > 1) dims++;
    if (model.height > 1) dims++;
    if (model.depth > 1) dims++;
    return dims;
  };
  publicAPI.resizeToMatch = (tex) => {
    if (tex.getWidth() !== model.width || tex.getHeight() !== model.height || tex.getDepth() !== model.depth) {
      model.width = tex.getWidth();
      model.height = tex.getHeight();
      model.depth = tex.getDepth();
      model.handle = model.device.getHandle().createTexture({
        size: [model.width, model.height, model.depth],
        format: model.format,
        usage: model.usage,
        label: model.label
      });
    }
  };
  publicAPI.resize = function(width, height) {
    let depth = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
    if (width !== model.width || height !== model.height || depth !== model.depth) {
      model.width = width;
      model.height = height;
      model.depth = depth;
      model.handle = model.device.getHandle().createTexture({
        size: [model.width, model.height, model.depth],
        format: model.format,
        usage: model.usage,
        label: model.label
      });
    }
  };
  publicAPI.createView = function(label) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!options.dimension) {
      options.dimension = model.depth === 1 ? "2d" : "3d";
    }
    const view = vtkWebGPUTextureView$1.newInstance({
      label
    });
    view.create(publicAPI, options);
    return view;
  };
}
var DEFAULT_VALUES95 = {
  device: null,
  handle: null,
  buffer: null,
  ready: false,
  label: null
};
function extend97(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES95, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["handle", "ready", "width", "height", "depth", "format", "usage"]);
  macro.setGet(publicAPI, model, ["device", "label"]);
  vtkWebGPUTexture(publicAPI, model);
}
var newInstance96 = macro.newInstance(extend97);
var vtkWebGPUTexture$1 = {
  newInstance: newInstance96,
  extend: extend97
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/OpaquePass.js
function vtkWebGPUOpaquePass(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUOpaquePass");
  publicAPI.traverse = (renNode, viewNode) => {
    if (model.deleted) {
      return;
    }
    model._currentParent = viewNode;
    const device = viewNode.getDevice();
    if (!model.renderEncoder) {
      publicAPI.createRenderEncoder();
      model.colorTexture = vtkWebGPUTexture$1.newInstance({
        label: "opaquePassColor"
      });
      model.colorTexture.create(device, {
        width: viewNode.getCanvas().width,
        height: viewNode.getCanvas().height,
        format: "rgba16float",
        /* eslint-disable no-undef */
        /* eslint-disable no-bitwise */
        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC
      });
      const ctView = model.colorTexture.createView("opaquePassColorTexture");
      model.renderEncoder.setColorTextureView(0, ctView);
      model.depthFormat = "depth32float";
      model.depthTexture = vtkWebGPUTexture$1.newInstance({
        label: "opaquePassDepth"
      });
      model.depthTexture.create(device, {
        width: viewNode.getCanvas().width,
        height: viewNode.getCanvas().height,
        format: model.depthFormat,
        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC
      });
      const dView = model.depthTexture.createView("opaquePassDepthTexture");
      model.renderEncoder.setDepthTextureView(dView);
    } else {
      model.colorTexture.resize(viewNode.getCanvas().width, viewNode.getCanvas().height);
      model.depthTexture.resize(viewNode.getCanvas().width, viewNode.getCanvas().height);
    }
    model.renderEncoder.attachTextureViews();
    publicAPI.setCurrentOperation("opaquePass");
    renNode.setRenderEncoder(model.renderEncoder);
    renNode.traverse(publicAPI);
  };
  publicAPI.getColorTextureView = () => model.renderEncoder.getColorTextureViews()[0];
  publicAPI.getDepthTextureView = () => model.renderEncoder.getDepthTextureView();
  publicAPI.createRenderEncoder = () => {
    model.renderEncoder = vtkWebGPURenderEncoder$1.newInstance({
      label: "OpaquePass"
    });
    model.renderEncoder.setPipelineHash("op");
  };
}
var DEFAULT_VALUES96 = {
  renderEncoder: null,
  colorTexture: null,
  depthTexture: null
};
function extend98(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES96, initialValues);
  vtkRenderPass$1.extend(publicAPI, model, initialValues);
  macro.get(publicAPI, model, ["colorTexture", "depthTexture"]);
  vtkWebGPUOpaquePass(publicAPI, model);
}
var newInstance97 = macro.newInstance(extend98, "vtkWebGPUOpaquePass");
var vtkWebGPUOpaquePass$1 = {
  newInstance: newInstance97,
  extend: extend98
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/OrderIndependentTranslucentPass.js
var oitpFragTemplate2 = `
//VTK::Mapper::Dec

//VTK::TCoord::Dec

//VTK::RenderEncoder::Dec

//VTK::IOStructs::Dec

@fragment
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output: fragmentOutput;

  var tcoord: vec2<i32> = vec2<i32>(i32(input.fragPos.x), i32(input.fragPos.y));
  var reveal: f32 = textureLoad(oitpAccumTexture, tcoord, 0).r;
  if (reveal == 1.0) { discard; }
  var tcolor: vec4<f32> = textureLoad(oitpColorTexture, tcoord, 0);
  var total: f32 = max(tcolor.a, 0.01);
  var computedColor: vec4<f32> = vec4<f32>(tcolor.r/total, tcolor.g/total, tcolor.b/total, 1.0 - reveal);

  //VTK::RenderEncoder::Impl
  return output;
}
`;
function vtkWebGPUOrderIndependentTranslucentPass(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUOrderIndependentTranslucentPass");
  publicAPI.traverse = (renNode, viewNode) => {
    if (model.deleted) {
      return;
    }
    model._currentParent = viewNode;
    const device = viewNode.getDevice();
    if (!model.translucentRenderEncoder) {
      publicAPI.createRenderEncoder();
      publicAPI.createFinalEncoder();
      model.translucentColorTexture = vtkWebGPUTexture$1.newInstance({
        label: "translucentPassColor"
      });
      model.translucentColorTexture.create(device, {
        width: viewNode.getCanvas().width,
        height: viewNode.getCanvas().height,
        format: "rgba16float",
        /* eslint-disable no-undef */
        /* eslint-disable no-bitwise */
        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
      });
      const v1 = model.translucentColorTexture.createView("oitpColorTexture");
      model.translucentRenderEncoder.setColorTextureView(0, v1);
      model.translucentAccumulateTexture = vtkWebGPUTexture$1.newInstance({
        label: "translucentPassAccumulate"
      });
      model.translucentAccumulateTexture.create(device, {
        width: viewNode.getCanvas().width,
        height: viewNode.getCanvas().height,
        format: "r16float",
        /* eslint-disable no-undef */
        /* eslint-disable no-bitwise */
        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
      });
      const v2 = model.translucentAccumulateTexture.createView("oitpAccumTexture");
      model.translucentRenderEncoder.setColorTextureView(1, v2);
      model.fullScreenQuad = vtkWebGPUFullScreenQuad$1.newInstance();
      model.fullScreenQuad.setDevice(viewNode.getDevice());
      model.fullScreenQuad.setPipelineHash("oitpfsq");
      model.fullScreenQuad.setTextureViews(model.translucentRenderEncoder.getColorTextureViews());
      model.fullScreenQuad.setFragmentShaderTemplate(oitpFragTemplate2);
    } else {
      model.translucentColorTexture.resizeToMatch(model.colorTextureView.getTexture());
      model.translucentAccumulateTexture.resizeToMatch(model.colorTextureView.getTexture());
    }
    model.translucentRenderEncoder.setDepthTextureView(model.depthTextureView);
    model.translucentRenderEncoder.attachTextureViews();
    publicAPI.setCurrentOperation("translucentPass");
    renNode.setRenderEncoder(model.translucentRenderEncoder);
    renNode.traverse(publicAPI);
    publicAPI.finalPass(viewNode, renNode);
  };
  publicAPI.finalPass = (viewNode, renNode) => {
    model.translucentFinalEncoder.setColorTextureView(0, model.colorTextureView);
    model.translucentFinalEncoder.attachTextureViews();
    model.translucentFinalEncoder.begin(viewNode.getCommandEncoder());
    renNode.scissorAndViewport(model.translucentFinalEncoder);
    model.fullScreenQuad.prepareAndDraw(model.translucentFinalEncoder);
    model.translucentFinalEncoder.end();
  };
  publicAPI.getTextures = () => [model.translucentColorTexture, model.translucentAccumulateTexture];
  publicAPI.createRenderEncoder = () => {
    model.translucentRenderEncoder = vtkWebGPURenderEncoder$1.newInstance({
      label: "translucentRender"
    });
    const rDesc = model.translucentRenderEncoder.getDescription();
    rDesc.colorAttachments = [{
      view: void 0,
      clearValue: [0, 0, 0, 0],
      loadOp: "clear",
      storeOp: "store"
    }, {
      view: void 0,
      clearValue: [1, 0, 0, 0],
      loadOp: "clear",
      storeOp: "store"
    }];
    rDesc.depthStencilAttachment = {
      view: void 0,
      depthLoadOp: "load",
      depthStoreOp: "store"
    };
    model.translucentRenderEncoder.setReplaceShaderCodeFunction((pipeline) => {
      const fDesc = pipeline.getShaderDescription("fragment");
      fDesc.addOutput("vec4<f32>", "outColor");
      fDesc.addOutput("f32", "outAccum");
      fDesc.addBuiltinInput("vec4<f32>", "@builtin(position) fragPos");
      let code = fDesc.getCode();
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::RenderEncoder::Impl", [
        // very simple depth weighting in w z ranges from 1.0 near to 0.0
        "var w: f32 = computedColor.a * pow(0.1 + input.fragPos.z, 2.0);",
        "output.outColor = vec4<f32>(computedColor.rgb*w, w);",
        "output.outAccum = computedColor.a;"
      ]).result;
      fDesc.setCode(code);
    });
    model.translucentRenderEncoder.setPipelineHash("oitpr");
    model.translucentRenderEncoder.setPipelineSettings({
      primitive: {
        cullMode: "none"
      },
      depthStencil: {
        depthWriteEnabled: false,
        depthCompare: "greater",
        format: "depth32float"
      },
      fragment: {
        targets: [{
          format: "rgba16float",
          blend: {
            color: {
              srcFactor: "one",
              dstFactor: "one"
            },
            alpha: {
              srcfactor: "one",
              dstFactor: "one"
            }
          }
        }, {
          format: "r16float",
          blend: {
            color: {
              srcFactor: "zero",
              dstFactor: "one-minus-src"
            },
            alpha: {
              srcfactor: "one",
              dstFactor: "one-minus-src-alpha"
            }
          }
        }]
      }
    });
  };
  publicAPI.createFinalEncoder = () => {
    model.translucentFinalEncoder = vtkWebGPURenderEncoder$1.newInstance({
      label: "translucentFinal"
    });
    model.translucentFinalEncoder.setDescription({
      colorAttachments: [{
        view: null,
        loadOp: "load",
        storeOp: "store"
      }]
    });
    model.translucentFinalEncoder.setReplaceShaderCodeFunction((pipeline) => {
      const fDesc = pipeline.getShaderDescription("fragment");
      fDesc.addOutput("vec4<f32>", "outColor");
      fDesc.addBuiltinInput("vec4<f32>", "@builtin(position) fragPos");
      let code = fDesc.getCode();
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::RenderEncoder::Impl", ["output.outColor = vec4<f32>(computedColor.rgb, computedColor.a);"]).result;
      fDesc.setCode(code);
    });
    model.translucentFinalEncoder.setPipelineHash("oitpf");
    model.translucentFinalEncoder.setPipelineSettings({
      primitive: {
        cullMode: "none"
      },
      fragment: {
        targets: [{
          format: "rgba16float",
          blend: {
            color: {
              srcFactor: "src-alpha",
              dstFactor: "one-minus-src-alpha"
            },
            alpha: {
              srcfactor: "one",
              dstFactor: "one-minus-src-alpha"
            }
          }
        }]
      }
    });
  };
}
var DEFAULT_VALUES97 = {
  colorTextureView: null,
  depthTextureView: null
};
function extend99(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES97, initialValues);
  vtkRenderPass$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["colorTextureView", "depthTextureView"]);
  vtkWebGPUOrderIndependentTranslucentPass(publicAPI, model);
}
var newInstance98 = macro.newInstance(extend99, "vtkWebGPUOrderIndependentTranslucentPass");
var vtkWebGPUOrderIndepenentTranslucentPass = {
  newInstance: newInstance98,
  extend: extend99
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/VolumePassFSQ.js
var volFragTemplate = `
//VTK::Renderer::Dec

//VTK::Mapper::Dec

//VTK::TCoord::Dec

//VTK::Volume::TraverseDec

//VTK::RenderEncoder::Dec

//VTK::IOStructs::Dec

fn getTextureValue(vTex: texture_3d<f32>, tpos: vec4<f32>) -> f32
{
  // todo multicomponent support
  return textureSampleLevel(vTex, clampSampler, tpos.xyz, 0.0).r;
}

fn getGradient(vTex: texture_3d<f32>, tpos: vec4<f32>, vNum: i32, scalar: f32) -> vec4<f32>
{
  var result: vec4<f32>;

  var tstep: vec4<f32> = volumeSSBO.values[vNum].tstep;
  result.x = getTextureValue(vTex, tpos + vec4<f32>(tstep.x, 0.0, 0.0, 1.0)) - scalar;
  result.y = getTextureValue(vTex, tpos + vec4<f32>(0.0, tstep.y, 0.0, 1.0)) - scalar;
  result.z = getTextureValue(vTex, tpos + vec4<f32>(0.0, 0.0, tstep.z, 1.0)) - scalar;
  result.w = 0.0;

  // divide by spacing as that is our delta
  result = result / volumeSSBO.values[vNum].spacing;
  // now we have a gradient in unit tcoords

  var grad: f32 = length(result.xyz);
  if (grad > 0.0)
  {
    // rotate to View Coords, needed for lighting and shading
    var nMat: mat4x4<f32> = rendererUBO.SCVCMatrix * volumeSSBO.values[vNum].planeNormals;
    result = nMat * result;
    result = result / length(result);
  }

  // store gradient magnitude in .w
  result.w = grad;

  return result;
}

fn processVolume(vTex: texture_3d<f32>, vNum: i32, cNum: i32, posSC: vec4<f32>, tfunRows: f32) -> vec4<f32>
{
  var outColor: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);

  // convert to tcoords and reject if outside the volume
  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*posSC;
  if (tpos.x < 0.0 || tpos.y < 0.0 || tpos.z < 0.0 ||
      tpos.x > 1.0 || tpos.y > 1.0 || tpos.z > 1.0) { return outColor; }

  var scalar: f32 = getTextureValue(vTex, tpos);

  var coord: vec2<f32> =
    vec2<f32>(scalar * componentSSBO.values[cNum].cScale + componentSSBO.values[cNum].cShift,
      (0.5 + 2.0 * f32(vNum)) / tfunRows);
  var color: vec4<f32> = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);

  var gofactor: f32 = 1.0;
  var normal: vec4<f32> = vec4<f32>(0.0,0.0,0.0,0.0);
  if (componentSSBO.values[cNum].gomin <  1.0 || volumeSSBO.values[vNum].shade[0] > 0.0)
  {
    normal = getGradient(vTex, tpos, vNum, scalar);
    if (componentSSBO.values[cNum].gomin <  1.0)
    {
      gofactor = clamp(normal.a*componentSSBO.values[cNum].goScale + componentSSBO.values[cNum].goShift,
      componentSSBO.values[cNum].gomin, componentSSBO.values[cNum].gomax);
    }
  }

  coord.x = (scalar * componentSSBO.values[cNum].oScale + componentSSBO.values[cNum].oShift);
  var opacity: f32 = textureSampleLevel(ofunTexture, clampSampler, coord, 0.0).r;

  if (volumeSSBO.values[vNum].shade[0] > 0.0)
  {
    color = color*abs(normal.z);
  }

  outColor = vec4<f32>(color.rgb, gofactor * opacity);

  return outColor;
}

// adjust the start and end point of a raycast such that it intersects the unit cube.
// This function is used to take a raycast starting point and step vector
// and numSteps and return the startijng and ending steps for intersecting the
// unit cube. Recall for a 3D texture, the unit cube is the range of texture coordsinates
// that have valid values. So this funtion can be used to take a ray in texture coordinates
// and bound it to intersecting the texture.
//
fn adjustBounds(tpos: vec4<f32>, tstep: vec4<f32>, numSteps: f32) -> vec2<f32>
{
  var result: vec2<f32> = vec2<f32>(0.0, numSteps);
  var tpos2: vec4<f32> = tpos + tstep*numSteps;

  // move tpos to the start of the volume
  var adjust: f32 =
    min(
      max(tpos.x/tstep.x, (tpos.x - 1.0)/tstep.x),
      min(
        max((tpos.y - 1.0)/tstep.y, tpos.y/tstep.y),
        max((tpos.z - 1.0)/tstep.z, tpos.z/tstep.z)));
  if (adjust < 0.0)
  {
    result.x = result.x - adjust;
  }

  // adjust length to the end
  adjust =
    max(
      min(tpos2.x/tstep.x, (tpos2.x - 1.0)/tstep.x),
      max(
        min((tpos2.y - 1.0)/tstep.y, tpos2.y/tstep.y),
        min((tpos2.z - 1.0)/tstep.z, tpos2.z/tstep.z)));
  if (adjust > 0.0)
  {
    result.y = result.y - adjust;
  }

  return result;
}

fn getSimpleColor(scalar: f32, vNum: i32, cNum: i32) -> vec4<f32>
{
  // how many rows (tfuns) do we have in our tfunTexture
  var tfunRows: f32 = f32(textureDimensions(tfunTexture).y);

  var coord: vec2<f32> =
    vec2<f32>(scalar * componentSSBO.values[cNum].cScale + componentSSBO.values[cNum].cShift,
      (0.5 + 2.0 * f32(vNum)) / tfunRows);
  var color: vec4<f32> = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);
  coord.x = (scalar * componentSSBO.values[cNum].oScale + componentSSBO.values[cNum].oShift);
  var opacity: f32 = textureSampleLevel(ofunTexture, clampSampler, coord, 0.0).r;
  return vec4<f32>(color.rgb, opacity);
}

fn traverseMax(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)
{
  // convert to tcoords and reject if outside the volume
  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;
  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;
  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);
  var tstep: vec4<f32> = tpos2 - tpos;

  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);

  // did we hit anything
  if (rayBounds.x >= rayBounds.y)
  {
    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);
    return;
  }

  tpos = tpos + tstep*rayBounds.x;
  var curDist: f32 = rayBounds.x;
  var maxVal: f32 = -1.0e37;
  loop
  {
    var scalar: f32 = getTextureValue(vTex, tpos);
    if (scalar > maxVal)
    {
      maxVal = scalar;
    }

    // increment position
    curDist = curDist + 1.0;
    tpos = tpos + tstep;

    // check if we have reached a terminating condition
    if (curDist > rayBounds.y) { break; }
  }

  // process to get the color and opacity
  traverseVals[vNum] = getSimpleColor(maxVal, vNum, cNum);
}

fn traverseMin(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)
{
  // convert to tcoords and reject if outside the volume
  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;
  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;
  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);
  var tstep: vec4<f32> = tpos2 - tpos;

  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);

  // did we hit anything
  if (rayBounds.x >= rayBounds.y)
  {
    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);
    return;
  }

  tpos = tpos + tstep*rayBounds.x;
  var curDist: f32 = rayBounds.x;
  var minVal: f32 = 1.0e37;
  loop
  {
    var scalar: f32 = getTextureValue(vTex, tpos);
    if (scalar < minVal)
    {
      minVal = scalar;
    }

    // increment position
    curDist = curDist + 1.0;
    tpos = tpos + tstep;

    // check if we have reached a terminating condition
    if (curDist > rayBounds.y) { break; }
  }

  // process to get the color and opacity
  traverseVals[vNum] = getSimpleColor(minVal, vNum, cNum);
}

fn traverseAverage(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)
{
  // convert to tcoords and reject if outside the volume
  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;
  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;
  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);
  var tstep: vec4<f32> = tpos2 - tpos;

  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);

  // did we hit anything
  if (rayBounds.x >= rayBounds.y)
  {
    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);
    return;
  }

  let ipRange: vec4<f32> = volumeSSBO.values[vNum].ipScalarRange;
  tpos = tpos + tstep*rayBounds.x;
  var curDist: f32 = rayBounds.x;
  var avgVal: f32 = 0.0;
  var sampleCount: f32 = 0.0;
  loop
  {
    var sample: f32 = getTextureValue(vTex, tpos);
    // right now leave filtering off until WebGL changes get merged
    // if (ipRange.z == 0.0 || sample >= ipRange.x && sample <= ipRange.y)
    // {
      avgVal = avgVal + sample;
      sampleCount = sampleCount + 1.0;
    // }

    // increment position
    curDist = curDist + 1.0;
    tpos = tpos + tstep;

    // check if we have reached a terminating condition
    if (curDist > rayBounds.y) { break; }
  }

  if (sampleCount <= 0.0)
  {
    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);
  }

  // process to get the color and opacity
  traverseVals[vNum] = getSimpleColor(avgVal/sampleCount, vNum, cNum);
}

fn traverseAdditive(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)
{
  // convert to tcoords and reject if outside the volume
  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;
  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;
  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);
  var tstep: vec4<f32> = tpos2 - tpos;

  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);

  // did we hit anything
  if (rayBounds.x >= rayBounds.y)
  {
    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);
    return;
  }

  let ipRange: vec4<f32> = volumeSSBO.values[vNum].ipScalarRange;
  tpos = tpos + tstep*rayBounds.x;
  var curDist: f32 = rayBounds.x;
  var sumVal: f32 = 0.0;
  loop
  {
    var sample: f32 = getTextureValue(vTex, tpos);
    // right now leave filtering off until WebGL changes get merged
    // if (ipRange.z == 0.0 || sample >= ipRange.x && sample <= ipRange.y)
    // {
      sumVal = sumVal + sample;
    // }

    // increment position
    curDist = curDist + 1.0;
    tpos = tpos + tstep;

    // check if we have reached a terminating condition
    if (curDist > rayBounds.y) { break; }
  }

  // process to get the color and opacity
  traverseVals[vNum] = getSimpleColor(sumVal, vNum, cNum);
}

fn composite(rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>) -> vec4<f32>
{
  // initial ray position is at the beginning
  var rayPosSC: vec4<f32> = minPosSC;

  // how many rows (tfuns) do we have in our tfunTexture
  var tfunRows: f32 = f32(textureDimensions(tfunTexture).y);

  var curDist: f32 = 0.0;
  var computedColor: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);
  var sampleColor: vec4<f32>;
//VTK::Volume::TraverseCalls

  loop
  {
    // for each volume, sample and accumulate color
//VTK::Volume::CompositeCalls

    // increment position
    curDist = curDist + mapperUBO.SampleDistance;
    rayPosSC = rayPosSC + rayStepSC;

    // check if we have reached a terminating condition
    if (curDist > rayLengthSC) { break; }
    if (computedColor.a > 0.98) { break; }
  }
  return computedColor;
}

@fragment
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output: fragmentOutput;

  var rayMax: f32 = textureSampleLevel(maxTexture, clampSampler, input.tcoordVS, 0.0).r;
  var rayMin: f32 = textureSampleLevel(minTexture, clampSampler, input.tcoordVS, 0.0).r;

  // discard empty rays
  if (rayMax <= rayMin) { discard; }
  else
  {
    // compute start and end ray positions in view coordinates
    var minPosSC: vec4<f32> = rendererUBO.PCSCMatrix*vec4<f32>(2.0 * input.tcoordVS.x - 1.0, 1.0 - 2.0 * input.tcoordVS.y, rayMax, 1.0);
    minPosSC = minPosSC * (1.0 / minPosSC.w);
    var maxPosSC: vec4<f32> = rendererUBO.PCSCMatrix*vec4<f32>(2.0 * input.tcoordVS.x - 1.0, 1.0 - 2.0 * input.tcoordVS.y, rayMin, 1.0);
    maxPosSC = maxPosSC * (1.0 / maxPosSC.w);

    var rayLengthSC: f32 = distance(minPosSC.xyz, maxPosSC.xyz);
    var rayStepSC: vec4<f32> = (maxPosSC - minPosSC)*(mapperUBO.SampleDistance/rayLengthSC);
    rayStepSC.w = 0.0;

    var computedColor: vec4<f32>;

//VTK::Volume::Loop

//VTK::RenderEncoder::Impl
  }

  return output;
}
`;
var tmpMat42 = new Float64Array(16);
var tmp2Mat42 = new Float64Array(16);
function vtkWebGPUVolumePassFSQ(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUVolumePassFSQ");
  publicAPI.replaceShaderPosition = (hash, pipeline, vertexInput) => {
    const vDesc = pipeline.getShaderDescription("vertex");
    vDesc.addBuiltinOutput("vec4<f32>", "@builtin(position) Position");
    let code = vDesc.getCode();
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Position::Impl", ["output.tcoordVS = vec2<f32>(vertexBC.x * 0.5 + 0.5, 1.0 - vertexBC.y * 0.5 - 0.5);", "output.Position = vec4<f32>(vertexBC, 1.0);"]).result;
    vDesc.setCode(code);
    const fDesc = pipeline.getShaderDescription("fragment");
    fDesc.addBuiltinInput("vec4<f32>", "@builtin(position) fragPos");
  };
  model.shaderReplacements.set("replaceShaderPosition", publicAPI.replaceShaderPosition);
  publicAPI.replaceShaderVolume = (hash, pipeline, vertexInput) => {
    const fDesc = pipeline.getShaderDescription("fragment");
    let code = fDesc.getCode();
    const compositeCalls = [];
    const traverseCalls = [];
    for (let i6 = 0; i6 < model.volumes.length; i6++) {
      const blendMode = model.volumes[i6].getRenderable().getMapper().getBlendMode();
      if (blendMode === BlendMode.COMPOSITE_BLEND) {
        compositeCalls.push(`    sampleColor = processVolume(volTexture${i6}, ${i6}, ${model.rowStarts[i6]}, rayPosSC, tfunRows);`);
        compositeCalls.push(`    computedColor = vec4<f32>(
          sampleColor.a * sampleColor.rgb * (1.0 - computedColor.a) + computedColor.rgb,
          (1.0 - computedColor.a)*sampleColor.a + computedColor.a);`);
      } else {
        traverseCalls.push(`  sampleColor = traverseVals[${i6}];`);
        traverseCalls.push(`  computedColor = vec4<f32>(
          sampleColor.a * sampleColor.rgb * (1.0 - computedColor.a) + computedColor.rgb,
          (1.0 - computedColor.a)*sampleColor.a + computedColor.a);`);
      }
    }
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Volume::CompositeCalls", compositeCalls).result;
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Volume::TraverseCalls", traverseCalls).result;
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Volume::TraverseDec", [`var<private> traverseVals: array<vec4<f32>,${model.volumes.length}>;`]).result;
    let compositeWhileTraversing = false;
    for (let vidx = 0; vidx < model.volumes.length; vidx++) {
      const blendMode = model.volumes[vidx].getRenderable().getMapper().getBlendMode();
      if (blendMode === BlendMode.COMPOSITE_BLEND) {
        compositeWhileTraversing = true;
      } else if (blendMode === BlendMode.MAXIMUM_INTENSITY_BLEND) {
        code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Volume::Loop", [`    traverseMax(volTexture${vidx}, ${vidx}, ${vidx}, rayLengthSC, minPosSC, rayStepSC);`, `    computedColor = traverseVals[${vidx}];`, "//VTK::Volume::Loop"]).result;
      } else if (blendMode === BlendMode.MINIMUM_INTENSITY_BLEND) {
        code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Volume::Loop", [`    traverseMin(volTexture${vidx}, ${vidx}, ${vidx}, rayLengthSC, minPosSC, rayStepSC);`, `    computedColor = traverseVals[${vidx}];`, "//VTK::Volume::Loop"]).result;
      } else if (blendMode === BlendMode.AVERAGE_INTENSITY_BLEND) {
        code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Volume::Loop", [`    traverseAverage(volTexture${vidx}, ${vidx}, ${vidx}, rayLengthSC, minPosSC, rayStepSC);`, `    computedColor = traverseVals[${vidx}];`, "//VTK::Volume::Loop"]).result;
      } else if (blendMode === BlendMode.ADDITIVE_INTENSITY_BLEND) {
        code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Volume::Loop", [`    traverseAdditive(volTexture${vidx}, ${vidx}, ${vidx}, rayLengthSC, minPosSC, rayStepSC);`, `    computedColor = traverseVals[${vidx}];`, "//VTK::Volume::Loop"]).result;
      }
    }
    if (compositeWhileTraversing) {
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Volume::Loop", ["    computedColor = composite(rayLengthSC, minPosSC, rayStepSC);"]).result;
    }
    fDesc.setCode(code);
  };
  model.shaderReplacements.set("replaceShaderVolume", publicAPI.replaceShaderVolume);
  publicAPI.updateLUTImage = (device) => {
    let mtime = publicAPI.getMTime();
    for (let i6 = 0; i6 < model.volumes.length; i6++) {
      const vol = model.volumes[i6].getRenderable();
      const image2 = vol.getMapper().getInputData();
      mtime = Math.max(mtime, vol.getMTime(), image2.getMTime());
    }
    if (mtime < model.lutBuildTime.getMTime()) {
      return;
    }
    model.numRows = 0;
    model.rowStarts = [];
    for (let vidx = 0; vidx < model.volumes.length; vidx++) {
      model.rowStarts.push(model.numRows);
      const webgpuvol = model.volumes[vidx];
      const actor = webgpuvol.getRenderable();
      const volMapr = actor.getMapper();
      const vprop = actor.getProperty();
      const image2 = volMapr.getInputData();
      const scalars = image2.getPointData() && image2.getPointData().getScalars();
      const numComp = scalars.getNumberOfComponents();
      const iComps = vprop.getIndependentComponents();
      const numIComps = iComps ? numComp : 1;
      model.numRows += numIComps;
    }
    const colorArray = new Uint8ClampedArray(model.numRows * 2 * model.rowLength * 4);
    const opacityArray = new Float32Array(model.numRows * 2 * model.rowLength);
    let imgRow = 0;
    const tmpTable = new Float32Array(model.rowLength * 3);
    const rowLength = model.rowLength;
    for (let vidx = 0; vidx < model.volumes.length; vidx++) {
      const webgpuvol = model.volumes[vidx];
      const actor = webgpuvol.getRenderable();
      const volMapr = actor.getMapper();
      const vprop = actor.getProperty();
      const image2 = volMapr.getInputData();
      const scalars = image2.getPointData() && image2.getPointData().getScalars();
      const numComp = scalars.getNumberOfComponents();
      const iComps = vprop.getIndependentComponents();
      const numIComps = iComps ? numComp : 1;
      for (let c6 = 0; c6 < numIComps; ++c6) {
        const cfun = vprop.getRGBTransferFunction(c6);
        const cRange = cfun.getRange();
        cfun.getTable(cRange[0], cRange[1], rowLength, tmpTable, 1);
        let ioffset = imgRow * rowLength * 4;
        for (let i6 = 0; i6 < rowLength; ++i6) {
          colorArray[ioffset + i6 * 4] = 255 * tmpTable[i6 * 3];
          colorArray[ioffset + i6 * 4 + 1] = 255 * tmpTable[i6 * 3 + 1];
          colorArray[ioffset + i6 * 4 + 2] = 255 * tmpTable[i6 * 3 + 2];
          colorArray[ioffset + i6 * 4 + 3] = 255;
          for (let co = 0; co < 4; co++) {
            colorArray[ioffset + (rowLength + i6) * 4 + co] = colorArray[ioffset + i6 * 4 + co];
          }
        }
        const ofun = vprop.getScalarOpacity(c6);
        const opacityFactor = model.sampleDist / vprop.getScalarOpacityUnitDistance(c6);
        const oRange = ofun.getRange();
        ofun.getTable(oRange[0], oRange[1], rowLength, tmpTable, 1);
        ioffset = imgRow * rowLength;
        for (let i6 = 0; i6 < rowLength; ++i6) {
          opacityArray[ioffset + i6] = 1 - __pow(1 - tmpTable[i6], opacityFactor);
          opacityArray[ioffset + i6 + rowLength] = opacityArray[ioffset + i6];
        }
        imgRow += 2;
      }
    }
    {
      const treq = {
        nativeArray: colorArray,
        width: model.rowLength,
        height: model.numRows * 2,
        depth: 1,
        format: "rgba8unorm"
      };
      const newTex = device.getTextureManager().getTexture(treq);
      const tview = newTex.createView("tfunTexture");
      model.textureViews[2] = tview;
    }
    {
      const treq = {
        nativeArray: opacityArray,
        width: model.rowLength,
        height: model.numRows * 2,
        depth: 1,
        format: "r16float"
      };
      const newTex = device.getTextureManager().getTexture(treq);
      const tview = newTex.createView("ofunTexture");
      model.textureViews[3] = tview;
    }
    model.lutBuildTime.modified();
  };
  publicAPI.updateSSBO = (device) => {
    let mtime = Math.max(publicAPI.getMTime(), model.WebGPURenderer.getStabilizedTime());
    for (let i6 = 0; i6 < model.volumes.length; i6++) {
      const vol = model.volumes[i6].getRenderable();
      const volMapr = vol.getMapper();
      const image2 = volMapr.getInputData();
      mtime = Math.max(mtime, vol.getMTime(), image2.getMTime(), volMapr.getMTime());
    }
    if (mtime < model.SSBO.getSendTime()) {
      return;
    }
    const center = model.WebGPURenderer.getStabilizedCenterByReference();
    model.SSBO.clearData();
    model.SSBO.setNumberOfInstances(model.volumes.length);
    const marray = new Float64Array(model.volumes.length * 16);
    const vPlaneArray = new Float64Array(model.volumes.length * 16);
    const tstepArray = new Float64Array(model.volumes.length * 4);
    const shadeArray = new Float64Array(model.volumes.length * 4);
    const spacingArray = new Float64Array(model.volumes.length * 4);
    const ipScalarRangeArray = new Float64Array(model.volumes.length * 4);
    for (let vidx = 0; vidx < model.volumes.length; vidx++) {
      const webgpuvol = model.volumes[vidx];
      const actor = webgpuvol.getRenderable();
      const volMapr = actor.getMapper();
      const image2 = volMapr.getInputData();
      mat4_exports.identity(tmpMat42);
      mat4_exports.translate(tmpMat42, tmpMat42, center);
      const mcwcmat = actor.getMatrix();
      mat4_exports.transpose(tmp2Mat42, mcwcmat);
      mat4_exports.invert(tmp2Mat42, tmp2Mat42);
      mat4_exports.multiply(tmpMat42, tmp2Mat42, tmpMat42);
      const modelToIndex = image2.getWorldToIndex();
      mat4_exports.multiply(tmpMat42, modelToIndex, tmpMat42);
      const dims = image2.getDimensions();
      mat4_exports.identity(tmp2Mat42);
      mat4_exports.scale(tmp2Mat42, tmp2Mat42, [1 / dims[0], 1 / dims[1], 1 / dims[2]]);
      mat4_exports.multiply(tmpMat42, tmp2Mat42, tmpMat42);
      for (let j2 = 0; j2 < 16; j2++) {
        marray[vidx * 16 + j2] = tmpMat42[j2];
      }
      mat4_exports.invert(tmpMat42, tmpMat42);
      for (let j2 = 0; j2 < 4; j2++) {
        vPlaneArray[vidx * 16 + j2 * 4] = tmpMat42[j2 * 4];
        vPlaneArray[vidx * 16 + j2 * 4 + 1] = tmpMat42[j2 * 4 + 1];
        vPlaneArray[vidx * 16 + j2 * 4 + 2] = tmpMat42[j2 * 4 + 2];
        vPlaneArray[vidx * 16 + j2 * 4 + 3] = 0;
      }
      tstepArray[vidx * 4] = 1 / dims[0];
      tstepArray[vidx * 4 + 1] = 1 / dims[1];
      tstepArray[vidx * 4 + 2] = 1 / dims[2];
      tstepArray[vidx * 4 + 3] = 1;
      shadeArray[vidx * 4] = actor.getProperty().getShade() ? 1 : 0;
      const spacing = image2.getSpacing();
      spacingArray[vidx * 4] = spacing[0];
      spacingArray[vidx * 4 + 1] = spacing[1];
      spacingArray[vidx * 4 + 2] = spacing[2];
      spacingArray[vidx * 4 + 3] = 1;
      const tScale = model.textureViews[vidx + 4].getTexture().getScale();
      const ipScalarRange = volMapr.getIpScalarRange();
      ipScalarRangeArray[vidx * 4] = ipScalarRange[0] / tScale;
      ipScalarRangeArray[vidx * 4 + 1] = ipScalarRange[1] / tScale;
      ipScalarRangeArray[vidx * 4 + 2] = volMapr.getFilterMode();
    }
    model.SSBO.addEntry("SCTCMatrix", "mat4x4<f32>");
    model.SSBO.addEntry("planeNormals", "mat4x4<f32>");
    model.SSBO.addEntry("shade", "vec4<f32>");
    model.SSBO.addEntry("tstep", "vec4<f32>");
    model.SSBO.addEntry("spacing", "vec4<f32>");
    model.SSBO.addEntry("ipScalarRange", "vec4<f32>");
    model.SSBO.setAllInstancesFromArray("SCTCMatrix", marray);
    model.SSBO.setAllInstancesFromArray("planeNormals", vPlaneArray);
    model.SSBO.setAllInstancesFromArray("shade", shadeArray);
    model.SSBO.setAllInstancesFromArray("tstep", tstepArray);
    model.SSBO.setAllInstancesFromArray("spacing", spacingArray);
    model.SSBO.setAllInstancesFromArray("ipScalarRange", ipScalarRangeArray);
    model.SSBO.send(device);
    model.componentSSBO.clearData();
    model.componentSSBO.setNumberOfInstances(model.numRows);
    const cScaleArray = new Float64Array(model.numRows);
    const cShiftArray = new Float64Array(model.numRows);
    const oScaleArray = new Float64Array(model.numRows);
    const oShiftArray = new Float64Array(model.numRows);
    const gominArray = new Float64Array(model.numRows);
    const gomaxArray = new Float64Array(model.numRows);
    const goshiftArray = new Float64Array(model.numRows);
    const goscaleArray = new Float64Array(model.numRows);
    let rowIdx = 0;
    for (let vidx = 0; vidx < model.volumes.length; vidx++) {
      const webgpuvol = model.volumes[vidx];
      const actor = webgpuvol.getRenderable();
      const volMapr = actor.getMapper();
      const vprop = actor.getProperty();
      const image2 = volMapr.getInputData();
      const scalars = image2.getPointData() && image2.getPointData().getScalars();
      const numComp = scalars.getNumberOfComponents();
      const iComps = vprop.getIndependentComponents();
      const tformat = model.textureViews[vidx + 4].getTexture().getFormat();
      const tDetails = vtkWebGPUTypes.getDetailsFromTextureFormat(tformat);
      const halfFloat = tDetails.elementSize === 2 && tDetails.sampleType === "float";
      const volInfo = {
        scale: [255],
        offset: [0]
      };
      if (halfFloat) {
        volInfo.scale[0] = 1;
      }
      for (let compIdx = 0; compIdx < numComp; compIdx++) {
        const target = iComps ? compIdx : 0;
        const sscale = volInfo.scale[compIdx];
        const ofun = vprop.getScalarOpacity(target);
        const oRange = ofun.getRange();
        const oscale = sscale / (oRange[1] - oRange[0]);
        const oshift = (volInfo.offset[compIdx] - oRange[0]) / (oRange[1] - oRange[0]);
        oShiftArray[rowIdx] = oshift;
        oScaleArray[rowIdx] = oscale;
        const cfun = vprop.getRGBTransferFunction(target);
        const cRange = cfun.getRange();
        cShiftArray[rowIdx] = (volInfo.offset[compIdx] - cRange[0]) / (cRange[1] - cRange[0]);
        cScaleArray[rowIdx] = sscale / (cRange[1] - cRange[0]);
        const useGO = vprop.getUseGradientOpacity(target);
        if (useGO) {
          const gomin = vprop.getGradientOpacityMinimumOpacity(target);
          const gomax = vprop.getGradientOpacityMaximumOpacity(target);
          gominArray[rowIdx] = gomin;
          gomaxArray[rowIdx] = gomax;
          const goRange = [vprop.getGradientOpacityMinimumValue(target), vprop.getGradientOpacityMaximumValue(target)];
          goscaleArray[rowIdx] = sscale * (gomax - gomin) / (goRange[1] - goRange[0]);
          goshiftArray[rowIdx] = -goRange[0] * (gomax - gomin) / (goRange[1] - goRange[0]) + gomin;
        } else {
          gominArray[rowIdx] = 1;
          gomaxArray[rowIdx] = 1;
          goscaleArray[rowIdx] = 0;
          goshiftArray[rowIdx] = 1;
        }
        rowIdx++;
      }
    }
    model.componentSSBO.addEntry("cScale", "f32");
    model.componentSSBO.addEntry("cShift", "f32");
    model.componentSSBO.addEntry("oScale", "f32");
    model.componentSSBO.addEntry("oShift", "f32");
    model.componentSSBO.addEntry("goShift", "f32");
    model.componentSSBO.addEntry("goScale", "f32");
    model.componentSSBO.addEntry("gomin", "f32");
    model.componentSSBO.addEntry("gomax", "f32");
    model.componentSSBO.setAllInstancesFromArray("cScale", cScaleArray);
    model.componentSSBO.setAllInstancesFromArray("cShift", cShiftArray);
    model.componentSSBO.setAllInstancesFromArray("oScale", oScaleArray);
    model.componentSSBO.setAllInstancesFromArray("oShift", oShiftArray);
    model.componentSSBO.setAllInstancesFromArray("goScale", goscaleArray);
    model.componentSSBO.setAllInstancesFromArray("goShift", goshiftArray);
    model.componentSSBO.setAllInstancesFromArray("gomin", gominArray);
    model.componentSSBO.setAllInstancesFromArray("gomax", gomaxArray);
    model.componentSSBO.send(device);
  };
  const superClassUpdateBuffers = publicAPI.updateBuffers;
  publicAPI.updateBuffers = () => {
    superClassUpdateBuffers();
    let sampleDist = model.volumes[0].getRenderable().getMapper().getSampleDistance();
    for (let i6 = 0; i6 < model.volumes.length; i6++) {
      const vol = model.volumes[i6];
      const volMapr = vol.getRenderable().getMapper();
      const sd = volMapr.getSampleDistance();
      if (sd < sampleDist) {
        sampleDist = sd;
      }
    }
    if (model.sampleDist !== sampleDist) {
      model.sampleDist = sampleDist;
      model.UBO.setValue("SampleDistance", sampleDist);
      model.UBO.sendIfNeeded(model.device);
    }
    for (let vidx = 0; vidx < model.volumes.length; vidx++) {
      const webgpuvol = model.volumes[vidx];
      const actor = webgpuvol.getRenderable();
      const volMapr = actor.getMapper();
      const image2 = volMapr.getInputData();
      const newTex = model.device.getTextureManager().getTextureForImageData(image2);
      if (!model.textureViews[vidx + 4] || model.textureViews[vidx + 4].getTexture() !== newTex) {
        const tview = newTex.createView(`volTexture${vidx}`);
        model.textureViews[vidx + 4] = tview;
      }
    }
    if (model.volumes.length < model.lastVolumeLength) {
      for (let i6 = model.volumes.length; i6 < model.lastVolumeLength; i6++) {
        model.textureViews.pop();
      }
    }
    model.lastVolumeLength = model.volumes.length;
    publicAPI.updateLUTImage(model.device);
    publicAPI.updateSSBO(model.device);
    if (!model.clampSampler) {
      model.clampSampler = vtkWebGPUSampler$1.newInstance({
        label: "clampSampler"
      });
      model.clampSampler.create(model.device, {
        minFilter: "linear",
        magFilter: "linear"
      });
    }
  };
  publicAPI.computePipelineHash = () => {
    model.pipelineHash = "volfsq";
    for (let vidx = 0; vidx < model.volumes.length; vidx++) {
      const blendMode = model.volumes[vidx].getRenderable().getMapper().getBlendMode();
      model.pipelineHash += `${blendMode}`;
    }
  };
  publicAPI.setVolumes = (val) => {
    if (!model.volumes || model.volumes.length !== val.length) {
      model.volumes = [...val];
      publicAPI.modified();
      return;
    }
    for (let i6 = 0; i6 < val.length; i6++) {
      if (val[i6] !== model.volumes[i6]) {
        model.volumes = [...val];
        publicAPI.modified();
        return;
      }
    }
  };
  const superclassGetBindables = publicAPI.getBindables;
  publicAPI.getBindables = () => {
    const bindables = superclassGetBindables();
    bindables.push(model.componentSSBO);
    bindables.push(model.clampSampler);
    return bindables;
  };
}
var DEFAULT_VALUES98 = {
  volumes: null,
  rowLength: 1024,
  lastVolumeLength: 0
};
function extend100(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES98, initialValues);
  vtkWebGPUFullScreenQuad$1.extend(publicAPI, model, initialValues);
  model.fragmentShaderTemplate = volFragTemplate;
  model.UBO = vtkWebGPUUniformBuffer$1.newInstance({
    label: "mapperUBO"
  });
  model.UBO.addEntry("SampleDistance", "f32");
  model.SSBO = vtkWebGPUStorageBuffer$1.newInstance({
    label: "volumeSSBO"
  });
  model.componentSSBO = vtkWebGPUStorageBuffer$1.newInstance({
    label: "componentSSBO"
  });
  model.lutBuildTime = {};
  macro.obj(model.lutBuildTime, {
    mtime: 0
  });
  vtkWebGPUVolumePassFSQ(publicAPI, model);
}
var newInstance99 = macro.newInstance(extend100, "vtkWebGPUVolumePassFSQ");
var vtkWebGPUVolumePassFSQ$1 = {
  newInstance: newInstance99,
  extend: extend100
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/VolumePass.js
var {
  Representation: Representation5
} = vtkProperty$1;
var {
  BufferUsage: BufferUsage6,
  PrimitiveTypes: PrimitiveTypes3
} = vtkWebGPUBufferManager$1;
var cubeFaceTriangles = [[0, 4, 6], [0, 6, 2], [1, 3, 7], [1, 7, 5], [0, 5, 4], [0, 1, 5], [2, 6, 7], [2, 7, 3], [0, 3, 1], [0, 2, 3], [4, 5, 7], [4, 7, 6]];
var DepthBoundsFS = `
//VTK::Renderer::Dec

//VTK::Select::Dec

//VTK::VolumePass::Dec

//VTK::TCoord::Dec

//VTK::RenderEncoder::Dec

//VTK::Mapper::Dec

//VTK::IOStructs::Dec

@fragment
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output : fragmentOutput;

  //VTK::Select::Impl

  //VTK::TCoord::Impl

  //VTK::VolumePass::Impl

  // use the maximum (closest) of the current value and the zbuffer
  // the blend func will then take the min to find the farthest stop value
  var stopval: f32 = max(input.fragPos.z, textureLoad(opaquePassDepthTexture, vec2<i32>(i32(input.fragPos.x), i32(input.fragPos.y)), 0));

  //VTK::RenderEncoder::Impl
  return output;
}
`;
var volumeCopyFragTemplate = `
//VTK::Renderer::Dec

//VTK::Mapper::Dec

//VTK::TCoord::Dec

//VTK::RenderEncoder::Dec

//VTK::IOStructs::Dec

@fragment
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output: fragmentOutput;

  var computedColor: vec4<f32> = textureSample(volumePassColorTexture,
    volumePassColorTextureSampler, mapperUBO.tscale*input.tcoordVS);

  //VTK::RenderEncoder::Impl
  return output;
}
`;
function vtkWebGPUVolumePass(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUVolumePass");
  publicAPI.initialize = (viewNode) => {
    if (!model._clearEncoder) {
      publicAPI.createClearEncoder(viewNode);
    }
    if (!model._mergeEncoder) {
      publicAPI.createMergeEncoder(viewNode);
    }
    if (!model._copyEncoder) {
      publicAPI.createCopyEncoder(viewNode);
    }
    if (!model._depthRangeEncoder) {
      publicAPI.createDepthRangeEncoder(viewNode);
    }
    if (!model.fullScreenQuad) {
      model.fullScreenQuad = vtkWebGPUVolumePassFSQ$1.newInstance();
      model.fullScreenQuad.setDevice(viewNode.getDevice());
      model.fullScreenQuad.setTextureViews([...model._depthRangeEncoder.getColorTextureViews()]);
    }
    if (!model._volumeCopyQuad) {
      model._volumeCopyQuad = vtkWebGPUFullScreenQuad$1.newInstance();
      model._volumeCopyQuad.setPipelineHash("volpassfsq");
      model._volumeCopyQuad.setDevice(viewNode.getDevice());
      model._volumeCopyQuad.setFragmentShaderTemplate(volumeCopyFragTemplate);
      model._copyUBO = vtkWebGPUUniformBuffer$1.newInstance({
        label: "mapperUBO"
      });
      model._copyUBO.addEntry("tscale", "vec2<f32>");
      model._volumeCopyQuad.setUBO(model._copyUBO);
      model._volumeCopyQuad.setTextureViews([model._colorTextureView]);
    }
  };
  publicAPI.traverse = (renNode, viewNode) => {
    if (model.deleted) {
      return;
    }
    model._currentParent = viewNode;
    publicAPI.initialize(viewNode);
    publicAPI.computeTiming(viewNode);
    publicAPI.renderDepthBounds(renNode, viewNode);
    model._firstGroup = true;
    const device = viewNode.getDevice();
    const maxVolumes = device.getHandle().limits.maxSampledTexturesPerShaderStage - 4;
    if (model.volumes.length > maxVolumes) {
      const cameraPos = renNode.getRenderable().getActiveCamera().getPosition();
      const distances = [];
      for (let v2 = 0; v2 < model.volumes.length; v2++) {
        const bounds = model.volumes[v2].getRenderable().getBounds();
        const centroid = [0.5 * (bounds[1] + bounds[0]), 0.5 * (bounds[3] + bounds[2]), 0.5 * (bounds[5] + bounds[4])];
        distances[v2] = distance2BetweenPoints(centroid, cameraPos);
      }
      const volumeOrder = [...Array(model.volumes.length).keys()];
      volumeOrder.sort((a4, b3) => distances[b3] - distances[a4]);
      let volumesToRender = [];
      let chunkSize = volumeOrder.length % maxVolumes;
      for (let v2 = 0; v2 < volumeOrder.length; v2++) {
        volumesToRender.push(model.volumes[volumeOrder[v2]]);
        if (volumesToRender.length >= chunkSize) {
          publicAPI.rayCastPass(viewNode, renNode, volumesToRender);
          volumesToRender = [];
          chunkSize = maxVolumes;
          model._firstGroup = false;
        }
      }
    } else {
      publicAPI.rayCastPass(viewNode, renNode, model.volumes);
    }
    model._volumeCopyQuad.setWebGPURenderer(renNode);
    if (model._useSmallViewport) {
      const width = model._colorTextureView.getTexture().getWidth();
      const height = model._colorTextureView.getTexture().getHeight();
      model._copyUBO.setArray("tscale", [model._smallViewportWidth / width, model._smallViewportHeight / height]);
    } else {
      model._copyUBO.setArray("tscale", [1, 1]);
    }
    model._copyUBO.sendIfNeeded(device);
    model._copyEncoder.setColorTextureView(0, model.colorTextureView);
    model._copyEncoder.attachTextureViews();
    model._copyEncoder.begin(viewNode.getCommandEncoder());
    renNode.scissorAndViewport(model._copyEncoder);
    model._volumeCopyQuad.prepareAndDraw(model._copyEncoder);
    model._copyEncoder.end();
  };
  publicAPI.delete = macro.chain(() => {
    if (model._animationRateSubscription) {
      model._animationRateSubscription.unsubscribe();
      model._animationRateSubscription = null;
    }
  }, publicAPI.delete);
  publicAPI.computeTiming = (viewNode) => {
    const rwi = viewNode.getRenderable().getInteractor();
    if (model._lastScale == null) {
      const firstMapper = model.volumes[0].getRenderable().getMapper();
      model._lastScale = firstMapper.getInitialInteractionScale() || 1;
    }
    model._useSmallViewport = false;
    if (rwi.isAnimating() && model._lastScale > 1.5) {
      model._useSmallViewport = true;
    }
    model._colorTexture.resize(viewNode.getCanvas().width, viewNode.getCanvas().height);
    if (!model._animationRateSubscription) {
      model._animationRateSubscription = rwi.onAnimationFrameRateUpdate(() => {
        const firstMapper = model.volumes[0].getRenderable().getMapper();
        if (firstMapper.getAutoAdjustSampleDistances()) {
          const frate = rwi.getRecentAnimationFrameRate();
          const targetScale = model._lastScale * rwi.getDesiredUpdateRate() / frate;
          model._lastScale = targetScale;
          if (model._lastScale > 400) {
            model._lastScale = 400;
          }
        } else {
          model._lastScale = firstMapper.getImageSampleDistance() * firstMapper.getImageSampleDistance();
        }
        if (model._lastScale < 1.5) {
          model._lastScale = 1.5;
        }
      });
    }
  };
  publicAPI.rayCastPass = (viewNode, renNode, volumes) => {
    const encoder2 = model._firstGroup ? model._clearEncoder : model._mergeEncoder;
    encoder2.attachTextureViews();
    encoder2.begin(viewNode.getCommandEncoder());
    let width = model._colorTextureView.getTexture().getWidth();
    let height = model._colorTextureView.getTexture().getHeight();
    if (model._useSmallViewport) {
      const canvas = viewNode.getCanvas();
      const scaleFactor = 1 / Math.sqrt(model._lastScale);
      model._smallViewportWidth = Math.ceil(scaleFactor * canvas.width);
      model._smallViewportHeight = Math.ceil(scaleFactor * canvas.height);
      width = model._smallViewportWidth;
      height = model._smallViewportHeight;
    }
    encoder2.getHandle().setViewport(0, 0, width, height, 0, 1);
    encoder2.getHandle().setScissorRect(0, 0, width, height);
    model.fullScreenQuad.setWebGPURenderer(renNode);
    model.fullScreenQuad.setVolumes(volumes);
    model.fullScreenQuad.prepareAndDraw(encoder2);
    encoder2.end();
  };
  publicAPI.renderDepthBounds = (renNode, viewNode) => {
    publicAPI.updateDepthPolyData(renNode);
    const pd = model._boundsPoly;
    const points = pd.getPoints();
    const cells = pd.getPolys();
    let buffRequest = {
      hash: `vp${cells.getMTime()}`,
      usage: BufferUsage6.Index,
      cells,
      numberOfPoints: points.getNumberOfPoints(),
      primitiveType: PrimitiveTypes3.Triangles,
      representation: Representation5.SURFACE
    };
    const indexBuffer = viewNode.getDevice().getBufferManager().getBuffer(buffRequest);
    model._mapper.getVertexInput().setIndexBuffer(indexBuffer);
    buffRequest = {
      usage: BufferUsage6.PointArray,
      format: "float32x4",
      hash: `vp${points.getMTime()}${cells.getMTime()}`,
      dataArray: points,
      indexBuffer,
      packExtra: true
    };
    const buff = viewNode.getDevice().getBufferManager().getBuffer(buffRequest);
    model._mapper.getVertexInput().addBuffer(buff, ["vertexBC"]);
    model._mapper.setNumberOfVertices(buff.getSizeInBytes() / buff.getStrideInBytes());
    publicAPI.drawDepthRange(renNode, viewNode);
  };
  publicAPI.updateDepthPolyData = (renNode) => {
    let update2 = false;
    for (let i6 = 0; i6 < model.volumes.length; i6++) {
      const mtime = model.volumes[i6].getMTime();
      if (!model._lastMTimes[i6] || mtime !== model._lastMTimes[i6]) {
        update2 = true;
        model._lastMTimes[i6] = mtime;
      }
    }
    const stime = renNode.getStabilizedTime();
    if (model._lastMTimes.length <= model.volumes.length || stime !== model._lastMTimes[model.volumes.length]) {
      update2 = true;
      model._lastMTimes[model.volumes.length] = stime;
    }
    if (!update2) {
      return;
    }
    const center = renNode.getStabilizedCenterByReference();
    const numPts = model.volumes.length * 8;
    const points = new Float64Array(numPts * 3);
    const numTris = model.volumes.length * 12;
    const polys = new Uint16Array(numTris * 4);
    for (let i6 = 0; i6 < model.volumes.length; i6++) {
      model.volumes[i6].getBoundingCubePoints(points, i6 * 24);
      let cellIdx = i6 * 12 * 4;
      const offset3 = i6 * 8;
      for (let t9 = 0; t9 < 12; t9++) {
        polys[cellIdx++] = 3;
        polys[cellIdx++] = offset3 + cubeFaceTriangles[t9][0];
        polys[cellIdx++] = offset3 + cubeFaceTriangles[t9][1];
        polys[cellIdx++] = offset3 + cubeFaceTriangles[t9][2];
      }
    }
    for (let p3 = 0; p3 < points.length; p3 += 3) {
      points[p3] -= center[0];
      points[p3 + 1] -= center[1];
      points[p3 + 2] -= center[2];
    }
    model._boundsPoly.getPoints().setData(points, 3);
    model._boundsPoly.getPoints().modified();
    model._boundsPoly.getPolys().setData(polys, 1);
    model._boundsPoly.getPolys().modified();
    model._boundsPoly.modified();
  };
  publicAPI.drawDepthRange = (renNode, viewNode) => {
    model._depthRangeTexture.resizeToMatch(model.colorTextureView.getTexture());
    model._depthRangeTexture2.resizeToMatch(model.colorTextureView.getTexture());
    model._depthRangeEncoder.attachTextureViews();
    publicAPI.setCurrentOperation("volumeDepthRangePass");
    renNode.setRenderEncoder(model._depthRangeEncoder);
    renNode.volumeDepthRangePass(true);
    model._mapper.setWebGPURenderer(renNode);
    model._mapper.prepareToDraw(model._depthRangeEncoder);
    model._mapper.registerDrawCallback(model._depthRangeEncoder);
    renNode.volumeDepthRangePass(false);
  };
  publicAPI.createDepthRangeEncoder = (viewNode) => {
    const device = viewNode.getDevice();
    model._depthRangeEncoder = vtkWebGPURenderEncoder$1.newInstance({
      label: "VolumePass DepthRange"
    });
    model._depthRangeEncoder.setPipelineHash("volr");
    model._depthRangeEncoder.setReplaceShaderCodeFunction((pipeline) => {
      const fDesc = pipeline.getShaderDescription("fragment");
      fDesc.addOutput("vec4<f32>", "outColor1");
      fDesc.addOutput("vec4<f32>", "outColor2");
      let code = fDesc.getCode();
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::RenderEncoder::Impl", ["output.outColor1 = vec4<f32>(input.fragPos.z, 0.0, 0.0, 0.0);", "output.outColor2 = vec4<f32>(stopval, 0.0, 0.0, 0.0);"]).result;
      fDesc.setCode(code);
    });
    model._depthRangeEncoder.setDescription({
      colorAttachments: [{
        view: null,
        clearValue: [0, 0, 0, 0],
        loadOp: "clear",
        storeOp: "store"
      }, {
        view: null,
        clearValue: [1, 1, 1, 1],
        loadOp: "clear",
        storeOp: "store"
      }]
    });
    model._depthRangeEncoder.setPipelineSettings({
      primitive: {
        cullMode: "none"
      },
      fragment: {
        targets: [{
          format: "r16float",
          blend: {
            color: {
              srcFactor: "one",
              dstFactor: "one",
              operation: "max"
            },
            alpha: {
              srcfactor: "one",
              dstFactor: "one",
              operation: "max"
            }
          }
        }, {
          format: "r16float",
          blend: {
            color: {
              srcFactor: "one",
              dstFactor: "one",
              operation: "min"
            },
            alpha: {
              srcfactor: "one",
              dstFactor: "one",
              operation: "min"
            }
          }
        }]
      }
    });
    model._depthRangeTexture = vtkWebGPUTexture$1.newInstance({
      label: "volumePassMaxDepth"
    });
    model._depthRangeTexture.create(device, {
      width: viewNode.getCanvas().width,
      height: viewNode.getCanvas().height,
      format: "r16float",
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
    });
    const maxView = model._depthRangeTexture.createView("maxTexture");
    model._depthRangeEncoder.setColorTextureView(0, maxView);
    model._depthRangeTexture2 = vtkWebGPUTexture$1.newInstance({
      label: "volumePassDepthMin"
    });
    model._depthRangeTexture2.create(device, {
      width: viewNode.getCanvas().width,
      height: viewNode.getCanvas().height,
      format: "r16float",
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
    });
    const minView = model._depthRangeTexture2.createView("minTexture");
    model._depthRangeEncoder.setColorTextureView(1, minView);
    model._mapper.setDevice(viewNode.getDevice());
    model._mapper.setTextureViews([model.depthTextureView]);
  };
  publicAPI.createClearEncoder = (viewNode) => {
    model._colorTexture = vtkWebGPUTexture$1.newInstance({
      label: "volumePassColor"
    });
    model._colorTexture.create(viewNode.getDevice(), {
      width: viewNode.getCanvas().width,
      height: viewNode.getCanvas().height,
      format: "bgra8unorm",
      /* eslint-disable no-undef */
      /* eslint-disable no-bitwise */
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC
    });
    model._colorTextureView = model._colorTexture.createView("volumePassColorTexture");
    model._colorTextureView.addSampler(viewNode.getDevice(), {
      minFilter: "linear",
      magFilter: "linear"
    });
    model._clearEncoder = vtkWebGPURenderEncoder$1.newInstance({
      label: "VolumePass Clear"
    });
    model._clearEncoder.setColorTextureView(0, model._colorTextureView);
    model._clearEncoder.setDescription({
      colorAttachments: [{
        view: null,
        clearValue: [0, 0, 0, 0],
        loadOp: "clear",
        storeOp: "store"
      }]
    });
    model._clearEncoder.setPipelineHash("volpf");
    model._clearEncoder.setPipelineSettings({
      primitive: {
        cullMode: "none"
      },
      fragment: {
        targets: [{
          format: "bgra8unorm",
          blend: {
            color: {
              srcFactor: "src-alpha",
              dstFactor: "one-minus-src-alpha"
            },
            alpha: {
              srcfactor: "one",
              dstFactor: "one-minus-src-alpha"
            }
          }
        }]
      }
    });
  };
  publicAPI.createCopyEncoder = (viewNode) => {
    model._copyEncoder = vtkWebGPURenderEncoder$1.newInstance({
      label: "volumePassCopy"
    });
    model._copyEncoder.setDescription({
      colorAttachments: [{
        view: null,
        loadOp: "load",
        storeOp: "store"
      }]
    });
    model._copyEncoder.setPipelineHash("volcopypf");
    model._copyEncoder.setPipelineSettings({
      primitive: {
        cullMode: "none"
      },
      fragment: {
        targets: [{
          format: "rgba16float",
          blend: {
            color: {
              srcFactor: "one",
              dstFactor: "one-minus-src-alpha"
            },
            alpha: {
              srcfactor: "one",
              dstFactor: "one-minus-src-alpha"
            }
          }
        }]
      }
    });
  };
  publicAPI.createMergeEncoder = (viewNode) => {
    model._mergeEncoder = vtkWebGPURenderEncoder$1.newInstance({
      label: "volumePassMerge"
    });
    model._mergeEncoder.setColorTextureView(0, model._colorTextureView);
    model._mergeEncoder.setDescription({
      colorAttachments: [{
        view: null,
        loadOp: "load",
        storeOp: "store"
      }]
    });
    model._mergeEncoder.setReplaceShaderCodeFunction((pipeline) => {
      const fDesc = pipeline.getShaderDescription("fragment");
      fDesc.addOutput("vec4<f32>", "outColor");
      let code = fDesc.getCode();
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::RenderEncoder::Impl", ["output.outColor = vec4<f32>(computedColor.rgb, computedColor.a);"]).result;
      fDesc.setCode(code);
    });
    model._mergeEncoder.setPipelineHash("volpf");
    model._mergeEncoder.setPipelineSettings({
      primitive: {
        cullMode: "none"
      },
      fragment: {
        targets: [{
          format: "bgra8unorm",
          blend: {
            color: {
              srcFactor: "src-alpha",
              dstFactor: "one-minus-src-alpha"
            },
            alpha: {
              srcfactor: "one",
              dstFactor: "one-minus-src-alpha"
            }
          }
        }]
      }
    });
  };
  publicAPI.setVolumes = (val) => {
    if (!model.volumes || model.volumes.length !== val.length) {
      model.volumes = [...val];
      publicAPI.modified();
      return;
    }
    for (let i6 = 0; i6 < val.length; i6++) {
      if (val[i6] !== model.volumes[i6]) {
        model.volumes = [...val];
        publicAPI.modified();
        return;
      }
    }
  };
}
var DEFAULT_VALUES99 = {
  colorTextureView: null,
  depthTextureView: null,
  volumes: null
};
function extend101(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES99, initialValues);
  vtkRenderPass$1.extend(publicAPI, model, initialValues);
  model._mapper = vtkWebGPUSimpleMapper$1.newInstance();
  model._mapper.setFragmentShaderTemplate(DepthBoundsFS);
  model._mapper.getShaderReplacements().set("replaceShaderVolumePass", (hash, pipeline, vertexInput) => {
    const fDesc = pipeline.getShaderDescription("fragment");
    fDesc.addBuiltinInput("vec4<f32>", "@builtin(position) fragPos");
  });
  model._boundsPoly = vtkPolyData$1.newInstance();
  model._lastMTimes = [];
  macro.setGet(publicAPI, model, ["colorTextureView", "depthTextureView"]);
  vtkWebGPUVolumePass(publicAPI, model);
}
var newInstance100 = macro.newInstance(extend101, "vtkWebGPUVolumePass");
var vtkWebGPUVolumePass$1 = {
  newInstance: newInstance100,
  extend: extend101
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/ForwardPass.js
var finalBlitFragTemplate = `
//VTK::Mapper::Dec

//VTK::TCoord::Dec

//VTK::RenderEncoder::Dec

//VTK::IOStructs::Dec

@fragment
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output: fragmentOutput;

  var computedColor: vec4<f32> = clamp(textureSampleLevel(opaquePassColorTexture, finalPassSampler, input.tcoordVS, 0.0),vec4<f32>(0.0),vec4<f32>(1.0));

  //VTK::RenderEncoder::Impl
  return output;
}
`;
function vtkForwardPass2(publicAPI, model) {
  model.classHierarchy.push("vtkForwardPass");
  publicAPI.traverse = function(viewNode) {
    let parent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    if (model.deleted) {
      return;
    }
    model._currentParent = parent;
    publicAPI.setCurrentOperation("buildPass");
    viewNode.traverse(publicAPI);
    if (!model.opaquePass) {
      model.opaquePass = vtkWebGPUOpaquePass$1.newInstance();
    }
    const numlayers = viewNode.getRenderable().getNumberOfLayers();
    const renderers = viewNode.getChildren();
    for (let i6 = 0; i6 < numlayers; i6++) {
      for (let index2 = 0; index2 < renderers.length; index2++) {
        const renNode = renderers[index2];
        const ren = viewNode.getRenderable().getRenderers()[index2];
        if (ren.getDraw() && ren.getLayer() === i6) {
          model.opaqueActorCount = 0;
          model.translucentActorCount = 0;
          model.volumes = [];
          publicAPI.setCurrentOperation("queryPass");
          renNode.traverse(publicAPI);
          publicAPI.setCurrentOperation("cameraPass");
          renNode.traverse(publicAPI);
          model.opaquePass.traverse(renNode, viewNode);
          if (model.translucentActorCount > 0) {
            if (!model.translucentPass) {
              model.translucentPass = vtkWebGPUOrderIndepenentTranslucentPass.newInstance();
            }
            model.translucentPass.setColorTextureView(model.opaquePass.getColorTextureView());
            model.translucentPass.setDepthTextureView(model.opaquePass.getDepthTextureView());
            model.translucentPass.traverse(renNode, viewNode);
          }
          if (model.volumes.length > 0) {
            if (!model.volumePass) {
              model.volumePass = vtkWebGPUVolumePass$1.newInstance();
            }
            model.volumePass.setColorTextureView(model.opaquePass.getColorTextureView());
            model.volumePass.setDepthTextureView(model.opaquePass.getDepthTextureView());
            model.volumePass.setVolumes(model.volumes);
            model.volumePass.traverse(renNode, viewNode);
          }
          publicAPI.finalPass(viewNode, renNode);
        }
      }
    }
  };
  publicAPI.finalPass = (viewNode, renNode) => {
    if (!model._finalBlitEncoder) {
      publicAPI.createFinalBlitEncoder(viewNode);
    }
    model._finalBlitOutputTextureView.createFromTextureHandle(viewNode.getCurrentTexture(), {
      depth: 1,
      format: viewNode.getPresentationFormat()
    });
    model._finalBlitEncoder.attachTextureViews();
    model._finalBlitEncoder.begin(viewNode.getCommandEncoder());
    renNode.scissorAndViewport(model._finalBlitEncoder);
    model._fullScreenQuad.prepareAndDraw(model._finalBlitEncoder);
    model._finalBlitEncoder.end();
  };
  publicAPI.createFinalBlitEncoder = (viewNode) => {
    model._finalBlitEncoder = vtkWebGPURenderEncoder$1.newInstance({
      label: "forwardPassBlit"
    });
    model._finalBlitEncoder.setDescription({
      colorAttachments: [{
        view: null,
        loadOp: "load",
        storeOp: "store"
      }]
    });
    model._finalBlitEncoder.setPipelineHash("fpf");
    model._finalBlitEncoder.setPipelineSettings({
      primitive: {
        cullMode: "none"
      },
      fragment: {
        targets: [{
          format: viewNode.getPresentationFormat(),
          blend: {
            color: {
              srcFactor: "src-alpha",
              dstFactor: "one-minus-src-alpha"
            },
            alpha: {
              srcfactor: "one",
              dstFactor: "one-minus-src-alpha"
            }
          }
        }]
      }
    });
    model._fsqSampler = vtkWebGPUSampler$1.newInstance({
      label: "finalPassSampler"
    });
    model._fsqSampler.create(viewNode.getDevice(), {
      minFilter: "linear",
      magFilter: "linear"
    });
    model._fullScreenQuad = vtkWebGPUFullScreenQuad$1.newInstance();
    model._fullScreenQuad.setDevice(viewNode.getDevice());
    model._fullScreenQuad.setPipelineHash("fpfsq");
    model._fullScreenQuad.setTextureViews([model.opaquePass.getColorTextureView()]);
    model._fullScreenQuad.setAdditionalBindables([model._fsqSampler]);
    model._fullScreenQuad.setFragmentShaderTemplate(finalBlitFragTemplate);
    model._finalBlitOutputTextureView = vtkWebGPUTextureView$1.newInstance();
    model._finalBlitEncoder.setColorTextureView(0, model._finalBlitOutputTextureView);
  };
  publicAPI.incrementOpaqueActorCount = () => model.opaqueActorCount++;
  publicAPI.incrementTranslucentActorCount = () => model.translucentActorCount++;
  publicAPI.addVolume = (volume) => {
    model.volumes.push(volume);
  };
}
var DEFAULT_VALUES100 = {
  opaqueActorCount: 0,
  translucentActorCount: 0,
  volumes: null,
  opaqueRenderEncoder: null,
  translucentPass: null,
  volumePass: null
};
function extend102(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES100, initialValues);
  vtkRenderPass$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["opaquePass", "translucentPass", "volumePass"]);
  vtkForwardPass2(publicAPI, model);
}
var newInstance101 = macro.newInstance(extend102, "vtkForwardPass");
var vtkForwardPass$12 = {
  newInstance: newInstance101,
  extend: extend102
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/TextureManager.js
var {
  VtkDataTypes: VtkDataTypes6
} = vtkDataArray$1;
function vtkWebGPUTextureManager(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUTextureManager");
  function _fillRequest(req) {
    if (req.imageData) {
      req.dataArray = req.imageData.getPointData().getScalars();
      req.time = req.dataArray.getMTime();
      req.nativeArray = req.dataArray.getData();
      const dims = req.imageData.getDimensions();
      req.width = dims[0];
      req.height = dims[1];
      req.depth = dims[2];
      const numComp = req.dataArray.getNumberOfComponents();
      switch (numComp) {
        case 1:
          req.format = "r";
          break;
        case 2:
          req.format = "rg";
          break;
        case 3:
        case 4:
        default:
          req.format = "rgba";
          break;
      }
      const dataType = req.dataArray.getDataType();
      switch (dataType) {
        case VtkDataTypes6.UNSIGNED_CHAR:
          req.format += "8unorm";
          break;
        case VtkDataTypes6.FLOAT:
        case VtkDataTypes6.UNSIGNED_INT:
        case VtkDataTypes6.INT:
        case VtkDataTypes6.DOUBLE:
        case VtkDataTypes6.UNSIGNED_SHORT:
        case VtkDataTypes6.SHORT:
        default:
          req.format += "16float";
          break;
      }
    }
    if (req.image) {
      req.width = req.image.width;
      req.height = req.image.height;
      req.depth = 1;
      req.format = "rgba8unorm";
    }
    if (req.jsImageData) {
      req.width = req.jsImageData.width;
      req.height = req.jsImageData.height;
      req.depth = 1;
      req.format = "rgba8unorm";
      req.flip = true;
      req.nativeArray = req.jsImageData.data;
    }
    if (req.canvas) {
      req.width = req.canvas.width;
      req.height = req.canvas.height;
      req.depth = 1;
      req.format = "rgba8unorm";
      req.flip = true;
      req.usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT;
    }
  }
  function _createTexture(req) {
    const newTex = vtkWebGPUTexture$1.newInstance();
    newTex.create(model.device, {
      width: req.width,
      height: req.height,
      depth: req.depth,
      format: req.format,
      usage: req.usage,
      mipLevel: req.mipLevel
    });
    if (req.nativeArray || req.image || req.canvas) {
      newTex.writeImageData(req);
    }
    return newTex;
  }
  publicAPI.getTexture = (req) => {
    if (req.hash) {
      return model.device.getCachedObject(req.hash, _createTexture, req);
    }
    return _createTexture(req);
  };
  publicAPI.getTextureForImageData = (imgData) => {
    const treq = {
      time: imgData.getMTime()
    };
    treq.imageData = imgData;
    _fillRequest(treq);
    treq.hash = treq.time + treq.format + treq.mipLevel;
    return model.device.getTextureManager().getTexture(treq);
  };
  publicAPI.getTextureForVTKTexture = (srcTexture) => {
    const treq = {
      time: srcTexture.getMTime()
    };
    if (srcTexture.getInputData()) {
      treq.imageData = srcTexture.getInputData();
    } else if (srcTexture.getImage()) {
      treq.image = srcTexture.getImage();
    } else if (srcTexture.getJsImageData()) {
      treq.jsImageData = srcTexture.getJsImageData();
    } else if (srcTexture.getCanvas()) {
      treq.canvas = srcTexture.getCanvas();
    }
    _fillRequest(treq);
    treq.mipLevel = srcTexture.getMipLevel();
    treq.hash = treq.time + treq.format + treq.mipLevel;
    return model.device.getTextureManager().getTexture(treq);
  };
}
var DEFAULT_VALUES101 = {
  handle: null,
  device: null
};
function extend103(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES101, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["device"]);
  vtkWebGPUTextureManager(publicAPI, model);
}
var newInstance102 = macro.newInstance(extend103);
var vtkWebGPUTextureManager$1 = {
  newInstance: newInstance102,
  extend: extend103
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/Device.js
var WeakRefMap = class extends Map {
  constructor() {
    super();
    this.registry = new FinalizationRegistry((key) => {
      const entry = super.get(key);
      if (entry && entry.deref && entry.deref() === void 0) super.delete(key);
    });
  }
  getValue(key) {
    const entry = super.get(key);
    if (entry) {
      const value = entry.deref();
      if (value !== void 0) return value;
      super.delete(key);
    }
    return void 0;
  }
  setValue(key, value) {
    let entry;
    if (value && typeof value === "object") {
      entry = new WeakRef(value);
      this.registry.register(value, key);
      super.set(key, entry);
    }
    return entry;
  }
};
function vtkWebGPUDevice(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUDevice");
  publicAPI.initialize = (handle) => {
    model.handle = handle;
  };
  publicAPI.createCommandEncoder = () => model.handle.createCommandEncoder();
  publicAPI.submitCommandEncoder = (commandEncoder) => {
    model.handle.queue.submit([commandEncoder.finish()]);
  };
  publicAPI.getShaderModule = (sd) => model.shaderCache.getShaderModule(sd);
  publicAPI.getBindGroupLayout = (val) => {
    if (!val.entries) {
      return null;
    }
    for (let i6 = 0; i6 < val.entries.length; i6++) {
      const ent = val.entries[i6];
      ent.binding = ent.binding || 0;
      ent.visibility = ent.visibility || GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT;
    }
    const sval = JSON.stringify(val);
    for (let i6 = 0; i6 < model.bindGroupLayouts.length; i6++) {
      if (model.bindGroupLayouts[i6].sval === sval) {
        return model.bindGroupLayouts[i6].layout;
      }
    }
    const layout = model.handle.createBindGroupLayout(val);
    model.bindGroupLayouts.push({
      sval,
      layout
    });
    return layout;
  };
  publicAPI.getBindGroupLayoutDescription = (layout) => {
    for (let i6 = 0; i6 < model.bindGroupLayouts.length; i6++) {
      if (model.bindGroupLayouts[i6].layout === layout) {
        return model.bindGroupLayouts[i6].sval;
      }
    }
    vtkErrorMacro("layout not found");
    console.trace();
    return null;
  };
  publicAPI.getPipeline = (hash) => {
    if (hash in model.pipelines) {
      return model.pipelines[hash];
    }
    return null;
  };
  publicAPI.createPipeline = (hash, pipeline) => {
    pipeline.initialize(publicAPI, hash);
    model.pipelines[hash] = pipeline;
  };
  publicAPI.onSubmittedWorkDone = () => model.handle.queue.onSubmittedWorkDone();
  publicAPI.hasCachedObject = (hash) => model.objectCache.getValue(hash);
  publicAPI.getCachedObject = function(hash, creator) {
    if (!hash) {
      vtkErrorMacro("attempt to cache an object without a hash");
      return null;
    }
    const existingValue = model.objectCache.getValue(hash);
    if (existingValue) {
      return existingValue;
    }
    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }
    const createdObject = creator(...args);
    model.objectCache.setValue(hash, createdObject);
    return createdObject;
  };
}
var DEFAULT_VALUES102 = {
  handle: null,
  pipelines: null,
  shaderCache: null,
  bindGroupLayouts: null,
  bufferManager: null,
  textureManager: null
};
function extend104(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES102, initialValues);
  obj(publicAPI, model);
  setGet(publicAPI, model, ["handle"]);
  get(publicAPI, model, ["bufferManager", "shaderCache", "textureManager"]);
  model.objectCache = new WeakRefMap();
  model.shaderCache = vtkWebGPUShaderCache$1.newInstance();
  model.shaderCache.setDevice(publicAPI);
  model.bindGroupLayouts = [];
  model.bufferManager = vtkWebGPUBufferManager$1.newInstance();
  model.bufferManager.setDevice(publicAPI);
  model.textureManager = vtkWebGPUTextureManager$1.newInstance();
  model.textureManager.setDevice(publicAPI);
  model.pipelines = {};
  vtkWebGPUDevice(publicAPI, model);
}
var newInstance103 = newInstance(extend104, "vtkWebGPUDevice");
var vtkWebGPUDevice$1 = {
  newInstance: newInstance103,
  extend: extend104
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/HardwareSelectionPass.js
function vtkWebGPUHardwareSelectionPass(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUHardwareSelectionPass");
  publicAPI.traverse = (viewNode, renNode) => {
    if (model.deleted) {
      return;
    }
    model._currentParent = null;
    publicAPI.setCurrentOperation("buildPass");
    viewNode.traverse(publicAPI);
    const device = viewNode.getDevice();
    if (!model.selectionRenderEncoder) {
      publicAPI.createRenderEncoder();
      model.colorTexture = vtkWebGPUTexture$1.newInstance({
        label: "hardwareSelectorColor"
      });
      model.colorTexture.create(device, {
        width: viewNode.getCanvas().width,
        height: viewNode.getCanvas().height,
        format: "rgba32uint",
        /* eslint-disable no-undef */
        /* eslint-disable no-bitwise */
        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC
      });
      const v1 = model.colorTexture.createView("hardwareSelectColorTexture");
      model.selectionRenderEncoder.setColorTextureView(0, v1);
      model.depthTexture = vtkWebGPUTexture$1.newInstance({
        label: "hardwareSelectorDepth"
      });
      model.depthTexture.create(device, {
        width: viewNode.getCanvas().width,
        height: viewNode.getCanvas().height,
        format: "depth32float",
        /* eslint-disable no-undef */
        /* eslint-disable no-bitwise */
        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC
      });
      const v2 = model.depthTexture.createView("hardwareSelectDepthTexture");
      model.selectionRenderEncoder.setDepthTextureView(v2);
    } else {
      model.colorTexture.resize(viewNode.getCanvas().width, viewNode.getCanvas().height);
      model.depthTexture.resizeToMatch(model.colorTexture);
    }
    model.selectionRenderEncoder.attachTextureViews();
    renNode.setRenderEncoder(model.selectionRenderEncoder);
    publicAPI.setCurrentOperation("cameraPass");
    renNode.traverse(publicAPI);
    publicAPI.setCurrentOperation("opaquePass");
    renNode.traverse(publicAPI);
  };
  publicAPI.createRenderEncoder = () => {
    model.selectionRenderEncoder = vtkWebGPURenderEncoder$1.newInstance({
      label: "HardwareSelectionPass"
    });
    model.selectionRenderEncoder.setPipelineHash("sel");
    model.selectionRenderEncoder.setReplaceShaderCodeFunction((pipeline) => {
      const fDesc = pipeline.getShaderDescription("fragment");
      fDesc.addOutput("vec4<u32>", "outColor");
      let code = fDesc.getCode();
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::RenderEncoder::Impl", ["output.outColor = vec4<u32>(mapperUBO.PropID, compositeID, 0u, 0u);"]).result;
      fDesc.setCode(code);
    });
    const renDesc = model.selectionRenderEncoder.getDescription();
    renDesc.colorAttachments[0].clearValue = [0, 0, 0, 0];
    model.selectionRenderEncoder.setPipelineSettings({
      primitive: {
        cullMode: "none"
      },
      depthStencil: {
        depthWriteEnabled: true,
        depthCompare: "greater",
        format: "depth32float"
      },
      fragment: {
        targets: [{
          format: "rgba32uint",
          blend: void 0
        }]
      }
    });
  };
}
var DEFAULT_VALUES103 = {
  selectionRenderEncoder: null,
  colorTexture: null,
  depthTexture: null
};
function extend105(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES103, initialValues);
  vtkRenderPass$1.extend(publicAPI, model, initialValues);
  macro.get(publicAPI, model, ["colorTexture", "depthTexture"]);
  vtkWebGPUHardwareSelectionPass(publicAPI, model);
}
var newInstance104 = macro.newInstance(extend105, "vtkWebGPUHardwareSelectionPass");
var vtkWebGPUHardwareSelectionPass$1 = {
  newInstance: newInstance104,
  extend: extend105
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/HardwareSelector.js
var {
  SelectionContent: SelectionContent3,
  SelectionField: SelectionField3
} = vtkSelectionNode$1;
var {
  FieldAssociations: FieldAssociations5
} = vtkDataSet$1;
var {
  vtkErrorMacro: vtkErrorMacro35
} = macro;
function getInfoHash2(info) {
  return `${info.propID} ${info.compositeID}`;
}
function convert2(xx, yy, buffdata, channel) {
  const offset3 = ((buffdata.height - yy - 1) * buffdata.colorBufferWidth + xx) * 4 + channel;
  return buffdata.colorValues[offset3];
}
function getPixelInformationWithData2(buffdata, inDisplayPosition, maxDistance, outSelectedPosition) {
  const maxDist = maxDistance < 0 ? 0 : maxDistance;
  if (maxDist === 0) {
    outSelectedPosition[0] = inDisplayPosition[0];
    outSelectedPosition[1] = inDisplayPosition[1];
    if (inDisplayPosition[0] < 0 || inDisplayPosition[0] >= buffdata.width || inDisplayPosition[1] < 0 || inDisplayPosition[1] >= buffdata.height) {
      return null;
    }
    const actorid = convert2(inDisplayPosition[0], inDisplayPosition[1], buffdata, 0);
    if (actorid <= 0) {
      return null;
    }
    const info2 = {};
    info2.propID = actorid;
    let compositeID = convert2(inDisplayPosition[0], inDisplayPosition[1], buffdata, 1);
    if (compositeID < 0 || compositeID > 16777215) {
      compositeID = 0;
    }
    info2.compositeID = compositeID;
    if (buffdata.captureZValues) {
      const offset3 = (buffdata.height - inDisplayPosition[1] - 1) * buffdata.zbufferBufferWidth + inDisplayPosition[0];
      info2.zValue = buffdata.depthValues[offset3];
      info2.zValue = buffdata.webGPURenderer.convertToOpenGLDepth(info2.zValue);
      info2.displayPosition = inDisplayPosition;
    }
    return info2;
  }
  const dispPos = [inDisplayPosition[0], inDisplayPosition[1]];
  const curPos = [0, 0];
  let info = getPixelInformationWithData2(buffdata, inDisplayPosition, 0, outSelectedPosition);
  if (info) {
    return info;
  }
  for (let dist3 = 1; dist3 < maxDist; ++dist3) {
    for (let y3 = dispPos[1] > dist3 ? dispPos[1] - dist3 : 0; y3 <= dispPos[1] + dist3; ++y3) {
      curPos[1] = y3;
      if (dispPos[0] >= dist3) {
        curPos[0] = dispPos[0] - dist3;
        info = getPixelInformationWithData2(buffdata, curPos, 0, outSelectedPosition);
        if (info) {
          return info;
        }
      }
      curPos[0] = dispPos[0] + dist3;
      info = getPixelInformationWithData2(buffdata, curPos, 0, outSelectedPosition);
      if (info) {
        return info;
      }
    }
    for (let x2 = dispPos[0] >= dist3 ? dispPos[0] - (dist3 - 1) : 0; x2 <= dispPos[0] + (dist3 - 1); ++x2) {
      curPos[0] = x2;
      if (dispPos[1] >= dist3) {
        curPos[1] = dispPos[1] - dist3;
        info = getPixelInformationWithData2(buffdata, curPos, 0, outSelectedPosition);
        if (info) {
          return info;
        }
      }
      curPos[1] = dispPos[1] + dist3;
      info = getPixelInformationWithData2(buffdata, curPos, 0, outSelectedPosition);
      if (info) {
        return info;
      }
    }
  }
  outSelectedPosition[0] = inDisplayPosition[0];
  outSelectedPosition[1] = inDisplayPosition[1];
  return null;
}
function convertSelection2(fieldassociation, dataMap, buffdata) {
  const sel = [];
  let count = 0;
  dataMap.forEach((value, key) => {
    const child = vtkSelectionNode$1.newInstance();
    child.setContentType(SelectionContent3.INDICES);
    switch (fieldassociation) {
      case FieldAssociations5.FIELD_ASSOCIATION_CELLS:
        child.setFieldType(SelectionField3.CELL);
        break;
      case FieldAssociations5.FIELD_ASSOCIATION_POINTS:
        child.setFieldType(SelectionField3.POINT);
        break;
      default:
        vtkErrorMacro35("Unknown field association");
    }
    child.getProperties().propID = value.info.propID;
    const wprop = buffdata.webGPURenderer.getPropFromID(value.info.propID);
    child.getProperties().prop = wprop.getRenderable();
    child.getProperties().compositeID = value.info.compositeID;
    child.getProperties().pixelCount = value.pixelCount;
    if (buffdata.captureZValues) {
      child.getProperties().displayPosition = [value.info.displayPosition[0], value.info.displayPosition[1], value.info.zValue];
      child.getProperties().worldPosition = buffdata.webGPURenderWindow.displayToWorld(value.info.displayPosition[0], value.info.displayPosition[1], value.info.zValue, buffdata.renderer);
    }
    child.setSelectionList(value.attributeIDs);
    sel[count] = child;
    count++;
  });
  return sel;
}
function generateSelectionWithData2(buffdata, fx1, fy1, fx2, fy2) {
  const x1 = Math.floor(fx1);
  const y1 = Math.floor(fy1);
  const x2 = Math.floor(fx2);
  const y22 = Math.floor(fy2);
  const dataMap = /* @__PURE__ */ new Map();
  const outSelectedPosition = [0, 0];
  for (let yy = y1; yy <= y22; yy++) {
    for (let xx = x1; xx <= x2; xx++) {
      const pos = [xx, yy];
      const info = getPixelInformationWithData2(buffdata, pos, 0, outSelectedPosition);
      if (info) {
        const hash = getInfoHash2(info);
        if (!dataMap.has(hash)) {
          dataMap.set(hash, {
            info,
            pixelCount: 1,
            attributeIDs: [info.attributeID]
          });
        } else {
          const dmv = dataMap.get(hash);
          dmv.pixelCount++;
          if (buffdata.captureZValues) {
            if (info.zValue < dmv.info.zValue) {
              dmv.info = info;
            }
          }
          if (dmv.attributeIDs.indexOf(info.attributeID) === -1) {
            dmv.attributeIDs.push(info.attributeID);
          }
        }
      }
    }
  }
  return convertSelection2(buffdata.fieldAssociation, dataMap, buffdata);
}
function vtkWebGPUHardwareSelector(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUHardwareSelector");
  publicAPI.endSelection = () => {
    model.WebGPURenderer.setSelector(null);
  };
  publicAPI.getSourceDataAsync = (renderer) => __async(this, null, function* () {
    if (!renderer || !model._WebGPURenderWindow) {
      vtkErrorMacro35("Renderer and view must be set before calling Select.");
      return false;
    }
    model._WebGPURenderWindow.getRenderable().preRender();
    if (!model._WebGPURenderWindow.getInitialized()) {
      model._WebGPURenderWindow.initialize();
      yield new Promise((resolve) => {
        model._WebGPURenderWindow.onInitialized(resolve);
      });
    }
    const webGPURenderer = model._WebGPURenderWindow.getViewNodeFor(renderer);
    if (!webGPURenderer) {
      return false;
    }
    const originalSuppress = webGPURenderer.getSuppressClear();
    webGPURenderer.setSuppressClear(true);
    model._selectionPass.traverse(model._WebGPURenderWindow, webGPURenderer);
    webGPURenderer.setSuppressClear(originalSuppress);
    const device = model._WebGPURenderWindow.getDevice();
    const texture = model._selectionPass.getColorTexture();
    const depthTexture = model._selectionPass.getDepthTexture();
    const result = {
      area: [0, 0, texture.getWidth() - 1, texture.getHeight() - 1],
      captureZValues: model.captureZValues,
      fieldAssociation: model.fieldAssociation,
      renderer,
      webGPURenderer,
      webGPURenderWindow: model._WebGPURenderWindow,
      width: texture.getWidth(),
      height: texture.getHeight()
    };
    result.colorBufferWidth = 16 * Math.floor((result.width + 15) / 16);
    result.colorBufferSizeInBytes = result.colorBufferWidth * result.height * 4 * 4;
    const colorBuffer = vtkWebGPUBuffer$1.newInstance({
      label: "hardwareSelectColorBuffer"
    });
    colorBuffer.setDevice(device);
    colorBuffer.create(result.colorBufferSizeInBytes, GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST);
    const cmdEnc = model._WebGPURenderWindow.getCommandEncoder();
    cmdEnc.copyTextureToBuffer({
      texture: texture.getHandle()
    }, {
      buffer: colorBuffer.getHandle(),
      bytesPerRow: 16 * result.colorBufferWidth,
      rowsPerImage: result.height
    }, {
      width: result.width,
      height: result.height,
      depthOrArrayLayers: 1
    });
    let zbuffer;
    if (model.captureZValues) {
      result.zbufferBufferWidth = 64 * Math.floor((result.width + 63) / 64);
      zbuffer = vtkWebGPUBuffer$1.newInstance({
        label: "hardwareSelectDepthBuffer"
      });
      zbuffer.setDevice(device);
      result.zbufferSizeInBytes = result.height * result.zbufferBufferWidth * 4;
      zbuffer.create(result.zbufferSizeInBytes, GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST);
      cmdEnc.copyTextureToBuffer({
        texture: depthTexture.getHandle(),
        aspect: "depth-only"
      }, {
        buffer: zbuffer.getHandle(),
        bytesPerRow: 4 * result.zbufferBufferWidth,
        rowsPerImage: result.height
      }, {
        width: result.width,
        height: result.height,
        depthOrArrayLayers: 1
      });
    }
    device.submitCommandEncoder(cmdEnc);
    const cLoad = colorBuffer.mapAsync(GPUMapMode.READ);
    if (model.captureZValues) {
      const zLoad = zbuffer.mapAsync(GPUMapMode.READ);
      yield Promise.all([cLoad, zLoad]);
      result.depthValues = new Float32Array(zbuffer.getMappedRange().slice());
      zbuffer.unmap();
    } else {
      yield cLoad;
    }
    result.colorValues = new Uint32Array(colorBuffer.getMappedRange().slice());
    colorBuffer.unmap();
    result.generateSelection = (fx1, fy1, fx2, fy2) => generateSelectionWithData2(result, fx1, fy1, fx2, fy2);
    return result;
  });
}
var DEFAULT_VALUES104 = {
  // WebGPURenderWindow: null,
};
function extend106(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES104, initialValues);
  vtkHardwareSelector$1.extend(publicAPI, model, initialValues);
  model._selectionPass = vtkWebGPUHardwareSelectionPass$1.newInstance();
  macro.setGet(publicAPI, model, ["_WebGPURenderWindow"]);
  macro.moveToProtected(publicAPI, model, ["WebGPURenderWindow"]);
  vtkWebGPUHardwareSelector(publicAPI, model);
}
var newInstance105 = macro.newInstance(extend106, "vtkWebGPUHardwareSelector");
var vtkWebGPUHardwareSelector$1 = {
  newInstance: newInstance105,
  extend: extend106
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/RenderWindow.js
var {
  vtkErrorMacro: vtkErrorMacro36
} = macro;
var SCREENSHOT_PLACEHOLDER2 = {
  position: "absolute",
  top: 0,
  left: 0,
  width: "100%",
  height: "100%"
};
function vtkWebGPURenderWindow(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPURenderWindow");
  publicAPI.getViewNodeFactory = () => model.myFactory;
  const previousSize = [0, 0];
  function updateWindow() {
    if (model.renderable) {
      if (model.size[0] !== previousSize[0] || model.size[1] !== previousSize[1]) {
        previousSize[0] = model.size[0];
        previousSize[1] = model.size[1];
        model.canvas.setAttribute("width", model.size[0]);
        model.canvas.setAttribute("height", model.size[1]);
        publicAPI.recreateSwapChain();
      }
    }
    if (model.viewStream) {
      model.viewStream.setSize(model.size[0], model.size[1]);
    }
    model.canvas.style.display = model.useOffScreen ? "none" : "block";
    if (model.el) {
      model.el.style.cursor = model.cursorVisibility ? model.cursor : "none";
    }
    model.containerSize = null;
  }
  publicAPI.onModified(updateWindow);
  publicAPI.recreateSwapChain = () => {
    if (model.context) {
      model.context.unconfigure();
      model.presentationFormat = navigator.gpu.getPreferredCanvasFormat(model.adapter);
      model.context.configure({
        device: model.device.getHandle(),
        format: model.presentationFormat,
        alphaMode: "premultiplied",
        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_DST,
        width: model.size[0],
        height: model.size[1]
      });
      model._configured = true;
    }
  };
  publicAPI.getCurrentTexture = () => model.context.getCurrentTexture();
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      if (!model.renderable) {
        return;
      }
      publicAPI.prepareNodes();
      publicAPI.addMissingNodes(model.renderable.getRenderersByReference());
      publicAPI.removeUnusedNodes();
      publicAPI.initialize();
    } else if (model.initialized) {
      if (!model._configured) {
        publicAPI.recreateSwapChain();
      }
      model.commandEncoder = model.device.createCommandEncoder();
    }
  };
  publicAPI.initialize = () => {
    if (!model.initializing) {
      model.initializing = true;
      if (!navigator.gpu) {
        vtkErrorMacro36("WebGPU is not enabled.");
        return;
      }
      publicAPI.create3DContextAsync().then(() => {
        model.initialized = true;
        if (model.deleted) {
          return;
        }
        publicAPI.invokeInitialized();
      });
    }
  };
  publicAPI.setContainer = (el) => {
    if (model.el && model.el !== el) {
      if (model.canvas.parentNode !== model.el) {
        vtkErrorMacro36("Error: canvas parent node does not match container");
      }
      model.el.removeChild(model.canvas);
      if (model.el.contains(model.bgImage)) {
        model.el.removeChild(model.bgImage);
      }
    }
    if (model.el !== el) {
      model.el = el;
      if (model.el) {
        model.el.appendChild(model.canvas);
        if (model.useBackgroundImage) {
          model.el.appendChild(model.bgImage);
        }
      }
      publicAPI.modified();
    }
  };
  publicAPI.getContainer = () => model.el;
  publicAPI.getContainerSize = () => {
    if (!model.containerSize && model.el) {
      const {
        width,
        height
      } = model.el.getBoundingClientRect();
      model.containerSize = [width, height];
    }
    return model.containerSize || model.size;
  };
  publicAPI.getFramebufferSize = () => model.size;
  publicAPI.create3DContextAsync = () => __async(this, null, function* () {
    model.adapter = yield navigator.gpu.requestAdapter({
      powerPreference: "high-performance"
    });
    if (model.deleted) {
      return;
    }
    model.device = vtkWebGPUDevice$1.newInstance();
    model.device.initialize(yield model.adapter.requestDevice());
    if (model.deleted) {
      model.device = null;
      return;
    }
    model.context = model.canvas.getContext("webgpu");
  });
  publicAPI.releaseGraphicsResources = () => {
    const rp = vtkRenderPass$1.newInstance();
    rp.setCurrentOperation("Release");
    rp.traverse(publicAPI, null);
    model.adapter = null;
    model.device = null;
    model.context = null;
    model.initialized = false;
    model.initializing = false;
  };
  publicAPI.setBackgroundImage = (img) => {
    model.bgImage.src = img.src;
  };
  publicAPI.setUseBackgroundImage = (value) => {
    model.useBackgroundImage = value;
    if (model.useBackgroundImage && !model.el.contains(model.bgImage)) {
      model.el.appendChild(model.bgImage);
    } else if (!model.useBackgroundImage && model.el.contains(model.bgImage)) {
      model.el.removeChild(model.bgImage);
    }
  };
  function getCanvasDataURL() {
    return __async(this, arguments, function* () {
      let format = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : model.imageFormat;
      const temporaryCanvas = document.createElement("canvas");
      const temporaryContext = temporaryCanvas.getContext("2d");
      temporaryCanvas.width = model.canvas.width;
      temporaryCanvas.height = model.canvas.height;
      const result = yield publicAPI.getPixelsAsync();
      const imageData = new ImageData(result.colorValues, result.width, result.height);
      temporaryContext.putImageData(imageData, 0, 0);
      const mainBoundingClientRect = model.canvas.getBoundingClientRect();
      const renderWindow = model.renderable;
      const renderers = renderWindow.getRenderers();
      renderers.forEach((renderer) => {
        const viewProps = renderer.getViewProps();
        viewProps.forEach((viewProp) => {
          if (viewProp.getContainer) {
            const container = viewProp.getContainer();
            const canvasList = container.getElementsByTagName("canvas");
            for (let i6 = 0; i6 < canvasList.length; i6++) {
              const currentCanvas = canvasList[i6];
              const boundingClientRect = currentCanvas.getBoundingClientRect();
              const newXPosition = boundingClientRect.x - mainBoundingClientRect.x;
              const newYPosition = boundingClientRect.y - mainBoundingClientRect.y;
              temporaryContext.drawImage(currentCanvas, newXPosition, newYPosition);
            }
          }
        });
      });
      const screenshot = temporaryCanvas.toDataURL(format);
      temporaryCanvas.remove();
      publicAPI.invokeImageReady(screenshot);
    });
  }
  publicAPI.captureNextImage = function() {
    let format = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "image/png";
    let {
      resetCamera = false,
      size: size3 = null,
      scale: scale7 = 1
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (model.deleted) {
      return null;
    }
    model.imageFormat = format;
    const previous = model.notifyStartCaptureImage;
    model.notifyStartCaptureImage = true;
    model._screenshot = {
      size: !!size3 || scale7 !== 1 ? size3 || model.size.map((val) => val * scale7) : null
    };
    return new Promise((resolve, reject) => {
      const subscription = publicAPI.onImageReady((imageURL) => {
        if (model._screenshot.size === null) {
          model.notifyStartCaptureImage = previous;
          subscription.unsubscribe();
          if (model._screenshot.placeHolder) {
            model.size = model._screenshot.originalSize;
            publicAPI.modified();
            if (model._screenshot.cameras) {
              model._screenshot.cameras.forEach((_ref) => {
                let {
                  restoreParamsFn,
                  arg
                } = _ref;
                return restoreParamsFn(arg);
              });
            }
            publicAPI.traverseAllPasses();
            model.el.removeChild(model._screenshot.placeHolder);
            model._screenshot.placeHolder.remove();
            model._screenshot = null;
          }
          resolve(imageURL);
        } else {
          const tmpImg = document.createElement("img");
          tmpImg.style = SCREENSHOT_PLACEHOLDER2;
          tmpImg.src = imageURL;
          model._screenshot.placeHolder = model.el.appendChild(tmpImg);
          model.canvas.style.display = "none";
          model._screenshot.originalSize = model.size;
          model.size = model._screenshot.size;
          model._screenshot.size = null;
          publicAPI.modified();
          if (resetCamera) {
            const isUserResetCamera = resetCamera !== true;
            model._screenshot.cameras = model.renderable.getRenderers().map((renderer) => {
              const camera = renderer.getActiveCamera();
              const params = camera.get("focalPoint", "position", "parallelScale");
              return {
                resetCameraArgs: isUserResetCamera ? {
                  renderer
                } : void 0,
                resetCameraFn: isUserResetCamera ? resetCamera : renderer.resetCamera,
                restoreParamsFn: camera.set,
                // "clone" the params so we don't keep refs to properties
                arg: JSON.parse(JSON.stringify(params))
              };
            });
            model._screenshot.cameras.forEach((_ref2) => {
              let {
                resetCameraFn,
                resetCameraArgs
              } = _ref2;
              return resetCameraFn(resetCameraArgs);
            });
          }
          publicAPI.traverseAllPasses();
        }
      });
    });
  };
  publicAPI.traverseAllPasses = () => {
    if (model.deleted) {
      return;
    }
    if (!model.initialized) {
      publicAPI.initialize();
      const subscription = publicAPI.onInitialized(() => {
        subscription.unsubscribe();
        publicAPI.traverseAllPasses();
      });
    } else {
      if (model.renderPasses) {
        for (let index2 = 0; index2 < model.renderPasses.length; ++index2) {
          model.renderPasses[index2].traverse(publicAPI, null);
        }
      }
      if (model.commandEncoder) {
        model.device.submitCommandEncoder(model.commandEncoder);
        model.commandEncoder = null;
        if (model.notifyStartCaptureImage) {
          model.device.onSubmittedWorkDone().then(() => {
            getCanvasDataURL();
          });
        }
      }
    }
  };
  publicAPI.setViewStream = (stream) => {
    if (model.viewStream === stream) {
      return false;
    }
    if (model.subscription) {
      model.subscription.unsubscribe();
      model.subscription = null;
    }
    model.viewStream = stream;
    if (model.viewStream) {
      const mainRenderer = model.renderable.getRenderers()[0];
      mainRenderer.getBackgroundByReference()[3] = 0;
      publicAPI.setUseBackgroundImage(true);
      model.subscription = model.viewStream.onImageReady((e13) => publicAPI.setBackgroundImage(e13.image));
      model.viewStream.setSize(model.size[0], model.size[1]);
      model.viewStream.invalidateCache();
      model.viewStream.render();
      publicAPI.modified();
    }
    return true;
  };
  publicAPI.getUniquePropID = () => model.nextPropID++;
  publicAPI.getPropFromID = (id) => {
    for (let i6 = 0; i6 < model.children.length; i6++) {
      const res = model.children[i6].getPropFromID(id);
      if (res !== null) {
        return res;
      }
    }
    return null;
  };
  publicAPI.getPixelsAsync = () => __async(this, null, function* () {
    const device = model.device;
    const texture = model.renderPasses[0].getOpaquePass().getColorTexture();
    const result = {
      width: texture.getWidth(),
      height: texture.getHeight()
    };
    result.colorBufferWidth = 32 * Math.floor((result.width + 31) / 32);
    result.colorBufferSizeInBytes = result.colorBufferWidth * result.height * 8;
    const colorBuffer = vtkWebGPUBuffer$1.newInstance();
    colorBuffer.setDevice(device);
    colorBuffer.create(result.colorBufferSizeInBytes, GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST);
    const cmdEnc = model.device.createCommandEncoder();
    cmdEnc.copyTextureToBuffer({
      texture: texture.getHandle()
    }, {
      buffer: colorBuffer.getHandle(),
      bytesPerRow: 8 * result.colorBufferWidth,
      rowsPerImage: result.height
    }, {
      width: result.width,
      height: result.height,
      depthOrArrayLayers: 1
    });
    device.submitCommandEncoder(cmdEnc);
    const cLoad = colorBuffer.mapAsync(GPUMapMode.READ);
    yield cLoad;
    result.colorValues = new Uint16Array(colorBuffer.getMappedRange().slice());
    colorBuffer.unmap();
    const tmparray = new Uint8ClampedArray(result.height * result.width * 4);
    for (let y3 = 0; y3 < result.height; y3++) {
      for (let x2 = 0; x2 < result.width; x2++) {
        const doffset = (y3 * result.width + x2) * 4;
        const soffset = (y3 * result.colorBufferWidth + x2) * 4;
        tmparray[doffset] = 255 * HalfFloat.fromHalf(result.colorValues[soffset]);
        tmparray[doffset + 1] = 255 * HalfFloat.fromHalf(result.colorValues[soffset + 1]);
        tmparray[doffset + 2] = 255 * HalfFloat.fromHalf(result.colorValues[soffset + 2]);
        tmparray[doffset + 3] = 255 * HalfFloat.fromHalf(result.colorValues[soffset + 3]);
      }
    }
    result.colorValues = tmparray;
    return result;
  });
  publicAPI.createSelector = () => {
    const ret = vtkWebGPUHardwareSelector$1.newInstance();
    ret.setWebGPURenderWindow(publicAPI);
    return ret;
  };
  const superSetSize = publicAPI.setSize;
  publicAPI.setSize = (width, height) => {
    const modified = superSetSize(width, height);
    if (modified) {
      publicAPI.invokeWindowResizeEvent({
        width,
        height
      });
    }
    return modified;
  };
  publicAPI.delete = macro.chain(publicAPI.delete, publicAPI.setViewStream);
}
var DEFAULT_VALUES105 = {
  initialized: false,
  context: null,
  adapter: null,
  device: null,
  canvas: null,
  cursorVisibility: true,
  cursor: "pointer",
  containerSize: null,
  renderPasses: [],
  notifyStartCaptureImage: false,
  imageFormat: "image/png",
  useOffScreen: false,
  useBackgroundImage: false,
  nextPropID: 1,
  xrSupported: false,
  presentationFormat: null
};
function extend107(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES105, initialValues);
  model.canvas = document.createElement("canvas");
  model.canvas.style.width = "100%";
  model.bgImage = new Image();
  model.bgImage.style.position = "absolute";
  model.bgImage.style.left = "0";
  model.bgImage.style.top = "0";
  model.bgImage.style.width = "100%";
  model.bgImage.style.height = "100%";
  model.bgImage.style.zIndex = "-1";
  vtkRenderWindowViewNode$1.extend(publicAPI, model, initialValues);
  model.myFactory = vtkWebGPUViewNodeFactory$1.newInstance();
  model.renderPasses[0] = vtkForwardPass$12.newInstance();
  if (!model.selector) {
    model.selector = vtkWebGPUHardwareSelector$1.newInstance();
    model.selector.setWebGPURenderWindow(publicAPI);
  }
  macro.event(publicAPI, model, "imageReady");
  macro.event(publicAPI, model, "initialized");
  macro.get(publicAPI, model, ["commandEncoder", "device", "presentationFormat", "useBackgroundImage", "xrSupported"]);
  macro.setGet(publicAPI, model, ["initialized", "context", "canvas", "device", "renderPasses", "notifyStartCaptureImage", "cursor", "useOffScreen"]);
  macro.setGetArray(publicAPI, model, ["size"], 2);
  macro.event(publicAPI, model, "windowResizeEvent");
  vtkWebGPURenderWindow(publicAPI, model);
}
var newInstance106 = macro.newInstance(extend107, "vtkWebGPURenderWindow");
registerViewConstructor("WebGPU", newInstance106);
registerOverride2("vtkRenderWindow", newInstance106);

// node_modules/@kitware/vtk.js/Rendering/Misc/GenericRenderWindow.js
var userParams = vtkURLExtract.extractURLParameters();
function vtkGenericRenderWindow(publicAPI, model) {
  var _a9;
  const invokeResize = publicAPI.invokeResize;
  delete publicAPI.invokeResize;
  model.renderWindow = vtkRenderWindow$1.newInstance();
  model.renderer = vtkRenderer$1.newInstance();
  model.renderWindow.addRenderer(model.renderer);
  model._apiSpecificRenderWindow = model.renderWindow.newAPISpecificView((_a9 = userParams.viewAPI) != null ? _a9 : model.defaultViewAPI);
  model.renderWindow.addView(model._apiSpecificRenderWindow);
  model.interactor = vtkRenderWindowInteractor$1.newInstance();
  model.interactor.setInteractorStyle(vtkInteractorStyleTrackballCamera$1.newInstance());
  model.interactor.setView(model._apiSpecificRenderWindow);
  model.interactor.initialize();
  publicAPI.setBackground = model.renderer.setBackground;
  publicAPI.setBackground(...model.background);
  publicAPI.resize = () => {
    if (model.container) {
      const dims = model.container.getBoundingClientRect();
      const devicePixelRatio = window.devicePixelRatio || 1;
      model._apiSpecificRenderWindow.setSize(Math.floor(dims.width * devicePixelRatio), Math.floor(dims.height * devicePixelRatio));
      invokeResize();
      model.renderWindow.render();
    }
  };
  publicAPI.setContainer = (el) => {
    if (model.container) {
      model.interactor.unbindEvents(model.container);
    }
    model.container = el;
    model._apiSpecificRenderWindow.setContainer(model.container);
    if (model.container) {
      model.interactor.bindEvents(model.container);
    }
  };
  publicAPI.delete = macro.chain(publicAPI.setContainer, model._apiSpecificRenderWindow.delete, publicAPI.delete);
  if (model.listenWindowResize) {
    window.addEventListener("resize", publicAPI.resize);
  }
  publicAPI.resize();
}
var DEFAULT_VALUES106 = {
  background: [0.32, 0.34, 0.43],
  listenWindowResize: true,
  container: null
};
function extend108(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES106, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["renderWindow", "renderer", "_apiSpecificRenderWindow", "interactor", "container"]);
  macro.moveToProtected(publicAPI, model, ["_apiSpecificRenderWindow"]);
  macro.event(publicAPI, model, "resize");
  vtkGenericRenderWindow(publicAPI, model);
}
var newInstance107 = macro.newInstance(extend108);
var vtkGenericRenderWindow$1 = {
  newInstance: newInstance107,
  extend: extend108
};

// node_modules/@itk-viewer/vtkjs/dist/view-2d-vtkjs.machine.js
var view2dLogic = setup({
  types: {},
  actions: {
    setContainer: () => {
      throw new Error("Function not implemented.");
    },
    imageBuilt: () => {
      throw new Error("Function not implemented.");
    },
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    applyCameraPose: (_2, __) => {
      throw new Error("Function not implemented.");
    },
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    axis: (_2, __) => {
      throw new Error("Function not implemented.");
    },
    forwardToParent: sendTo(({ context }) => context.parent, ({ event: event2 }) => {
      return event2;
    })
  }
}).createMachine({
  context: ({ input: { parent } }) => {
    return {
      rendererContainer: vtkGenericRenderWindow$1.newInstance({
        listenWindowResize: false
      }),
      camera: void 0,
      axis: "z",
      parent
    };
  },
  id: "view2dVtkjs",
  initial: "vtkjs",
  states: {
    vtkjs: {
      on: {
        setContainer: {
          actions: [
            { type: "setContainer" },
            {
              type: "axis",
              params: ({ context: { axis: axis2 } }) => ({
                axis: axis2
              })
            }
          ]
        },
        setResolution: {
          actions: ["forwardToParent"]
        },
        imageBuilt: {
          actions: [{ type: "imageBuilt" }]
        },
        setCamera: {
          actions: [
            ({ context, self: self2 }) => {
              var _a9;
              (_a9 = context.camera) == null ? void 0 : _a9.send({ type: "watchPoseStop", watcher: self2 });
            },
            assign({
              camera: ({ event: { camera } }) => camera
            }),
            ({ event: event2, self: self2 }) => {
              event2.camera.send({ type: "watchPose", watcher: self2 });
            }
          ]
        },
        setCameraPose: {
          actions: [
            {
              type: "applyCameraPose",
              params: ({ event: event2 }) => ({
                pose: event2.pose,
                parallelScaleRatio: event2.parallelScaleRatio
              })
            }
          ]
        },
        axis: {
          actions: [
            assign({
              axis: ({ event: event2 }) => event2.axis
            }),
            {
              type: "axis",
              params: ({ event: event2 }) => ({
                axis: event2.axis
              })
            }
          ]
        }
      }
    }
  }
});

// node_modules/@itk-viewer/vtkjs/dist/view-2d-vtkjs.js
var axisToSliceMode = {
  // @ts-expect-error can't find SlicingMode
  x: vtkImageMapper$1.SlicingMode.X,
  // @ts-expect-error can't find SlicingMode
  y: vtkImageMapper$1.SlicingMode.Y,
  // @ts-expect-error can't find SlicingMode
  z: vtkImageMapper$1.SlicingMode.Z
};
var setupContainer = (rendererContainer, container, self2) => {
  rendererContainer.setContainer(container);
  rendererContainer.resize();
  const resizer = new ResizeObserver((entries) => {
    if (!entries.length)
      return;
    rendererContainer.resize();
    const { width, height } = entries[0].contentRect;
    self2.send({ type: "setResolution", resolution: [width, height] });
  });
  resizer.observe(container);
  const renderer = rendererContainer.getRenderer();
  const renderWindow = rendererContainer.getRenderWindow();
  const mapper = vtkImageMapper$1.newInstance();
  const actor = vtkImageSlice$1.newInstance();
  actor.setMapper(mapper);
  renderWindow.getInteractor().setInteractorStyle(void 0);
  const camera = renderer.getActiveCamera();
  camera.setParallelProjection(true);
  return { actor, mapper, renderer, renderWindow };
};
var createImplementation = () => {
  let actor = void 0;
  let mapper = void 0;
  let renderer = void 0;
  let renderWindow = void 0;
  const viewMat = mat4_exports.create();
  let addedActorToRenderer = false;
  const cleanupContainer = (rendererContainer) => {
    actor == null ? void 0 : actor.delete();
    actor = void 0;
    mapper == null ? void 0 : mapper.delete();
    mapper = void 0;
    renderer == null ? void 0 : renderer.delete();
    renderer = void 0;
    renderWindow == null ? void 0 : renderWindow.delete();
    renderWindow = void 0;
    rendererContainer.setContainer(void 0);
  };
  const render = () => {
    renderer.resetCameraClippingRange();
    renderWindow.render();
  };
  const config = {
    actions: {
      setContainer: ({ event: event2, context: { rendererContainer }, self: self2 }) => {
        const { container } = event2;
        if (!container) {
          return cleanupContainer(rendererContainer);
        }
        const scene = setupContainer(rendererContainer, container, self2);
        actor = scene.actor;
        mapper = scene.mapper;
        renderer = scene.renderer;
        renderWindow = scene.renderWindow;
      },
      imageBuilt: ({ event: event2, context }) => {
        var _a9;
        const { image: image2, sliceIndex } = event2;
        const vtkImage = ITKHelper.convertItkToVtkImage(image2);
        mapper.setInputData(vtkImage);
        mapper.setSlice(sliceIndex);
        if (!addedActorToRenderer) {
          addedActorToRenderer = true;
          renderer.addActor(actor);
          const snap = (_a9 = context.camera) == null ? void 0 : _a9.getSnapshot();
          if (snap) {
            toMat4(viewMat, snap.context.pose);
            const cameraVtk = renderer.getActiveCamera();
            cameraVtk.setViewMatrix(viewMat);
          } else {
            renderer.resetCamera();
          }
        }
        render();
      },
      applyCameraPose: (_2, { pose, parallelScaleRatio }) => {
        const cameraVtk = renderer == null ? void 0 : renderer.getActiveCamera();
        if (!cameraVtk)
          return;
        cameraVtk.setParallelScale(parallelScaleRatio * pose.distance);
        const image2 = mapper == null ? void 0 : mapper.getInputData();
        if (image2) {
          const bounds = image2.getBounds();
          const center = vec3_exports.fromValues((bounds[0] + bounds[1]) / 2, (bounds[2] + bounds[3]) / 2, (bounds[4] + bounds[5]) / 2);
          const distanceToCenter = vec3_exports.distance(center, pose.center);
          let w1 = bounds[1] - bounds[0];
          let w2 = bounds[3] - bounds[2];
          let w3 = bounds[5] - bounds[4];
          w1 *= w1;
          w2 *= w2;
          w3 *= w3;
          let radius = w1 + w2 + w3;
          radius = radius === 0 ? 1 : radius;
          radius = Math.sqrt(radius) * 0.5;
          const ensureOutOfImageDistance = distanceToCenter + radius;
          toMat4(viewMat, __spreadProps(__spreadValues({}, pose), { distance: ensureOutOfImageDistance }));
        } else {
          toMat4(viewMat, pose);
        }
        cameraVtk.setViewMatrix(viewMat);
        render();
      },
      axis: (_2, { axis: axis2 }) => {
        mapper == null ? void 0 : mapper.setSlicingMode(axisToSliceMode[axis2]);
      }
    }
  };
  return config;
};
var createLogic = () => {
  return view2dLogic.provide(createImplementation());
};

// node_modules/@itk-viewer/arcball/src/arcball.js
var vec3 = vec3_exports;
var mat3 = mat3_exports;
var mat4 = mat4_exports;
var quat = quat_exports;
var scratch0 = new Float32Array(16);
var scratch1 = new Float32Array(16);
function ArcballCamera(rotation, center, distance3) {
  this.rotation = rotation;
  this.center = center;
  this.distance = distance3;
}
var proto = ArcballCamera.prototype;
proto.view = function(out) {
  if (!out) {
    out = mat4.create();
  }
  scratch1[0] = scratch1[1] = 0;
  scratch1[2] = -this.distance;
  mat4.fromRotationTranslation(
    out,
    quat.conjugate(scratch0, this.rotation),
    scratch1
  );
  mat4.translate(out, out, vec3.negate(scratch0, this.center));
  return out;
};
proto.lookAt = function(eye, center, up) {
  mat4.lookAt(scratch0, eye, center, up);
  mat3.fromMat4(scratch0, scratch0);
  quat.fromMat3(this.rotation, scratch0);
  vec3.copy(this.center, center);
  this.distance = vec3.distance(eye, center);
};
proto.pan = function(dpan) {
  var d3 = this.distance;
  scratch0[0] = -d3 * (dpan[0] || 0);
  scratch0[1] = d3 * (dpan[1] || 0);
  scratch0[2] = d3 * (dpan[2] || 0);
  vec3.transformQuat(scratch0, scratch0, this.rotation);
  vec3.add(this.center, this.center, scratch0);
};
proto.zoom = function(d3) {
  this.distance += d3;
  if (this.distance < 0) {
    this.distance = 0;
  }
};
function quatFromVec(out, da) {
  var x2 = da[0];
  var y3 = -da[1];
  var s9 = Math.sqrt(x2 * x2 + y3 * y3);
  if (s9 > 1) {
    s9 = 1;
  }
  out[0] = x2;
  out[1] = y3;
  out[2] = Math.sqrt(1 - s9);
  out[3] = 0;
}
proto.rotate = function(da, db) {
  quatFromVec(scratch0, da);
  quatFromVec(scratch1, db);
  quat.normalize(scratch0, scratch0);
  quat.normalize(scratch1, scratch1);
  quat.conjugate(scratch0, scratch0);
  quat.multiply(scratch0, scratch1, scratch0);
  if (quat.length(scratch0) < 1e-6) {
    return;
  }
  quat.normalize(scratch0, scratch0);
  quat.multiply(this.rotation, this.rotation, scratch0);
  quat.normalize(this.rotation, this.rotation);
};
function createArcballCamera(eye, target, up) {
  eye = eye || [0, 0, -1];
  target = target || [0, 0, 0];
  up = up || [0, 1, 0];
  var camera = new ArcballCamera(quat.create(), vec3.create(), 1);
  camera.lookAt(eye, target, up);
  return camera;
}

// node_modules/@itk-viewer/element/dist/itk-camera.js
var __decorate4 = function(decorators, target, key, desc) {
  var c6 = arguments.length, r9 = c6 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
  else for (var i6 = decorators.length - 1; i6 >= 0; i6--) if (d3 = decorators[i6]) r9 = (c6 < 3 ? d3(r9) : c6 > 3 ? d3(target, key, r9) : d3(target, key)) || r9;
  return c6 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
};
var PAN_SPEED = 1;
var ZOOM_SPEED = 1e-3;
var bindCamera = (camera, viewport, onUpdate) => {
  let width = viewport.clientWidth;
  let height = viewport.clientHeight;
  const updateView = () => {
    onUpdate(camera.center, camera.rotation, camera.distance);
  };
  const resizeObserver = new ResizeObserver((entries) => {
    for (const entry of entries) {
      width = entry.contentRect.width;
      height = entry.contentRect.height;
    }
  });
  resizeObserver.observe(viewport);
  let rotate3 = false;
  let pan = false;
  let scale7 = false;
  const onPointerDown = (e13) => {
    e13.preventDefault();
    if (e13.button === 0) {
      rotate3 = true;
    } else if (e13.button === 1) {
      scale7 = true;
    } else if (e13.button === 2) {
      pan = true;
    }
  };
  viewport.addEventListener("pointerdown", onPointerDown);
  const onPointerUp = (e13) => {
    e13.preventDefault();
    if (e13.button === 0) {
      rotate3 = false;
    } else if (e13.button === 1) {
      scale7 = false;
    } else if (e13.button === 2) {
      pan = false;
    }
  };
  window.addEventListener("pointerup", onPointerUp);
  let prevPointerX = 0;
  let prevPointerY = 0;
  const onPointerMove = (e13) => {
    const pointerX = e13.offsetX;
    const pointerY = e13.offsetY;
    if (rotate3) {
      camera.rotate([pointerX / width - 0.5, pointerY / height - 0.5], [prevPointerX / width - 0.5, prevPointerY / height - 0.5]);
    }
    if (pan) {
      camera.pan([
        PAN_SPEED * (pointerX - prevPointerX) / width,
        PAN_SPEED * (pointerY - prevPointerY) / height
      ]);
    }
    if (scale7) {
      const d3 = pointerY - prevPointerY;
      if (d3)
        camera.distance *= Math.exp(d3 / height);
    }
    prevPointerX = pointerX;
    prevPointerY = pointerY;
    if (!rotate3 && !pan && !scale7)
      return;
    updateView();
  };
  viewport.addEventListener("pointermove", onPointerMove);
  const onWheel = (e13) => {
    e13.preventDefault();
    camera.zoom(ZOOM_SPEED * camera.distance * e13.deltaY);
    updateView();
  };
  viewport.addEventListener("wheel", onWheel, { passive: false });
  const preventDefault2 = (e13) => e13.preventDefault();
  viewport.addEventListener("contextmenu", preventDefault2);
  const unBind = () => {
    resizeObserver.disconnect();
    viewport.removeEventListener("pointerdown", onPointerDown);
    window.removeEventListener("pointerup", onPointerUp);
    viewport.removeEventListener("pointermove", onPointerMove);
    viewport.removeEventListener("wheel", onWheel);
    viewport.removeEventListener("contextmenu", preventDefault2);
  };
  return unBind;
};
var ItkCamera = class ItkCamera2 extends s3 {
  constructor() {
    super();
    this.cameraController = createArcballCamera([0, 0, -1], [0, 0, 0], [0, 1, 0]);
  }
  firstUpdated() {
    this.unBind = bindCamera(this.cameraController, this, (center, rotation, distance3) => {
      if (!this.actor)
        return;
      this.actor.send({
        type: "setPose",
        pose: {
          center,
          rotation,
          distance: distance3
        }
      });
    });
  }
  disconnectedCallback() {
    var _a9;
    super.disconnectedCallback();
    (_a9 = this.unBind) == null ? void 0 : _a9.call(this);
  }
  willUpdate(changedProperties) {
    var _a9, _b2, _c;
    if (changedProperties.has("actor") && this.actor) {
      this.pose = new SelectorController(this, this.actor, (state) => state == null ? void 0 : state.context.pose);
    }
    if (((_a9 = this.pose) == null ? void 0 : _a9.value) !== this.oldPose) {
      this.oldPose = (_b2 = this.pose) == null ? void 0 : _b2.value;
      if ((_c = this.pose) == null ? void 0 : _c.value) {
        vec3_exports.copy(this.cameraController.center, this.pose.value.center);
        quat_exports.copy(this.cameraController.rotation, this.pose.value.rotation);
        this.cameraController.distance = this.pose.value.distance;
      }
    }
  }
  render() {
    return x`<slot></slot>`;
  }
};
__decorate4([
  n4({ attribute: false })
], ItkCamera.prototype, "actor", void 0);
ItkCamera = __decorate4([
  t3("itk-camera")
], ItkCamera);

// node_modules/@itk-viewer/element/dist/itk-view-2d-vtkjs.js
var __decorate5 = function(decorators, target, key, desc) {
  var c6 = arguments.length, r9 = c6 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
  else for (var i6 = decorators.length - 1; i6 >= 0; i6--) if (d3 = decorators[i6]) r9 = (c6 < 3 ? d3(r9) : c6 > 3 ? d3(target, key, r9) : d3(target, key)) || r9;
  return c6 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
};
var _a7;
var ItkView2dVtkjs = (_a7 = class extends s3 {
  constructor() {
    super(...arguments);
    this.dispatched = false;
  }
  getActor() {
    return this.actor;
  }
  setActor(actor) {
    this.actor = actor;
    this.sendContainer();
    this.cameraActor = new SelectorController(this, this.actor, (state) => state.context.camera);
  }
  sendContainer() {
    if (!this.actor)
      return;
    this.actor.send({ type: "setContainer", container: this.container });
  }
  onContainer(container) {
    if (container instanceof HTMLElement || container == void 0) {
      this.container = container;
      this.sendContainer();
    }
  }
  render() {
    var _a9;
    if (!this.dispatched) {
      dispatchSpawn(this, "renderer", createLogic(), (actor) => this.setActor(actor));
      this.dispatched = true;
    }
    return x`
      <itk-camera .actor=${(_a9 = this.cameraActor) == null ? void 0 : _a9.value} class="container">
        <div class="container" ${n7(this.onContainer)}></div>
      </itk-camera>
    `;
  }
}, _a7.styles = i`
    :host {
      flex: 1;
      display: flex;
      flex-direction: column;
    }

    .container {
      flex: 1;
      min-height: 0;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }
  `, _a7);
ItkView2dVtkjs = __decorate5([
  t3("itk-view-2d-vtkjs")
], ItkView2dVtkjs);

// node_modules/@itk-viewer/element/dist/view-2d-controls-controller.js
var View2dControls = class {
  constructor(host) {
    this.host = host;
    host.addController(this);
  }
  hostConnected() {
  }
  setActor(actor) {
    this.actor = actor;
    this.scale = new SelectorController(this.host, this.actor, (state) => state.context.scale);
    this.scaleCount = new SelectorController(this.host, this.actor, (state) => {
      const image2 = state.context.image;
      if (!image2)
        return 1;
      return image2.coarsestScale + 1;
    });
    this.slice = new SelectorController(this.host, this.actor, (state) => state.context.slice);
    this.imageDimension = new SelectorController(this.host, this.actor, (state) => {
      var _a9, _b2;
      return (_b2 = (_a9 = state.context.image) == null ? void 0 : _a9.imageType.dimension) != null ? _b2 : 0;
    });
    this.host.requestUpdate();
  }
  onSlice(event2) {
    const target = event2.target;
    const slice = Number(target.value);
    this.actor.send({
      type: "setSlice",
      slice
    });
  }
  onScale(event2) {
    const target = event2.target;
    const scale7 = Number(target.value);
    this.actor.send({ type: "setScale", scale: scale7 });
  }
};

// node_modules/@itk-viewer/element/dist/itk-view-2d-controls-shoelace.js
var __decorate6 = function(decorators, target, key, desc) {
  var c6 = arguments.length, r9 = c6 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
  else for (var i6 = decorators.length - 1; i6 >= 0; i6--) if (d3 = decorators[i6]) r9 = (c6 < 3 ? d3(r9) : c6 > 3 ? d3(target, key, r9) : d3(target, key)) || r9;
  return c6 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
};
var View2dControlsShoelace = class View2dControlsShoelace2 extends s3 {
  constructor() {
    super(...arguments);
    this.controls = new View2dControls(this);
  }
  setActor(actor) {
    this.actor = actor;
    this.controls.setActor(actor);
  }
  render() {
    var _a9, _b2, _c, _d, _e, _f;
    const slice = (_a9 = this.controls.slice) == null ? void 0 : _a9.value;
    const imageDimension = (_c = (_b2 = this.controls.imageDimension) == null ? void 0 : _b2.value) != null ? _c : 0;
    const scale7 = (_d = this.controls.scale) == null ? void 0 : _d.value;
    const scaleCount = (_f = (_e = this.controls.scaleCount) == null ? void 0 : _e.value) != null ? _f : 1;
    const scaleOptions = Array.from({ length: scaleCount }, (_2, i6) => i6).reverse();
    const showSliceSlider = imageDimension >= 3;
    const showScale = scaleCount >= 2;
    if (!showSliceSlider && !showScale) {
      return "";
    }
    return x`
      <sl-card>
        ${showSliceSlider ? x`<label>
              <sl-range
                value=${Number(slice)}
                @sl-change="${this.controls.onSlice}"
                min="0"
                max="1"
                step=".01"
                label="Slice"
              ></sl-range
            ></label>` : ""}
        ${showScale ? x`<sl-select
              label="Image Scale"
              value=${scale7}
              @sl-change="${this.controls.onScale}"
            >
              ${scaleOptions.map((option) => x`<sl-option value=${option}> ${option} </sl-option>`)}
            </sl-select>` : ""}
      </sl-card>
    `;
  }
};
View2dControlsShoelace = __decorate6([
  t3("itk-view-2d-controls-shoelace")
], View2dControlsShoelace);

// node_modules/@itk-viewer/element/dist/itk-viewer-2d.js
var __decorate7 = function(decorators, target, key, desc) {
  var c6 = arguments.length, r9 = c6 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
  else for (var i6 = decorators.length - 1; i6 >= 0; i6--) if (d3 = decorators[i6]) r9 = (c6 < 3 ? d3(r9) : c6 > 3 ? d3(target, key, r9) : d3(target, key)) || r9;
  return c6 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
};
var _a8;
var ItkViewer2d = (_a8 = class extends s3 {
  constructor() {
    super(...arguments);
    this.viewer = e11();
    this.view = e11();
    this.controls = e11();
  }
  getActor() {
    var _a9;
    return (_a9 = this.viewer.value) == null ? void 0 : _a9.getActor();
  }
  render() {
    return x`
      <itk-viewer class="fill" ${n7(this.viewer)}>
        <itk-viewport class="fill">
          <div style="position: relative" class="fill">
            <div style="position: absolute; top: 0.25rem; left: 0.25rem">
              <itk-view-2d-controls-shoelace
                ${n7(this.controls)}
              ></itk-view-2d-controls-shoelace>
              <!-- <itk-view-2d-controls-material
                ${n7(this.controls)}
              ></itk-view-2d-controls-material> -->
            </div>
            <itk-view-2d ${n7(this.view)} class="fill">
              <itk-view-2d-vtkjs></itk-view-2d-vtkjs>
            </itk-view-2d>
          </div>
        </itk-viewport>
      </itk-viewer>
    `;
  }
  firstUpdated() {
    return __async(this, null, function* () {
      yield this.updateComplete;
      const viewActor = this.view.value.getActor();
      const controls = this.controls.value;
      controls.setActor(viewActor);
    });
  }
}, _a8.styles = i`
    :host {
      flex: 1;
      display: flex;
      flex-direction: column;
    }

    .fill {
      flex: 1;
      min-height: 0;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }
  `, _a8);
ItkViewer2d = __decorate7([
  t3("itk-viewer-2d")
], ItkViewer2d);

// node_modules/itk-wasm/dist/interface-types/int-types.js
var IntTypes = {
  Int8: "int8",
  UInt8: "uint8",
  Int16: "int16",
  UInt16: "uint16",
  Int32: "int32",
  UInt32: "uint32",
  Int64: "int64",
  UInt64: "uint64",
  SizeValueType: "uint64",
  IdentifierType: "uint64",
  IndexValueType: "int64",
  OffsetValueType: "int64"
};
var int_types_default = IntTypes;

// node_modules/itk-wasm/dist/interface-types/float-types.js
var FloatTypes = {
  Float32: "float32",
  Float64: "float64",
  SpacePrecisionType: "float64"
};
var float_types_default = FloatTypes;

// node_modules/itk-wasm/dist/buffer-to-typed-array.js
function bufferToTypedArray(wasmType, buffer) {
  let typedArray = null;
  switch (wasmType) {
    case int_types_default.UInt8: {
      typedArray = new Uint8Array(buffer);
      break;
    }
    case int_types_default.Int8: {
      typedArray = new Int8Array(buffer);
      break;
    }
    case int_types_default.UInt16: {
      typedArray = new Uint16Array(buffer);
      break;
    }
    case int_types_default.Int16: {
      typedArray = new Int16Array(buffer);
      break;
    }
    case int_types_default.UInt32: {
      typedArray = new Uint32Array(buffer);
      break;
    }
    case int_types_default.Int32: {
      typedArray = new Int32Array(buffer);
      break;
    }
    case int_types_default.UInt64: {
      if (typeof globalThis.BigUint64Array === "function") {
        typedArray = new BigUint64Array(buffer);
      } else {
        typedArray = new Uint8Array(buffer);
      }
      break;
    }
    case int_types_default.Int64: {
      if (typeof globalThis.BigInt64Array === "function") {
        typedArray = new BigInt64Array(buffer);
      } else {
        typedArray = new Uint8Array(buffer);
      }
      break;
    }
    case float_types_default.Float32: {
      typedArray = new Float32Array(buffer);
      break;
    }
    case float_types_default.Float64: {
      typedArray = new Float64Array(buffer);
      break;
    }
    case "null": {
      typedArray = null;
      break;
    }
    case null: {
      typedArray = null;
      break;
    }
    default:
      throw new Error("Type is not supported as a TypedArray");
  }
  return typedArray;
}
var buffer_to_typed_array_default = bufferToTypedArray;

// node_modules/itk-wasm/dist/interface-types/pixel-types.js
var PixelTypes = {
  Unknown: "Unknown",
  Scalar: "Scalar",
  RGB: "RGB",
  RGBA: "RGBA",
  Offset: "Offset",
  Vector: "Vector",
  Point: "Point",
  CovariantVector: "CovariantVector",
  SymmetricSecondRankTensor: "SymmetricSecondRankTensor",
  DiffusionTensor3D: "DiffusionTensor3D",
  Complex: "Complex",
  FixedArray: "FixedArray",
  Array: "Array",
  Matrix: "Matrix",
  VariableLengthVector: "VariableLengthVector",
  VariableSizeMatrix: "VariableSizeMatrix"
};
var pixel_types_default = PixelTypes;

// node_modules/itk-wasm/dist/worker-pool.js
var WorkerPool = class {
  /* poolSize is the maximum number of web workers to create in the pool.
   *
   * The function, fcn, should accept null or an existing worker as its first argument.
   * It most also return and object with the used worker on the `webWorker`
   * property.  * Example: runPipeline.
   *
   **/
  constructor(poolSize, fcn) {
    __publicField(this, "fcn");
    __publicField(this, "workerQueue");
    __publicField(this, "runInfo");
    this.fcn = fcn;
    this.workerQueue = new Array(poolSize);
    this.workerQueue.fill(null);
    this.runInfo = [];
  }
  /*
   * Run the tasks specified by the arguments in the taskArgsArray that will
   * be passed to the pool fcn.
   *
   * An optional progressCallback will be called with the number of complete
   * tasks and the total number of tasks as arguments every time a task has
   * completed.
   *
   * Returns an object containing a promise ('promise') to communicate results
   * as well as an id ('runId') which can be used to cancel any remaining pending
   * tasks before they complete.
   */
  runTasks(taskArgsArray, progressCallback = null) {
    const info = {
      taskQueue: [],
      results: [],
      addingTasks: false,
      postponed: false,
      runningWorkers: 0,
      index: 0,
      completedTasks: 0,
      progressCallback,
      canceled: false
    };
    this.runInfo.push(info);
    info.index = this.runInfo.length - 1;
    return {
      promise: new Promise((resolve, reject) => {
        info.resolve = resolve;
        info.reject = reject;
        info.results = new Array(taskArgsArray.length);
        info.completedTasks = 0;
        info.addingTasks = true;
        taskArgsArray.forEach((taskArg, index2) => {
          this.addTask(info.index, index2, taskArg);
        });
        info.addingTasks = false;
      }),
      runId: info.index
    };
  }
  terminateWorkers() {
    for (let index2 = 0; index2 < this.workerQueue.length; index2++) {
      const worker = this.workerQueue[index2];
      if (worker != null) {
        worker.terminate();
      }
      this.workerQueue[index2] = null;
    }
  }
  cancel(runId) {
    const info = this.runInfo[runId];
    if (info !== null && info !== void 0) {
      info.canceled = true;
    }
  }
  addTask(infoIndex, resultIndex, taskArgs) {
    const info = this.runInfo[infoIndex];
    if ((info == null ? void 0 : info.canceled) === true) {
      info.reject("Remaining tasks canceled");
      this.clearTask(info.index);
      return;
    }
    if (this.workerQueue.length > 0) {
      const worker = this.workerQueue.pop();
      info.runningWorkers++;
      this.fcn(worker, ...taskArgs).then((_a9) => {
        var _b2 = _a9, { webWorker } = _b2, result = __objRest(_b2, ["webWorker"]);
        this.workerQueue.push(webWorker);
        if (this.runInfo[infoIndex] !== null) {
          info.runningWorkers--;
          info.results[resultIndex] = result;
          info.completedTasks++;
          if (info.progressCallback != null) {
            info.progressCallback(info.completedTasks, info.results.length);
          }
          if (info.taskQueue.length > 0) {
            const reTask = info.taskQueue.shift();
            this.addTask(infoIndex, reTask[0], reTask[1]);
          } else if (!info.addingTasks && info.runningWorkers === 0) {
            const results = info.results;
            info.resolve(results);
            this.clearTask(info.index);
          }
        }
      }).catch((error) => {
        info.reject(error);
        this.clearTask(info.index);
      });
    } else {
      if (info.runningWorkers !== 0 || info.postponed) {
        info.taskQueue.push([resultIndex, taskArgs]);
      } else {
        info.postponed = true;
        setTimeout(() => {
          info.postponed = false;
          this.addTask(info.index, resultIndex, taskArgs);
        }, 50);
      }
    }
  }
  clearTask(clearIndex) {
    this.runInfo[clearIndex].results = [];
    this.runInfo[clearIndex].taskQueue = [];
    this.runInfo[clearIndex].progressCallback = null;
    this.runInfo[clearIndex].canceled = null;
    this.runInfo[clearIndex].reject = () => {
    };
    this.runInfo[clearIndex].resolve = () => {
    };
  }
};
var worker_pool_default = WorkerPool;

// node_modules/itk-wasm/dist/interface-types/interface-types.js
var InterfaceTypes = {
  TextFile: "TextFile",
  BinaryFile: "BinaryFile",
  TextStream: "TextStream",
  BinaryStream: "BinaryStream",
  Image: "Image",
  Mesh: "Mesh",
  PolyData: "PolyData",
  JsonCompatible: "JsonCompatible"
};
var interface_types_default = InterfaceTypes;

// node_modules/comlink/dist/esm/comlink.mjs
var proxyMarker = Symbol("Comlink.proxy");
var createEndpoint = Symbol("Comlink.endpoint");
var releaseProxy = Symbol("Comlink.releaseProxy");
var finalizer = Symbol("Comlink.finalizer");
var throwMarker = Symbol("Comlink.thrown");
var isObject = (val) => typeof val === "object" && val !== null || typeof val === "function";
var proxyTransferHandler = {
  canHandle: (val) => isObject(val) && val[proxyMarker],
  serialize(obj2) {
    const { port1, port2 } = new MessageChannel();
    expose(obj2, port1);
    return [port2, [port2]];
  },
  deserialize(port) {
    port.start();
    return wrap(port);
  }
};
var throwTransferHandler = {
  canHandle: (value) => isObject(value) && throwMarker in value,
  serialize({ value }) {
    let serialized;
    if (value instanceof Error) {
      serialized = {
        isError: true,
        value: {
          message: value.message,
          name: value.name,
          stack: value.stack
        }
      };
    } else {
      serialized = { isError: false, value };
    }
    return [serialized, []];
  },
  deserialize(serialized) {
    if (serialized.isError) {
      throw Object.assign(new Error(serialized.value.message), serialized.value);
    }
    throw serialized.value;
  }
};
var transferHandlers = /* @__PURE__ */ new Map([
  ["proxy", proxyTransferHandler],
  ["throw", throwTransferHandler]
]);
function isAllowedOrigin(allowedOrigins, origin2) {
  for (const allowedOrigin of allowedOrigins) {
    if (origin2 === allowedOrigin || allowedOrigin === "*") {
      return true;
    }
    if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin2)) {
      return true;
    }
  }
  return false;
}
function expose(obj2, ep = globalThis, allowedOrigins = ["*"]) {
  ep.addEventListener("message", function callback(ev) {
    if (!ev || !ev.data) {
      return;
    }
    if (!isAllowedOrigin(allowedOrigins, ev.origin)) {
      console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);
      return;
    }
    const { id, type, path } = Object.assign({ path: [] }, ev.data);
    const argumentList = (ev.data.argumentList || []).map(fromWireValue);
    let returnValue;
    try {
      const parent = path.slice(0, -1).reduce((obj3, prop) => obj3[prop], obj2);
      const rawValue = path.reduce((obj3, prop) => obj3[prop], obj2);
      switch (type) {
        case "GET":
          {
            returnValue = rawValue;
          }
          break;
        case "SET":
          {
            parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);
            returnValue = true;
          }
          break;
        case "APPLY":
          {
            returnValue = rawValue.apply(parent, argumentList);
          }
          break;
        case "CONSTRUCT":
          {
            const value = new rawValue(...argumentList);
            returnValue = proxy2(value);
          }
          break;
        case "ENDPOINT":
          {
            const { port1, port2 } = new MessageChannel();
            expose(obj2, port2);
            returnValue = transfer(port1, [port1]);
          }
          break;
        case "RELEASE":
          {
            returnValue = void 0;
          }
          break;
        default:
          return;
      }
    } catch (value) {
      returnValue = { value, [throwMarker]: 0 };
    }
    Promise.resolve(returnValue).catch((value) => {
      return { value, [throwMarker]: 0 };
    }).then((returnValue2) => {
      const [wireValue, transferables] = toWireValue(returnValue2);
      ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);
      if (type === "RELEASE") {
        ep.removeEventListener("message", callback);
        closeEndPoint(ep);
        if (finalizer in obj2 && typeof obj2[finalizer] === "function") {
          obj2[finalizer]();
        }
      }
    }).catch((error) => {
      const [wireValue, transferables] = toWireValue({
        value: new TypeError("Unserializable return value"),
        [throwMarker]: 0
      });
      ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);
    });
  });
  if (ep.start) {
    ep.start();
  }
}
function isMessagePort(endpoint) {
  return endpoint.constructor.name === "MessagePort";
}
function closeEndPoint(endpoint) {
  if (isMessagePort(endpoint))
    endpoint.close();
}
function wrap(ep, target) {
  return createProxy(ep, [], target);
}
function throwIfProxyReleased(isReleased) {
  if (isReleased) {
    throw new Error("Proxy has been released and is not useable");
  }
}
function releaseEndpoint(ep) {
  return requestResponseMessage(ep, {
    type: "RELEASE"
  }).then(() => {
    closeEndPoint(ep);
  });
}
var proxyCounter = /* @__PURE__ */ new WeakMap();
var proxyFinalizers = "FinalizationRegistry" in globalThis && new FinalizationRegistry((ep) => {
  const newCount = (proxyCounter.get(ep) || 0) - 1;
  proxyCounter.set(ep, newCount);
  if (newCount === 0) {
    releaseEndpoint(ep);
  }
});
function registerProxy(proxy3, ep) {
  const newCount = (proxyCounter.get(ep) || 0) + 1;
  proxyCounter.set(ep, newCount);
  if (proxyFinalizers) {
    proxyFinalizers.register(proxy3, ep, proxy3);
  }
}
function unregisterProxy(proxy3) {
  if (proxyFinalizers) {
    proxyFinalizers.unregister(proxy3);
  }
}
function createProxy(ep, path = [], target = function() {
}) {
  let isProxyReleased = false;
  const proxy3 = new Proxy(target, {
    get(_target, prop) {
      throwIfProxyReleased(isProxyReleased);
      if (prop === releaseProxy) {
        return () => {
          unregisterProxy(proxy3);
          releaseEndpoint(ep);
          isProxyReleased = true;
        };
      }
      if (prop === "then") {
        if (path.length === 0) {
          return { then: () => proxy3 };
        }
        const r9 = requestResponseMessage(ep, {
          type: "GET",
          path: path.map((p3) => p3.toString())
        }).then(fromWireValue);
        return r9.then.bind(r9);
      }
      return createProxy(ep, [...path, prop]);
    },
    set(_target, prop, rawValue) {
      throwIfProxyReleased(isProxyReleased);
      const [value, transferables] = toWireValue(rawValue);
      return requestResponseMessage(ep, {
        type: "SET",
        path: [...path, prop].map((p3) => p3.toString()),
        value
      }, transferables).then(fromWireValue);
    },
    apply(_target, _thisArg, rawArgumentList) {
      throwIfProxyReleased(isProxyReleased);
      const last = path[path.length - 1];
      if (last === createEndpoint) {
        return requestResponseMessage(ep, {
          type: "ENDPOINT"
        }).then(fromWireValue);
      }
      if (last === "bind") {
        return createProxy(ep, path.slice(0, -1));
      }
      const [argumentList, transferables] = processArguments(rawArgumentList);
      return requestResponseMessage(ep, {
        type: "APPLY",
        path: path.map((p3) => p3.toString()),
        argumentList
      }, transferables).then(fromWireValue);
    },
    construct(_target, rawArgumentList) {
      throwIfProxyReleased(isProxyReleased);
      const [argumentList, transferables] = processArguments(rawArgumentList);
      return requestResponseMessage(ep, {
        type: "CONSTRUCT",
        path: path.map((p3) => p3.toString()),
        argumentList
      }, transferables).then(fromWireValue);
    }
  });
  registerProxy(proxy3, ep);
  return proxy3;
}
function myFlat(arr) {
  return Array.prototype.concat.apply([], arr);
}
function processArguments(argumentList) {
  const processed = argumentList.map(toWireValue);
  return [processed.map((v2) => v2[0]), myFlat(processed.map((v2) => v2[1]))];
}
var transferCache = /* @__PURE__ */ new WeakMap();
function transfer(obj2, transfers) {
  transferCache.set(obj2, transfers);
  return obj2;
}
function proxy2(obj2) {
  return Object.assign(obj2, { [proxyMarker]: true });
}
function toWireValue(value) {
  for (const [name, handler] of transferHandlers) {
    if (handler.canHandle(value)) {
      const [serializedValue, transferables] = handler.serialize(value);
      return [
        {
          type: "HANDLER",
          name,
          value: serializedValue
        },
        transferables
      ];
    }
  }
  return [
    {
      type: "RAW",
      value
    },
    transferCache.get(value) || []
  ];
}
function fromWireValue(value) {
  switch (value.type) {
    case "HANDLER":
      return transferHandlers.get(value.name).deserialize(value.value);
    case "RAW":
      return value.value;
  }
}
function requestResponseMessage(ep, msg, transfers) {
  return new Promise((resolve) => {
    const id = generateUUID();
    ep.addEventListener("message", function l5(ev) {
      if (!ev.data || !ev.data.id || ev.data.id !== id) {
        return;
      }
      ep.removeEventListener("message", l5);
      resolve(ev.data);
    });
    if (ep.start) {
      ep.start();
    }
    ep.postMessage(Object.assign({ id }, msg), transfers);
  });
}
function generateUUID() {
  return new Array(4).fill(0).map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16)).join("-");
}

// node_modules/axios/lib/helpers/bind.js
function bind(fn, thisArg) {
  return function wrap2() {
    return fn.apply(thisArg, arguments);
  };
}

// node_modules/axios/lib/utils.js
var { toString } = Object.prototype;
var { getPrototypeOf } = Object;
var kindOf = /* @__PURE__ */ ((cache2) => (thing) => {
  const str6 = toString.call(thing);
  return cache2[str6] || (cache2[str6] = str6.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
var kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type;
};
var typeOfTest = (type) => (thing) => typeof thing === type;
var { isArray: isArray2 } = Array;
var isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
var isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
var isString = typeOfTest("string");
var isFunction = typeOfTest("function");
var isNumber = typeOfTest("number");
var isObject2 = (thing) => thing !== null && typeof thing === "object";
var isBoolean = (thing) => thing === true || thing === false;
var isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype3 = getPrototypeOf(val);
  return (prototype3 === null || prototype3 === Object.prototype || Object.getPrototypeOf(prototype3) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
var isDate = kindOfTest("Date");
var isFile = kindOfTest("File");
var isBlob = kindOfTest("Blob");
var isFileList = kindOfTest("FileList");
var isStream = (val) => isObject2(val) && isFunction(val.pipe);
var isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
};
var isURLSearchParams = kindOfTest("URLSearchParams");
var [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
var trim = (str6) => str6.trim ? str6.trim() : str6.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach3(obj2, fn, { allOwnKeys = false } = {}) {
  if (obj2 === null || typeof obj2 === "undefined") {
    return;
  }
  let i6;
  let l5;
  if (typeof obj2 !== "object") {
    obj2 = [obj2];
  }
  if (isArray2(obj2)) {
    for (i6 = 0, l5 = obj2.length; i6 < l5; i6++) {
      fn.call(null, obj2[i6], i6, obj2);
    }
  } else {
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj2) : Object.keys(obj2);
    const len4 = keys.length;
    let key;
    for (i6 = 0; i6 < len4; i6++) {
      key = keys[i6];
      fn.call(null, obj2[key], key, obj2);
    }
  }
}
function findKey(obj2, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj2);
  let i6 = keys.length;
  let _key;
  while (i6-- > 0) {
    _key = keys[i6];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
var _global = (() => {
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
var isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray2(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i6 = 0, l5 = arguments.length; i6 < l5; i6++) {
    arguments[i6] && forEach3(arguments[i6], assignValue);
  }
  return result;
}
var extend109 = (a4, b3, thisArg, { allOwnKeys } = {}) => {
  forEach3(b3, (val, key) => {
    if (thisArg && isFunction(val)) {
      a4[key] = bind(val, thisArg);
    } else {
      a4[key] = val;
    }
  }, { allOwnKeys });
  return a4;
};
var stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
var inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
var toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
  let props;
  let i6;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null) return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i6 = props.length;
    while (i6-- > 0) {
      prop = props[i6];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
var endsWith = (str6, searchString, position) => {
  str6 = String(str6);
  if (position === void 0 || position > str6.length) {
    position = str6.length;
  }
  position -= searchString.length;
  const lastIndex = str6.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
var toArray2 = (thing) => {
  if (!thing) return null;
  if (isArray2(thing)) return thing;
  let i6 = thing.length;
  if (!isNumber(i6)) return null;
  const arr = new Array(i6);
  while (i6-- > 0) {
    arr[i6] = thing[i6];
  }
  return arr;
};
var isTypedArray2 = /* @__PURE__ */ ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
var forEachEntry = (obj2, fn) => {
  const generator = obj2 && obj2[Symbol.iterator];
  const iterator = generator.call(obj2);
  let result;
  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj2, pair[0], pair[1]);
  }
};
var matchAll = (regExp, str6) => {
  let matches2;
  const arr = [];
  while ((matches2 = regExp.exec(str6)) !== null) {
    arr.push(matches2);
  }
  return arr;
};
var isHTMLForm = kindOfTest("HTMLFormElement");
var toCamelCase = (str6) => {
  return str6.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer(m3, p1, p22) {
      return p1.toUpperCase() + p22;
    }
  );
};
var hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj2, prop) => hasOwnProperty2.call(obj2, prop))(Object.prototype);
var isRegExp = kindOfTest("RegExp");
var reduceDescriptors = (obj2, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj2);
  const reducedDescriptors = {};
  forEach3(descriptors2, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj2)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });
  Object.defineProperties(obj2, reducedDescriptors);
};
var freezeMethods = (obj2) => {
  reduceDescriptors(obj2, (descriptor, name) => {
    if (isFunction(obj2) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
      return false;
    }
    const value = obj2[name];
    if (!isFunction(value)) return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name + "'");
      };
    }
  });
};
var toObjectSet = (arrayOrString, delimiter) => {
  const obj2 = {};
  const define2 = (arr) => {
    arr.forEach((value) => {
      obj2[value] = true;
    });
  };
  isArray2(arrayOrString) ? define2(arrayOrString) : define2(String(arrayOrString).split(delimiter));
  return obj2;
};
var noop = () => {
};
var toFiniteNumber = (value, defaultValue2) => {
  return value != null && Number.isFinite(value = +value) ? value : defaultValue2;
};
var ALPHA = "abcdefghijklmnopqrstuvwxyz";
var DIGIT = "0123456789";
var ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
var generateString = (size3 = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str6 = "";
  const { length: length4 } = alphabet;
  while (size3--) {
    str6 += alphabet[Math.random() * length4 | 0];
  }
  return str6;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
}
var toJSONObject = (obj2) => {
  const stack = new Array(10);
  const visit = (source, i6) => {
    if (isObject2(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i6] = source;
        const target = isArray2(source) ? [] : {};
        forEach3(source, (value, key) => {
          const reducedValue = visit(value, i6 + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i6] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj2, 0);
};
var isAsyncFn = kindOfTest("AsyncFunction");
var isThenable = (thing) => thing && (isObject2(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
var utils_default = {
  isArray: isArray2,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject: isObject2,
  isPlainObject,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray: isTypedArray2,
  isFileList,
  forEach: forEach3,
  merge,
  extend: extend109,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray: toArray2,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable
};

// node_modules/axios/lib/core/AxiosError.js
function AxiosError(message, code, config, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  response && (this.response = response);
}
utils_default.inherits(AxiosError, Error, {
  toJSON: function toJSON2() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils_default.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
var prototype = AxiosError.prototype;
var descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code) => {
  descriptors[code] = { value: code };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, "isAxiosError", { value: true });
AxiosError.from = (error, code, config, request, response, customProps) => {
  const axiosError = Object.create(prototype);
  utils_default.toFlatObject(error, axiosError, function filter2(obj2) {
    return obj2 !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError.call(axiosError, error.message, code, config, request, response);
  axiosError.cause = error;
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
var AxiosError_default = AxiosError;

// node_modules/axios/lib/helpers/null.js
var null_default = null;

// node_modules/axios/lib/helpers/toFormData.js
function isVisitable(thing) {
  return utils_default.isPlainObject(thing) || utils_default.isArray(thing);
}
function removeBrackets(key) {
  return utils_default.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path, key, dots) {
  if (!path) return key;
  return path.concat(key).map(function each(token, i6) {
    token = removeBrackets(token);
    return !dots && i6 ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils_default.isArray(arr) && !arr.some(isVisitable);
}
var predicates = utils_default.toFlatObject(utils_default, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData(obj2, formData, options) {
  if (!utils_default.isObject(obj2)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new (null_default || FormData)();
  options = utils_default.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils_default.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils_default.isSpecCompliantForm(formData);
  if (!utils_default.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null) return "";
    if (utils_default.isDate(value)) {
      return value.toISOString();
    }
    if (!useBlob && utils_default.isBlob(value)) {
      throw new AxiosError_default("Blob is not supported. Use a Buffer instead.");
    }
    if (utils_default.isArrayBuffer(value) || utils_default.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path) {
    let arr = value;
    if (value && !path && typeof value === "object") {
      if (utils_default.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils_default.isArray(value) && isFlatArray(value) || (utils_default.isFileList(value) || utils_default.endsWith(key, "[]")) && (arr = utils_default.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(function each(el, index2) {
          !(utils_default.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index2, dots) : indexes === null ? key : key + "[]",
            convertValue(el)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path) {
    if (utils_default.isUndefined(value)) return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path.join("."));
    }
    stack.push(value);
    utils_default.forEach(value, function each(el, key) {
      const result = !(utils_default.isUndefined(el) || el === null) && visitor.call(
        formData,
        el,
        utils_default.isString(key) ? key.trim() : key,
        path,
        exposedHelpers
      );
      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils_default.isObject(obj2)) {
    throw new TypeError("data must be an object");
  }
  build(obj2);
  return formData;
}
var toFormData_default = toFormData;

// node_modules/axios/lib/helpers/AxiosURLSearchParams.js
function encode(str6) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str6).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData_default(params, this, options);
}
var prototype2 = AxiosURLSearchParams.prototype;
prototype2.append = function append(name, value) {
  this._pairs.push([name, value]);
};
prototype2.toString = function toString2(encoder2) {
  const _encode = encoder2 ? function(value) {
    return encoder2.call(this, value, encode);
  } : encode;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
var AxiosURLSearchParams_default = AxiosURLSearchParams;

// node_modules/axios/lib/helpers/buildURL.js
function encode2(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url, params, options) {
  if (!params) {
    return url;
  }
  const _encode = options && options.encode || encode2;
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils_default.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams_default(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}

// node_modules/axios/lib/core/InterceptorManager.js
var InterceptorManager = class {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils_default.forEach(this.handlers, function forEachHandler(h5) {
      if (h5 !== null) {
        fn(h5);
      }
    });
  }
};
var InterceptorManager_default = InterceptorManager;

// node_modules/axios/lib/defaults/transitional.js
var transitional_default = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};

// node_modules/axios/lib/platform/browser/classes/URLSearchParams.js
var URLSearchParams_default = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams_default;

// node_modules/axios/lib/platform/browser/classes/FormData.js
var FormData_default = typeof FormData !== "undefined" ? FormData : null;

// node_modules/axios/lib/platform/browser/classes/Blob.js
var Blob_default = typeof Blob !== "undefined" ? Blob : null;

// node_modules/axios/lib/platform/browser/index.js
var browser_default = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams_default,
    FormData: FormData_default,
    Blob: Blob_default
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
};

// node_modules/axios/lib/platform/common/utils.js
var utils_exports = {};
__export(utils_exports, {
  hasBrowserEnv: () => hasBrowserEnv,
  hasStandardBrowserEnv: () => hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv: () => hasStandardBrowserWebWorkerEnv,
  origin: () => origin
});
var hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
var hasStandardBrowserEnv = ((product) => {
  return hasBrowserEnv && ["ReactNative", "NativeScript", "NS"].indexOf(product) < 0;
})(typeof navigator !== "undefined" && navigator.product);
var hasStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
var origin = hasBrowserEnv && window.location.href || "http://localhost";

// node_modules/axios/lib/platform/index.js
var platform_default = __spreadValues(__spreadValues({}, utils_exports), browser_default);

// node_modules/axios/lib/helpers/toURLEncodedForm.js
function toURLEncodedForm(data, options) {
  return toFormData_default(data, new platform_default.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path, helpers) {
      if (platform_default.isNode && utils_default.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}

// node_modules/axios/lib/helpers/formDataToJSON.js
function parsePropPath(name) {
  return utils_default.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
}
function arrayToObject(arr) {
  const obj2 = {};
  const keys = Object.keys(arr);
  let i6;
  const len4 = keys.length;
  let key;
  for (i6 = 0; i6 < len4; i6++) {
    key = keys[i6];
    obj2[key] = arr[key];
  }
  return obj2;
}
function formDataToJSON(formData) {
  function buildPath(path, value, target, index2) {
    let name = path[index2++];
    if (name === "__proto__") return true;
    const isNumericKey = Number.isFinite(+name);
    const isLast = index2 >= path.length;
    name = !name && utils_default.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils_default.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }
      return !isNumericKey;
    }
    if (!target[name] || !utils_default.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path, value, target[name], index2);
    if (result && utils_default.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey;
  }
  if (utils_default.isFormData(formData) && utils_default.isFunction(formData.entries)) {
    const obj2 = {};
    utils_default.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj2, 0);
    });
    return obj2;
  }
  return null;
}
var formDataToJSON_default = formDataToJSON;

// node_modules/axios/lib/defaults/index.js
function stringifySafely(rawValue, parser2, encoder2) {
  if (utils_default.isString(rawValue)) {
    try {
      (parser2 || JSON.parse)(rawValue);
      return utils_default.trim(rawValue);
    } catch (e13) {
      if (e13.name !== "SyntaxError") {
        throw e13;
      }
    }
  }
  return (encoder2 || JSON.stringify)(rawValue);
}
var defaults = {
  transitional: transitional_default,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils_default.isObject(data);
    if (isObjectPayload && utils_default.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils_default.isFormData(data);
    if (isFormData2) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON_default(data)) : data;
    }
    if (utils_default.isArrayBuffer(data) || utils_default.isBuffer(data) || utils_default.isStream(data) || utils_default.isFile(data) || utils_default.isBlob(data) || utils_default.isReadableStream(data)) {
      return data;
    }
    if (utils_default.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils_default.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils_default.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData_default(
          isFileList2 ? { "files[]": data } : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional2 = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (utils_default.isResponse(data) || utils_default.isReadableStream(data)) {
      return data;
    }
    if (data && utils_default.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e13) {
        if (strictJSONParsing) {
          if (e13.name === "SyntaxError") {
            throw AxiosError_default.from(e13, AxiosError_default.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e13;
        }
      }
    }
    return data;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform_default.classes.FormData,
    Blob: platform_default.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils_default.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults.headers[method] = {};
});
var defaults_default = defaults;

// node_modules/axios/lib/helpers/parseHeaders.js
var ignoreDuplicateOf = utils_default.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
var parseHeaders_default = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i6;
  rawHeaders && rawHeaders.split("\n").forEach(function parser2(line) {
    i6 = line.indexOf(":");
    key = line.substring(0, i6).trim().toLowerCase();
    val = line.substring(i6 + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};

// node_modules/axios/lib/core/AxiosHeaders.js
var $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils_default.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str6) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str6)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
var isValidHeaderName = (str6) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str6.trim());
function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
  if (utils_default.isFunction(filter2)) {
    return filter2.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils_default.isString(value)) return;
  if (utils_default.isString(filter2)) {
    return value.indexOf(filter2) !== -1;
  }
  if (utils_default.isRegExp(filter2)) {
    return filter2.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w2, char, str6) => {
    return char.toUpperCase() + str6;
  });
}
function buildAccessors(obj2, header) {
  const accessorName = utils_default.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj2, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
var AxiosHeaders = class {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils_default.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils_default.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils_default.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils_default.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders_default(header), valueOrRewrite);
    } else if (utils_default.isHeaders(header)) {
      for (const [key, value] of header.entries()) {
        setHeader(value, key, rewrite);
      }
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser2) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser2) {
          return value;
        }
        if (parser2 === true) {
          return parseTokens(value);
        }
        if (utils_default.isFunction(parser2)) {
          return parser2.call(this, value, key);
        }
        if (utils_default.isRegExp(parser2)) {
          return parser2.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils_default.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils_default.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys = Object.keys(this);
    let i6 = keys.length;
    let deleted = false;
    while (i6--) {
      const key = keys[i6];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format) {
    const self2 = this;
    const headers = {};
    utils_default.forEach(this, (value, header) => {
      const key = utils_default.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj2 = /* @__PURE__ */ Object.create(null);
    utils_default.forEach(this, (value, header) => {
      value != null && value !== false && (obj2[header] = asStrings && utils_default.isArray(value) ? value.join(", ") : value);
    });
    return obj2;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed = new this(first);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype3 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype3, _header);
        accessors[lHeader] = true;
      }
    }
    utils_default.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
};
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils_default.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1);
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils_default.freezeMethods(AxiosHeaders);
var AxiosHeaders_default = AxiosHeaders;

// node_modules/axios/lib/core/transformData.js
function transformData(fns, response) {
  const config = this || defaults_default;
  const context = response || config;
  const headers = AxiosHeaders_default.from(context.headers);
  let data = context.data;
  utils_default.forEach(fns, function transform2(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}

// node_modules/axios/lib/cancel/isCancel.js
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}

// node_modules/axios/lib/cancel/CanceledError.js
function CanceledError(message, config, request) {
  AxiosError_default.call(this, message == null ? "canceled" : message, AxiosError_default.ERR_CANCELED, config, request);
  this.name = "CanceledError";
}
utils_default.inherits(CanceledError, AxiosError_default, {
  __CANCEL__: true
});
var CanceledError_default = CanceledError;

// node_modules/axios/lib/core/settle.js
function settle(resolve, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError_default(
      "Request failed with status code " + response.status,
      [AxiosError_default.ERR_BAD_REQUEST, AxiosError_default.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}

// node_modules/axios/lib/helpers/parseProtocol.js
function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || "";
}

// node_modules/axios/lib/helpers/speedometer.js
function speedometer(samplesCount, min5) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min5 = min5 !== void 0 ? min5 : 1e3;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now;
    let i6 = tail;
    let bytesCount = 0;
    while (i6 !== head) {
      bytesCount += bytes[i6++];
      i6 = i6 % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min5) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
var speedometer_default = speedometer;

// node_modules/axios/lib/helpers/throttle.js
function throttle2(fn, freq) {
  let timestamp = 0;
  const threshold = 1e3 / freq;
  let timer = null;
  return function throttled() {
    const force = this === true;
    const now = Date.now();
    if (force || now - timestamp > threshold) {
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }
      timestamp = now;
      return fn.apply(null, arguments);
    }
    if (!timer) {
      timer = setTimeout(() => {
        timer = null;
        timestamp = Date.now();
        return fn.apply(null, arguments);
      }, threshold - (now - timestamp));
    }
  };
}
var throttle_default = throttle2;

// node_modules/axios/lib/helpers/progressEventReducer.js
var progressEventReducer_default = (listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = speedometer_default(50, 250);
  return throttle_default((e13) => {
    const loaded = e13.loaded;
    const total = e13.lengthComputable ? e13.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e13,
      lengthComputable: total != null
    };
    data[isDownloadStream ? "download" : "upload"] = true;
    listener(data);
  }, freq);
};

// node_modules/axios/lib/helpers/isURLSameOrigin.js
var isURLSameOrigin_default = platform_default.hasStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function standardBrowserEnv() {
    const msie = /(msie|trident)/i.test(navigator.userAgent);
    const urlParsingNode = document.createElement("a");
    let originURL;
    function resolveURL(url) {
      let href = url;
      if (msie) {
        urlParsingNode.setAttribute("href", href);
        href = urlParsingNode.href;
      }
      urlParsingNode.setAttribute("href", href);
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
      };
    }
    originURL = resolveURL(window.location.href);
    return function isURLSameOrigin(requestURL) {
      const parsed = utils_default.isString(requestURL) ? resolveURL(requestURL) : requestURL;
      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  /* @__PURE__ */ function nonStandardBrowserEnv() {
    return function isURLSameOrigin() {
      return true;
    };
  }()
);

// node_modules/axios/lib/helpers/cookies.js
var cookies_default = platform_default.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(name, value, expires, path, domain, secure) {
      const cookie = [name + "=" + encodeURIComponent(value)];
      utils_default.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
      utils_default.isString(path) && cookie.push("path=" + path);
      utils_default.isString(domain) && cookie.push("domain=" + domain);
      secure === true && cookie.push("secure");
      document.cookie = cookie.join("; ");
    },
    read(name) {
      const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
      return match ? decodeURIComponent(match[3]) : null;
    },
    remove(name) {
      this.write(name, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);

// node_modules/axios/lib/helpers/isAbsoluteURL.js
function isAbsoluteURL(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}

// node_modules/axios/lib/helpers/combineURLs.js
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}

// node_modules/axios/lib/core/buildFullPath.js
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}

// node_modules/axios/lib/core/mergeConfig.js
var headersToObject = (thing) => thing instanceof AxiosHeaders_default ? __spreadValues({}, thing) : thing;
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config = {};
  function getMergedValue(target, source, caseless) {
    if (utils_default.isPlainObject(target) && utils_default.isPlainObject(source)) {
      return utils_default.merge.call({ caseless }, target, source);
    } else if (utils_default.isPlainObject(source)) {
      return utils_default.merge({}, source);
    } else if (utils_default.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a4, b3, caseless) {
    if (!utils_default.isUndefined(b3)) {
      return getMergedValue(a4, b3, caseless);
    } else if (!utils_default.isUndefined(a4)) {
      return getMergedValue(void 0, a4, caseless);
    }
  }
  function valueFromConfig2(a4, b3) {
    if (!utils_default.isUndefined(b3)) {
      return getMergedValue(void 0, b3);
    }
  }
  function defaultToConfig2(a4, b3) {
    if (!utils_default.isUndefined(b3)) {
      return getMergedValue(void 0, b3);
    } else if (!utils_default.isUndefined(a4)) {
      return getMergedValue(void 0, a4);
    }
  }
  function mergeDirectKeys(a4, b3, prop) {
    if (prop in config2) {
      return getMergedValue(a4, b3);
    } else if (prop in config1) {
      return getMergedValue(void 0, a4);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a4, b3) => mergeDeepProperties(headersToObject(a4), headersToObject(b3), true)
  };
  utils_default.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils_default.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
}

// node_modules/axios/lib/helpers/resolveConfig.js
var resolveConfig_default = (config) => {
  const newConfig = mergeConfig({}, config);
  let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
  newConfig.headers = headers = AxiosHeaders_default.from(headers);
  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url), config.params, config.paramsSerializer);
  if (auth) {
    headers.set(
      "Authorization",
      "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
    );
  }
  let contentType;
  if (utils_default.isFormData(data)) {
    if (platform_default.hasStandardBrowserEnv || platform_default.hasStandardBrowserWebWorkerEnv) {
      headers.setContentType(void 0);
    } else if ((contentType = headers.getContentType()) !== false) {
      const [type, ...tokens] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
      headers.setContentType([type || "multipart/form-data", ...tokens].join("; "));
    }
  }
  if (platform_default.hasStandardBrowserEnv) {
    withXSRFToken && utils_default.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
    if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin_default(newConfig.url)) {
      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies_default.read(xsrfCookieName);
      if (xsrfValue) {
        headers.set(xsrfHeaderName, xsrfValue);
      }
    }
  }
  return newConfig;
};

// node_modules/axios/lib/adapters/xhr.js
var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
var xhr_default = isXHRAdapterSupported && function(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    const _config = resolveConfig_default(config);
    let requestData = _config.data;
    const requestHeaders = AxiosHeaders_default.from(_config.headers).normalize();
    let { responseType } = _config;
    let onCanceled;
    function done() {
      if (_config.cancelToken) {
        _config.cancelToken.unsubscribe(onCanceled);
      }
      if (_config.signal) {
        _config.signal.removeEventListener("abort", onCanceled);
      }
    }
    let request = new XMLHttpRequest();
    request.open(_config.method.toUpperCase(), _config.url, true);
    request.timeout = _config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders_default.from(
        "getAllResponseHeaders" in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };
      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request = null;
    }
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError_default("Request aborted", AxiosError_default.ECONNABORTED, _config, request));
      request = null;
    };
    request.onerror = function handleError() {
      reject(new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, _config, request));
      request = null;
    };
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = _config.transitional || transitional_default;
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject(new AxiosError_default(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED,
        _config,
        request
      ));
      request = null;
    };
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils_default.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }
    if (!utils_default.isUndefined(_config.withCredentials)) {
      request.withCredentials = !!_config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = _config.responseType;
    }
    if (typeof _config.onDownloadProgress === "function") {
      request.addEventListener("progress", progressEventReducer_default(_config.onDownloadProgress, true));
    }
    if (typeof _config.onUploadProgress === "function" && request.upload) {
      request.upload.addEventListener("progress", progressEventReducer_default(_config.onUploadProgress));
    }
    if (_config.cancelToken || _config.signal) {
      onCanceled = (cancel2) => {
        if (!request) {
          return;
        }
        reject(!cancel2 || cancel2.type ? new CanceledError_default(null, config, request) : cancel2);
        request.abort();
        request = null;
      };
      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(_config.url);
    if (protocol && platform_default.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError_default("Unsupported protocol " + protocol + ":", AxiosError_default.ERR_BAD_REQUEST, config));
      return;
    }
    request.send(requestData || null);
  });
};

// node_modules/axios/lib/helpers/composeSignals.js
var composeSignals = (signals, timeout) => {
  let controller = new AbortController();
  let aborted;
  const onabort = function(cancel2) {
    if (!aborted) {
      aborted = true;
      unsubscribe();
      const err = cancel2 instanceof Error ? cancel2 : this.reason;
      controller.abort(err instanceof AxiosError_default ? err : new CanceledError_default(err instanceof Error ? err.message : err));
    }
  };
  let timer = timeout && setTimeout(() => {
    onabort(new AxiosError_default(`timeout ${timeout} of ms exceeded`, AxiosError_default.ETIMEDOUT));
  }, timeout);
  const unsubscribe = () => {
    if (signals) {
      timer && clearTimeout(timer);
      timer = null;
      signals.forEach((signal2) => {
        signal2 && (signal2.removeEventListener ? signal2.removeEventListener("abort", onabort) : signal2.unsubscribe(onabort));
      });
      signals = null;
    }
  };
  signals.forEach((signal2) => signal2 && signal2.addEventListener && signal2.addEventListener("abort", onabort));
  const { signal } = controller;
  signal.unsubscribe = unsubscribe;
  return [signal, () => {
    timer && clearTimeout(timer);
    timer = null;
  }];
};
var composeSignals_default = composeSignals;

// node_modules/axios/lib/helpers/trackStream.js
var streamChunk = function* (chunk2, chunkSize) {
  let len4 = chunk2.byteLength;
  if (!chunkSize || len4 < chunkSize) {
    yield chunk2;
    return;
  }
  let pos = 0;
  let end;
  while (pos < len4) {
    end = pos + chunkSize;
    yield chunk2.slice(pos, end);
    pos = end;
  }
};
var readBytes = function(iterable, chunkSize, encode3) {
  return __asyncGenerator(this, null, function* () {
    try {
      for (var iter = __forAwait(iterable), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
        const chunk2 = temp.value;
        yield* __yieldStar(streamChunk(ArrayBuffer.isView(chunk2) ? chunk2 : yield new __await(encode3(String(chunk2))), chunkSize));
      }
    } catch (temp) {
      error = [temp];
    } finally {
      try {
        more && (temp = iter.return) && (yield new __await(temp.call(iter)));
      } finally {
        if (error)
          throw error[0];
      }
    }
  });
};
var trackStream = (stream, chunkSize, onProgress, onFinish, encode3) => {
  const iterator = readBytes(stream, chunkSize, encode3);
  let bytes = 0;
  return new ReadableStream({
    type: "bytes",
    pull(controller) {
      return __async(this, null, function* () {
        const { done, value } = yield iterator.next();
        if (done) {
          controller.close();
          onFinish();
          return;
        }
        let len4 = value.byteLength;
        onProgress && onProgress(bytes += len4);
        controller.enqueue(new Uint8Array(value));
      });
    },
    cancel(reason) {
      onFinish(reason);
      return iterator.return();
    }
  }, {
    highWaterMark: 2
  });
};

// node_modules/axios/lib/adapters/fetch.js
var fetchProgressDecorator = (total, fn) => {
  const lengthComputable = total != null;
  return (loaded) => setTimeout(() => fn({
    lengthComputable,
    total,
    loaded
  }));
};
var isFetchSupported = typeof fetch === "function" && typeof Request === "function" && typeof Response === "function";
var isReadableStreamSupported = isFetchSupported && typeof ReadableStream === "function";
var encodeText = isFetchSupported && (typeof TextEncoder === "function" ? /* @__PURE__ */ ((encoder2) => (str6) => encoder2.encode(str6))(new TextEncoder()) : (str6) => __async(void 0, null, function* () {
  return new Uint8Array(yield new Response(str6).arrayBuffer());
}));
var supportsRequestStream = isReadableStreamSupported && (() => {
  let duplexAccessed = false;
  const hasContentType = new Request(platform_default.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      duplexAccessed = true;
      return "half";
    }
  }).headers.has("Content-Type");
  return duplexAccessed && !hasContentType;
})();
var DEFAULT_CHUNK_SIZE = 64 * 1024;
var supportsResponseStream = isReadableStreamSupported && !!(() => {
  try {
    return utils_default.isReadableStream(new Response("").body);
  } catch (err) {
  }
})();
var resolvers = {
  stream: supportsResponseStream && ((res) => res.body)
};
isFetchSupported && ((res) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type) => {
    !resolvers[type] && (resolvers[type] = utils_default.isFunction(res[type]) ? (res2) => res2[type]() : (_2, config) => {
      throw new AxiosError_default(`Response type '${type}' is not supported`, AxiosError_default.ERR_NOT_SUPPORT, config);
    });
  });
})(new Response());
var getBodyLength = (body) => __async(void 0, null, function* () {
  if (body == null) {
    return 0;
  }
  if (utils_default.isBlob(body)) {
    return body.size;
  }
  if (utils_default.isSpecCompliantForm(body)) {
    return (yield new Request(body).arrayBuffer()).byteLength;
  }
  if (utils_default.isArrayBufferView(body)) {
    return body.byteLength;
  }
  if (utils_default.isURLSearchParams(body)) {
    body = body + "";
  }
  if (utils_default.isString(body)) {
    return (yield encodeText(body)).byteLength;
  }
});
var resolveBodyLength = (headers, body) => __async(void 0, null, function* () {
  const length4 = utils_default.toFiniteNumber(headers.getContentLength());
  return length4 == null ? getBodyLength(body) : length4;
});
var fetch_default = isFetchSupported && ((config) => __async(void 0, null, function* () {
  let {
    url,
    method,
    data,
    signal,
    cancelToken,
    timeout,
    onDownloadProgress,
    onUploadProgress,
    responseType,
    headers,
    withCredentials = "same-origin",
    fetchOptions
  } = resolveConfig_default(config);
  responseType = responseType ? (responseType + "").toLowerCase() : "text";
  let [composedSignal, stopTimeout] = signal || cancelToken || timeout ? composeSignals_default([signal, cancelToken], timeout) : [];
  let finished, request;
  const onFinish = () => {
    !finished && setTimeout(() => {
      composedSignal && composedSignal.unsubscribe();
    });
    finished = true;
  };
  let requestContentLength;
  try {
    if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = yield resolveBodyLength(headers, data)) !== 0) {
      let _request = new Request(url, {
        method: "POST",
        body: data,
        duplex: "half"
      });
      let contentTypeHeader;
      if (utils_default.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
        headers.setContentType(contentTypeHeader);
      }
      if (_request.body) {
        data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, fetchProgressDecorator(
          requestContentLength,
          progressEventReducer_default(onUploadProgress)
        ), null, encodeText);
      }
    }
    if (!utils_default.isString(withCredentials)) {
      withCredentials = withCredentials ? "cors" : "omit";
    }
    request = new Request(url, __spreadProps(__spreadValues({}, fetchOptions), {
      signal: composedSignal,
      method: method.toUpperCase(),
      headers: headers.normalize().toJSON(),
      body: data,
      duplex: "half",
      withCredentials
    }));
    let response = yield fetch(request);
    const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
    if (supportsResponseStream && (onDownloadProgress || isStreamResponse)) {
      const options = {};
      ["status", "statusText", "headers"].forEach((prop) => {
        options[prop] = response[prop];
      });
      const responseContentLength = utils_default.toFiniteNumber(response.headers.get("content-length"));
      response = new Response(
        trackStream(response.body, DEFAULT_CHUNK_SIZE, onDownloadProgress && fetchProgressDecorator(
          responseContentLength,
          progressEventReducer_default(onDownloadProgress, true)
        ), isStreamResponse && onFinish, encodeText),
        options
      );
    }
    responseType = responseType || "text";
    let responseData = yield resolvers[utils_default.findKey(resolvers, responseType) || "text"](response, config);
    !isStreamResponse && onFinish();
    stopTimeout && stopTimeout();
    return yield new Promise((resolve, reject) => {
      settle(resolve, reject, {
        data: responseData,
        headers: AxiosHeaders_default.from(response.headers),
        status: response.status,
        statusText: response.statusText,
        config,
        request
      });
    });
  } catch (err) {
    onFinish();
    if (err && err.name === "TypeError" && /fetch/i.test(err.message)) {
      throw Object.assign(
        new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config, request),
        {
          cause: err.cause || err
        }
      );
    }
    throw AxiosError_default.from(err, err && err.code, config, request);
  }
}));

// node_modules/axios/lib/adapters/adapters.js
var knownAdapters = {
  http: null_default,
  xhr: xhr_default,
  fetch: fetch_default
};
utils_default.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value });
    } catch (e13) {
    }
    Object.defineProperty(fn, "adapterName", { value });
  }
});
var renderReason = (reason) => `- ${reason}`;
var isResolvedHandle = (adapter) => utils_default.isFunction(adapter) || adapter === null || adapter === false;
var adapters_default = {
  getAdapter: (adapters) => {
    adapters = utils_default.isArray(adapters) ? adapters : [adapters];
    const { length: length4 } = adapters;
    let nameOrAdapter;
    let adapter;
    const rejectedReasons = {};
    for (let i6 = 0; i6 < length4; i6++) {
      nameOrAdapter = adapters[i6];
      let id;
      adapter = nameOrAdapter;
      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
        if (adapter === void 0) {
          throw new AxiosError_default(`Unknown adapter '${id}'`);
        }
      }
      if (adapter) {
        break;
      }
      rejectedReasons[id || "#" + i6] = adapter;
    }
    if (!adapter) {
      const reasons = Object.entries(rejectedReasons).map(
        ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
      );
      let s9 = length4 ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
      throw new AxiosError_default(
        `There is no suitable adapter to dispatch the request ` + s9,
        "ERR_NOT_SUPPORT"
      );
    }
    return adapter;
  },
  adapters: knownAdapters
};

// node_modules/axios/lib/core/dispatchRequest.js
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError_default(null, config);
  }
}
function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = AxiosHeaders_default.from(config.headers);
  config.data = transformData.call(
    config,
    config.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config.method) !== -1) {
    config.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters_default.getAdapter(config.adapter || defaults_default.adapter);
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );
    response.headers = AxiosHeaders_default.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders_default.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}

// node_modules/axios/lib/env/data.js
var VERSION = "1.7.2";

// node_modules/axios/lib/helpers/validator.js
var validators = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i6) => {
  validators[type] = function validator(thing) {
    return typeof thing === type || "a" + (i6 < 1 ? "n " : " ") + type;
  };
});
var deprecatedWarnings = {};
validators.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts) => {
    if (validator === false) {
      throw new AxiosError_default(
        formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
        AxiosError_default.ERR_DEPRECATED
      );
    }
    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version + " and will be removed in the near future"
        )
      );
    }
    return validator ? validator(value, opt, opts) : true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError_default("options must be an object", AxiosError_default.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i6 = keys.length;
  while (i6-- > 0) {
    const opt = keys[i6];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === void 0 || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError_default("option " + opt + " must be " + result, AxiosError_default.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError_default("Unknown option " + opt, AxiosError_default.ERR_BAD_OPTION);
    }
  }
}
var validator_default = {
  assertOptions,
  validators
};

// node_modules/axios/lib/core/Axios.js
var validators2 = validator_default.validators;
var Axios = class {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager_default(),
      response: new InterceptorManager_default()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  request(configOrUrl, config) {
    return __async(this, null, function* () {
      try {
        return yield this._request(configOrUrl, config);
      } catch (err) {
        if (err instanceof Error) {
          let dummy;
          Error.captureStackTrace ? Error.captureStackTrace(dummy = {}) : dummy = new Error();
          const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
          try {
            if (!err.stack) {
              err.stack = stack;
            } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
              err.stack += "\n" + stack;
            }
          } catch (e13) {
          }
        }
        throw err;
      }
    });
  }
  _request(configOrUrl, config) {
    if (typeof configOrUrl === "string") {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig(this.defaults, config);
    const { transitional: transitional2, paramsSerializer, headers } = config;
    if (transitional2 !== void 0) {
      validator_default.assertOptions(transitional2, {
        silentJSONParsing: validators2.transitional(validators2.boolean),
        forcedJSONParsing: validators2.transitional(validators2.boolean),
        clarifyTimeoutError: validators2.transitional(validators2.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils_default.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator_default.assertOptions(paramsSerializer, {
          encode: validators2.function,
          serialize: validators2.function
        }, true);
      }
    }
    config.method = (config.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils_default.merge(
      headers.common,
      headers[config.method]
    );
    headers && utils_default.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config.headers = AxiosHeaders_default.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i6 = 0;
    let len4;
    if (!synchronousRequestInterceptors) {
      const chain2 = [dispatchRequest.bind(this), void 0];
      chain2.unshift.apply(chain2, requestInterceptorChain);
      chain2.push.apply(chain2, responseInterceptorChain);
      len4 = chain2.length;
      promise = Promise.resolve(config);
      while (i6 < len4) {
        promise = promise.then(chain2[i6++], chain2[i6++]);
      }
      return promise;
    }
    len4 = requestInterceptorChain.length;
    let newConfig = config;
    i6 = 0;
    while (i6 < len4) {
      const onFulfilled = requestInterceptorChain[i6++];
      const onRejected = requestInterceptorChain[i6++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i6 = 0;
    len4 = responseInterceptorChain.length;
    while (i6 < len4) {
      promise = promise.then(responseInterceptorChain[i6++], responseInterceptorChain[i6++]);
    }
    return promise;
  }
  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
};
utils_default.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});
utils_default.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url,
        data
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
var Axios_default = Axios;

// node_modules/axios/lib/cancel/CancelToken.js
var CancelToken = class _CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    const token = this;
    this.promise.then((cancel2) => {
      if (!token._listeners) return;
      let i6 = token._listeners.length;
      while (i6-- > 0) {
        token._listeners[i6](cancel2);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve) => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel2(message, config, request) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError_default(message, config, request);
      resolvePromise(token.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index2 = this._listeners.indexOf(listener);
    if (index2 !== -1) {
      this._listeners.splice(index2, 1);
    }
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel2;
    const token = new _CancelToken(function executor(c6) {
      cancel2 = c6;
    });
    return {
      token,
      cancel: cancel2
    };
  }
};
var CancelToken_default = CancelToken;

// node_modules/axios/lib/helpers/spread.js
function spread(callback) {
  return function wrap2(arr) {
    return callback.apply(null, arr);
  };
}

// node_modules/axios/lib/helpers/isAxiosError.js
function isAxiosError(payload) {
  return utils_default.isObject(payload) && payload.isAxiosError === true;
}

// node_modules/axios/lib/helpers/HttpStatusCode.js
var HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});
var HttpStatusCode_default = HttpStatusCode;

// node_modules/axios/lib/axios.js
function createInstance(defaultConfig) {
  const context = new Axios_default(defaultConfig);
  const instance = bind(Axios_default.prototype.request, context);
  utils_default.extend(instance, Axios_default.prototype, context, { allOwnKeys: true });
  utils_default.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create6(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance;
}
var axios = createInstance(defaults_default);
axios.Axios = Axios_default;
axios.CanceledError = CanceledError_default;
axios.CancelToken = CancelToken_default;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData_default;
axios.AxiosError = AxiosError_default;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders_default;
axios.formToJSON = (thing) => formDataToJSON_default(utils_default.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters_default.getAdapter;
axios.HttpStatusCode = HttpStatusCode_default;
axios.default = axios;
var axios_default = axios;

// node_modules/axios/index.js
var {
  Axios: Axios2,
  AxiosError: AxiosError2,
  CanceledError: CanceledError2,
  isCancel: isCancel2,
  CancelToken: CancelToken2,
  VERSION: VERSION2,
  all: all2,
  Cancel,
  isAxiosError: isAxiosError2,
  spread: spread2,
  toFormData: toFormData2,
  AxiosHeaders: AxiosHeaders2,
  HttpStatusCode: HttpStatusCode2,
  formToJSON,
  getAdapter,
  mergeConfig: mergeConfig2
} = axios_default;

// node_modules/itk-wasm/dist/pipeline/create-worker-proxy.js
var import_meta = {};
function workerToWorkerProxy(worker) {
  const workerProxy = wrap(worker);
  const itkWebWorker = worker;
  itkWebWorker.workerProxy = workerProxy;
  itkWebWorker.originalTerminate = itkWebWorker.terminate;
  itkWebWorker.terminate = () => {
    itkWebWorker.workerProxy[releaseProxy]();
    itkWebWorker.originalTerminate();
  };
  return { workerProxy, worker: itkWebWorker };
}
function createWorkerProxy(existingWorker, pipelineWorkerUrl2) {
  return __async(this, null, function* () {
    let workerProxy;
    if (existingWorker != null) {
      const itkWebWorker = existingWorker;
      if (itkWebWorker.workerProxy !== void 0) {
        workerProxy = itkWebWorker.workerProxy;
        return { workerProxy, worker: itkWebWorker };
      } else {
        return workerToWorkerProxy(existingWorker);
      }
    }
    const workerUrl = pipelineWorkerUrl2;
    let worker = null;
    if (workerUrl === null) {
      worker = new Worker(new URL("./web-workers/itk-wasm-pipeline.worker.js", import_meta.url), { type: "module" });
    } else {
      if (workerUrl.startsWith("http")) {
        const response = yield axios_default.get(workerUrl, { responseType: "blob" });
        const workerObjectUrl = URL.createObjectURL(response.data);
        worker = new Worker(workerObjectUrl, { type: "module" });
      } else {
        worker = new Worker(workerUrl, { type: "module" });
      }
    }
    return workerToWorkerProxy(worker);
  });
}
var create_worker_proxy_default = createWorkerProxy;

// node_modules/itk-wasm/dist/pipeline/internal/load-emscripten-module-main-thread.js
function loadEmscriptenModuleMainThread(moduleRelativePathOrURL, baseUrl) {
  return __async(this, null, function* () {
    let modulePrefix = "unknown";
    if (typeof moduleRelativePathOrURL !== "string") {
      modulePrefix = moduleRelativePathOrURL.href;
    } else if (moduleRelativePathOrURL.startsWith("http")) {
      modulePrefix = moduleRelativePathOrURL;
    } else {
      modulePrefix = typeof baseUrl !== "undefined" ? `${baseUrl}/${moduleRelativePathOrURL}` : moduleRelativePathOrURL;
    }
    if (modulePrefix.endsWith(".js")) {
      modulePrefix = modulePrefix.substring(0, modulePrefix.length - 3);
    }
    if (modulePrefix.endsWith(".wasm")) {
      modulePrefix = modulePrefix.substring(0, modulePrefix.length - 5);
    }
    const wasmBinaryPath = `${modulePrefix}.wasm`;
    const response = yield axios_default.get(wasmBinaryPath, { responseType: "arraybuffer" });
    const wasmBinary = response.data;
    const fullModulePath = `${modulePrefix}.js`;
    const result = yield import(
      /* webpackIgnore: true */
      /* @vite-ignore */
      fullModulePath
    );
    const instantiated = result.default({ wasmBinary });
    return instantiated;
  });
}
var load_emscripten_module_main_thread_default = loadEmscriptenModuleMainThread;

// node_modules/wasm-feature-detect/dist/esm/index.js
var simd = () => __async(void 0, null, function* () {
  return WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 123, 3, 2, 1, 0, 10, 10, 1, 8, 0, 65, 0, 253, 15, 253, 98, 11]));
});

// node_modules/itk-wasm/dist/pipeline/internal/run-pipeline-emscripten.js
var haveSharedArrayBuffer = typeof globalThis.SharedArrayBuffer === "function";
var encoder = new TextEncoder();
var decoder = new TextDecoder("utf-8");
function readFileSharedArray(emscriptenModule, path) {
  const opts = { flags: "r", encoding: "binary" };
  const stream = emscriptenModule.fs_open(path, opts.flags);
  const stat = emscriptenModule.fs_stat(path);
  const length4 = stat.size;
  let arrayBufferData = null;
  if (haveSharedArrayBuffer) {
    arrayBufferData = new SharedArrayBuffer(length4);
  } else {
    arrayBufferData = new ArrayBuffer(length4);
  }
  const array = new Uint8Array(arrayBufferData);
  emscriptenModule.fs_read(stream, array, 0, length4, 0);
  emscriptenModule.fs_close(stream);
  return array;
}
function memoryUint8SharedArray(emscriptenModule, byteOffset, length4) {
  let arrayBufferData = null;
  if (haveSharedArrayBuffer) {
    arrayBufferData = new SharedArrayBuffer(length4);
  } else {
    arrayBufferData = new ArrayBuffer(length4);
  }
  const array = new Uint8Array(arrayBufferData);
  const dataArrayView = new Uint8Array(emscriptenModule.HEAPU8.buffer, byteOffset, length4);
  array.set(dataArrayView);
  return array;
}
function setPipelineModuleInputArray(emscriptenModule, dataArray, inputIndex, subIndex) {
  let dataPtr = 0;
  if (dataArray !== null) {
    dataPtr = emscriptenModule.ccall("itk_wasm_input_array_alloc", "number", ["number", "number", "number", "number"], [0, inputIndex, subIndex, dataArray.buffer.byteLength]);
    emscriptenModule.HEAPU8.set(new Uint8Array(dataArray.buffer), dataPtr);
  }
  return dataPtr;
}
function setPipelineModuleInputJSON(emscriptenModule, dataObject, inputIndex) {
  const dataJSON = JSON.stringify(dataObject);
  const jsonPtr = emscriptenModule.ccall("itk_wasm_input_json_alloc", "number", ["number", "number", "number"], [0, inputIndex, dataJSON.length]);
  emscriptenModule.writeAsciiToMemory(dataJSON, jsonPtr, false);
}
function getPipelineModuleOutputArray(emscriptenModule, outputIndex, subIndex, componentType) {
  const dataPtr = emscriptenModule.ccall("itk_wasm_output_array_address", "number", ["number", "number", "number"], [0, outputIndex, subIndex]);
  const dataSize = emscriptenModule.ccall("itk_wasm_output_array_size", "number", ["number", "number", "number"], [0, outputIndex, subIndex]);
  const dataUint8 = memoryUint8SharedArray(emscriptenModule, dataPtr, dataSize);
  const data = buffer_to_typed_array_default(componentType, dataUint8.buffer);
  return data;
}
function getPipelineModuleOutputJSON(emscriptenModule, outputIndex) {
  const jsonPtr = emscriptenModule.ccall("itk_wasm_output_json_address", "number", ["number", "number"], [0, outputIndex]);
  const dataJSON = emscriptenModule.AsciiToString(jsonPtr);
  const dataObject = JSON.parse(dataJSON);
  return dataObject;
}
function runPipelineEmscripten(pipelineModule, args, outputs, inputs) {
  if (!(inputs == null) && inputs.length > 0) {
    inputs.forEach(function(input, index2) {
      var _a9;
      switch (input.type) {
        case interface_types_default.TextStream: {
          const dataArray = encoder.encode(input.data.data);
          const arrayPtr = setPipelineModuleInputArray(pipelineModule, dataArray, index2, 0);
          const dataJSON = { size: dataArray.buffer.byteLength, data: `data:application/vnd.itk.address,0:${arrayPtr}` };
          setPipelineModuleInputJSON(pipelineModule, dataJSON, index2);
          break;
        }
        case interface_types_default.JsonCompatible: {
          const dataArray = encoder.encode(JSON.stringify(input.data));
          const arrayPtr = setPipelineModuleInputArray(pipelineModule, dataArray, index2, 0);
          const dataJSON = { size: dataArray.buffer.byteLength, data: `data:application/vnd.itk.address,0:${arrayPtr}` };
          setPipelineModuleInputJSON(pipelineModule, dataJSON, index2);
          break;
        }
        case interface_types_default.BinaryStream: {
          const dataArray = input.data.data;
          const arrayPtr = setPipelineModuleInputArray(pipelineModule, dataArray, index2, 0);
          const dataJSON = { size: dataArray.buffer.byteLength, data: `data:application/vnd.itk.address,0:${arrayPtr}` };
          setPipelineModuleInputJSON(pipelineModule, dataJSON, index2);
          break;
        }
        case interface_types_default.TextFile: {
          pipelineModule.fs_writeFile(input.data.path, input.data.data);
          break;
        }
        case interface_types_default.BinaryFile: {
          pipelineModule.fs_writeFile(input.data.path, input.data.data);
          break;
        }
        case interface_types_default.Image: {
          const image2 = input.data;
          const dataPtr = setPipelineModuleInputArray(pipelineModule, image2.data, index2, 0);
          const directionPtr = setPipelineModuleInputArray(pipelineModule, image2.direction, index2, 1);
          const metadata = typeof ((_a9 = image2.metadata) == null ? void 0 : _a9.entries) !== "undefined" ? JSON.stringify(Array.from(image2.metadata.entries())) : "[]";
          const imageJSON = {
            imageType: image2.imageType,
            name: image2.name,
            origin: image2.origin,
            spacing: image2.spacing,
            direction: `data:application/vnd.itk.address,0:${directionPtr}`,
            size: image2.size,
            data: `data:application/vnd.itk.address,0:${dataPtr}`,
            metadata
          };
          setPipelineModuleInputJSON(pipelineModule, imageJSON, index2);
          break;
        }
        case interface_types_default.Mesh: {
          const mesh = input.data;
          const pointsPtr = setPipelineModuleInputArray(pipelineModule, mesh.points, index2, 0);
          const cellsPtr = setPipelineModuleInputArray(pipelineModule, mesh.cells, index2, 1);
          const pointDataPtr = setPipelineModuleInputArray(pipelineModule, mesh.pointData, index2, 2);
          const cellDataPtr = setPipelineModuleInputArray(pipelineModule, mesh.cellData, index2, 3);
          const meshJSON = {
            meshType: mesh.meshType,
            name: mesh.name,
            numberOfPoints: mesh.numberOfPoints,
            points: `data:application/vnd.itk.address,0:${pointsPtr}`,
            numberOfCells: mesh.numberOfCells,
            cells: `data:application/vnd.itk.address,0:${cellsPtr}`,
            cellBufferSize: mesh.cellBufferSize,
            numberOfPointPixels: mesh.numberOfPointPixels,
            pointData: `data:application/vnd.itk.address,0:${pointDataPtr}`,
            numberOfCellPixels: mesh.numberOfCellPixels,
            cellData: `data:application/vnd.itk.address,0:${cellDataPtr}`
          };
          setPipelineModuleInputJSON(pipelineModule, meshJSON, index2);
          break;
        }
        case interface_types_default.PolyData: {
          const polyData = input.data;
          const pointsPtr = setPipelineModuleInputArray(pipelineModule, polyData.points, index2, 0);
          const verticesPtr = setPipelineModuleInputArray(pipelineModule, polyData.vertices, index2, 1);
          const linesPtr = setPipelineModuleInputArray(pipelineModule, polyData.lines, index2, 2);
          const polygonsPtr = setPipelineModuleInputArray(pipelineModule, polyData.polygons, index2, 3);
          const triangleStripsPtr = setPipelineModuleInputArray(pipelineModule, polyData.triangleStrips, index2, 4);
          const pointDataPtr = setPipelineModuleInputArray(pipelineModule, polyData.pointData, index2, 5);
          const cellDataPtr = setPipelineModuleInputArray(pipelineModule, polyData.pointData, index2, 6);
          const polyDataJSON = {
            polyDataType: polyData.polyDataType,
            name: polyData.name,
            numberOfPoints: polyData.numberOfPoints,
            points: `data:application/vnd.itk.address,0:${pointsPtr}`,
            verticesBufferSize: polyData.verticesBufferSize,
            vertices: `data:application/vnd.itk.address,0:${verticesPtr}`,
            linesBufferSize: polyData.linesBufferSize,
            lines: `data:application/vnd.itk.address,0:${linesPtr}`,
            polygonsBufferSize: polyData.polygonsBufferSize,
            polygons: `data:application/vnd.itk.address,0:${polygonsPtr}`,
            triangleStripsBufferSize: polyData.triangleStripsBufferSize,
            triangleStrips: `data:application/vnd.itk.address,0:${triangleStripsPtr}`,
            numberOfPointPixels: polyData.numberOfPointPixels,
            pointData: `data:application/vnd.itk.address,0:${pointDataPtr}`,
            numberOfCellPixels: polyData.numberOfCellPixels,
            cellData: `data:application/vnd.itk.address,0:${cellDataPtr}`
          };
          setPipelineModuleInputJSON(pipelineModule, polyDataJSON, index2);
          break;
        }
        default:
          throw Error("Unsupported input InterfaceType");
      }
    });
  }
  pipelineModule.resetModuleStdout();
  pipelineModule.resetModuleStderr();
  const stackPtr = pipelineModule.stackSave();
  let returnValue = 0;
  try {
    returnValue = pipelineModule.callMain(args.slice());
  } catch (exception) {
    if (typeof exception === "number") {
      console.log("Exception while running pipeline:");
      console.log("stdout:", pipelineModule.getModuleStdout());
      console.error("stderr:", pipelineModule.getModuleStderr());
      if (typeof pipelineModule.getExceptionMessage !== "undefined") {
        console.error("exception:", pipelineModule.getExceptionMessage(exception));
      } else {
        console.error("Build module in Debug mode for exception message information.");
      }
    }
    throw exception;
  } finally {
    pipelineModule.stackRestore(stackPtr);
  }
  const stdout = pipelineModule.getModuleStdout();
  const stderr = pipelineModule.getModuleStderr();
  const populatedOutputs = [];
  if (!(outputs == null) && outputs.length > 0 && returnValue === 0) {
    outputs.forEach(function(output, index2) {
      let outputData = null;
      switch (output.type) {
        case interface_types_default.TextStream: {
          const dataPtr = pipelineModule.ccall("itk_wasm_output_array_address", "number", ["number", "number", "number"], [0, index2, 0]);
          const dataSize = pipelineModule.ccall("itk_wasm_output_array_size", "number", ["number", "number", "number"], [0, index2, 0]);
          const dataArrayView = new Uint8Array(pipelineModule.HEAPU8.buffer, dataPtr, dataSize);
          outputData = { data: decoder.decode(dataArrayView) };
          break;
        }
        case interface_types_default.JsonCompatible: {
          const dataPtr = pipelineModule.ccall("itk_wasm_output_array_address", "number", ["number", "number", "number"], [0, index2, 0]);
          const dataSize = pipelineModule.ccall("itk_wasm_output_array_size", "number", ["number", "number", "number"], [0, index2, 0]);
          const dataArrayView = new Uint8Array(pipelineModule.HEAPU8.buffer, dataPtr, dataSize);
          outputData = JSON.parse(decoder.decode(dataArrayView));
          break;
        }
        case interface_types_default.BinaryStream: {
          const dataPtr = pipelineModule.ccall("itk_wasm_output_array_address", "number", ["number", "number", "number"], [0, index2, 0]);
          const dataSize = pipelineModule.ccall("itk_wasm_output_array_size", "number", ["number", "number", "number"], [0, index2, 0]);
          outputData = { data: memoryUint8SharedArray(pipelineModule, dataPtr, dataSize) };
          break;
        }
        case interface_types_default.TextFile: {
          outputData = { path: output.data.path, data: pipelineModule.fs_readFile(output.data.path, { encoding: "utf8" }) };
          break;
        }
        case interface_types_default.BinaryFile: {
          outputData = { path: output.data.path, data: readFileSharedArray(pipelineModule, output.data.path) };
          break;
        }
        case interface_types_default.Image: {
          const image2 = getPipelineModuleOutputJSON(pipelineModule, index2);
          image2.data = getPipelineModuleOutputArray(pipelineModule, index2, 0, image2.imageType.componentType);
          image2.direction = getPipelineModuleOutputArray(pipelineModule, index2, 1, float_types_default.Float64);
          image2.metadata = new Map(image2.metadata);
          outputData = image2;
          break;
        }
        case interface_types_default.Mesh: {
          const mesh = getPipelineModuleOutputJSON(pipelineModule, index2);
          if (mesh.numberOfPoints > 0) {
            mesh.points = getPipelineModuleOutputArray(pipelineModule, index2, 0, mesh.meshType.pointComponentType);
          } else {
            mesh.points = buffer_to_typed_array_default(mesh.meshType.pointComponentType, new ArrayBuffer(0));
          }
          if (mesh.numberOfCells > 0) {
            mesh.cells = getPipelineModuleOutputArray(pipelineModule, index2, 1, mesh.meshType.cellComponentType);
          } else {
            mesh.cells = buffer_to_typed_array_default(mesh.meshType.cellComponentType, new ArrayBuffer(0));
          }
          if (mesh.numberOfPointPixels > 0) {
            mesh.pointData = getPipelineModuleOutputArray(pipelineModule, index2, 2, mesh.meshType.pointPixelComponentType);
          } else {
            mesh.pointData = buffer_to_typed_array_default(mesh.meshType.pointPixelComponentType, new ArrayBuffer(0));
          }
          if (mesh.numberOfCellPixels > 0) {
            mesh.cellData = getPipelineModuleOutputArray(pipelineModule, index2, 3, mesh.meshType.cellPixelComponentType);
          } else {
            mesh.cellData = buffer_to_typed_array_default(mesh.meshType.cellPixelComponentType, new ArrayBuffer(0));
          }
          outputData = mesh;
          break;
        }
        case interface_types_default.PolyData: {
          const polyData = getPipelineModuleOutputJSON(pipelineModule, index2);
          if (polyData.numberOfPoints > 0) {
            polyData.points = getPipelineModuleOutputArray(pipelineModule, index2, 0, float_types_default.Float32);
          } else {
            polyData.points = new Float32Array();
          }
          if (polyData.verticesBufferSize > 0) {
            polyData.vertices = getPipelineModuleOutputArray(pipelineModule, index2, 1, int_types_default.UInt32);
          } else {
            polyData.vertices = new Uint32Array();
          }
          if (polyData.linesBufferSize > 0) {
            polyData.lines = getPipelineModuleOutputArray(pipelineModule, index2, 2, int_types_default.UInt32);
          } else {
            polyData.lines = new Uint32Array();
          }
          if (polyData.polygonsBufferSize > 0) {
            polyData.polygons = getPipelineModuleOutputArray(pipelineModule, index2, 3, int_types_default.UInt32);
          } else {
            polyData.polygons = new Uint32Array();
          }
          if (polyData.triangleStripsBufferSize > 0) {
            polyData.triangleStrips = getPipelineModuleOutputArray(pipelineModule, index2, 4, int_types_default.UInt32);
          } else {
            polyData.triangleStrips = new Uint32Array();
          }
          if (polyData.numberOfPointPixels > 0) {
            polyData.pointData = getPipelineModuleOutputArray(pipelineModule, index2, 5, polyData.polyDataType.pointPixelComponentType);
          } else {
            polyData.pointData = buffer_to_typed_array_default(polyData.polyDataType.pointPixelComponentType, new ArrayBuffer(0));
          }
          if (polyData.numberOfCellPixels > 0) {
            polyData.cellData = getPipelineModuleOutputArray(pipelineModule, index2, 6, polyData.polyDataType.cellPixelComponentType);
          } else {
            polyData.cellData = buffer_to_typed_array_default(polyData.polyDataType.cellPixelComponentType, new ArrayBuffer(0));
          }
          outputData = polyData;
          break;
        }
        default:
          throw Error("Unsupported output InterfaceType");
      }
      const populatedOutput = {
        type: output.type,
        data: outputData
      };
      populatedOutputs.push(populatedOutput);
    });
  }
  return { returnValue, stdout, stderr, outputs: populatedOutputs };
}
var run_pipeline_emscripten_default = runPipelineEmscripten;

// node_modules/itk-wasm/dist/get-transferables.js
var haveSharedArrayBuffer2 = typeof globalThis.SharedArrayBuffer !== "undefined";
function getTransferables(data) {
  if (data === void 0 || data === null) {
    return [];
  }
  const transferables = [];
  for (let i6 = 0; i6 < data.length; i6++) {
    const transferable = getTransferable(data[i6]);
    if (transferable !== null) {
      transferables.push(transferable);
    }
  }
  return transferables;
}
function getTransferable(data) {
  if (data === void 0 || data === null) {
    return null;
  }
  let result = null;
  if (data.buffer !== void 0) {
    result = data.buffer;
  } else if (data.byteLength !== void 0) {
    result = data;
  }
  if (haveSharedArrayBuffer2 && result instanceof SharedArrayBuffer) {
    return null;
  }
  return result;
}
var get_transferables_default = getTransferables;

// node_modules/itk-wasm/dist/pipeline/internal/image-transferables.js
function imageTransferables(image2) {
  return [
    image2.data,
    image2.direction
  ];
}
var image_transferables_default = imageTransferables;

// node_modules/itk-wasm/dist/pipeline/internal/mesh-transferables.js
function meshTransferables(mesh) {
  return [
    mesh.points,
    mesh.pointData,
    mesh.cells,
    mesh.cellData
  ];
}
var mesh_transferables_default = meshTransferables;

// node_modules/itk-wasm/dist/pipeline/internal/poly-data-transferables.js
function polyDataTransferables(polyData) {
  return [
    polyData.points,
    polyData.vertices,
    polyData.lines,
    polyData.polygons,
    polyData.triangleStrips,
    polyData.pointData,
    polyData.cellData
  ];
}
var poly_data_transferables_default = polyDataTransferables;

// node_modules/itk-wasm/dist/pipeline/pipelines-base-url.js
var pipelinesBaseUrl;
function getPipelinesBaseUrl() {
  return pipelinesBaseUrl;
}

// node_modules/itk-wasm/dist/pipeline/pipeline-worker-url.js
var pipelineWorkerUrl;
function getPipelineWorkerUrl() {
  return pipelineWorkerUrl;
}

// node_modules/itk-wasm/dist/pipeline/run-pipeline.js
var pipelineToModule = /* @__PURE__ */ new Map();
function defaultPipelineWorkerUrl() {
  let result = getPipelineWorkerUrl();
  if (typeof result === "undefined") {
    result = null;
  }
  return result;
}
function defaultPipelinesBaseUrl() {
  let result = getPipelinesBaseUrl();
  if (typeof result === "undefined") {
    result = new URL("/pipelines", document.location.origin).href;
  }
  return result;
}
function loadPipelineModule(pipelinePath, pipelineBaseUrl) {
  return __async(this, null, function* () {
    var _a9;
    let moduleRelativePathOrURL = pipelinePath;
    let pipeline = pipelinePath;
    if (typeof pipelinePath !== "string") {
      moduleRelativePathOrURL = new URL(pipelinePath.href);
      pipeline = moduleRelativePathOrURL.href;
    }
    if (pipelineToModule.has(pipeline)) {
      return pipelineToModule.get(pipeline);
    } else {
      const pipelineModule = yield load_emscripten_module_main_thread_default(pipelinePath, (_a9 = pipelineBaseUrl == null ? void 0 : pipelineBaseUrl.toString()) != null ? _a9 : defaultPipelinesBaseUrl());
      pipelineToModule.set(pipeline, pipelineModule);
      return pipelineModule;
    }
  });
}
function runPipeline(webWorker, pipelinePath, args, outputs, inputs, options) {
  return __async(this, null, function* () {
    var _a9, _b2;
    if (!(yield simd())) {
      const simdErrorMessage = "WebAssembly SIMD support is required -- please update your browser.";
      alert(simdErrorMessage);
      throw new Error(simdErrorMessage);
    }
    if (webWorker === false) {
      const pipelineModule = yield loadPipelineModule(pipelinePath.toString(), options == null ? void 0 : options.pipelineBaseUrl);
      const result2 = run_pipeline_emscripten_default(pipelineModule, args, outputs, inputs);
      return result2;
    }
    let worker = webWorker;
    const pipelineWorkerUrl2 = (_a9 = options == null ? void 0 : options.pipelineWorkerUrl) != null ? _a9 : defaultPipelineWorkerUrl();
    const pipelineWorkerUrlString = typeof pipelineWorkerUrl2 !== "string" && typeof (pipelineWorkerUrl2 == null ? void 0 : pipelineWorkerUrl2.href) !== "undefined" ? pipelineWorkerUrl2.href : pipelineWorkerUrl2;
    const { workerProxy, worker: usedWorker } = yield create_worker_proxy_default(worker, pipelineWorkerUrlString);
    worker = usedWorker;
    const transferables = [];
    if (!(inputs == null) && inputs.length > 0) {
      inputs.forEach(function(input) {
        if (input.type === interface_types_default.BinaryStream) {
          const dataArray = input.data.data;
          transferables.push(dataArray);
        } else if (input.type === interface_types_default.BinaryFile) {
          const dataArray = input.data.data;
          transferables.push(dataArray);
        } else if (input.type === interface_types_default.Image) {
          const image2 = input.data;
          if (image2.data !== null) {
            transferables.push(...image_transferables_default(image2));
          }
        } else if (input.type === interface_types_default.Mesh) {
          const mesh = input.data;
          transferables.push(...mesh_transferables_default(mesh));
        } else if (input.type === interface_types_default.PolyData) {
          const polyData = input.data;
          transferables.push(...poly_data_transferables_default(polyData));
        }
      });
    }
    const pipelineBaseUrl = (_b2 = options == null ? void 0 : options.pipelineBaseUrl) != null ? _b2 : defaultPipelinesBaseUrl();
    const pipelineBaseUrlString = typeof pipelineBaseUrl !== "string" && typeof (pipelineBaseUrl == null ? void 0 : pipelineBaseUrl.href) !== "undefined" ? pipelineBaseUrl.href : pipelineBaseUrl;
    const transferedInputs = inputs != null ? transfer(inputs, get_transferables_default(transferables)) : null;
    const result = yield workerProxy.runPipeline(pipelinePath.toString(), pipelineBaseUrlString, args, outputs, transferedInputs);
    return {
      returnValue: result.returnValue,
      stdout: result.stdout,
      stderr: result.stderr,
      outputs: result.outputs,
      webWorker: worker
    };
  });
}
var run_pipeline_default = runPipeline;

// node_modules/eventemitter3/index.mjs
var import_index = __toESM(require_eventemitter3(), 1);

// node_modules/p-timeout/index.js
var TimeoutError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "TimeoutError";
  }
};
var AbortError = class extends Error {
  constructor(message) {
    super();
    this.name = "AbortError";
    this.message = message;
  }
};
var getDOMException = (errorMessage) => globalThis.DOMException === void 0 ? new AbortError(errorMessage) : new DOMException(errorMessage);
var getAbortedReason = (signal) => {
  const reason = signal.reason === void 0 ? getDOMException("This operation was aborted.") : signal.reason;
  return reason instanceof Error ? reason : getDOMException(reason);
};
function pTimeout(promise, options) {
  const {
    milliseconds,
    fallback: fallback2,
    message,
    customTimers = { setTimeout, clearTimeout }
  } = options;
  let timer;
  const wrappedPromise = new Promise((resolve, reject) => {
    if (typeof milliseconds !== "number" || Math.sign(milliseconds) !== 1) {
      throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${milliseconds}\``);
    }
    if (options.signal) {
      const { signal } = options;
      if (signal.aborted) {
        reject(getAbortedReason(signal));
      }
      signal.addEventListener("abort", () => {
        reject(getAbortedReason(signal));
      });
    }
    if (milliseconds === Number.POSITIVE_INFINITY) {
      promise.then(resolve, reject);
      return;
    }
    const timeoutError = new TimeoutError();
    timer = customTimers.setTimeout.call(void 0, () => {
      if (fallback2) {
        try {
          resolve(fallback2());
        } catch (error) {
          reject(error);
        }
        return;
      }
      if (typeof promise.cancel === "function") {
        promise.cancel();
      }
      if (message === false) {
        resolve();
      } else if (message instanceof Error) {
        reject(message);
      } else {
        timeoutError.message = message != null ? message : `Promise timed out after ${milliseconds} milliseconds`;
        reject(timeoutError);
      }
    }, milliseconds);
    (() => __async(this, null, function* () {
      try {
        resolve(yield promise);
      } catch (error) {
        reject(error);
      }
    }))();
  });
  const cancelablePromise = wrappedPromise.finally(() => {
    cancelablePromise.clear();
  });
  cancelablePromise.clear = () => {
    customTimers.clearTimeout.call(void 0, timer);
    timer = void 0;
  };
  return cancelablePromise;
}

// node_modules/p-queue/dist/lower-bound.js
function lowerBound(array, value, comparator) {
  let first = 0;
  let count = array.length;
  while (count > 0) {
    const step = Math.trunc(count / 2);
    let it = first + step;
    if (comparator(array[it], value) <= 0) {
      first = ++it;
      count -= step + 1;
    } else {
      count = step;
    }
  }
  return first;
}

// node_modules/p-queue/dist/priority-queue.js
var _queue;
var PriorityQueue = class {
  constructor() {
    __privateAdd(this, _queue, []);
  }
  enqueue(run, options) {
    options = __spreadValues({
      priority: 0
    }, options);
    const element = {
      priority: options.priority,
      run
    };
    if (this.size && __privateGet(this, _queue)[this.size - 1].priority >= options.priority) {
      __privateGet(this, _queue).push(element);
      return;
    }
    const index2 = lowerBound(__privateGet(this, _queue), element, (a4, b3) => b3.priority - a4.priority);
    __privateGet(this, _queue).splice(index2, 0, element);
  }
  dequeue() {
    const item = __privateGet(this, _queue).shift();
    return item == null ? void 0 : item.run;
  }
  filter(options) {
    return __privateGet(this, _queue).filter((element) => element.priority === options.priority).map((element) => element.run);
  }
  get size() {
    return __privateGet(this, _queue).length;
  }
};
_queue = new WeakMap();

// node_modules/p-queue/dist/index.js
var _carryoverConcurrencyCount, _isIntervalIgnored, _intervalCount, _intervalCap, _interval, _intervalEnd, _intervalId, _timeoutId, _queue2, _queueClass, _pending, _concurrency, _isPaused, _throwOnTimeout, _PQueue_instances, doesIntervalAllowAnother_get, doesConcurrentAllowAnother_get, next_fn, onResumeInterval_fn, isIntervalPaused_get, tryToStartAnother_fn, initializeIntervalIfNeeded_fn, onInterval_fn, processQueue_fn, throwOnAbort_fn, onEvent_fn;
var PQueue = class extends import_index.default {
  // TODO: The `throwOnTimeout` option should affect the return types of `add()` and `addAll()`
  constructor(options) {
    var _a9, _b2, _c, _d;
    super();
    __privateAdd(this, _PQueue_instances);
    __privateAdd(this, _carryoverConcurrencyCount);
    __privateAdd(this, _isIntervalIgnored);
    __privateAdd(this, _intervalCount, 0);
    __privateAdd(this, _intervalCap);
    __privateAdd(this, _interval);
    __privateAdd(this, _intervalEnd, 0);
    __privateAdd(this, _intervalId);
    __privateAdd(this, _timeoutId);
    __privateAdd(this, _queue2);
    __privateAdd(this, _queueClass);
    __privateAdd(this, _pending, 0);
    // The `!` is needed because of https://github.com/microsoft/TypeScript/issues/32194
    __privateAdd(this, _concurrency);
    __privateAdd(this, _isPaused);
    __privateAdd(this, _throwOnTimeout);
    /**
        Per-operation timeout in milliseconds. Operations fulfill once `timeout` elapses if they haven't already.
    
        Applies to each future operation.
        */
    __publicField(this, "timeout");
    options = __spreadValues({
      carryoverConcurrencyCount: false,
      intervalCap: Number.POSITIVE_INFINITY,
      interval: 0,
      concurrency: Number.POSITIVE_INFINITY,
      autoStart: true,
      queueClass: PriorityQueue
    }, options);
    if (!(typeof options.intervalCap === "number" && options.intervalCap >= 1)) {
      throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(_b2 = (_a9 = options.intervalCap) == null ? void 0 : _a9.toString()) != null ? _b2 : ""}\` (${typeof options.intervalCap})`);
    }
    if (options.interval === void 0 || !(Number.isFinite(options.interval) && options.interval >= 0)) {
      throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(_d = (_c = options.interval) == null ? void 0 : _c.toString()) != null ? _d : ""}\` (${typeof options.interval})`);
    }
    __privateSet(this, _carryoverConcurrencyCount, options.carryoverConcurrencyCount);
    __privateSet(this, _isIntervalIgnored, options.intervalCap === Number.POSITIVE_INFINITY || options.interval === 0);
    __privateSet(this, _intervalCap, options.intervalCap);
    __privateSet(this, _interval, options.interval);
    __privateSet(this, _queue2, new options.queueClass());
    __privateSet(this, _queueClass, options.queueClass);
    this.concurrency = options.concurrency;
    this.timeout = options.timeout;
    __privateSet(this, _throwOnTimeout, options.throwOnTimeout === true);
    __privateSet(this, _isPaused, options.autoStart === false);
  }
  get concurrency() {
    return __privateGet(this, _concurrency);
  }
  set concurrency(newConcurrency) {
    if (!(typeof newConcurrency === "number" && newConcurrency >= 1)) {
      throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${newConcurrency}\` (${typeof newConcurrency})`);
    }
    __privateSet(this, _concurrency, newConcurrency);
    __privateMethod(this, _PQueue_instances, processQueue_fn).call(this);
  }
  add(_0) {
    return __async(this, arguments, function* (function_, options = {}) {
      options = __spreadValues({
        timeout: this.timeout,
        throwOnTimeout: __privateGet(this, _throwOnTimeout)
      }, options);
      return new Promise((resolve, reject) => {
        __privateGet(this, _queue2).enqueue(() => __async(this, null, function* () {
          var _a9;
          __privateWrapper(this, _pending)._++;
          __privateWrapper(this, _intervalCount)._++;
          try {
            (_a9 = options.signal) == null ? void 0 : _a9.throwIfAborted();
            let operation = function_({ signal: options.signal });
            if (options.timeout) {
              operation = pTimeout(Promise.resolve(operation), { milliseconds: options.timeout });
            }
            if (options.signal) {
              operation = Promise.race([operation, __privateMethod(this, _PQueue_instances, throwOnAbort_fn).call(this, options.signal)]);
            }
            const result = yield operation;
            resolve(result);
            this.emit("completed", result);
          } catch (error) {
            if (error instanceof TimeoutError && !options.throwOnTimeout) {
              resolve();
              return;
            }
            reject(error);
            this.emit("error", error);
          } finally {
            __privateMethod(this, _PQueue_instances, next_fn).call(this);
          }
        }), options);
        this.emit("add");
        __privateMethod(this, _PQueue_instances, tryToStartAnother_fn).call(this);
      });
    });
  }
  addAll(functions, options) {
    return __async(this, null, function* () {
      return Promise.all(functions.map((function_) => __async(this, null, function* () {
        return this.add(function_, options);
      })));
    });
  }
  /**
  Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)
  */
  start() {
    if (!__privateGet(this, _isPaused)) {
      return this;
    }
    __privateSet(this, _isPaused, false);
    __privateMethod(this, _PQueue_instances, processQueue_fn).call(this);
    return this;
  }
  /**
  Put queue execution on hold.
  */
  pause() {
    __privateSet(this, _isPaused, true);
  }
  /**
  Clear the queue.
  */
  clear() {
    __privateSet(this, _queue2, new (__privateGet(this, _queueClass))());
  }
  /**
      Can be called multiple times. Useful if you for example add additional items at a later time.
  
      @returns A promise that settles when the queue becomes empty.
      */
  onEmpty() {
    return __async(this, null, function* () {
      if (__privateGet(this, _queue2).size === 0) {
        return;
      }
      yield __privateMethod(this, _PQueue_instances, onEvent_fn).call(this, "empty");
    });
  }
  /**
      @returns A promise that settles when the queue size is less than the given limit: `queue.size < limit`.
  
      If you want to avoid having the queue grow beyond a certain size you can `await queue.onSizeLessThan()` before adding a new item.
  
      Note that this only limits the number of items waiting to start. There could still be up to `concurrency` jobs already running that this call does not include in its calculation.
      */
  onSizeLessThan(limit) {
    return __async(this, null, function* () {
      if (__privateGet(this, _queue2).size < limit) {
        return;
      }
      yield __privateMethod(this, _PQueue_instances, onEvent_fn).call(this, "next", () => __privateGet(this, _queue2).size < limit);
    });
  }
  /**
      The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.
  
      @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.
      */
  onIdle() {
    return __async(this, null, function* () {
      if (__privateGet(this, _pending) === 0 && __privateGet(this, _queue2).size === 0) {
        return;
      }
      yield __privateMethod(this, _PQueue_instances, onEvent_fn).call(this, "idle");
    });
  }
  /**
  Size of the queue, the number of queued items waiting to run.
  */
  get size() {
    return __privateGet(this, _queue2).size;
  }
  /**
      Size of the queue, filtered by the given options.
  
      For example, this can be used to find the number of items remaining in the queue with a specific priority level.
      */
  sizeBy(options) {
    return __privateGet(this, _queue2).filter(options).length;
  }
  /**
  Number of running items (no longer in the queue).
  */
  get pending() {
    return __privateGet(this, _pending);
  }
  /**
  Whether the queue is currently paused.
  */
  get isPaused() {
    return __privateGet(this, _isPaused);
  }
};
_carryoverConcurrencyCount = new WeakMap();
_isIntervalIgnored = new WeakMap();
_intervalCount = new WeakMap();
_intervalCap = new WeakMap();
_interval = new WeakMap();
_intervalEnd = new WeakMap();
_intervalId = new WeakMap();
_timeoutId = new WeakMap();
_queue2 = new WeakMap();
_queueClass = new WeakMap();
_pending = new WeakMap();
_concurrency = new WeakMap();
_isPaused = new WeakMap();
_throwOnTimeout = new WeakMap();
_PQueue_instances = new WeakSet();
doesIntervalAllowAnother_get = function() {
  return __privateGet(this, _isIntervalIgnored) || __privateGet(this, _intervalCount) < __privateGet(this, _intervalCap);
};
doesConcurrentAllowAnother_get = function() {
  return __privateGet(this, _pending) < __privateGet(this, _concurrency);
};
next_fn = function() {
  __privateWrapper(this, _pending)._--;
  __privateMethod(this, _PQueue_instances, tryToStartAnother_fn).call(this);
  this.emit("next");
};
onResumeInterval_fn = function() {
  __privateMethod(this, _PQueue_instances, onInterval_fn).call(this);
  __privateMethod(this, _PQueue_instances, initializeIntervalIfNeeded_fn).call(this);
  __privateSet(this, _timeoutId, void 0);
};
isIntervalPaused_get = function() {
  const now = Date.now();
  if (__privateGet(this, _intervalId) === void 0) {
    const delay = __privateGet(this, _intervalEnd) - now;
    if (delay < 0) {
      __privateSet(this, _intervalCount, __privateGet(this, _carryoverConcurrencyCount) ? __privateGet(this, _pending) : 0);
    } else {
      if (__privateGet(this, _timeoutId) === void 0) {
        __privateSet(this, _timeoutId, setTimeout(() => {
          __privateMethod(this, _PQueue_instances, onResumeInterval_fn).call(this);
        }, delay));
      }
      return true;
    }
  }
  return false;
};
tryToStartAnother_fn = function() {
  if (__privateGet(this, _queue2).size === 0) {
    if (__privateGet(this, _intervalId)) {
      clearInterval(__privateGet(this, _intervalId));
    }
    __privateSet(this, _intervalId, void 0);
    this.emit("empty");
    if (__privateGet(this, _pending) === 0) {
      this.emit("idle");
    }
    return false;
  }
  if (!__privateGet(this, _isPaused)) {
    const canInitializeInterval = !__privateGet(this, _PQueue_instances, isIntervalPaused_get);
    if (__privateGet(this, _PQueue_instances, doesIntervalAllowAnother_get) && __privateGet(this, _PQueue_instances, doesConcurrentAllowAnother_get)) {
      const job = __privateGet(this, _queue2).dequeue();
      if (!job) {
        return false;
      }
      this.emit("active");
      job();
      if (canInitializeInterval) {
        __privateMethod(this, _PQueue_instances, initializeIntervalIfNeeded_fn).call(this);
      }
      return true;
    }
  }
  return false;
};
initializeIntervalIfNeeded_fn = function() {
  if (__privateGet(this, _isIntervalIgnored) || __privateGet(this, _intervalId) !== void 0) {
    return;
  }
  __privateSet(this, _intervalId, setInterval(() => {
    __privateMethod(this, _PQueue_instances, onInterval_fn).call(this);
  }, __privateGet(this, _interval)));
  __privateSet(this, _intervalEnd, Date.now() + __privateGet(this, _interval));
};
onInterval_fn = function() {
  if (__privateGet(this, _intervalCount) === 0 && __privateGet(this, _pending) === 0 && __privateGet(this, _intervalId)) {
    clearInterval(__privateGet(this, _intervalId));
    __privateSet(this, _intervalId, void 0);
  }
  __privateSet(this, _intervalCount, __privateGet(this, _carryoverConcurrencyCount) ? __privateGet(this, _pending) : 0);
  __privateMethod(this, _PQueue_instances, processQueue_fn).call(this);
};
/**
Executes all queued functions until it reaches the limit.
*/
processQueue_fn = function() {
  while (__privateMethod(this, _PQueue_instances, tryToStartAnother_fn).call(this)) {
  }
};
throwOnAbort_fn = function(signal) {
  return __async(this, null, function* () {
    return new Promise((_resolve, reject) => {
      signal.addEventListener("abort", () => {
        reject(signal.reason);
      }, { once: true });
    });
  });
};
onEvent_fn = function(event2, filter2) {
  return __async(this, null, function* () {
    return new Promise((resolve) => {
      const listener = () => {
        if (filter2 && !filter2()) {
          return;
        }
        this.off(event2, listener);
        resolve();
      };
      this.on(event2, listener);
    });
  });
};

// node_modules/@itk-viewer/utils/dist/dtypeUtils.js
var bigIntArrayType = typeof globalThis.BigInt64Array === "function" ? globalThis.BigInt64Array : Int32Array;
var bigUintArrayType = typeof globalThis.BigUint64Array === "function" ? globalThis.BigUint64Array : Uint32Array;
var dtypeUtils = Array.from(/* @__PURE__ */ new Map([
  ["b", [Int8Array, "getInt8", int_types_default.Int8]],
  ["B", [Uint8Array, "getUint8", int_types_default.UInt8]],
  ["u1", [Uint8Array, "getUint8", int_types_default.UInt8]],
  ["i1", [Int8Array, "getInt8", int_types_default.Int8]],
  ["u2", [Uint16Array, "getUint16", int_types_default.UInt16]],
  ["i2", [Int16Array, "getInt16", int_types_default.Int16]],
  ["u4", [Uint32Array, "getUint32", int_types_default.UInt32]],
  ["i4", [Int32Array, "getInt32", int_types_default.Int32]],
  ["u8", [bigUintArrayType, "getBigUint64", int_types_default.UInt64]],
  ["i8", [bigIntArrayType, "getBigInt64", int_types_default.Int64]],
  ["f4", [Float32Array, "getFloat32", float_types_default.Float32]],
  ["f8", [Float64Array, "getFloat64", float_types_default.Float64]]
])).reduce((map, [dtype, [TypedArray, dataViewGetter, itkComponent]]) => map.set(dtype, { TypedArray, dataViewGetter, itkComponent }), /* @__PURE__ */ new Map());
var getType = (dtype) => dtype.replace(/^(<|>|=|\|)/, "");
var getSize = (dtype) => {
  const type = getType(dtype);
  return type.length < 2 ? 1 : Number(type.slice(-1));
};
var getComponentType = (dtype) => dtypeUtils.get(getType(dtype)).itkComponent;
var getDtype = (typedArrayConstructor, endianness = "<") => {
  const typedArrayToDtype = new Map(Array.from(dtypeUtils).map(([key, { TypedArray }]) => [TypedArray, key]));
  return `${endianness}${typedArrayToDtype.get(typedArrayConstructor)}`;
};

// node_modules/@itk-viewer/blosc-zarr/bloscZarrDecompress.js
var cores = navigator.hardwareConcurrency ? navigator.hardwareConcurrency : 4;
var numberOfWorkers = cores + Math.floor(Math.sqrt(cores));
var workerPool = new worker_pool_default(numberOfWorkers, run_pipeline_default);
function bloscZarrDecompress(chunkData) {
  return __async(this, null, function* () {
    const options = {
      pipelineBaseUrl: getPipelinesBaseUrl(),
      pipelineWorkerUrl: getPipelineWorkerUrl()
    };
    const desiredOutputs = [{ type: interface_types_default.BinaryStream }];
    const taskArgsArray = [];
    let dtype = null;
    for (let index2 = 0; index2 < chunkData.length; index2++) {
      const zarrayMetadata = chunkData[index2].metadata;
      const compressedChunk = chunkData[index2].data;
      dtype = zarrayMetadata.dtype;
      const nElements = zarrayMetadata.chunks.reduce((a4, b3) => a4 * b3);
      const elementSize = getSize(dtype);
      if (!elementSize) throw Error("Unknown dtype in .zarray metadata");
      const outputSize = nElements * elementSize;
      const inputs = [
        {
          type: interface_types_default.BinaryStream,
          data: { data: new Uint8Array(compressedChunk) }
        }
      ];
      const args = [
        "0",
        "0",
        zarrayMetadata.compressor.cname,
        compressedChunk.byteLength.toString(),
        "--output-size",
        outputSize.toString(),
        "--decompress",
        "--memory-io"
      ];
      taskArgsArray.push(["BloscZarr", args, desiredOutputs, inputs, options]);
    }
    const results = yield workerPool.runTasks(taskArgsArray).promise;
    return results.map((result) => result.outputs[0].data.data.buffer);
  });
}

// node_modules/@itk-viewer/io/dist/componentTypeToTypedArray.js
var componentTypeToTypedArray = /* @__PURE__ */ new Map([
  [int_types_default.Int8, Int8Array],
  [int_types_default.UInt8, Uint8Array],
  [int_types_default.Int16, Int16Array],
  [int_types_default.UInt16, Uint16Array],
  [int_types_default.Int32, Int32Array],
  [int_types_default.UInt32, Uint32Array],
  [float_types_default.Float32, Float32Array],
  [float_types_default.Float64, Float64Array]
]);

// node_modules/@itk-viewer/io/dist/dimensionUtils.js
var CXYZT = Object.freeze(["c", "x", "y", "z", "t"]);
var ensuredDims = (defaultValue2, ensuredDims2, dimMap) => ensuredDims2.reduce((map, dim) => {
  var _a9;
  return map.set(dim, (_a9 = map.get(dim)) != null ? _a9 : defaultValue2);
}, new Map(dimMap));
var toDimensionMap = (dims, array) => new Map(dims.map((dim, i6) => [dim, array[i6]]));
var orderBy = (dims) => (map) => new Map(dims.map((dim) => {
  const value = map.get(dim);
  if (!value)
    throw new Error(`Dimension ${dim} not found in map ${map}`);
  return [dim, value];
}));
var chunk = (chunkSize, array) => {
  const chunks = [];
  for (let i6 = 0; i6 < array.length; i6 += chunkSize) {
    chunks.push(array.slice(i6, i6 + chunkSize));
  }
  return chunks;
};
var XYZ = Object.freeze(["x", "y", "z"]);

// node_modules/@itk-viewer/io/dist/transformBounds.js
function computeCornerPoints2(bounds, point1, point2) {
  point1[0] = bounds[0];
  point1[1] = bounds[2];
  point1[2] = bounds[4];
  point2[0] = bounds[1];
  point2[1] = bounds[3];
  point2[2] = bounds[5];
  return point1;
}
function computeBoundsFromPoints2(point1, point2, bounds) {
  bounds[0] = Math.min(point1[0], point2[0]);
  bounds[1] = Math.max(point1[0], point2[0]);
  bounds[2] = Math.min(point1[1], point2[1]);
  bounds[3] = Math.max(point1[1], point2[1]);
  bounds[4] = Math.min(point1[2], point2[2]);
  bounds[5] = Math.max(point1[2], point2[2]);
  return bounds;
}
var transformBounds2 = (transformingMat4, bounds) => {
  const in1 = Array(3);
  const in2 = Array(3);
  computeCornerPoints2(bounds, in1, in2);
  const out1 = Array(3);
  const out2 = Array(3);
  vec3_exports.transformMat4(out1, in1, transformingMat4);
  vec3_exports.transformMat4(out2, in2, transformingMat4);
  return computeBoundsFromPoints2(out1, out2, Array(6));
};

// node_modules/@itk-viewer/io/dist/MultiscaleSpatialImage.js
var import_meta2 = {};
function setMatrixElement(matrixData, columns, row, column, value) {
  matrixData[column + row * columns] = value;
}
var imageDataFromChunksWorker = new Worker(new URL("./ImageDataFromChunks.worker.js", import_meta2.url), { type: "module" });
var imageDataFromChunksProxy = wrap(imageDataFromChunksWorker);
function inflate2(bounds, delta) {
  bounds[0] -= delta;
  bounds[1] += delta;
  bounds[2] -= delta;
  bounds[3] += delta;
  bounds[4] -= delta;
  bounds[5] += delta;
  return bounds;
}
var extentToBounds = (ex, indexToWorld) => {
  const corners = [
    ex[0],
    ex[2],
    ex[4],
    ex[1],
    ex[2],
    ex[4],
    ex[0],
    ex[3],
    ex[4],
    ex[1],
    ex[3],
    ex[4],
    ex[0],
    ex[2],
    ex[5],
    ex[1],
    ex[2],
    ex[5],
    ex[0],
    ex[3],
    ex[5],
    ex[1],
    ex[3],
    ex[5]
  ];
  const idx = new Float32Array([corners[0], corners[1], corners[2]]);
  const vout = new Float32Array(3);
  vec3_exports.transformMat4(vout, idx, indexToWorld);
  const bounds = [
    vout[0],
    vout[0],
    vout[1],
    vout[1],
    vout[2],
    vout[2]
  ];
  for (let i6 = 3; i6 < 24; i6 += 3) {
    vec3_exports.set(idx, corners[i6], corners[i6 + 1], corners[i6 + 2]);
    vec3_exports.transformMat4(vout, idx, indexToWorld);
    if (vout[0] < bounds[0]) {
      bounds[0] = vout[0];
    }
    if (vout[1] < bounds[2]) {
      bounds[2] = vout[1];
    }
    if (vout[2] < bounds[4]) {
      bounds[4] = vout[2];
    }
    if (vout[0] > bounds[1]) {
      bounds[1] = vout[0];
    }
    if (vout[1] > bounds[3]) {
      bounds[3] = vout[1];
    }
    if (vout[2] > bounds[5]) {
      bounds[5] = vout[2];
    }
  }
  return bounds;
};
var ensure3dDirection = (d3) => {
  if (d3.length >= 9) {
    return mat3_exports.fromValues(d3[0], d3[1], d3[2], d3[3], d3[4], d3[5], d3[6], d3[7], d3[8]);
  }
  return mat3_exports.fromValues(d3[0], d3[1], 0, d3[2], d3[3], 0, 0, 0, 1);
};
var makeMat4 = ({ direction: direction2, origin: origin2, spacing }) => {
  const mat = mat4_exports.create();
  mat4_exports.fromTranslation(mat, origin2);
  mat[0] = direction2[0];
  mat[1] = direction2[1];
  mat[2] = direction2[2];
  mat[4] = direction2[3];
  mat[5] = direction2[4];
  mat[6] = direction2[5];
  mat[8] = direction2[6];
  mat[9] = direction2[7];
  mat[10] = direction2[8];
  return mat4_exports.scale(mat, mat, spacing);
};
var makeIndexToWorld = ({ direction: inDirection, origin: origin2, spacing }) => {
  const DIMENSIONS = 3;
  const direction2 = Array(inDirection.length);
  for (let idx = 0; idx < DIMENSIONS; ++idx) {
    for (let col = 0; col < DIMENSIONS; ++col) {
      direction2[col + idx * 3] = inDirection[idx + col * DIMENSIONS];
    }
  }
  const origin3d = [...origin2];
  if (origin3d[2] === void 0)
    origin3d[2] = 0;
  const spacing3d = [...spacing];
  if (spacing3d[2] === void 0)
    spacing3d[2] = 1;
  return makeMat4({ direction: direction2, origin: origin3d, spacing: spacing3d });
};
var worldBoundsToIndexBounds = ({ bounds, fullIndexBounds, worldToIndex }) => {
  const fullIndexBoundsWithZCT = ensuredDims([0, 1], CXYZT, fullIndexBounds);
  if (!bounds) {
    return fullIndexBoundsWithZCT;
  }
  const imageBounds = transformBounds2(worldToIndex, bounds);
  const imageBoundsByDim = chunk(2, imageBounds);
  const spaceBounds = ["x", "y", "z"].map((dim, idx) => {
    const [min5, max5] = fullIndexBoundsWithZCT.get(dim);
    const [bmin, bmax] = imageBoundsByDim[idx];
    return [
      dim,
      [
        Math.floor(Math.min(max5, Math.max(min5, bmin))),
        Math.ceil(Math.min(max5, Math.max(min5, bmax)))
      ]
    ];
  });
  const ctBounds = ["c", "t"].map((dim) => [dim, fullIndexBoundsWithZCT.get(dim)]);
  return new Map([...spaceBounds, ...ctBounds]);
};
function isContained(benchmarkBounds, testedBounds) {
  return Array.from(benchmarkBounds).every(([dim, [benchmarkMin, benchmarkMax]]) => {
    const testDimBounds = testedBounds.get(dim);
    if (!testDimBounds)
      throw new Error("Dimension not found");
    const [testedMin, testedMax] = testDimBounds;
    return benchmarkMin <= testedMin && testedMax <= benchmarkMax;
  });
}
function findImageInBounds({ cache: cache2, scale: scale7, bounds }) {
  var _a9, _b2;
  const imagesAtScale = (_a9 = cache2.get(scale7)) != null ? _a9 : [];
  return (_b2 = imagesAtScale.find(({ bounds: cachedBounds }) => isContained(cachedBounds, bounds))) == null ? void 0 : _b2.image;
}
function storeImage({ cache: cache2, scale: scale7, bounds, image: image2 }) {
  cache2.set(scale7, [{ bounds, image: image2 }]);
}
var MultiscaleSpatialImage = class {
  constructor(scaleInfos, imageType, name = "Image") {
    this.scaleInfos = [];
    this.name = "Image";
    this.scaleInfos = scaleInfos;
    this.name = name;
    this.imageType = imageType;
    const pixelType = componentTypeToTypedArray.get(imageType.componentType);
    if (!pixelType)
      throw new Error("Unsupported component type");
    this.pixelArrayType = pixelType;
    this.spatialDims = ["x", "y", "z"].slice(0, imageType.dimension);
    this.cachedImages = /* @__PURE__ */ new Map();
  }
  get coarsestScale() {
    return this.scaleInfos.length - 1;
  }
  scaleOrigin(scale7) {
    return __async(this, null, function* () {
      const info = this.scaleInfos[scale7];
      if (info.origin)
        return info.origin;
      const origin2 = new Array(this.spatialDims.length);
      for (let index2 = 0; index2 < this.spatialDims.length; index2++) {
        const dim = this.spatialDims[index2];
        if (info.coords.has(dim)) {
          const coords = yield info.coords.get(dim);
          if (!coords)
            throw new Error("No coords for dim: " + dim);
          origin2[index2] = coords[0];
        } else {
          origin2[index2] = 0;
        }
      }
      info.origin = origin2;
      return origin2;
    });
  }
  scaleSpacing(scale7) {
    return __async(this, null, function* () {
      const info = this.scaleInfos[scale7];
      if (info.spacing)
        return info.spacing;
      const spacing = new Array(this.spatialDims.length);
      for (let index2 = 0; index2 < this.spatialDims.length; index2++) {
        const dim = this.spatialDims[index2];
        const dimCoords = yield info.coords.get(dim);
        if (dimCoords && dimCoords.length >= 2) {
          spacing[index2] = dimCoords[1] - dimCoords[0];
        } else {
          spacing[index2] = 1;
        }
      }
      info.spacing = spacing;
      return spacing;
    });
  }
  get direction() {
    const dimension2 = this.imageType.dimension;
    const direction2 = new Float64Array(dimension2 * dimension2);
    const infoDirection = this.scaleInfos[0].direction;
    if (infoDirection) {
      const dims = this.scaleInfos[0].dims;
      for (let d1 = 0; d1 < dimension2; d1++) {
        const sd1 = this.spatialDims[d1];
        const di1 = dims.indexOf(sd1);
        for (let d22 = 0; d22 < dimension2; d22++) {
          const sd2 = this.spatialDims[d22];
          const di2 = dims.indexOf(sd2);
          setMatrixElement(direction2, dimension2, d1, d22, infoDirection[di1][di2]);
        }
      }
    } else {
      direction2.fill(0);
      for (let d3 = 0; d3 < dimension2; d3++) {
        setMatrixElement(direction2, dimension2, d3, d3, 1);
      }
    }
    return direction2;
  }
  /* Return a promise that provides the requested chunk at a given scale and
   * chunk index. */
  getChunks(scale7, cxyztArray) {
    return __async(this, null, function* () {
      return this.getChunksImpl(scale7, cxyztArray);
    });
  }
  getChunksImpl(_scale, _cxyztArray) {
    return __async(this, null, function* () {
      console.error("Override me in a derived class");
      return [];
    });
  }
  buildImage(scale7, indexBounds) {
    return __async(this, null, function* () {
      var _a9, _b2, _c;
      const { chunkSize, chunkCount, pixelArrayMetadata } = this.scaleInfos[scale7];
      const [indexToWorld, spacing] = yield Promise.all([
        this.scaleIndexToWorld(scale7),
        this.scaleSpacing(scale7)
      ]);
      const start = new Map(CXYZT.map((dim) => {
        var _a10, _b3;
        return [dim, (_b3 = (_a10 = indexBounds.get(dim)) == null ? void 0 : _a10[0]) != null ? _b3 : 0];
      }));
      const end = new Map(CXYZT.map((dim) => {
        var _a10, _b3;
        return [dim, ((_b3 = (_a10 = indexBounds.get(dim)) == null ? void 0 : _a10[1]) != null ? _b3 : 0) + 1];
      }));
      const arrayShape = new Map(CXYZT.map((dim) => [dim, end.get(dim) - start.get(dim)]));
      const startXYZ = new Float32Array(["x", "y", "z"].map((dim) => start.get(dim)));
      const origin2 = Array.from(vec3_exports.transformMat4(vec3_exports.create(), startXYZ, indexToWorld).slice(0, this.imageType.dimension));
      const chunkSizeWith1 = ensuredDims(1, CXYZT, chunkSize);
      const l5 = 0;
      const zChunkStart = Math.floor(start.get("z") / chunkSizeWith1.get("z"));
      const zChunkEnd = Math.ceil(end.get("z") / chunkSizeWith1.get("z"));
      const yChunkStart = Math.floor(start.get("y") / chunkSizeWith1.get("y"));
      const yChunkEnd = Math.ceil(end.get("y") / chunkSizeWith1.get("y"));
      const xChunkStart = Math.floor(start.get("x") / chunkSizeWith1.get("x"));
      const xChunkEnd = Math.ceil(end.get("x") / chunkSizeWith1.get("x"));
      const cChunkStart = 0;
      const cChunkEnd = (_a9 = chunkCount.get("c")) != null ? _a9 : 1;
      const chunkIndices = [];
      for (let k2 = zChunkStart; k2 < zChunkEnd; k2++) {
        for (let j2 = yChunkStart; j2 < yChunkEnd; j2++) {
          for (let i6 = xChunkStart; i6 < xChunkEnd; i6++) {
            for (let h5 = cChunkStart; h5 < cChunkEnd; h5++) {
              chunkIndices.push([h5, i6, j2, k2, l5]);
            }
          }
        }
      }
      const chunks = yield this.getChunks(scale7, chunkIndices);
      const preComputedRanges = this.scaleInfos[scale7].ranges;
      const args = {
        scaleInfo: {
          chunkSize: chunkSizeWith1,
          arrayShape,
          dtype: (_b2 = pixelArrayMetadata == null ? void 0 : pixelArrayMetadata.dtype) != null ? _b2 : getDtype(this.pixelArrayType)
        },
        imageType: this.imageType,
        chunkIndices,
        chunks,
        indexStart: start,
        indexEnd: end,
        areRangesNeeded: !preComputedRanges
      };
      const { pixelArray, ranges: ranges2 } = yield imageDataFromChunksProxy.imageDataFromChunks(args);
      const size3 = ["x", "y", "z"].slice(0, this.imageType.dimension).map((dim) => arrayShape.get(dim));
      return {
        imageType: this.imageType,
        name: (_c = this.scaleInfos[scale7].name) != null ? _c : "Default Image Name",
        origin: origin2,
        spacing,
        direction: this.direction,
        size: size3,
        data: pixelArray,
        ranges: preComputedRanges != null ? preComputedRanges : ranges2,
        metadata: /* @__PURE__ */ new Map()
      };
    });
  }
  scaleIndexToWorld(requestedScale) {
    return __async(this, null, function* () {
      const scale7 = Math.min(requestedScale, this.scaleInfos.length - 1);
      if (this.scaleInfos[scale7].indexToWorld)
        return this.scaleInfos[scale7].indexToWorld;
      const [origin2, spacing] = yield Promise.all([
        this.scaleOrigin(scale7),
        this.scaleSpacing(scale7)
      ]);
      const direction2 = ensure3dDirection(this.direction);
      const indexToWorld = makeIndexToWorld({
        direction: direction2,
        origin: origin2,
        spacing
      });
      this.scaleInfos[scale7].indexToWorld = indexToWorld;
      return indexToWorld;
    });
  }
  /* Retrieve bounded image at scale. */
  getImage(requestedScale, worldBounds = void 0) {
    return __async(this, null, function* () {
      const scale7 = Math.min(requestedScale, this.scaleInfos.length - 1);
      const indexToWorld = yield this.scaleIndexToWorld(scale7);
      const { dims } = this.scaleInfos[scale7];
      const indexBounds = orderBy(dims)(worldBoundsToIndexBounds({
        bounds: worldBounds,
        fullIndexBounds: this.getIndexBounds(scale7),
        worldToIndex: mat4_exports.invert(mat4_exports.create(), indexToWorld)
      }));
      const cachedImage = findImageInBounds({
        cache: this.cachedImages,
        scale: scale7,
        bounds: indexBounds
      });
      if (cachedImage)
        return cachedImage;
      const image2 = yield this.buildImage(scale7, indexBounds);
      storeImage({ cache: this.cachedImages, scale: scale7, bounds: indexBounds, image: image2 });
      return image2;
    });
  }
  getIndexBounds(scale7) {
    const { arrayShape } = this.scaleInfos[scale7];
    return new Map(Array.from(arrayShape).map(([dim, size3]) => [
      dim,
      [0, size3 - 1]
    ]));
  }
  getWorldBounds(scale7) {
    return __async(this, null, function* () {
      const indexToWorld = yield this.scaleIndexToWorld(scale7);
      const imageBounds = ensuredDims([0, 1], ["x", "y", "z"], this.getIndexBounds(scale7));
      const bounds = ["x", "y", "z"].flatMap((dim) => imageBounds.get(dim));
      inflate2(bounds, 0.5);
      return extentToBounds(bounds, indexToWorld);
    });
  }
};
var MultiscaleSpatialImage_default = MultiscaleSpatialImage;

// node_modules/@itk-viewer/io/dist/ZarrStoreParser.js
var isMetadata = (item) => [".zattrs", ".zgroup", ".zarray"].some((knownMetadataFile) => item.endsWith(knownMetadataFile));
var ZarrStoreParser = class {
  constructor(store) {
    this.store = store;
    this.decoder = new TextDecoder();
  }
  toJson(data) {
    return JSON.parse(this.decoder.decode(data));
  }
  getItem(item) {
    return __async(this, null, function* () {
      const data = yield this.store.getItem(item);
      return isMetadata(item) ? this.toJson(data) : data;
    });
  }
};

// node_modules/@itk-viewer/io/dist/HttpStore.js
var HttpStore = class {
  constructor(url) {
    this.href = url.href;
  }
  getItem(item) {
    return __async(this, null, function* () {
      const url = `${this.href}/${item}`;
      return (yield axios_default.get(url, { responseType: "arraybuffer" })).data;
    });
  }
};
var HttpStore_default = HttpStore;

// node_modules/zod/lib/index.mjs
var util;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj2 = {};
    for (const item of items) {
      obj2[item] = item;
    }
    return obj2;
  };
  util2.getValidEnumValues = (obj2) => {
    const validKeys = util2.objectKeys(obj2).filter((k2) => typeof obj2[obj2[k2]] !== "number");
    const filtered = {};
    for (const k2 of validKeys) {
      filtered[k2] = obj2[k2];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj2) => {
    return util2.objectKeys(obj2).map(function(e13) {
      return obj2[e13];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj2) => Object.keys(obj2) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_2, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return __spreadValues(__spreadValues({}, first), second);
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = (data) => {
  const t9 = typeof data;
  switch (t9) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = (obj2) => {
  const json = JSON.stringify(obj2, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};
var ZodError = class _ZodError extends Error {
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub5) => {
      this.issues = [...this.issues, sub5];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  get errors() {
    return this.issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i6 = 0;
          while (i6 < issue.path.length) {
            const el = issue.path[i6];
            const terminal = i6 === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i6++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof _ZodError)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub5 of this.issues) {
      if (sub5.path.length > 0) {
        fieldErrors[sub5.path[0]] = fieldErrors[sub5.path[0]] || [];
        fieldErrors[sub5.path[0]].push(mapper(sub5));
      } else {
        formErrors.push(mapper(sub5));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
var errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
var overrideErrorMap = errorMap;
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}
var makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = __spreadProps(__spreadValues({}, issueData), {
    path: fullPath
  });
  if (issueData.message !== void 0) {
    return __spreadProps(__spreadValues({}, issueData), {
      path: fullPath,
      message: issueData.message
    });
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m3) => !!m3).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return __spreadProps(__spreadValues({}, issueData), {
    path: fullPath,
    message: errorMessage
  });
};
var EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      overrideMap,
      overrideMap === errorMap ? void 0 : errorMap
      // then global default map
    ].filter((x2) => !!x2)
  });
  ctx.common.issues.push(issue);
}
var ParseStatus = class _ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s9 of results) {
      if (s9.status === "aborted")
        return INVALID;
      if (s9.status === "dirty")
        status.dirty();
      arrayValue.push(s9.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static mergeObjectAsync(status, pairs) {
    return __async(this, null, function* () {
      const syncPairs = [];
      for (const pair of pairs) {
        const key = yield pair.key;
        const value = yield pair.value;
        syncPairs.push({
          key,
          value
        });
      }
      return _ParseStatus.mergeObjectSync(status, syncPairs);
    });
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value) => ({ status: "dirty", value });
var OK = (value) => ({ status: "valid", value });
var isAborted = (x2) => x2.status === "aborted";
var isDirty = (x2) => x2.status === "dirty";
var isValid2 = (x2) => x2.status === "valid";
var isAsync = (x2) => typeof Promise !== "undefined" && x2 instanceof Promise;
function __classPrivateFieldGet(receiver, state, kind, f5) {
  if (kind === "a" && !f5) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f5 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f5 : kind === "a" ? f5.call(receiver) : f5 ? f5.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f5) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f5) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f5 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f5.call(receiver, value) : f5 ? f5.value = value : state.set(receiver, value), value;
}
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));
var _ZodEnum_cache;
var _ZodNativeEnum_cache;
var ParseInputLazyPath = class {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
var handleResult = (ctx, result) => {
  if (isValid2(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    var _a9, _b2;
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message !== null && message !== void 0 ? message : ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: (_a9 = message !== null && message !== void 0 ? message : required_error) !== null && _a9 !== void 0 ? _a9 : ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: (_b2 = message !== null && message !== void 0 ? message : invalid_type_error) !== null && _b2 !== void 0 ? _b2 : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
var ZodType = class {
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a9;
    const ctx = {
      common: {
        issues: [],
        async: (_a9 = params === null || params === void 0 ? void 0 : params.async) !== null && _a9 !== void 0 ? _a9 : false,
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  parseAsync(data, params) {
    return __async(this, null, function* () {
      const result = yield this.safeParseAsync(data, params);
      if (result.success)
        return result.data;
      throw result.error;
    });
  }
  safeParseAsync(data, params) {
    return __async(this, null, function* () {
      const ctx = {
        common: {
          issues: [],
          contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
          async: true
        },
        path: (params === null || params === void 0 ? void 0 : params.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data,
        parsedType: getParsedType(data)
      };
      const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
      const result = yield isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult);
      return handleResult(ctx, result);
    });
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue(__spreadValues({
        code: ZodIssueCode.custom
      }, getIssueProperties(val)));
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this, this._def);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform2) {
    return new ZodEffects(__spreadProps(__spreadValues({}, processCreateParams(this._def)), {
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform: transform2 }
    }));
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault(__spreadProps(__spreadValues({}, processCreateParams(this._def)), {
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    }));
  }
  brand() {
    return new ZodBranded(__spreadValues({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this
    }, processCreateParams(this._def)));
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch(__spreadProps(__spreadValues({}, processCreateParams(this._def)), {
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    }));
  }
  describe(description) {
    const This = this.constructor;
    return new This(__spreadProps(__spreadValues({}, this._def), {
      description
    }));
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[0-9a-z]+$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var nanoidRegex = /^[a-z0-9_-]{21}$/i;
var durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
var emojiRegex;
var ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
var base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
var dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
var dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let regex = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
  if (args.precision) {
    regex = `${regex}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    regex = `${regex}(\\.\\d+)?`;
  }
  return regex;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
var ZodString = class _ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a9) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), __spreadValues({
      validation,
      code: ZodIssueCode.invalid_string
    }, errorUtil.errToObj(message)));
  }
  _addCheck(check) {
    return new _ZodString(__spreadProps(__spreadValues({}, this._def), {
      checks: [...this._def.checks, check]
    }));
  }
  email(message) {
    return this._addCheck(__spreadValues({ kind: "email" }, errorUtil.errToObj(message)));
  }
  url(message) {
    return this._addCheck(__spreadValues({ kind: "url" }, errorUtil.errToObj(message)));
  }
  emoji(message) {
    return this._addCheck(__spreadValues({ kind: "emoji" }, errorUtil.errToObj(message)));
  }
  uuid(message) {
    return this._addCheck(__spreadValues({ kind: "uuid" }, errorUtil.errToObj(message)));
  }
  nanoid(message) {
    return this._addCheck(__spreadValues({ kind: "nanoid" }, errorUtil.errToObj(message)));
  }
  cuid(message) {
    return this._addCheck(__spreadValues({ kind: "cuid" }, errorUtil.errToObj(message)));
  }
  cuid2(message) {
    return this._addCheck(__spreadValues({ kind: "cuid2" }, errorUtil.errToObj(message)));
  }
  ulid(message) {
    return this._addCheck(__spreadValues({ kind: "ulid" }, errorUtil.errToObj(message)));
  }
  base64(message) {
    return this._addCheck(__spreadValues({ kind: "base64" }, errorUtil.errToObj(message)));
  }
  ip(options) {
    return this._addCheck(__spreadValues({ kind: "ip" }, errorUtil.errToObj(options)));
  }
  datetime(options) {
    var _a9, _b2;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck(__spreadValues({
      kind: "datetime",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      offset: (_a9 = options === null || options === void 0 ? void 0 : options.offset) !== null && _a9 !== void 0 ? _a9 : false,
      local: (_b2 = options === null || options === void 0 ? void 0 : options.local) !== null && _b2 !== void 0 ? _b2 : false
    }, errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)));
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck(__spreadValues({
      kind: "time",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision
    }, errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)));
  }
  duration(message) {
    return this._addCheck(__spreadValues({ kind: "duration" }, errorUtil.errToObj(message)));
  }
  regex(regex, message) {
    return this._addCheck(__spreadValues({
      kind: "regex",
      regex
    }, errorUtil.errToObj(message)));
  }
  includes(value, options) {
    return this._addCheck(__spreadValues({
      kind: "includes",
      value,
      position: options === null || options === void 0 ? void 0 : options.position
    }, errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)));
  }
  startsWith(value, message) {
    return this._addCheck(__spreadValues({
      kind: "startsWith",
      value
    }, errorUtil.errToObj(message)));
  }
  endsWith(value, message) {
    return this._addCheck(__spreadValues({
      kind: "endsWith",
      value
    }, errorUtil.errToObj(message)));
  }
  min(minLength, message) {
    return this._addCheck(__spreadValues({
      kind: "min",
      value: minLength
    }, errorUtil.errToObj(message)));
  }
  max(maxLength, message) {
    return this._addCheck(__spreadValues({
      kind: "max",
      value: maxLength
    }, errorUtil.errToObj(message)));
  }
  length(len4, message) {
    return this._addCheck(__spreadValues({
      kind: "length",
      value: len4
    }, errorUtil.errToObj(message)));
  }
  /**
   * @deprecated Use z.string().min(1) instead.
   * @see {@link ZodString.min}
   */
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new _ZodString(__spreadProps(__spreadValues({}, this._def), {
      checks: [...this._def.checks, { kind: "trim" }]
    }));
  }
  toLowerCase() {
    return new _ZodString(__spreadProps(__spreadValues({}, this._def), {
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    }));
  }
  toUpperCase() {
    return new _ZodString(__spreadProps(__spreadValues({}, this._def), {
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    }));
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get minLength() {
    let min5 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min5 === null || ch.value > min5)
          min5 = ch.value;
      }
    }
    return min5;
  }
  get maxLength() {
    let max5 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max5 === null || ch.value < max5)
          max5 = ch.value;
      }
    }
    return max5;
  }
};
ZodString.create = (params) => {
  var _a9;
  return new ZodString(__spreadValues({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a9 = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a9 !== void 0 ? _a9 : false
  }, processCreateParams(params)));
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
var ZodNumber = class _ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodNumber(__spreadProps(__spreadValues({}, this._def), {
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    }));
  }
  _addCheck(check) {
    return new _ZodNumber(__spreadProps(__spreadValues({}, this._def), {
      checks: [...this._def.checks, check]
    }));
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min5 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min5 === null || ch.value > min5)
          min5 = ch.value;
      }
    }
    return min5;
  }
  get maxValue() {
    let max5 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max5 === null || ch.value < max5)
          max5 = ch.value;
      }
    }
    return max5;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max5 = null, min5 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min5 === null || ch.value > min5)
          min5 = ch.value;
      } else if (ch.kind === "max") {
        if (max5 === null || ch.value < max5)
          max5 = ch.value;
      }
    }
    return Number.isFinite(min5) && Number.isFinite(max5);
  }
};
ZodNumber.create = (params) => {
  return new ZodNumber(__spreadValues({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false
  }, processCreateParams(params)));
};
var ZodBigInt = class _ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = BigInt(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodBigInt(__spreadProps(__spreadValues({}, this._def), {
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    }));
  }
  _addCheck(check) {
    return new _ZodBigInt(__spreadProps(__spreadValues({}, this._def), {
      checks: [...this._def.checks, check]
    }));
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min5 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min5 === null || ch.value > min5)
          min5 = ch.value;
      }
    }
    return min5;
  }
  get maxValue() {
    let max5 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max5 === null || ch.value < max5)
          max5 = ch.value;
      }
    }
    return max5;
  }
};
ZodBigInt.create = (params) => {
  var _a9;
  return new ZodBigInt(__spreadValues({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a9 = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a9 !== void 0 ? _a9 : false
  }, processCreateParams(params)));
};
var ZodBoolean = class extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodBoolean.create = (params) => {
  return new ZodBoolean(__spreadValues({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false
  }, processCreateParams(params)));
};
var ZodDate = class _ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new _ZodDate(__spreadProps(__spreadValues({}, this._def), {
      checks: [...this._def.checks, check]
    }));
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min5 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min5 === null || ch.value > min5)
          min5 = ch.value;
      }
    }
    return min5 != null ? new Date(min5) : null;
  }
  get maxDate() {
    let max5 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max5 === null || ch.value < max5)
          max5 = ch.value;
      }
    }
    return max5 != null ? new Date(max5) : null;
  }
};
ZodDate.create = (params) => {
  return new ZodDate(__spreadValues({
    checks: [],
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate
  }, processCreateParams(params)));
};
var ZodSymbol = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodSymbol.create = (params) => {
  return new ZodSymbol(__spreadValues({
    typeName: ZodFirstPartyTypeKind.ZodSymbol
  }, processCreateParams(params)));
};
var ZodUndefined = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodUndefined.create = (params) => {
  return new ZodUndefined(__spreadValues({
    typeName: ZodFirstPartyTypeKind.ZodUndefined
  }, processCreateParams(params)));
};
var ZodNull = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodNull.create = (params) => {
  return new ZodNull(__spreadValues({
    typeName: ZodFirstPartyTypeKind.ZodNull
  }, processCreateParams(params)));
};
var ZodAny = class extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodAny.create = (params) => {
  return new ZodAny(__spreadValues({
    typeName: ZodFirstPartyTypeKind.ZodAny
  }, processCreateParams(params)));
};
var ZodUnknown = class extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodUnknown.create = (params) => {
  return new ZodUnknown(__spreadValues({
    typeName: ZodFirstPartyTypeKind.ZodUnknown
  }, processCreateParams(params)));
};
var ZodNever = class extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
};
ZodNever.create = (params) => {
  return new ZodNever(__spreadValues({
    typeName: ZodFirstPartyTypeKind.ZodNever
  }, processCreateParams(params)));
};
var ZodVoid = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodVoid.create = (params) => {
  return new ZodVoid(__spreadValues({
    typeName: ZodFirstPartyTypeKind.ZodVoid
  }, processCreateParams(params)));
};
var ZodArray = class _ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i6) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i6));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i6) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i6));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new _ZodArray(__spreadProps(__spreadValues({}, this._def), {
      minLength: { value: minLength, message: errorUtil.toString(message) }
    }));
  }
  max(maxLength, message) {
    return new _ZodArray(__spreadProps(__spreadValues({}, this._def), {
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    }));
  }
  length(len4, message) {
    return new _ZodArray(__spreadProps(__spreadValues({}, this._def), {
      exactLength: { value: len4, message: errorUtil.toString(message) }
    }));
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray.create = (schema, params) => {
  return new ZodArray(__spreadValues({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray
  }, processCreateParams(params)));
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject(__spreadProps(__spreadValues({}, schema._def), {
      shape: () => newShape
    }));
  } else if (schema instanceof ZodArray) {
    return new ZodArray(__spreadProps(__spreadValues({}, schema._def), {
      type: deepPartialify(schema.element)
    }));
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
var ZodObject = class _ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(() => __async(this, null, function* () {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = yield pair.key;
          const value = yield pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      })).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new _ZodObject(__spreadValues(__spreadProps(__spreadValues({}, this._def), {
      unknownKeys: "strict"
    }), message !== void 0 ? {
      errorMap: (issue, ctx) => {
        var _a9, _b2, _c, _d;
        const defaultError = (_c = (_b2 = (_a9 = this._def).errorMap) === null || _b2 === void 0 ? void 0 : _b2.call(_a9, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
        if (issue.code === "unrecognized_keys")
          return {
            message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
          };
        return {
          message: defaultError
        };
      }
    } : {}));
  }
  strip() {
    return new _ZodObject(__spreadProps(__spreadValues({}, this._def), {
      unknownKeys: "strip"
    }));
  }
  passthrough() {
    return new _ZodObject(__spreadProps(__spreadValues({}, this._def), {
      unknownKeys: "passthrough"
    }));
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new _ZodObject(__spreadProps(__spreadValues({}, this._def), {
      shape: () => __spreadValues(__spreadValues({}, this._def.shape()), augmentation)
    }));
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new _ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => __spreadValues(__spreadValues({}, this._def.shape()), merging._def.shape()),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index2) {
    return new _ZodObject(__spreadProps(__spreadValues({}, this._def), {
      catchall: index2
    }));
  }
  pick(mask) {
    const shape = {};
    util.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new _ZodObject(__spreadProps(__spreadValues({}, this._def), {
      shape: () => shape
    }));
  }
  omit(mask) {
    const shape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new _ZodObject(__spreadProps(__spreadValues({}, this._def), {
      shape: () => shape
    }));
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new _ZodObject(__spreadProps(__spreadValues({}, this._def), {
      shape: () => newShape
    }));
  }
  required(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new _ZodObject(__spreadProps(__spreadValues({}, this._def), {
      shape: () => newShape
    }));
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
};
ZodObject.create = (shape, params) => {
  return new ZodObject(__spreadValues({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject
  }, processCreateParams(params)));
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject(__spreadValues({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject
  }, processCreateParams(params)));
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject(__spreadValues({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject
  }, processCreateParams(params)));
};
var ZodUnion = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map((option) => __async(this, null, function* () {
        const childCtx = __spreadProps(__spreadValues({}, ctx), {
          common: __spreadProps(__spreadValues({}, ctx.common), {
            issues: []
          }),
          parent: null
        });
        return {
          result: yield option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      }))).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = __spreadProps(__spreadValues({}, ctx), {
          common: __spreadProps(__spreadValues({}, ctx.common), {
            issues: []
          }),
          parent: null
        });
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion.create = (types, params) => {
  return new ZodUnion(__spreadValues({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion
  }, processCreateParams(params)));
};
var getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return util.objectValues(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [void 0];
  } else if (type instanceof ZodNull) {
    return [null];
  } else if (type instanceof ZodOptional) {
    return [void 0, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodNullable) {
    return [null, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodBranded) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodReadonly) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodCatch) {
    return getDiscriminator(type._def.innerType);
  } else {
    return [];
  }
};
var ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new _ZodDiscriminatedUnion(__spreadValues({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap
    }, processCreateParams(params)));
  }
};
function mergeValues(a4, b3) {
  const aType = getParsedType(a4);
  const bType = getParsedType(b3);
  if (a4 === b3) {
    return { valid: true, data: a4 };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b3);
    const sharedKeys = util.objectKeys(a4).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = __spreadValues(__spreadValues({}, a4), b3);
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a4[key], b3[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a4.length !== b3.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index2 = 0; index2 < a4.length; index2++) {
      const itemA = a4[index2];
      const itemB = b3[index2];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a4 === +b3) {
    return { valid: true, data: a4 };
  } else {
    return { valid: false };
  }
}
var ZodIntersection = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection(__spreadValues({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection
  }, processCreateParams(params)));
};
var ZodTuple = class _ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x2) => !!x2);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new _ZodTuple(__spreadProps(__spreadValues({}, this._def), {
      rest
    }));
  }
};
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple(__spreadValues({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null
  }, processCreateParams(params)));
};
var ZodRecord = class _ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new _ZodRecord(__spreadValues({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord
      }, processCreateParams(third)));
    }
    return new _ZodRecord(__spreadValues({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord
    }, processCreateParams(second)));
  }
};
var ZodMap = class extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index2) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index2, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index2, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(() => __async(this, null, function* () {
        for (const pair of pairs) {
          const key = yield pair.key;
          const value = yield pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      }));
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap(__spreadValues({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap
  }, processCreateParams(params)));
};
var ZodSet = class _ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i6) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i6)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new _ZodSet(__spreadProps(__spreadValues({}, this._def), {
      minSize: { value: minSize, message: errorUtil.toString(message) }
    }));
  }
  max(maxSize, message) {
    return new _ZodSet(__spreadProps(__spreadValues({}, this._def), {
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    }));
  }
  size(size3, message) {
    return this.min(size3, message).max(size3, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet.create = (valueType, params) => {
  return new ZodSet(__spreadValues({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet
  }, processCreateParams(params)));
};
var ZodFunction = class _ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x2) => !!x2),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x2) => !!x2),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(function(...args) {
        return __async(this, null, function* () {
          const error = new ZodError([]);
          const parsedArgs = yield me._def.args.parseAsync(args, params).catch((e13) => {
            error.addIssue(makeArgsIssue(args, e13));
            throw error;
          });
          const result = yield Reflect.apply(fn, this, parsedArgs);
          const parsedReturns = yield me._def.returns._def.type.parseAsync(result, params).catch((e13) => {
            error.addIssue(makeReturnsIssue(result, e13));
            throw error;
          });
          return parsedReturns;
        });
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new _ZodFunction(__spreadProps(__spreadValues({}, this._def), {
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    }));
  }
  returns(returnType) {
    return new _ZodFunction(__spreadProps(__spreadValues({}, this._def), {
      returns: returnType
    }));
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new _ZodFunction(__spreadValues({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction
    }, processCreateParams(params)));
  }
};
var ZodLazy = class extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy.create = (getter, params) => {
  return new ZodLazy(__spreadValues({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy
  }, processCreateParams(params)));
};
var ZodLiteral = class extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral.create = (value, params) => {
  return new ZodLiteral(__spreadValues({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral
  }, processCreateParams(params)));
};
function createZodEnum(values, params) {
  return new ZodEnum(__spreadValues({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum
  }, processCreateParams(params)));
}
var ZodEnum = class _ZodEnum extends ZodType {
  constructor() {
    super(...arguments);
    _ZodEnum_cache.set(this, void 0);
  }
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f")) {
      __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values), "f");
    }
    if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f").has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return _ZodEnum.create(values, __spreadValues(__spreadValues({}, this._def), newDef));
  }
  exclude(values, newDef = this._def) {
    return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), __spreadValues(__spreadValues({}, this._def), newDef));
  }
};
_ZodEnum_cache = /* @__PURE__ */ new WeakMap();
ZodEnum.create = createZodEnum;
var ZodNativeEnum = class extends ZodType {
  constructor() {
    super(...arguments);
    _ZodNativeEnum_cache.set(this, void 0);
  }
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f")) {
      __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util.getValidEnumValues(this._def.values)), "f");
    }
    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f").has(input.data)) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
_ZodNativeEnum_cache = /* @__PURE__ */ new WeakMap();
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum(__spreadValues({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum
  }, processCreateParams(params)));
};
var ZodPromise = class extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise.create = (schema, params) => {
  return new ZodPromise(__spreadValues({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise
  }, processCreateParams(params)));
};
var ZodEffects = class extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then((processed2) => __async(this, null, function* () {
          if (status.value === "aborted")
            return INVALID;
          const result = yield this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        }));
      } else {
        if (status.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid2(base))
          return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid2(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util.assertNever(effect);
  }
};
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects(__spreadValues({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect
  }, processCreateParams(params)));
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects(__spreadValues({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects
  }, processCreateParams(params)));
};
var ZodOptional = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional.create = (type, params) => {
  return new ZodOptional(__spreadValues({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional
  }, processCreateParams(params)));
};
var ZodNullable = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable.create = (type, params) => {
  return new ZodNullable(__spreadValues({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable
  }, processCreateParams(params)));
};
var ZodDefault = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault.create = (type, params) => {
  return new ZodDefault(__spreadValues({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default
  }, processCreateParams(params)));
};
var ZodCatch = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = __spreadProps(__spreadValues({}, ctx), {
      common: __spreadProps(__spreadValues({}, ctx.common), {
        issues: []
      })
    });
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: __spreadValues({}, newCtx)
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch.create = (type, params) => {
  return new ZodCatch(__spreadValues({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch
  }, processCreateParams(params)));
};
var ZodNaN = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN.create = (params) => {
  return new ZodNaN(__spreadValues({
    typeName: ZodFirstPartyTypeKind.ZodNaN
  }, processCreateParams(params)));
};
var BRAND = Symbol("zod_brand");
var ZodBranded = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
var ZodPipeline = class _ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = () => __async(this, null, function* () {
        const inResult = yield this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      });
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a4, b3) {
    return new _ZodPipeline({
      in: a4,
      out: b3,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
};
var ZodReadonly = class extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid2(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodReadonly.create = (type, params) => {
  return new ZodReadonly(__spreadValues({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly
  }, processCreateParams(params)));
};
function custom(check, params = {}, fatal) {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a9, _b2;
      if (!check(data)) {
        const p3 = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
        const _fatal = (_b2 = (_a9 = p3.fatal) !== null && _a9 !== void 0 ? _a9 : fatal) !== null && _b2 !== void 0 ? _b2 : true;
        const p22 = typeof p3 === "string" ? { message: p3 } : p3;
        ctx.addIssue(__spreadProps(__spreadValues({ code: "custom" }, p22), { fatal: _fatal }));
      }
    });
  return ZodAny.create();
}
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = () => stringType().optional();
var onumber = () => numberType().optional();
var oboolean = () => booleanType().optional();
var coerce = {
  string: (arg) => ZodString.create(__spreadProps(__spreadValues({}, arg), { coerce: true })),
  number: (arg) => ZodNumber.create(__spreadProps(__spreadValues({}, arg), { coerce: true })),
  boolean: (arg) => ZodBoolean.create(__spreadProps(__spreadValues({}, arg), {
    coerce: true
  })),
  bigint: (arg) => ZodBigInt.create(__spreadProps(__spreadValues({}, arg), { coerce: true })),
  date: (arg) => ZodDate.create(__spreadProps(__spreadValues({}, arg), { coerce: true }))
};
var NEVER = INVALID;
var z2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid: isValid2,
  isAsync,
  get util() {
    return util;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  datetimeRegex,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  ZodReadonly,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  "enum": enumType,
  "function": functionType,
  "instanceof": instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  "null": nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  "undefined": undefinedType,
  union: unionType,
  unknown: unknownType,
  "void": voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});

// node_modules/@itk-viewer/io/dist/ngff-validator.js
var direction = z2.array(z2.array(z2.number()).length(3)).length(3);
var ranges = z2.array(z2.array(z2.number()).length(2));
var dimension = z2.enum(["x", "y", "z", "c", "t"]);
var axis = z2.object({
  name: dimension,
  type: z2.enum(["channel", "time", "space"]).optional()
});
var customNgffProperties = {
  direction: direction.optional(),
  ranges: ranges.optional()
};
var transform = z2.union([
  z2.object({
    type: z2.enum(["scale"]),
    scale: z2.array(z2.number()).min(2)
  }),
  z2.object({
    type: z2.enum(["translation"]),
    translation: z2.array(z2.number()).min(2)
  })
]);
var coordinateTransformations = z2.array(transform).min(1);
var IMAGE_VERSION_DEFAULT = "0.4";
var image = {
  "0.4": z2.object({
    // array of NgffImage
    multiscales: z2.array(z2.object(__spreadValues({
      name: z2.string().optional(),
      datasets: z2.array(z2.object({
        path: z2.string(),
        coordinateTransformations
      })).min(1),
      version: z2.enum(["0.4"]).optional(),
      axes: z2.array(axis).min(2).max(5),
      coordinateTransformations: coordinateTransformations.optional()
    }, customNgffProperties))).min(1).describe("The multiscale datasets for this image"),
    omero: z2.object({
      channels: z2.array(z2.object({
        window: z2.object({
          end: z2.number(),
          max: z2.number().optional(),
          // optional looser than spec
          min: z2.number().optional(),
          // optional looser than spec
          start: z2.number()
        }),
        label: z2.string().optional(),
        family: z2.string().optional(),
        color: z2.string(),
        active: z2.boolean().optional()
      }))
    }).optional()
  }).describe("JSON from OME-NGFF .zattrs"),
  "0.1": z2.object({
    multiscales: z2.array(z2.object(__spreadValues({
      name: z2.string().optional(),
      datasets: z2.array(z2.object({ path: z2.string() })).min(1),
      version: z2.enum(["0.1"]).optional(),
      metadata: z2.object({
        method: z2.string().optional(),
        version: z2.string().optional()
      }).optional()
    }, customNgffProperties))).min(1).describe("The multiscale datasets for this image"),
    omero: z2.object({
      channels: z2.array(z2.object({
        window: z2.object({
          end: z2.number(),
          max: z2.number().optional(),
          // optional looser than spec
          min: z2.number().optional(),
          // optional looser than spec
          start: z2.number()
        }),
        label: z2.string().optional(),
        family: z2.string().optional(),
        color: z2.string(),
        active: z2.boolean().optional()
      }))
    }).optional()
  }).describe("JSON from OME-NGFF .zattrs")
};
var datasetZattrs = z2.object(__spreadValues({
  _ARRAY_DIMENSIONS: z2.array(dimension).optional()
}, customNgffProperties));
var zArray = z2.object({
  shape: z2.array(z2.number()),
  chunks: z2.array(z2.number()),
  dtype: z2.string(),
  compressor: z2.object({
    cname: z2.enum(["raw", "zlib", "blosc", "bzip2", "lz4", "lz4hc", "zstd"]),
    blocksize: z2.number().optional(),
    clevel: z2.number().optional(),
    shuffle: z2.number().optional()
  }),
  dimension_separator: z2.string().optional()
});

// node_modules/@itk-viewer/io/dist/ZarrMultiscaleSpatialImage.js
var MAX_CONCURRENCY = 1e3;
var TCZYX = Object.freeze([
  "t",
  "c",
  "z",
  "y",
  "x"
]);
var composeTransforms = (transforms = [], dimCount) => transforms.reduce(({ scale: scale7, translation: translation2 }, transform2) => {
  if (transform2.type === "scale") {
    const { scale: transformScale } = transform2;
    return {
      scale: scale7.map((s9, i6) => s9 * transformScale[i6]),
      translation: translation2.map((t9, i6) => t9 * transformScale[i6])
    };
  }
  if (transform2.type === "translation") {
    const { translation: transformTranslation } = transform2;
    return {
      scale: scale7,
      translation: translation2.map((t9, i6) => t9 + transformTranslation[i6])
    };
  }
  const _exhaustiveCheck = transform2;
  throw new Error(`unknown transform type ${_exhaustiveCheck}`);
}, { scale: Array(dimCount).fill(1), translation: Array(dimCount).fill(0) });
var getComposedTransformation = (image2, dimCount) => {
  const coordinateTransformations2 = "coordinateTransformations" in image2 ? image2.coordinateTransformations : [];
  return composeTransforms(coordinateTransformations2, dimCount);
};
var computeTransform = (imageMetadata, datasetMetadata, dimCount) => {
  const global2 = getComposedTransformation(imageMetadata, dimCount);
  const dataset = getComposedTransformation(datasetMetadata, dimCount);
  return composeTransforms([
    { type: "scale", scale: dataset.scale },
    { type: "translation", translation: dataset.translation },
    { type: "scale", scale: global2.scale },
    { type: "translation", translation: global2.translation }
  ], dimCount);
};
var ensureScaleTransforms = (datasetsWithArrayMetadata) => {
  const hasDatasetCoordinateTransform = datasetsWithArrayMetadata.some(({ dataset }) => "coordinateTransformations" in dataset);
  if (hasDatasetCoordinateTransform)
    return datasetsWithArrayMetadata;
  const targetSize = datasetsWithArrayMetadata[0].pixelArrayMetadata.shape;
  return datasetsWithArrayMetadata.map(({ dataset, pixelArrayMetadata }) => {
    const { shape } = pixelArrayMetadata;
    const scale7 = targetSize.map((target, idx) => target / shape[idx]);
    return {
      dataset: __spreadProps(__spreadValues({}, dataset), {
        coordinateTransformations: [
          { scale: scale7, type: "scale" }
        ]
      }),
      pixelArrayMetadata
    };
  });
};
var makeCoords = ({ shape, multiscaleImage, dataset }) => {
  const axes = getAxisNames(multiscaleImage);
  const coords = new Map(axes.map((dim) => [dim, void 0]));
  const { scale: spacingDataset, translation: originDataset } = computeTransform(multiscaleImage, dataset, axes.length);
  return {
    get(dim) {
      if (!coords.get(dim)) {
        const dimIdx = axes.indexOf(dim);
        const spacing = spacingDataset[dimIdx];
        const origin2 = originDataset[dimIdx];
        const coordsPerElement = new Float32Array(shape[dimIdx]);
        for (let i6 = 0; i6 < coordsPerElement.length; i6++) {
          coordsPerElement[i6] = i6 * spacing + origin2;
        }
        coords.set(dim, coordsPerElement);
      }
      return coords.get(dim);
    },
    has(dim) {
      return axes.includes(dim);
    }
  };
};
var findAxesLongNames = (_0) => __async(void 0, [_0], function* ({ dataset, dataSource, dims }) {
  const upOneLevel = dataset.path.split("/").slice(0, -1).join("");
  return new Map(yield Promise.all(dims.map((dim) => dataSource.getItem(`${upOneLevel}/${dim}/.zattrs`))).then((dimensionsZattrs) => dimensionsZattrs.map(({ long_name }, i6) => [dims[i6], long_name])));
});
var getAxisNames = (image2) => {
  if ("axes" in image2)
    return image2.axes.map((axis2) => typeof axis2 === "object" ? axis2.name : axis2);
  return TCZYX;
};
var createScaledImageInfo = (_0) => __async(void 0, [_0], function* ({ multiscaleImage, dataset, pixelArrayMetadata, dataSource, multiscaleSpatialImageVersion }) {
  var _a9, _b2, _c;
  const scaleZattrsRaw = multiscaleSpatialImageVersion && (yield dataSource.getItem(`${dataset.path}/.zattrs`)) || {};
  const scaleZattrs = datasetZattrs.parse(scaleZattrsRaw);
  const dims = (_a9 = scaleZattrs._ARRAY_DIMENSIONS) != null ? _a9 : getAxisNames(multiscaleImage);
  const { shape, chunks } = pixelArrayMetadata;
  const chunkSize = toDimensionMap(dims, chunks);
  const arrayShape = toDimensionMap(dims, shape);
  const axesNames = multiscaleSpatialImageVersion ? yield findAxesLongNames({ dataset, dataSource, dims }) : void 0;
  return {
    dims,
    pixelArrayMetadata,
    name: multiscaleImage.name,
    pixelArrayPath: dataset.path,
    coords: makeCoords({ shape, multiscaleImage, dataset }),
    ranges: (_b2 = scaleZattrs.ranges) != null ? _b2 : multiscaleImage.ranges,
    direction: (_c = scaleZattrs.direction) != null ? _c : multiscaleImage.direction,
    axesNames,
    chunkCount: toDimensionMap(
      dims,
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      dims.map((dim) => Math.ceil(arrayShape.get(dim) / chunkSize.get(dim)))
    ),
    chunkSize,
    arrayShape
  };
});
var extractScaleSpacing = (dataSource) => __async(void 0, null, function* () {
  var _a9, _b2;
  const zattrs = yield dataSource.getItem(".zattrs");
  const { multiscales, multiscaleSpatialImageVersion } = zattrs;
  const multiscaleImage = Array.isArray(multiscales) ? multiscales[0] : multiscales;
  const schemaVersion = (_a9 = multiscaleImage == null ? void 0 : multiscaleImage.version) != null ? _a9 : IMAGE_VERSION_DEFAULT;
  if (["0.1", "0.4"].includes(schemaVersion)) {
    image[schemaVersion].parse(zattrs);
  }
  const datasetsWithArrayMetadataRaw = yield Promise.all(multiscaleImage.datasets.map((dataset) => __async(void 0, null, function* () {
    return {
      dataset,
      pixelArrayMetadata: zArray.parse(yield dataSource.getItem(`${dataset.path}/.zarray`))
    };
  })));
  const datasetsWithArrayMetadata = ensureScaleTransforms(datasetsWithArrayMetadataRaw);
  const scaleInfo = yield Promise.all(datasetsWithArrayMetadata.map((_0) => __async(void 0, [_0], function* ({ dataset, pixelArrayMetadata }) {
    return createScaledImageInfo({
      multiscaleImage,
      dataset,
      pixelArrayMetadata,
      dataSource,
      multiscaleSpatialImageVersion
    });
  })));
  const info = scaleInfo[0];
  const components = (_b2 = info.arrayShape.get("c")) != null ? _b2 : 1;
  const imageType = {
    // How many spatial dimensions?  Count greater than 1, X Y Z elements because "axis" metadata not defined in ngff V0.1
    dimension: ["x", "y", "z"].map((dim) => info.arrayShape.get(dim)).filter((dim) => dim && dim > 1).length,
    pixelType: components === 1 ? pixel_types_default.Scalar : pixel_types_default.VariableLengthVector,
    componentType: getComponentType(info.pixelArrayMetadata.dtype),
    components
  };
  return { scaleInfo, imageType };
});
var ZarrMultiscaleSpatialImage = class _ZarrMultiscaleSpatialImage extends MultiscaleSpatialImage_default {
  // Store parameter is object with getItem (but not a ZarrStoreParser)
  static fromStore(store, maxConcurrency = void 0) {
    return __async(this, null, function* () {
      const zarrStoreParser = new ZarrStoreParser(store);
      const { scaleInfo, imageType } = yield extractScaleSpacing(zarrStoreParser);
      return new _ZarrMultiscaleSpatialImage(zarrStoreParser, scaleInfo, imageType, maxConcurrency);
    });
  }
  static fromUrl(url, maxConcurrency = void 0) {
    return __async(this, null, function* () {
      return _ZarrMultiscaleSpatialImage.fromStore(new HttpStore_default(url), maxConcurrency);
    });
  }
  // Use static factory functions to construct
  constructor(zarrStoreParser, scaleInfos, imageType, maxConcurrency = void 0) {
    super(scaleInfos, imageType);
    this.dataSource = zarrStoreParser;
    const concurrency = Math.min(window.navigator.hardwareConcurrency, maxConcurrency != null ? maxConcurrency : MAX_CONCURRENCY);
    this.rpcQueue = new PQueue({ concurrency });
  }
  getChunksImpl(scale7, cxyztArray) {
    return __async(this, null, function* () {
      const info = this.scaleInfos[scale7];
      const chunkPathBase = info.pixelArrayPath;
      const chunkPaths = [];
      const chunkPromises = [];
      const { dimension_separator: dimSeparator = "." } = info.pixelArrayMetadata ? info.pixelArrayMetadata : {};
      for (let index2 = 0; index2 < cxyztArray.length; index2++) {
        let chunkPath = `${chunkPathBase}/`;
        for (let dd = 0; dd < info.dims.length; dd++) {
          const dim = info.dims[dd];
          chunkPath = `${chunkPath}${cxyztArray[index2][CXYZT.indexOf(dim)]}${dimSeparator}`;
        }
        chunkPath = chunkPath.slice(0, -1);
        chunkPaths.push(chunkPath);
        chunkPromises.push(() => this.dataSource.getItem(chunkPath));
      }
      const compressedChunks = yield this.rpcQueue.addAll(chunkPromises);
      const toDecompress = [];
      for (let index2 = 0; index2 < compressedChunks.length; index2++) {
        toDecompress.push({
          data: compressedChunks[index2],
          metadata: info.pixelArrayMetadata
        });
      }
      return bloscZarrDecompress(toDecompress);
    });
  }
};

// src/viewer.client.tsx
var import_jsx_runtime = __toESM(require_jsx_runtime());
function ViewerClient({ imagePath }) {
  const viewer = (0, import_react2.useRef)(null);
  (0, import_react2.useEffect)(() => {
    const element = viewer.current;
    if (!element) {
      return;
    }
    const url = new URL(imagePath, document.location.origin);
    ZarrMultiscaleSpatialImage.fromUrl(url).then((image2) => {
      const actor = element.getActor();
      actor.send({ type: "setImage", image: image2, name: "image" });
    });
  }, [imagePath, viewer]);
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("itk-viewer-2d", { ref: viewer, style: { width: "100%", height: "100%" } });
}

// src/viewer.tsx
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
function SSRFallback() {
  return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("div", { style: { width: "100%", height: "100%" }, children: "Loading itk-viewer..." });
}
function Viewer({ imagePath }) {
  return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(ClientOnly, { fallback: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(SSRFallback, {}), children: () => /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(ViewerClient, { imagePath }) });
}
export {
  Viewer
};
/*! Bundled license information:

react/cjs/react.development.js:
  (**
   * @license React
   * react.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react-jsx-runtime.development.js:
  (**
   * @license React
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@lit/reactive-element/css-tag.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/reactive-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/lit-html.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-element/lit-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/is-server.js:
  (**
   * @license
   * Copyright 2022 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/custom-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/property.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/state.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/event-options.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/base.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-all.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-async.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-assigned-elements.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-assigned-nodes.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directive.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/class-map.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/if-defined.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directive-helpers.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/live.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/static.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/unsafe-html.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/async-directive.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/ref.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/context/lib/context-request-event.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/context/lib/create-context.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/context/lib/controllers/context-consumer.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/context/lib/value-notifier.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/context/lib/controllers/context-provider.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/context/lib/context-root.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/context/lib/decorators/provide.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/context/lib/decorators/consume.js:
  (**
   * @license
   * Copyright 2022 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

comlink/dist/esm/comlink.mjs:
  (**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: Apache-2.0
   *)
*/
//# sourceMappingURL=viewer.mjs.map